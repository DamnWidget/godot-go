package godot

//------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "templates/classes.go.template" so they can be included in the generated
//   code.
//------------------------------------------------------------------------------

/*
#include <stdio.h>
#include <stdlib.h>
#include <godot/gdnative.h>
#include <godot_nativescript.h>

void **build_array(int length);
void **build_array(int length) {
	void *ptr;
	void **arr = malloc(sizeof(void *) * length);
	for (int i = 0; i < length; i++) {
	    arr[i] = ptr;
	}

	return arr;
}

void add_element(void**, void*, int);
void add_element(void **array, void *element, int index) {
	printf("CGO: Array %p %p %p %p %p\n", &array, array, &array[index], *array, array[index]);
    array[index] = element;
	printf("CGO: Index %i %p\n", index, element);
	printf("CGO: Array %p %p %p %p %p\n", &array, array, &array[index], *array, array[index]);
}
*/
import "C"

import (
	"log"
	"reflect"
	"unsafe"
)

// Class is an interface for any objects that can have Godot
// inheritance.
type Class interface {
	baseClass() string
	setOwner(object *C.godot_object)
	getOwner() *C.godot_object
}

/*

 */
type ARVRAnchor struct {
	Spatial
}

func (o *ARVRAnchor) baseClass() string {
	return "ARVRAnchor"
}

/*

 */
func (o *ARVRAnchor) GetAnchorId() int64 {
	log.Println("Calling ARVRAnchor.GetAnchorId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_anchor_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ARVRAnchor) GetAnchorName() string {
	log.Println("Calling ARVRAnchor.GetAnchorName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_anchor_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *ARVRAnchor) GetIsActive() *bool {
	log.Println("Calling ARVRAnchor.GetIsActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_is_active", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ARVRAnchor) GetSize() *Vector3 {
	log.Println("Calling ARVRAnchor.GetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_size", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *ARVRAnchor) SetAnchorId(anchorId int64) {
	log.Println("Calling ARVRAnchor.SetAnchorId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(anchorId)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_anchor_id", goArguments, "")

	log.Println("Got return value!")

}

/*
   ARVRAnchorImplementer is an interface for ARVRAnchor objects.

*/
type ARVRAnchorImplementer interface {
	SpatialImplementer

	GetAnchorId() int64

	GetAnchorName() string

	GetIsActive() *bool

	GetSize() *Vector3

	SetAnchorId(anchorId int64)
}

/*

 */
type ARVRCamera struct {
	Camera
}

func (o *ARVRCamera) baseClass() string {
	return "ARVRCamera"
}

/*
   ARVRCameraImplementer is an interface for ARVRCamera objects.

*/
type ARVRCameraImplementer interface {
	CameraImplementer
}

/*

 */
type ARVRController struct {
	Spatial
}

func (o *ARVRController) baseClass() string {
	return "ARVRController"
}

/*

 */
func (o *ARVRController) GetControllerId() int64 {
	log.Println("Calling ARVRController.GetControllerId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_controller_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ARVRController) GetControllerName() string {
	log.Println("Calling ARVRController.GetControllerName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_controller_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *ARVRController) GetIsActive() *bool {
	log.Println("Calling ARVRController.GetIsActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_is_active", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ARVRController) GetJoystickAxis(axis int64) float64 {
	log.Println("Calling ARVRController.GetJoystickAxis()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(axis)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_joystick_axis", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ARVRController) GetJoystickId() int64 {
	log.Println("Calling ARVRController.GetJoystickId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_joystick_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ARVRController) IsButtonPressed(button int64) int64 {
	log.Println("Calling ARVRController.IsButtonPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(button)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_button_pressed", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ARVRController) SetControllerId(controllerId int64) {
	log.Println("Calling ARVRController.SetControllerId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(controllerId)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_controller_id", goArguments, "")

	log.Println("Got return value!")

}

/*
   ARVRControllerImplementer is an interface for ARVRController objects.

*/
type ARVRControllerImplementer interface {
	SpatialImplementer

	GetControllerId() int64

	GetControllerName() string

	GetIsActive() *bool

	GetJoystickAxis(axis int64) float64

	GetJoystickId() int64

	IsButtonPressed(button int64) int64

	SetControllerId(controllerId int64)
}

/*

 */
type ARVRInterface struct {
	Reference
}

func (o *ARVRInterface) baseClass() string {
	return "ARVRInterface"
}

/*

 */
func (o *ARVRInterface) GetName() string {
	log.Println("Calling ARVRInterface.GetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *ARVRInterface) GetRecommendedRenderTargetsize() *Vector2 {
	log.Println("Calling ARVRInterface.GetRecommendedRenderTargetsize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_recommended_render_targetsize", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *ARVRInterface) HmdIsPresent() *bool {
	log.Println("Calling ARVRInterface.HmdIsPresent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "hmd_is_present", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ARVRInterface) Initialize() *bool {
	log.Println("Calling ARVRInterface.Initialize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "initialize", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ARVRInterface) IsInitialized() *bool {
	log.Println("Calling ARVRInterface.IsInitialized()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_initialized", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ARVRInterface) IsInstalled() *bool {
	log.Println("Calling ARVRInterface.IsInstalled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_installed", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ARVRInterface) IsPrimary() *bool {
	log.Println("Calling ARVRInterface.IsPrimary()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_primary", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ARVRInterface) SetIsPrimary(enable *bool) {
	log.Println("Calling ARVRInterface.SetIsPrimary()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_is_primary", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ARVRInterface) SupportsHmd() *bool {
	log.Println("Calling ARVRInterface.SupportsHmd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "supports_hmd", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ARVRInterface) Uninitialize() {
	log.Println("Calling ARVRInterface.Uninitialize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "uninitialize", goArguments, "")

	log.Println("Got return value!")

}

/*
   ARVRInterfaceImplementer is an interface for ARVRInterface objects.

*/
type ARVRInterfaceImplementer interface {
	ReferenceImplementer

	GetName() string

	GetRecommendedRenderTargetsize() *Vector2

	HmdIsPresent() *bool

	Initialize() *bool

	IsInitialized() *bool

	IsInstalled() *bool

	IsPrimary() *bool

	SetIsPrimary(enable *bool)

	SupportsHmd() *bool

	Uninitialize()
}

/*

 */
type ARVROrigin struct {
	Spatial
}

func (o *ARVROrigin) baseClass() string {
	return "ARVROrigin"
}

/*

 */
func (o *ARVROrigin) GetWorldScale() float64 {
	log.Println("Calling ARVROrigin.GetWorldScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_world_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ARVROrigin) SetWorldScale(worldScale float64) {
	log.Println("Calling ARVROrigin.SetWorldScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(worldScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_world_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   ARVROriginImplementer is an interface for ARVROrigin objects.

*/
type ARVROriginImplementer interface {
	SpatialImplementer

	GetWorldScale() float64

	SetWorldScale(worldScale float64)
}

/*

 */
type ARVRPositionalTracker struct {
	Object
}

func (o *ARVRPositionalTracker) baseClass() string {
	return "ARVRPositionalTracker"
}

/*

 */
func (o *ARVRPositionalTracker) GetJoyId() int64 {
	log.Println("Calling ARVRPositionalTracker.GetJoyId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_joy_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ARVRPositionalTracker) GetName() string {
	log.Println("Calling ARVRPositionalTracker.GetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *ARVRPositionalTracker) GetOrientation() *Basis {
	log.Println("Calling ARVRPositionalTracker.GetOrientation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_orientation", goArguments, "*Basis")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Basis)

	return returnValue

}

/*

 */
func (o *ARVRPositionalTracker) GetPosition() *Vector3 {
	log.Println("Calling ARVRPositionalTracker.GetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_position", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *ARVRPositionalTracker) GetTracksOrientation() *bool {
	log.Println("Calling ARVRPositionalTracker.GetTracksOrientation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tracks_orientation", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ARVRPositionalTracker) GetTracksPosition() *bool {
	log.Println("Calling ARVRPositionalTracker.GetTracksPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tracks_position", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ARVRPositionalTracker) GetTransform(adjustByReferenceFrame *bool) *Transform {
	log.Println("Calling ARVRPositionalTracker.GetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(adjustByReferenceFrame)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_transform", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*

 */
func (o *ARVRPositionalTracker) GetType() int64 {
	log.Println("Calling ARVRPositionalTracker.GetType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   ARVRPositionalTrackerImplementer is an interface for ARVRPositionalTracker objects.

*/
type ARVRPositionalTrackerImplementer interface {
	ObjectImplementer

	GetJoyId() int64

	GetName() string

	GetOrientation() *Basis

	GetPosition() *Vector3

	GetTracksOrientation() *bool

	GetTracksPosition() *bool

	GetTransform(adjustByReferenceFrame *bool) *Transform

	GetType() int64
}

/*

 */
type ARVRScriptInterface struct {
	ARVRInterface
}

func (o *ARVRScriptInterface) baseClass() string {
	return "ARVRScriptInterface"
}

/*

 */
func (o *ARVRScriptInterface) X_GetProjectionForEye() {
	log.Println("Calling ARVRScriptInterface.X_GetProjectionForEye()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_get_projection_for_eye", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ARVRScriptInterface) CommitForEye(eye int64, renderTarget *RID) {
	log.Println("Calling ARVRScriptInterface.CommitForEye()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(eye)
	goArguments[1] = reflect.ValueOf(renderTarget)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "commit_for_eye", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ARVRScriptInterface) GetRecommendedRenderTargetsize() *Vector2 {
	log.Println("Calling ARVRScriptInterface.GetRecommendedRenderTargetsize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_recommended_render_targetsize", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *ARVRScriptInterface) GetTransformForEye(eye int64, camTransform *Transform) *Transform {
	log.Println("Calling ARVRScriptInterface.GetTransformForEye()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(eye)
	goArguments[1] = reflect.ValueOf(camTransform)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_transform_for_eye", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*

 */
func (o *ARVRScriptInterface) HmdIsPresent() *bool {
	log.Println("Calling ARVRScriptInterface.HmdIsPresent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "hmd_is_present", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ARVRScriptInterface) Initialize() *bool {
	log.Println("Calling ARVRScriptInterface.Initialize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "initialize", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ARVRScriptInterface) IsInitialized() *bool {
	log.Println("Calling ARVRScriptInterface.IsInitialized()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_initialized", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ARVRScriptInterface) IsInstalled() *bool {
	log.Println("Calling ARVRScriptInterface.IsInstalled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_installed", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ARVRScriptInterface) IsStereo() *bool {
	log.Println("Calling ARVRScriptInterface.IsStereo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_stereo", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ARVRScriptInterface) Process() {
	log.Println("Calling ARVRScriptInterface.Process()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "process", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ARVRScriptInterface) SupportsHmd() *bool {
	log.Println("Calling ARVRScriptInterface.SupportsHmd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "supports_hmd", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ARVRScriptInterface) Uninitialize() {
	log.Println("Calling ARVRScriptInterface.Uninitialize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "uninitialize", goArguments, "")

	log.Println("Got return value!")

}

/*
   ARVRScriptInterfaceImplementer is an interface for ARVRScriptInterface objects.

*/
type ARVRScriptInterfaceImplementer interface {
	ARVRInterfaceImplementer

	X_GetProjectionForEye()

	CommitForEye(eye int64, renderTarget *RID)

	GetRecommendedRenderTargetsize() *Vector2

	GetTransformForEye(eye int64, camTransform *Transform) *Transform

	HmdIsPresent() *bool

	Initialize() *bool

	IsInitialized() *bool

	IsInstalled() *bool

	IsStereo() *bool

	Process()

	SupportsHmd() *bool

	Uninitialize()
}

/*

 */
type ARVRServer struct {
	Object
}

func (o *ARVRServer) baseClass() string {
	return "ARVRServer"
}

/*

 */
func (o *ARVRServer) AddInterface(arg0 *ARVRInterface) {
	log.Println("Calling ARVRServer.AddInterface()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_interface", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ARVRServer) FindInterface(name string) *ARVRInterface {
	log.Println("Calling ARVRServer.FindInterface()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "find_interface", goArguments, "*ARVRInterface")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*ARVRInterface)

	return returnValue

}

/*

 */
func (o *ARVRServer) GetInterface(idx int64) *ARVRInterface {
	log.Println("Calling ARVRServer.GetInterface()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_interface", goArguments, "*ARVRInterface")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*ARVRInterface)

	return returnValue

}

/*

 */
func (o *ARVRServer) GetInterfaceCount() int64 {
	log.Println("Calling ARVRServer.GetInterfaceCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_interface_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ARVRServer) GetReferenceFrame() *Transform {
	log.Println("Calling ARVRServer.GetReferenceFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_reference_frame", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*

 */
func (o *ARVRServer) GetTracker(idx int64) *ARVRPositionalTracker {
	log.Println("Calling ARVRServer.GetTracker()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tracker", goArguments, "*ARVRPositionalTracker")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*ARVRPositionalTracker)

	return returnValue

}

/*

 */
func (o *ARVRServer) GetTrackerCount() int64 {
	log.Println("Calling ARVRServer.GetTrackerCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tracker_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ARVRServer) GetWorldScale() float64 {
	log.Println("Calling ARVRServer.GetWorldScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_world_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ARVRServer) RemoveInterface(arg0 *ARVRInterface) {
	log.Println("Calling ARVRServer.RemoveInterface()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_interface", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ARVRServer) RequestReferenceFrame(ignoreTilt *bool, keepHeight *bool) {
	log.Println("Calling ARVRServer.RequestReferenceFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ignoreTilt)
	goArguments[1] = reflect.ValueOf(keepHeight)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "request_reference_frame", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ARVRServer) SetPrimaryInterface(arg0 *ARVRInterface) {
	log.Println("Calling ARVRServer.SetPrimaryInterface()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_primary_interface", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ARVRServer) SetWorldScale(arg0 float64) {
	log.Println("Calling ARVRServer.SetWorldScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_world_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   ARVRServerImplementer is an interface for ARVRServer objects.

*/
type ARVRServerImplementer interface {
	ObjectImplementer

	AddInterface(arg0 *ARVRInterface)

	FindInterface(name string) *ARVRInterface

	GetInterface(idx int64) *ARVRInterface

	GetInterfaceCount() int64

	GetReferenceFrame() *Transform

	GetTracker(idx int64) *ARVRPositionalTracker

	GetTrackerCount() int64

	GetWorldScale() float64

	RemoveInterface(arg0 *ARVRInterface)

	RequestReferenceFrame(ignoreTilt *bool, keepHeight *bool)

	SetPrimaryInterface(arg0 *ARVRInterface)

	SetWorldScale(arg0 float64)
}

/*
        A* (A star) is a computer algorithm that is widely used in pathfinding and graph traversal, the process of plotting an efficiently directed path between multiple points. It enjoys widespread use due to its performance and accuracy. Godot's A* implementation make use of vectors as points.
		You must add points manually with [method AStar.add_point] and create segments manually with [method AStar.connect_points]. So you can test if there is a path between two points with the [method AStar.are_points_connected] function, get the list of existing ids in the found path with [method AStar.get_id_path], or the points list with [method AStar.get_point_path].
*/
type AStar struct {
	Reference
}

func (o *AStar) baseClass() string {
	return "AStar"
}

/*

 */
func (o *AStar) X_ComputeCost(fromId int64, toId int64) {
	log.Println("Calling AStar.X_ComputeCost()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(fromId)
	goArguments[1] = reflect.ValueOf(toId)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_compute_cost", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AStar) X_EstimateCost(fromId int64, toId int64) {
	log.Println("Calling AStar.X_EstimateCost()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(fromId)
	goArguments[1] = reflect.ValueOf(toId)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_estimate_cost", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a new point at the given position [code]pos[/code] with the given identifier [code]id[/code]. The [code]weight_scale[/code] has to be 1 or larger.
*/
func (o *AStar) AddPoint(id int64, pos *Vector3, weightScale float64) {
	log.Println("Calling AStar.AddPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(pos)
	goArguments[2] = reflect.ValueOf(weightScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_point", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns if there is a connection/segment between points [code]id[/code] and [code]from_id[/code]
*/
func (o *AStar) ArePointsConnected(id int64, toId int64) *bool {
	log.Println("Calling AStar.ArePointsConnected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(toId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "are_points_connected", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Clear all the points and segments from AStar instance.
*/
func (o *AStar) Clear() {
	log.Println("Calling AStar.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Create a segment between points [code]id[/code] and [code]to_id[/code].
*/
func (o *AStar) ConnectPoints(id int64, toId int64, bidirectional *bool) {
	log.Println("Calling AStar.ConnectPoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(toId)
	goArguments[2] = reflect.ValueOf(bidirectional)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "connect_points", goArguments, "")

	log.Println("Got return value!")

}

/*
   Deletes a segment between points [code]id[/code] and [code]to_id[/code].
*/
func (o *AStar) DisconnectPoints(id int64, toId int64) {
	log.Println("Calling AStar.DisconnectPoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(toId)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "disconnect_points", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AStar) GetAvailablePointId() int64 {
	log.Println("Calling AStar.GetAvailablePointId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_available_point_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the id of closest point of given point.  -1 is returned if there are no points on AStar.
*/
func (o *AStar) GetClosestPoint(toPos *Vector3) int64 {
	log.Println("Calling AStar.GetClosestPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(toPos)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_point", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the position of closest point that has segments.
*/
func (o *AStar) GetClosestPosInSegment(toPos *Vector3) *Vector3 {
	log.Println("Calling AStar.GetClosestPosInSegment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(toPos)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_pos_in_segment", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Returns an array with the point ids of path found by AStar between two given points.
*/
func (o *AStar) GetIdPath(fromId int64, toId int64) *PoolIntArray {
	log.Println("Calling AStar.GetIdPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(fromId)
	goArguments[1] = reflect.ValueOf(toId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_id_path", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*
   Returns an array with the points of path found by AStar between two given points.
*/
func (o *AStar) GetPointPath(fromId int64, toId int64) *PoolVector3Array {
	log.Println("Calling AStar.GetPointPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(fromId)
	goArguments[1] = reflect.ValueOf(toId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_path", goArguments, "*PoolVector3Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector3Array)

	return returnValue

}

/*
   Returns the position of point with given id.
*/
func (o *AStar) GetPointPos(id int64) *Vector3 {
	log.Println("Calling AStar.GetPointPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_pos", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Returns the weight scale of point with given id.
*/
func (o *AStar) GetPointWeightScale(id int64) float64 {
	log.Println("Calling AStar.GetPointWeightScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_weight_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns if the point with given id exists on AStar;
*/
func (o *AStar) HasPoint(id int64) *bool {
	log.Println("Calling AStar.HasPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_point", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Removes the point with given id.
*/
func (o *AStar) RemovePoint(id int64) {
	log.Println("Calling AStar.RemovePoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_point", goArguments, "")

	log.Println("Got return value!")

}

/*
        AStarImplementer is an interface for AStar objects.
        A* (A star) is a computer algorithm that is widely used in pathfinding and graph traversal, the process of plotting an efficiently directed path between multiple points. It enjoys widespread use due to its performance and accuracy. Godot's A* implementation make use of vectors as points.
		You must add points manually with [method AStar.add_point] and create segments manually with [method AStar.connect_points]. So you can test if there is a path between two points with the [method AStar.are_points_connected] function, get the list of existing ids in the found path with [method AStar.get_id_path], or the points list with [method AStar.get_point_path].
*/
type AStarImplementer interface {
	ReferenceImplementer

	X_ComputeCost(fromId int64, toId int64)

	X_EstimateCost(fromId int64, toId int64)

	AddPoint(id int64, pos *Vector3, weightScale float64)

	ArePointsConnected(id int64, toId int64) *bool

	Clear()

	ConnectPoints(id int64, toId int64, bidirectional *bool)

	DisconnectPoints(id int64, toId int64)

	GetAvailablePointId() int64

	GetClosestPoint(toPos *Vector3) int64

	GetClosestPosInSegment(toPos *Vector3) *Vector3

	GetIdPath(fromId int64, toId int64) *PoolIntArray

	GetPointPath(fromId int64, toId int64) *PoolVector3Array

	GetPointPos(id int64) *Vector3

	GetPointWeightScale(id int64) float64

	HasPoint(id int64) *bool

	RemovePoint(id int64)
}

/*
   This dialog is useful for small notifications to the user about an event. It can only be accepted or closed, with the same result.
*/
type AcceptDialog struct {
	WindowDialog
}

func (o *AcceptDialog) baseClass() string {
	return "AcceptDialog"
}

/*
                Add custom button to the dialog and return the created button.
				The button titled with [i]text[/i] and the [i]action[/i] will be passed to [custom_action] signal when it is pressed.
*/
func (o *AcceptDialog) AddButton(text string, right *bool, action string) *Button {
	log.Println("Calling AcceptDialog.AddButton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(text)
	goArguments[1] = reflect.ValueOf(right)
	goArguments[2] = reflect.ValueOf(action)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "add_button", goArguments, "*Button")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Button)

	return returnValue

}

/*
   Add custom cancel button to the dialog and return the created button.
*/
func (o *AcceptDialog) AddCancel(name string) *Button {
	log.Println("Calling AcceptDialog.AddCancel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "add_cancel", goArguments, "*Button")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Button)

	return returnValue

}

/*
   Return true if the dialog will be hidden when accepted (default true).
*/
func (o *AcceptDialog) GetHideOnOk() *bool {
	log.Println("Calling AcceptDialog.GetHideOnOk()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_hide_on_ok", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return the label used for built-in text.
*/
func (o *AcceptDialog) GetLabel() *Label {
	log.Println("Calling AcceptDialog.GetLabel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_label", goArguments, "*Label")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Label)

	return returnValue

}

/*
   Return the OK Button.
*/
func (o *AcceptDialog) GetOk() *Button {
	log.Println("Calling AcceptDialog.GetOk()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ok", goArguments, "*Button")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Button)

	return returnValue

}

/*
   Return the built-in label text.
*/
func (o *AcceptDialog) GetText() string {
	log.Println("Calling AcceptDialog.GetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Register a [LineEdit] in the dialog. When the enter key is pressed, the dialog will be accepted.
*/
func (o *AcceptDialog) RegisterTextEnter(lineEdit *Node) {
	log.Println("Calling AcceptDialog.RegisterTextEnter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(lineEdit)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "register_text_enter", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether the dialog is hidden when accepted (default true).
*/
func (o *AcceptDialog) SetHideOnOk(enabled *bool) {
	log.Println("Calling AcceptDialog.SetHideOnOk()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_hide_on_ok", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the built-in label text.
*/
func (o *AcceptDialog) SetText(text string) {
	log.Println("Calling AcceptDialog.SetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_text", goArguments, "")

	log.Println("Got return value!")

}

/*
   AcceptDialogImplementer is an interface for AcceptDialog objects.
   This dialog is useful for small notifications to the user about an event. It can only be accepted or closed, with the same result.
*/
type AcceptDialogImplementer interface {
	WindowDialogImplementer

	AddButton(text string, right *bool, action string) *Button

	AddCancel(name string) *Button

	GetHideOnOk() *bool

	GetLabel() *Label

	GetOk() *Button

	GetText() string

	RegisterTextEnter(lineEdit *Node)

	SetHideOnOk(enabled *bool)

	SetText(text string)
}

/*
   Sprite node that can use multiple textures for animation.
*/
type AnimatedSprite struct {
	Node2D
}

func (o *AnimatedSprite) baseClass() string {
	return "AnimatedSprite"
}

/*
   Return the name of the current animation set to the node.
*/
func (o *AnimatedSprite) GetAnimation() string {
	log.Println("Calling AnimatedSprite.GetAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_animation", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the visible frame index.
*/
func (o *AnimatedSprite) GetFrame() int64 {
	log.Println("Calling AnimatedSprite.GetFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_frame", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the offset of the sprite in the node origin.
*/
func (o *AnimatedSprite) GetOffset() *Vector2 {
	log.Println("Calling AnimatedSprite.GetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Get the [SpriteFrames] resource, which contains all frames.
*/
func (o *AnimatedSprite) GetSpriteFrames() *SpriteFrames {
	log.Println("Calling AnimatedSprite.GetSpriteFrames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sprite_frames", goArguments, "*SpriteFrames")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*SpriteFrames)

	return returnValue

}

/*
   Return true when centered. See [method set_centered].
*/
func (o *AnimatedSprite) IsCentered() *bool {
	log.Println("Calling AnimatedSprite.IsCentered()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_centered", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if sprite is flipped horizontally.
*/
func (o *AnimatedSprite) IsFlippedH() *bool {
	log.Println("Calling AnimatedSprite.IsFlippedH()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_flipped_h", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if sprite is flipped vertically.
*/
func (o *AnimatedSprite) IsFlippedV() *bool {
	log.Println("Calling AnimatedSprite.IsFlippedV()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_flipped_v", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if an animation if currently being played.
*/
func (o *AnimatedSprite) IsPlaying() *bool {
	log.Println("Calling AnimatedSprite.IsPlaying()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_playing", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Play the animation set in parameter. If no parameter is provided, the current animation is played.
*/
func (o *AnimatedSprite) Play(anim string) {
	log.Println("Calling AnimatedSprite.Play()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(anim)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "play", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the current animation of the node and reinits the frame counter of the animation.
*/
func (o *AnimatedSprite) SetAnimation(animation string) {
	log.Println("Calling AnimatedSprite.SetAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(animation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_animation", goArguments, "")

	log.Println("Got return value!")

}

/*
   When turned on, offset at (0,0) is the center of the sprite, when off, the top-left corner is.
*/
func (o *AnimatedSprite) SetCentered(centered *bool) {
	log.Println("Calling AnimatedSprite.SetCentered()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(centered)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_centered", goArguments, "")

	log.Println("Got return value!")

}

/*
   If true, sprite is flipped horizontally.
*/
func (o *AnimatedSprite) SetFlipH(flipH *bool) {
	log.Println("Calling AnimatedSprite.SetFlipH()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flipH)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flip_h", goArguments, "")

	log.Println("Got return value!")

}

/*
   If true, sprite is flipped vertically.
*/
func (o *AnimatedSprite) SetFlipV(flipV *bool) {
	log.Println("Calling AnimatedSprite.SetFlipV()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flipV)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flip_v", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the visible sprite frame index (from the list of frames inside the [SpriteFrames] resource).
*/
func (o *AnimatedSprite) SetFrame(frame int64) {
	log.Println("Calling AnimatedSprite.SetFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(frame)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_frame", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the offset of the sprite in the node origin. Position varies depending on whether it is centered or not.
*/
func (o *AnimatedSprite) SetOffset(offset *Vector2) {
	log.Println("Calling AnimatedSprite.SetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the [SpriteFrames] resource, which contains all frames.
*/
func (o *AnimatedSprite) SetSpriteFrames(spriteFrames *SpriteFrames) {
	log.Println("Calling AnimatedSprite.SetSpriteFrames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(spriteFrames)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sprite_frames", goArguments, "")

	log.Println("Got return value!")

}

/*
   Stop the current animation (does not reset the frame counter).
*/
func (o *AnimatedSprite) Stop() {
	log.Println("Calling AnimatedSprite.Stop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "stop", goArguments, "")

	log.Println("Got return value!")

}

/*
   AnimatedSpriteImplementer is an interface for AnimatedSprite objects.
   Sprite node that can use multiple textures for animation.
*/
type AnimatedSpriteImplementer interface {
	Node2DImplementer

	GetAnimation() string

	GetFrame() int64

	GetOffset() *Vector2

	GetSpriteFrames() *SpriteFrames

	IsCentered() *bool

	IsFlippedH() *bool

	IsFlippedV() *bool

	IsPlaying() *bool

	Play(anim string)

	SetAnimation(animation string)

	SetCentered(centered *bool)

	SetFlipH(flipH *bool)

	SetFlipV(flipV *bool)

	SetFrame(frame int64)

	SetOffset(offset *Vector2)

	SetSpriteFrames(spriteFrames *SpriteFrames)

	Stop()
}

/*

 */
type AnimatedSprite3D struct {
	SpriteBase3D
}

func (o *AnimatedSprite3D) baseClass() string {
	return "AnimatedSprite3D"
}

/*
   Return the name of the current animation set to the node.
*/
func (o *AnimatedSprite3D) GetAnimation() string {
	log.Println("Calling AnimatedSprite3D.GetAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_animation", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the visible frame index.
*/
func (o *AnimatedSprite3D) GetFrame() int64 {
	log.Println("Calling AnimatedSprite3D.GetFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_frame", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the [SpriteFrames] resource, which contains all frames.
*/
func (o *AnimatedSprite3D) GetSpriteFrames() *SpriteFrames {
	log.Println("Calling AnimatedSprite3D.GetSpriteFrames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sprite_frames", goArguments, "*SpriteFrames")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*SpriteFrames)

	return returnValue

}

/*
   Return true if an animation if currently being played.
*/
func (o *AnimatedSprite3D) IsPlaying() *bool {
	log.Println("Calling AnimatedSprite3D.IsPlaying()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_playing", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Play the animation set in parameter. If no parameter is provided, the current animation is played.
*/
func (o *AnimatedSprite3D) Play(anim string) {
	log.Println("Calling AnimatedSprite3D.Play()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(anim)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "play", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the current animation of the node and reinits the frame counter of the animation.
*/
func (o *AnimatedSprite3D) SetAnimation(animation string) {
	log.Println("Calling AnimatedSprite3D.SetAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(animation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_animation", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the visible sprite frame index (from the list of frames inside the [SpriteFrames] resource).
*/
func (o *AnimatedSprite3D) SetFrame(frame int64) {
	log.Println("Calling AnimatedSprite3D.SetFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(frame)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_frame", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the [SpriteFrames] resource, which contains all frames.
*/
func (o *AnimatedSprite3D) SetSpriteFrames(spriteFrames *SpriteFrames) {
	log.Println("Calling AnimatedSprite3D.SetSpriteFrames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(spriteFrames)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sprite_frames", goArguments, "")

	log.Println("Got return value!")

}

/*
   Stop the current animation (does not reset the frame counter).
*/
func (o *AnimatedSprite3D) Stop() {
	log.Println("Calling AnimatedSprite3D.Stop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "stop", goArguments, "")

	log.Println("Got return value!")

}

/*
   AnimatedSprite3DImplementer is an interface for AnimatedSprite3D objects.

*/
type AnimatedSprite3DImplementer interface {
	SpriteBase3DImplementer

	GetAnimation() string

	GetFrame() int64

	GetSpriteFrames() *SpriteFrames

	IsPlaying() *bool

	Play(anim string)

	SetAnimation(animation string)

	SetFrame(frame int64)

	SetSpriteFrames(spriteFrames *SpriteFrames)

	Stop()
}

/*
        An Animation resource contains data used to animate everything in the engine. Animations are divided into tracks, and each track must be linked to a node. The state of that node can be changed through time, by adding timed keys (events) to the track.
		Animations are just data containers, and must be added to odes such as an [AnimationPlayer] or [AnimationTreePlayer] to be played back.
*/
type Animation struct {
	Resource
}

func (o *Animation) baseClass() string {
	return "Animation"
}

/*
   Add a track to the Animation. The track type must be specified as any of the values in the TYPE_* enumeration.
*/
func (o *Animation) AddTrack(aType int64, atPos int64) int64 {
	log.Println("Calling Animation.AddTrack()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(aType)
	goArguments[1] = reflect.ValueOf(atPos)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "add_track", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Clear the animation (clear all tracks and reset all).
*/
func (o *Animation) Clear() {
	log.Println("Calling Animation.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the index of the specified track. If the track is not found, return -1.
*/
func (o *Animation) FindTrack(path *NodePath) int64 {
	log.Println("Calling Animation.FindTrack()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "find_track", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the total length of the animation (in seconds).
*/
func (o *Animation) GetLength() float64 {
	log.Println("Calling Animation.GetLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_length", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Get the animation step value.
*/
func (o *Animation) GetStep() float64 {
	log.Println("Calling Animation.GetStep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_step", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the amount of tracks in the animation.
*/
func (o *Animation) GetTrackCount() int64 {
	log.Println("Calling Animation.GetTrackCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_track_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return whether the animation has the loop flag set.
*/
func (o *Animation) HasLoop() *bool {
	log.Println("Calling Animation.HasLoop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_loop", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return all the key indices of a method track, given a position and delta time.
*/
func (o *Animation) MethodTrackGetKeyIndices(idx int64, timeSec float64, delta float64) *PoolIntArray {
	log.Println("Calling Animation.MethodTrackGetKeyIndices()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(timeSec)
	goArguments[2] = reflect.ValueOf(delta)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "method_track_get_key_indices", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*
   Return the method name of a method track.
*/
func (o *Animation) MethodTrackGetName(idx int64, keyIdx int64) string {
	log.Println("Calling Animation.MethodTrackGetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(keyIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "method_track_get_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the arguments values to be called on a method track for a given key in a given track.
*/
func (o *Animation) MethodTrackGetParams(idx int64, keyIdx int64) *Array {
	log.Println("Calling Animation.MethodTrackGetParams()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(keyIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "method_track_get_params", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Remove a track by specifying the track index.
*/
func (o *Animation) RemoveTrack(idx int64) {
	log.Println("Calling Animation.RemoveTrack()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_track", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the total length of the animation (in seconds). Note that length is not delimited by the last key, as this one may be before or after the end to ensure correct interpolation and looping.
*/
func (o *Animation) SetLength(timeSec float64) {
	log.Println("Calling Animation.SetLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(timeSec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_length", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set a flag indicating that the animation must loop. This is uses for correct interpolation of animation cycles, and for hinting the player that it must restart the animation.
*/
func (o *Animation) SetLoop(enabled *bool) {
	log.Println("Calling Animation.SetLoop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_loop", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the animation step value.
*/
func (o *Animation) SetStep(sizeSec float64) {
	log.Println("Calling Animation.SetStep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(sizeSec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_step", goArguments, "")

	log.Println("Got return value!")

}

/*
   Find the key index by time in a given track. Optionally, only find it if the exact time is given.
*/
func (o *Animation) TrackFindKey(idx int64, time float64, exact *bool) int64 {
	log.Println("Calling Animation.TrackFindKey()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(time)
	goArguments[2] = reflect.ValueOf(exact)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "track_find_key", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Animation) TrackGetInterpolationLoopWrap(idx int64) *bool {
	log.Println("Calling Animation.TrackGetInterpolationLoopWrap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "track_get_interpolation_loop_wrap", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return the interpolation type of a given track, from the INTERPOLATION_* enum.
*/
func (o *Animation) TrackGetInterpolationType(idx int64) int64 {
	log.Println("Calling Animation.TrackGetInterpolationType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "track_get_interpolation_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the amount of keys in a given track.
*/
func (o *Animation) TrackGetKeyCount(idx int64) int64 {
	log.Println("Calling Animation.TrackGetKeyCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "track_get_key_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the time at which the key is located.
*/
func (o *Animation) TrackGetKeyTime(idx int64, keyIdx int64) float64 {
	log.Println("Calling Animation.TrackGetKeyTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(keyIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "track_get_key_time", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the transition curve (easing) for a specific key (see built-in math function "ease").
*/
func (o *Animation) TrackGetKeyTransition(idx int64, keyIdx int64) float64 {
	log.Println("Calling Animation.TrackGetKeyTransition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(keyIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "track_get_key_transition", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the value of a given key in a given track.
*/
func (o *Animation) TrackGetKeyValue(idx int64, keyIdx int64) *Variant {
	log.Println("Calling Animation.TrackGetKeyValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(keyIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "track_get_key_value", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Get the path of a track. for more information on the path format, see [method track_set_path]
*/
func (o *Animation) TrackGetPath(idx int64) *NodePath {
	log.Println("Calling Animation.TrackGetPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "track_get_path", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*
   Get the type of a track.
*/
func (o *Animation) TrackGetType(idx int64) int64 {
	log.Println("Calling Animation.TrackGetType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "track_get_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Insert a generic key in a given track.
*/
func (o *Animation) TrackInsertKey(idx int64, time float64, key *Variant, transition float64) {
	log.Println("Calling Animation.TrackInsertKey()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(time)
	goArguments[2] = reflect.ValueOf(key)
	goArguments[3] = reflect.ValueOf(transition)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "track_insert_key", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if the given track is imported. Else, return false.
*/
func (o *Animation) TrackIsImported(idx int64) *bool {
	log.Println("Calling Animation.TrackIsImported()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "track_is_imported", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Move a track down.
*/
func (o *Animation) TrackMoveDown(idx int64) {
	log.Println("Calling Animation.TrackMoveDown()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "track_move_down", goArguments, "")

	log.Println("Got return value!")

}

/*
   Move a track up.
*/
func (o *Animation) TrackMoveUp(idx int64) {
	log.Println("Calling Animation.TrackMoveUp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "track_move_up", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove a key by index in a given track.
*/
func (o *Animation) TrackRemoveKey(idx int64, keyIdx int64) {
	log.Println("Calling Animation.TrackRemoveKey()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(keyIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "track_remove_key", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove a key by position (seconds) in a given track.
*/
func (o *Animation) TrackRemoveKeyAtPos(idx int64, pos float64) {
	log.Println("Calling Animation.TrackRemoveKeyAtPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(pos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "track_remove_key_at_pos", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the given track as imported or not.
*/
func (o *Animation) TrackSetImported(idx int64, imported *bool) {
	log.Println("Calling Animation.TrackSetImported()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(imported)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "track_set_imported", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Animation) TrackSetInterpolationLoopWrap(idx int64, interpolation *bool) {
	log.Println("Calling Animation.TrackSetInterpolationLoopWrap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(interpolation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "track_set_interpolation_loop_wrap", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the interpolation type of a given track, from the INTERPOLATION_* enum.
*/
func (o *Animation) TrackSetInterpolationType(idx int64, interpolation int64) {
	log.Println("Calling Animation.TrackSetInterpolationType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(interpolation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "track_set_interpolation_type", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the transition curve (easing) for a specific key (see built-in math function "ease").
*/
func (o *Animation) TrackSetKeyTransition(idx int64, keyIdx int64, transition float64) {
	log.Println("Calling Animation.TrackSetKeyTransition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(keyIdx)
	goArguments[2] = reflect.ValueOf(transition)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "track_set_key_transition", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the value of an existing key.
*/
func (o *Animation) TrackSetKeyValue(idx int64, key int64, value *Variant) {
	log.Println("Calling Animation.TrackSetKeyValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(key)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "track_set_key_value", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the path of a track. Paths must be valid scene-tree paths to a node, and must be specified starting from the parent node of the node that will reproduce the animation. Tracks that control properties or bones must append their name after the path, separated by ":". Example: "character/skeleton:ankle" or "character/mesh:transform/local"
*/
func (o *Animation) TrackSetPath(idx int64, path *NodePath) {
	log.Println("Calling Animation.TrackSetPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "track_set_path", goArguments, "")

	log.Println("Got return value!")

}

/*
   Insert a transform key for a transform track.
*/
func (o *Animation) TransformTrackInsertKey(idx int64, time float64, loc *Vector3, rot *Quat, scale *Vector3) int64 {
	log.Println("Calling Animation.TransformTrackInsertKey()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(time)
	goArguments[2] = reflect.ValueOf(loc)
	goArguments[3] = reflect.ValueOf(rot)
	goArguments[4] = reflect.ValueOf(scale)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "transform_track_insert_key", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the interpolated value of a transform track at a given time (in seconds). An array consisting of 3 elements: position ([Vector3]), rotation ([Quat]) and scale ([Vector3]).
*/
func (o *Animation) TransformTrackInterpolate(idx int64, timeSec float64) *Array {
	log.Println("Calling Animation.TransformTrackInterpolate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(timeSec)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "transform_track_interpolate", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Return all the key indices of a value track, given a position and delta time.
*/
func (o *Animation) ValueTrackGetKeyIndices(idx int64, timeSec float64, delta float64) *PoolIntArray {
	log.Println("Calling Animation.ValueTrackGetKeyIndices()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(timeSec)
	goArguments[2] = reflect.ValueOf(delta)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "value_track_get_key_indices", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*

 */
func (o *Animation) ValueTrackGetUpdateMode(idx int64) int64 {
	log.Println("Calling Animation.ValueTrackGetUpdateMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "value_track_get_update_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Animation) ValueTrackSetUpdateMode(idx int64, mode int64) {
	log.Println("Calling Animation.ValueTrackSetUpdateMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "value_track_set_update_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
        AnimationImplementer is an interface for Animation objects.
        An Animation resource contains data used to animate everything in the engine. Animations are divided into tracks, and each track must be linked to a node. The state of that node can be changed through time, by adding timed keys (events) to the track.
		Animations are just data containers, and must be added to odes such as an [AnimationPlayer] or [AnimationTreePlayer] to be played back.
*/
type AnimationImplementer interface {
	ResourceImplementer

	AddTrack(aType int64, atPos int64) int64

	Clear()

	FindTrack(path *NodePath) int64

	GetLength() float64

	GetStep() float64

	GetTrackCount() int64

	HasLoop() *bool

	MethodTrackGetKeyIndices(idx int64, timeSec float64, delta float64) *PoolIntArray

	MethodTrackGetName(idx int64, keyIdx int64) string

	MethodTrackGetParams(idx int64, keyIdx int64) *Array

	RemoveTrack(idx int64)

	SetLength(timeSec float64)

	SetLoop(enabled *bool)

	SetStep(sizeSec float64)

	TrackFindKey(idx int64, time float64, exact *bool) int64

	TrackGetInterpolationLoopWrap(idx int64) *bool

	TrackGetInterpolationType(idx int64) int64

	TrackGetKeyCount(idx int64) int64

	TrackGetKeyTime(idx int64, keyIdx int64) float64

	TrackGetKeyTransition(idx int64, keyIdx int64) float64

	TrackGetKeyValue(idx int64, keyIdx int64) *Variant

	TrackGetPath(idx int64) *NodePath

	TrackGetType(idx int64) int64

	TrackInsertKey(idx int64, time float64, key *Variant, transition float64)

	TrackIsImported(idx int64) *bool

	TrackMoveDown(idx int64)

	TrackMoveUp(idx int64)

	TrackRemoveKey(idx int64, keyIdx int64)

	TrackRemoveKeyAtPos(idx int64, pos float64)

	TrackSetImported(idx int64, imported *bool)

	TrackSetInterpolationLoopWrap(idx int64, interpolation *bool)

	TrackSetInterpolationType(idx int64, interpolation int64)

	TrackSetKeyTransition(idx int64, keyIdx int64, transition float64)

	TrackSetKeyValue(idx int64, key int64, value *Variant)

	TrackSetPath(idx int64, path *NodePath)

	TransformTrackInsertKey(idx int64, time float64, loc *Vector3, rot *Quat, scale *Vector3) int64

	TransformTrackInterpolate(idx int64, timeSec float64) *Array

	ValueTrackGetKeyIndices(idx int64, timeSec float64, delta float64) *PoolIntArray

	ValueTrackGetUpdateMode(idx int64) int64

	ValueTrackSetUpdateMode(idx int64, mode int64)
}

/*
   An animation player is used for general purpose playback of [Animation] resources. It contains a dictionary of animations (referenced by name) and custom blend times between their transitions. Additionally, animations can be played and blended in different channels.
*/
type AnimationPlayer struct {
	Node
}

func (o *AnimationPlayer) baseClass() string {
	return "AnimationPlayer"
}

/*
   Add an animation resource to the player, which will be later referenced by the "name" argument.
*/
func (o *AnimationPlayer) AddAnimation(name string, animation *Animation) int64 {
	log.Println("Calling AnimationPlayer.AddAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(animation)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "add_animation", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Used to skip ahead or skip back in an animation. Delta is the time in seconds to skip.
*/
func (o *AnimationPlayer) Advance(delta float64) {
	log.Println("Calling AnimationPlayer.Advance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(delta)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "advance", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationPlayer) AnimationGetNext(animFrom string) string {
	log.Println("Calling AnimationPlayer.AnimationGetNext()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(animFrom)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "animation_get_next", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *AnimationPlayer) AnimationSetNext(animFrom string, animTo string) {
	log.Println("Calling AnimationPlayer.AnimationSetNext()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(animFrom)
	goArguments[1] = reflect.ValueOf(animTo)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "animation_set_next", goArguments, "")

	log.Println("Got return value!")

}

/*
   The animation player creates caches for faster access to the nodes it will animate. However, if a specific node is removed, it may not notice it, so clear_caches will force the player to search for the nodes again.
*/
func (o *AnimationPlayer) ClearCaches() {
	log.Println("Calling AnimationPlayer.ClearCaches()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_caches", goArguments, "")

	log.Println("Got return value!")

}

/*
   If animations are queued to play, clear them.
*/
func (o *AnimationPlayer) ClearQueue() {
	log.Println("Calling AnimationPlayer.ClearQueue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_queue", goArguments, "")

	log.Println("Got return value!")

}

/*
   Find an animation name by resource.
*/
func (o *AnimationPlayer) FindAnimation(animation *Animation) string {
	log.Println("Calling AnimationPlayer.FindAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(animation)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "find_animation", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get an [Animation] resource by requesting a name.
*/
func (o *AnimationPlayer) GetAnimation(name string) *Animation {
	log.Println("Calling AnimationPlayer.GetAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_animation", goArguments, "*Animation")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Animation)

	return returnValue

}

/*
   Get the list of names of the animations stored in the player.
*/
func (o *AnimationPlayer) GetAnimationList() *PoolStringArray {
	log.Println("Calling AnimationPlayer.GetAnimationList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_animation_list", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   Return the mode in which the animation player processes. See [method set_animation_process_mode].
*/
func (o *AnimationPlayer) GetAnimationProcessMode() int64 {
	log.Println("Calling AnimationPlayer.GetAnimationProcessMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_animation_process_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the name of the animation that will be automatically played when the scene is loaded.
*/
func (o *AnimationPlayer) GetAutoplay() string {
	log.Println("Calling AnimationPlayer.GetAutoplay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_autoplay", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the blend time between two animations, referenced by their names.
*/
func (o *AnimationPlayer) GetBlendTime(animFrom string, animTo string) float64 {
	log.Println("Calling AnimationPlayer.GetBlendTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(animFrom)
	goArguments[1] = reflect.ValueOf(animTo)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_blend_time", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the name of the animation being played.
*/
func (o *AnimationPlayer) GetCurrentAnimation() string {
	log.Println("Calling AnimationPlayer.GetCurrentAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_animation", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the length (in seconds) of the currently being played animation.
*/
func (o *AnimationPlayer) GetCurrentAnimationLength() float64 {
	log.Println("Calling AnimationPlayer.GetCurrentAnimationLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_animation_length", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Get the position (in seconds) of the currently being played animation.
*/
func (o *AnimationPlayer) GetCurrentAnimationPos() float64 {
	log.Println("Calling AnimationPlayer.GetCurrentAnimationPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_animation_pos", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the default blend time between animations.
*/
func (o *AnimationPlayer) GetDefaultBlendTime() float64 {
	log.Println("Calling AnimationPlayer.GetDefaultBlendTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_default_blend_time", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the playback position (in seconds) in an animation channel (or channel 0 if none is provided).
*/
func (o *AnimationPlayer) GetPos() float64 {
	log.Println("Calling AnimationPlayer.GetPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pos", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return path to root node (see [method set_root]).
*/
func (o *AnimationPlayer) GetRoot() *NodePath {
	log.Println("Calling AnimationPlayer.GetRoot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_root", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*
   Get the speed scaling ratio in a given animation channel (or channel 0 if none is provided). Default ratio is [i]1[/i] (no scaling).
*/
func (o *AnimationPlayer) GetSpeedScale() float64 {
	log.Println("Calling AnimationPlayer.GetSpeedScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_speed_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Request whether an [Animation] name exist within the player.
*/
func (o *AnimationPlayer) HasAnimation(name string) *bool {
	log.Println("Calling AnimationPlayer.HasAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_animation", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if the player is active.
*/
func (o *AnimationPlayer) IsActive() *bool {
	log.Println("Calling AnimationPlayer.IsActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_active", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether an animation is playing.
*/
func (o *AnimationPlayer) IsPlaying() *bool {
	log.Println("Calling AnimationPlayer.IsPlaying()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_playing", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Play a given animation by the animation name. Custom speed and blend times can be set. If custom speed is negative (-1), 'from_end' being true can play the animation backwards.
*/
func (o *AnimationPlayer) Play(name string, customBlend float64, customSpeed float64, fromEnd *bool) {
	log.Println("Calling AnimationPlayer.Play()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(customBlend)
	goArguments[2] = reflect.ValueOf(customSpeed)
	goArguments[3] = reflect.ValueOf(fromEnd)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "play", goArguments, "")

	log.Println("Got return value!")

}

/*
   Play a given animation by the animation name in reverse.
*/
func (o *AnimationPlayer) PlayBackwards(name string, customBlend float64) {
	log.Println("Calling AnimationPlayer.PlayBackwards()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(customBlend)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "play_backwards", goArguments, "")

	log.Println("Got return value!")

}

/*
   Queue an animation for playback once the current one is done.
*/
func (o *AnimationPlayer) Queue(name string) {
	log.Println("Calling AnimationPlayer.Queue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "queue", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove an animation from the player (by supplying the same name used to add it).
*/
func (o *AnimationPlayer) RemoveAnimation(name string) {
	log.Println("Calling AnimationPlayer.RemoveAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_animation", goArguments, "")

	log.Println("Got return value!")

}

/*
   Rename an existing animation.
*/
func (o *AnimationPlayer) RenameAnimation(name string, newname string) {
	log.Println("Calling AnimationPlayer.RenameAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(newname)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rename_animation", goArguments, "")

	log.Println("Got return value!")

}

/*
   Seek the animation to a given position in time (in seconds). If 'update' is true, the animation will be updated too, otherwise it will be updated at process time.
*/
func (o *AnimationPlayer) Seek(posSec float64, update *bool) {
	log.Println("Calling AnimationPlayer.Seek()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(posSec)
	goArguments[1] = reflect.ValueOf(update)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "seek", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the player as active (playing). If false, it will do nothing.
*/
func (o *AnimationPlayer) SetActive(active *bool) {
	log.Println("Calling AnimationPlayer.SetActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(active)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_active", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the mode in which the animation player processes. By default, it processes on idle time (framerate dependent), but using fixed time works well for animating static collision bodies in 2D and 3D. See enum ANIMATION_PROCESS_*.
*/
func (o *AnimationPlayer) SetAnimationProcessMode(mode int64) {
	log.Println("Calling AnimationPlayer.SetAnimationProcessMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_animation_process_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the name of the animation that will be automatically played when the scene is loaded.
*/
func (o *AnimationPlayer) SetAutoplay(name string) {
	log.Println("Calling AnimationPlayer.SetAutoplay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_autoplay", goArguments, "")

	log.Println("Got return value!")

}

/*
   Specify a blend time (in seconds) between two animations, referenced by their names.
*/
func (o *AnimationPlayer) SetBlendTime(animFrom string, animTo string, sec float64) {
	log.Println("Calling AnimationPlayer.SetBlendTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(animFrom)
	goArguments[1] = reflect.ValueOf(animTo)
	goArguments[2] = reflect.ValueOf(sec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_blend_time", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the current animation (even if no playback occurs). Using set_current_animation() and set_active() are similar to calling play().
*/
func (o *AnimationPlayer) SetCurrentAnimation(anim string) {
	log.Println("Calling AnimationPlayer.SetCurrentAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(anim)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_current_animation", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the default blend time between animations.
*/
func (o *AnimationPlayer) SetDefaultBlendTime(sec float64) {
	log.Println("Calling AnimationPlayer.SetDefaultBlendTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(sec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_default_blend_time", goArguments, "")

	log.Println("Got return value!")

}

/*
   AnimationPlayer resolves animation track paths from this node (which is relative to itself), by default root is "..", but it can be changed.
*/
func (o *AnimationPlayer) SetRoot(path *NodePath) {
	log.Println("Calling AnimationPlayer.SetRoot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_root", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set a speed scaling ratio in a given animation channel (or channel 0 if none is provided). Default ratio is [i]1[/i] (no scaling).
*/
func (o *AnimationPlayer) SetSpeedScale(speed float64) {
	log.Println("Calling AnimationPlayer.SetSpeedScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(speed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_speed_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Stop the currently playing animation.
*/
func (o *AnimationPlayer) Stop(reset *bool) {
	log.Println("Calling AnimationPlayer.Stop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(reset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "stop", goArguments, "")

	log.Println("Got return value!")

}

/*
   Stop playback of animations (deprecated).
*/
func (o *AnimationPlayer) StopAll() {
	log.Println("Calling AnimationPlayer.StopAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "stop_all", goArguments, "")

	log.Println("Got return value!")

}

/*
   AnimationPlayerImplementer is an interface for AnimationPlayer objects.
   An animation player is used for general purpose playback of [Animation] resources. It contains a dictionary of animations (referenced by name) and custom blend times between their transitions. Additionally, animations can be played and blended in different channels.
*/
type AnimationPlayerImplementer interface {
	NodeImplementer

	AddAnimation(name string, animation *Animation) int64

	Advance(delta float64)

	AnimationGetNext(animFrom string) string

	AnimationSetNext(animFrom string, animTo string)

	ClearCaches()

	ClearQueue()

	FindAnimation(animation *Animation) string

	GetAnimation(name string) *Animation

	GetAnimationList() *PoolStringArray

	GetAnimationProcessMode() int64

	GetAutoplay() string

	GetBlendTime(animFrom string, animTo string) float64

	GetCurrentAnimation() string

	GetCurrentAnimationLength() float64

	GetCurrentAnimationPos() float64

	GetDefaultBlendTime() float64

	GetPos() float64

	GetRoot() *NodePath

	GetSpeedScale() float64

	HasAnimation(name string) *bool

	IsActive() *bool

	IsPlaying() *bool

	Play(name string, customBlend float64, customSpeed float64, fromEnd *bool)

	PlayBackwards(name string, customBlend float64)

	Queue(name string)

	RemoveAnimation(name string)

	RenameAnimation(name string, newname string)

	Seek(posSec float64, update *bool)

	SetActive(active *bool)

	SetAnimationProcessMode(mode int64)

	SetAutoplay(name string)

	SetBlendTime(animFrom string, animTo string, sec float64)

	SetCurrentAnimation(anim string)

	SetDefaultBlendTime(sec float64)

	SetRoot(path *NodePath)

	SetSpeedScale(speed float64)

	Stop(reset *bool)

	StopAll()
}

/*
   Animation Player that uses a node graph for the blending. This kind of player is very useful when animating character or other skeleton based rigs, because it can combine several animations to form a desired pose.
*/
type AnimationTreePlayer struct {
	Node
}

func (o *AnimationTreePlayer) baseClass() string {
	return "AnimationTreePlayer"
}

/*
   Add a node of a given type in the graph with given id.
*/
func (o *AnimationTreePlayer) AddNode(aType int64, id string) {
	log.Println("Calling AnimationTreePlayer.AddNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(aType)
	goArguments[1] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_node", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) Advance(delta float64) {
	log.Println("Calling AnimationTreePlayer.Advance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(delta)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "advance", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) AnimationNodeGetAnimation(id string) *Animation {
	log.Println("Calling AnimationTreePlayer.AnimationNodeGetAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "animation_node_get_animation", goArguments, "*Animation")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Animation)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) AnimationNodeGetMasterAnimation(id string) string {
	log.Println("Calling AnimationTreePlayer.AnimationNodeGetMasterAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "animation_node_get_master_animation", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Set the animation for an animation node.
*/
func (o *AnimationTreePlayer) AnimationNodeSetAnimation(id string, animation *Animation) {
	log.Println("Calling AnimationTreePlayer.AnimationNodeSetAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(animation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "animation_node_set_animation", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) AnimationNodeSetFilterPath(id string, path *NodePath, enable *bool) {
	log.Println("Calling AnimationTreePlayer.AnimationNodeSetFilterPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(path)
	goArguments[2] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "animation_node_set_filter_path", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) AnimationNodeSetMasterAnimation(id string, source string) {
	log.Println("Calling AnimationTreePlayer.AnimationNodeSetMasterAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(source)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "animation_node_set_master_animation", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) AreNodesConnected(id string, dstId string, dstInputIdx int64) *bool {
	log.Println("Calling AnimationTreePlayer.AreNodesConnected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(dstId)
	goArguments[2] = reflect.ValueOf(dstInputIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "are_nodes_connected", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) Blend2NodeGetAmount(id string) float64 {
	log.Println("Calling AnimationTreePlayer.Blend2NodeGetAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "blend2_node_get_amount", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) Blend2NodeSetAmount(id string, blend float64) {
	log.Println("Calling AnimationTreePlayer.Blend2NodeSetAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(blend)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "blend2_node_set_amount", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) Blend2NodeSetFilterPath(id string, path *NodePath, enable *bool) {
	log.Println("Calling AnimationTreePlayer.Blend2NodeSetFilterPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(path)
	goArguments[2] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "blend2_node_set_filter_path", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) Blend3NodeGetAmount(id string) float64 {
	log.Println("Calling AnimationTreePlayer.Blend3NodeGetAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "blend3_node_get_amount", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) Blend3NodeSetAmount(id string, blend float64) {
	log.Println("Calling AnimationTreePlayer.Blend3NodeSetAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(blend)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "blend3_node_set_amount", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) Blend4NodeGetAmount(id string) *Vector2 {
	log.Println("Calling AnimationTreePlayer.Blend4NodeGetAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "blend4_node_get_amount", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) Blend4NodeSetAmount(id string, blend *Vector2) {
	log.Println("Calling AnimationTreePlayer.Blend4NodeSetAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(blend)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "blend4_node_set_amount", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) ConnectNodes(id string, dstId string, dstInputIdx int64) int64 {
	log.Println("Calling AnimationTreePlayer.ConnectNodes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(dstId)
	goArguments[2] = reflect.ValueOf(dstInputIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "connect_nodes", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) DisconnectNodes(id string, dstInputIdx int64) {
	log.Println("Calling AnimationTreePlayer.DisconnectNodes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(dstInputIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "disconnect_nodes", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) GetAnimationProcessMode() int64 {
	log.Println("Calling AnimationTreePlayer.GetAnimationProcessMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_animation_process_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) GetBasePath() *NodePath {
	log.Println("Calling AnimationTreePlayer.GetBasePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_path", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) GetMasterPlayer() *NodePath {
	log.Println("Calling AnimationTreePlayer.GetMasterPlayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_master_player", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) GetNodeList() *PoolStringArray {
	log.Println("Calling AnimationTreePlayer.GetNodeList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_list", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) IsActive() *bool {
	log.Println("Calling AnimationTreePlayer.IsActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_active", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) MixNodeGetAmount(id string) float64 {
	log.Println("Calling AnimationTreePlayer.MixNodeGetAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "mix_node_get_amount", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) MixNodeSetAmount(id string, ratio float64) {
	log.Println("Calling AnimationTreePlayer.MixNodeSetAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(ratio)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "mix_node_set_amount", goArguments, "")

	log.Println("Got return value!")

}

/*
   Check if a node exists (by name).
*/
func (o *AnimationTreePlayer) NodeExists(node string) *bool {
	log.Println("Calling AnimationTreePlayer.NodeExists()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "node_exists", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return the input count for a given node. Different types of nodes have different amount of inputs.
*/
func (o *AnimationTreePlayer) NodeGetInputCount(id string) int64 {
	log.Println("Calling AnimationTreePlayer.NodeGetInputCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "node_get_input_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the input source for a given node input.
*/
func (o *AnimationTreePlayer) NodeGetInputSource(id string, idx int64) string {
	log.Println("Calling AnimationTreePlayer.NodeGetInputSource()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "node_get_input_source", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) NodeGetPos(id string) *Vector2 {
	log.Println("Calling AnimationTreePlayer.NodeGetPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "node_get_pos", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Get the node type, will return from NODE_* enum.
*/
func (o *AnimationTreePlayer) NodeGetType(id string) int64 {
	log.Println("Calling AnimationTreePlayer.NodeGetType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "node_get_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Rename a node in the graph.
*/
func (o *AnimationTreePlayer) NodeRename(node string, newName string) int64 {
	log.Println("Calling AnimationTreePlayer.NodeRename()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(node)
	goArguments[1] = reflect.ValueOf(newName)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "node_rename", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) NodeSetPos(id string, screenPos *Vector2) {
	log.Println("Calling AnimationTreePlayer.NodeSetPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(screenPos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "node_set_pos", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) OneshotNodeGetAutorestartDelay(id string) float64 {
	log.Println("Calling AnimationTreePlayer.OneshotNodeGetAutorestartDelay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "oneshot_node_get_autorestart_delay", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) OneshotNodeGetAutorestartRandomDelay(id string) float64 {
	log.Println("Calling AnimationTreePlayer.OneshotNodeGetAutorestartRandomDelay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "oneshot_node_get_autorestart_random_delay", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) OneshotNodeGetFadeinTime(id string) float64 {
	log.Println("Calling AnimationTreePlayer.OneshotNodeGetFadeinTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "oneshot_node_get_fadein_time", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) OneshotNodeGetFadeoutTime(id string) float64 {
	log.Println("Calling AnimationTreePlayer.OneshotNodeGetFadeoutTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "oneshot_node_get_fadeout_time", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) OneshotNodeHasAutorestart(id string) *bool {
	log.Println("Calling AnimationTreePlayer.OneshotNodeHasAutorestart()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "oneshot_node_has_autorestart", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) OneshotNodeIsActive(id string) *bool {
	log.Println("Calling AnimationTreePlayer.OneshotNodeIsActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "oneshot_node_is_active", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) OneshotNodeSetAutorestart(id string, enable *bool) {
	log.Println("Calling AnimationTreePlayer.OneshotNodeSetAutorestart()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "oneshot_node_set_autorestart", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) OneshotNodeSetAutorestartDelay(id string, delaySec float64) {
	log.Println("Calling AnimationTreePlayer.OneshotNodeSetAutorestartDelay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(delaySec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "oneshot_node_set_autorestart_delay", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) OneshotNodeSetAutorestartRandomDelay(id string, randSec float64) {
	log.Println("Calling AnimationTreePlayer.OneshotNodeSetAutorestartRandomDelay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(randSec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "oneshot_node_set_autorestart_random_delay", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) OneshotNodeSetFadeinTime(id string, timeSec float64) {
	log.Println("Calling AnimationTreePlayer.OneshotNodeSetFadeinTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(timeSec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "oneshot_node_set_fadein_time", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) OneshotNodeSetFadeoutTime(id string, timeSec float64) {
	log.Println("Calling AnimationTreePlayer.OneshotNodeSetFadeoutTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(timeSec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "oneshot_node_set_fadeout_time", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) OneshotNodeSetFilterPath(id string, path *NodePath, enable *bool) {
	log.Println("Calling AnimationTreePlayer.OneshotNodeSetFilterPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(path)
	goArguments[2] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "oneshot_node_set_filter_path", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) OneshotNodeStart(id string) {
	log.Println("Calling AnimationTreePlayer.OneshotNodeStart()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "oneshot_node_start", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) OneshotNodeStop(id string) {
	log.Println("Calling AnimationTreePlayer.OneshotNodeStop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "oneshot_node_stop", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) RecomputeCaches() {
	log.Println("Calling AnimationTreePlayer.RecomputeCaches()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "recompute_caches", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) RemoveNode(id string) {
	log.Println("Calling AnimationTreePlayer.RemoveNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_node", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) Reset() {
	log.Println("Calling AnimationTreePlayer.Reset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "reset", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) SetActive(enabled *bool) {
	log.Println("Calling AnimationTreePlayer.SetActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_active", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) SetAnimationProcessMode(mode int64) {
	log.Println("Calling AnimationTreePlayer.SetAnimationProcessMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_animation_process_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) SetBasePath(path *NodePath) {
	log.Println("Calling AnimationTreePlayer.SetBasePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_path", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) SetMasterPlayer(nodepath *NodePath) {
	log.Println("Calling AnimationTreePlayer.SetMasterPlayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(nodepath)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_master_player", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) TimescaleNodeGetScale(id string) float64 {
	log.Println("Calling AnimationTreePlayer.TimescaleNodeGetScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "timescale_node_get_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) TimescaleNodeSetScale(id string, scale float64) {
	log.Println("Calling AnimationTreePlayer.TimescaleNodeSetScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "timescale_node_set_scale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) TimeseekNodeSeek(id string, posSec float64) {
	log.Println("Calling AnimationTreePlayer.TimeseekNodeSeek()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(posSec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "timeseek_node_seek", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) TransitionNodeDeleteInput(id string, inputIdx int64) {
	log.Println("Calling AnimationTreePlayer.TransitionNodeDeleteInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(inputIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "transition_node_delete_input", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) TransitionNodeGetCurrent(id string) int64 {
	log.Println("Calling AnimationTreePlayer.TransitionNodeGetCurrent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "transition_node_get_current", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) TransitionNodeGetInputCount(id string) int64 {
	log.Println("Calling AnimationTreePlayer.TransitionNodeGetInputCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "transition_node_get_input_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) TransitionNodeGetXfadeTime(id string) float64 {
	log.Println("Calling AnimationTreePlayer.TransitionNodeGetXfadeTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "transition_node_get_xfade_time", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) TransitionNodeHasInputAutoAdvance(id string, inputIdx int64) *bool {
	log.Println("Calling AnimationTreePlayer.TransitionNodeHasInputAutoAdvance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(inputIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "transition_node_has_input_auto_advance", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *AnimationTreePlayer) TransitionNodeSetCurrent(id string, inputIdx int64) {
	log.Println("Calling AnimationTreePlayer.TransitionNodeSetCurrent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(inputIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "transition_node_set_current", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) TransitionNodeSetInputAutoAdvance(id string, inputIdx int64, enable *bool) {
	log.Println("Calling AnimationTreePlayer.TransitionNodeSetInputAutoAdvance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(inputIdx)
	goArguments[2] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "transition_node_set_input_auto_advance", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) TransitionNodeSetInputCount(id string, count int64) {
	log.Println("Calling AnimationTreePlayer.TransitionNodeSetInputCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(count)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "transition_node_set_input_count", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AnimationTreePlayer) TransitionNodeSetXfadeTime(id string, timeSec float64) {
	log.Println("Calling AnimationTreePlayer.TransitionNodeSetXfadeTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(timeSec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "transition_node_set_xfade_time", goArguments, "")

	log.Println("Got return value!")

}

/*
   AnimationTreePlayerImplementer is an interface for AnimationTreePlayer objects.
   Animation Player that uses a node graph for the blending. This kind of player is very useful when animating character or other skeleton based rigs, because it can combine several animations to form a desired pose.
*/
type AnimationTreePlayerImplementer interface {
	NodeImplementer

	AddNode(aType int64, id string)

	Advance(delta float64)

	AnimationNodeGetAnimation(id string) *Animation

	AnimationNodeGetMasterAnimation(id string) string

	AnimationNodeSetAnimation(id string, animation *Animation)

	AnimationNodeSetFilterPath(id string, path *NodePath, enable *bool)

	AnimationNodeSetMasterAnimation(id string, source string)

	AreNodesConnected(id string, dstId string, dstInputIdx int64) *bool

	Blend2NodeGetAmount(id string) float64

	Blend2NodeSetAmount(id string, blend float64)

	Blend2NodeSetFilterPath(id string, path *NodePath, enable *bool)

	Blend3NodeGetAmount(id string) float64

	Blend3NodeSetAmount(id string, blend float64)

	Blend4NodeGetAmount(id string) *Vector2

	Blend4NodeSetAmount(id string, blend *Vector2)

	ConnectNodes(id string, dstId string, dstInputIdx int64) int64

	DisconnectNodes(id string, dstInputIdx int64)

	GetAnimationProcessMode() int64

	GetBasePath() *NodePath

	GetMasterPlayer() *NodePath

	GetNodeList() *PoolStringArray

	IsActive() *bool

	MixNodeGetAmount(id string) float64

	MixNodeSetAmount(id string, ratio float64)

	NodeExists(node string) *bool

	NodeGetInputCount(id string) int64

	NodeGetInputSource(id string, idx int64) string

	NodeGetPos(id string) *Vector2

	NodeGetType(id string) int64

	NodeRename(node string, newName string) int64

	NodeSetPos(id string, screenPos *Vector2)

	OneshotNodeGetAutorestartDelay(id string) float64

	OneshotNodeGetAutorestartRandomDelay(id string) float64

	OneshotNodeGetFadeinTime(id string) float64

	OneshotNodeGetFadeoutTime(id string) float64

	OneshotNodeHasAutorestart(id string) *bool

	OneshotNodeIsActive(id string) *bool

	OneshotNodeSetAutorestart(id string, enable *bool)

	OneshotNodeSetAutorestartDelay(id string, delaySec float64)

	OneshotNodeSetAutorestartRandomDelay(id string, randSec float64)

	OneshotNodeSetFadeinTime(id string, timeSec float64)

	OneshotNodeSetFadeoutTime(id string, timeSec float64)

	OneshotNodeSetFilterPath(id string, path *NodePath, enable *bool)

	OneshotNodeStart(id string)

	OneshotNodeStop(id string)

	RecomputeCaches()

	RemoveNode(id string)

	Reset()

	SetActive(enabled *bool)

	SetAnimationProcessMode(mode int64)

	SetBasePath(path *NodePath)

	SetMasterPlayer(nodepath *NodePath)

	TimescaleNodeGetScale(id string) float64

	TimescaleNodeSetScale(id string, scale float64)

	TimeseekNodeSeek(id string, posSec float64)

	TransitionNodeDeleteInput(id string, inputIdx int64)

	TransitionNodeGetCurrent(id string) int64

	TransitionNodeGetInputCount(id string) int64

	TransitionNodeGetXfadeTime(id string) float64

	TransitionNodeHasInputAutoAdvance(id string, inputIdx int64) *bool

	TransitionNodeSetCurrent(id string, inputIdx int64)

	TransitionNodeSetInputAutoAdvance(id string, inputIdx int64, enable *bool)

	TransitionNodeSetInputCount(id string, count int64)

	TransitionNodeSetXfadeTime(id string, timeSec float64)
}

/*
   General purpose area detection for 3D physics. Areas can be used for detection of objects that enter/exit them, as well as overriding space parameters (changing gravity, damping, etc). For this, use any space override different from AREA_SPACE_OVERRIDE_DISABLE and point gravity at the center of mass.
*/
type Area struct {
	CollisionObject
}

func (o *Area) baseClass() string {
	return "Area"
}

/*
   Return the angular damp rate.
*/
func (o *Area) GetAngularDamp() float64 {
	log.Println("Calling Area.GetAngularDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_angular_damp", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Area) GetAudioBus() string {
	log.Println("Calling Area.GetAudioBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_audio_bus", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the physics layer this area is in.
*/
func (o *Area) GetCollisionLayer() int64 {
	log.Println("Calling Area.GetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_layer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return an individual bit on the layer mask.
*/
func (o *Area) GetCollisionLayerBit(bit int64) *bool {
	log.Println("Calling Area.GetCollisionLayerBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bit)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_layer_bit", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return the physics layers this area can scan for collisions.
*/
func (o *Area) GetCollisionMask() int64 {
	log.Println("Calling Area.GetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return an individual bit on the collision mask.
*/
func (o *Area) GetCollisionMaskBit(bit int64) *bool {
	log.Println("Calling Area.GetCollisionMaskBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bit)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_mask_bit", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return the gravity intensity.
*/
func (o *Area) GetGravity() float64 {
	log.Println("Calling Area.GetGravity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gravity", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the falloff factor for point gravity.
*/
func (o *Area) GetGravityDistanceScale() float64 {
	log.Println("Calling Area.GetGravityDistanceScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gravity_distance_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the gravity vector. If gravity is a point (see [method is_gravity_a_point]), this will be the attraction center.
*/
func (o *Area) GetGravityVector() *Vector3 {
	log.Println("Calling Area.GetGravityVector()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gravity_vector", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Return the linear damp rate.
*/
func (o *Area) GetLinearDamp() float64 {
	log.Println("Calling Area.GetLinearDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_linear_damp", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return a list of the areas that are totally or partially inside this area.
*/
func (o *Area) GetOverlappingAreas() *Array {
	log.Println("Calling Area.GetOverlappingAreas()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_overlapping_areas", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Return a list of the bodies ([PhysicsBody]) that are totally or partially inside this area.
*/
func (o *Area) GetOverlappingBodies() *Array {
	log.Println("Calling Area.GetOverlappingBodies()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_overlapping_bodies", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Return the processing order of this area.
*/
func (o *Area) GetPriority() float64 {
	log.Println("Calling Area.GetPriority()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_priority", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Area) GetReverbAmount() float64 {
	log.Println("Calling Area.GetReverbAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_reverb_amount", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Area) GetReverbBus() string {
	log.Println("Calling Area.GetReverbBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_reverb_bus", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *Area) GetReverbUniformity() float64 {
	log.Println("Calling Area.GetReverbUniformity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_reverb_uniformity", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the space override mode.
*/
func (o *Area) GetSpaceOverrideMode() int64 {
	log.Println("Calling Area.GetSpaceOverrideMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_space_override_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return whether gravity is a point. A point gravity will attract objects towards it, as opposed to a gravity vector, which moves them in a given direction.
*/
func (o *Area) IsGravityAPoint() *bool {
	log.Println("Calling Area.IsGravityAPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_gravity_a_point", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether this area can be detected by other, monitoring, areas.
*/
func (o *Area) IsMonitorable() *bool {
	log.Println("Calling Area.IsMonitorable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_monitorable", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether this area detects bodies/areas entering/exiting it.
*/
func (o *Area) IsMonitoring() *bool {
	log.Println("Calling Area.IsMonitoring()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_monitoring", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Area) IsOverridingAudioBus() *bool {
	log.Println("Calling Area.IsOverridingAudioBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_overriding_audio_bus", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Area) IsUsingReverbBus() *bool {
	log.Println("Calling Area.IsUsingReverbBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_using_reverb_bus", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether the area passed is totally or partially inside this area.
*/
func (o *Area) OverlapsArea(area *Node) *bool {
	log.Println("Calling Area.OverlapsArea()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "overlaps_area", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether the body passed is totally or partially inside this area.
*/
func (o *Area) OverlapsBody(body *Node) *bool {
	log.Println("Calling Area.OverlapsBody()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "overlaps_body", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
                Set the rate at which objects stop spinning in this area, if there are not any other forces making it spin. The value is a fraction of its current speed, lost per second. Thus, a value of 1.0 should mean stopping immediately, and 0.0 means the object never stops.
				In practice, as the fraction of speed lost gets smaller with each frame, a value of 1.0 does not mean the object will stop in exactly one second. Only when the physics calculations are done at 1 frame per second, it does stop in a second.
*/
func (o *Area) SetAngularDamp(angularDamp float64) {
	log.Println("Calling Area.SetAngularDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(angularDamp)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_angular_damp", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Area) SetAudioBus(name string) {
	log.Println("Calling Area.SetAudioBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_audio_bus", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Area) SetAudioBusOverride(enable *bool) {
	log.Println("Calling Area.SetAudioBusOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_audio_bus_override", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set the physics layers this area is in.
				Collidable objects can exist in any of 32 different layers. These layers are not visual, but more of a tagging system instead. A collidable can use these layers/tags to select with which objects it can collide, using [method set_collision_mask].
				A contact is detected if object A is in any of the layers that object B scans, or object B is in any layer scanned by object A.
*/
func (o *Area) SetCollisionLayer(collisionLayer int64) {
	log.Println("Calling Area.SetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collisionLayer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set/clear individual bits on the layer mask. This makes getting an area in/out of only one layer easier.
*/
func (o *Area) SetCollisionLayerBit(bit int64, value *bool) {
	log.Println("Calling Area.SetCollisionLayerBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(bit)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer_bit", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the physics layers this area can scan for collisions.
*/
func (o *Area) SetCollisionMask(collisionMask int64) {
	log.Println("Calling Area.SetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collisionMask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_mask", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set/clear individual bits on the collision mask. This makes selecting the areas scanned easier.
*/
func (o *Area) SetCollisionMaskBit(bit int64, value *bool) {
	log.Println("Calling Area.SetCollisionMaskBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(bit)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_mask_bit", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set the gravity intensity. This is useful to alter the force of gravity without altering its direction.
				This value multiplies the gravity vector, whether it is the given vector ([method set_gravity_vector]), or a calculated one (when using a center of gravity).
*/
func (o *Area) SetGravity(gravity float64) {
	log.Println("Calling Area.SetGravity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(gravity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the falloff factor for point gravity. The greater this value is, the faster the strength of gravity decreases with the square of distance.
*/
func (o *Area) SetGravityDistanceScale(distanceScale float64) {
	log.Println("Calling Area.SetGravityDistanceScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(distanceScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity_distance_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   When overriding space parameters, this method sets whether this area has a center of gravity. To set/get the location of the center of gravity, use [method set_gravity_vector]/[method get_gravity_vector].
*/
func (o *Area) SetGravityIsPoint(enable *bool) {
	log.Println("Calling Area.SetGravityIsPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity_is_point", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set the gravity vector. This vector does not have to be normalized.
				If gravity is a point (see [method is_gravity_a_point]), this will be the attraction center.
*/
func (o *Area) SetGravityVector(vector *Vector3) {
	log.Println("Calling Area.SetGravityVector()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vector)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity_vector", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set the rate at which objects stop moving in this area, if there are not any other forces moving it. The value is a fraction of its current speed, lost per second. Thus, a value of 1.0 should mean stopping immediately, and 0.0 means the object never stops.
				In practice, as the fraction of speed lost gets smaller with each frame, a value of 1.0 does not mean the object will stop in exactly one second. Only when the physics calculations are done at 1 frame per second, it does stop in a second.
*/
func (o *Area) SetLinearDamp(linearDamp float64) {
	log.Println("Calling Area.SetLinearDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(linearDamp)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_linear_damp", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether this area can be detected by other, monitoring, areas. Only areas need to be marked as monitorable. Bodies are always so.
*/
func (o *Area) SetMonitorable(enable *bool) {
	log.Println("Calling Area.SetMonitorable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_monitorable", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether this area can detect bodies/areas entering/exiting it.
*/
func (o *Area) SetMonitoring(enable *bool) {
	log.Println("Calling Area.SetMonitoring()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_monitoring", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set the order in which the area is processed. Greater values mean the area gets processed first. This is useful for areas which have a space override different from AREA_SPACE_OVERRIDE_DISABLED or AREA_SPACE_OVERRIDE_COMBINE, as they replace values, and are thus order-dependent.
				Areas with the same priority value get evaluated in an unpredictable order, and should be differentiated if evaluation order is to be important.
*/
func (o *Area) SetPriority(priority float64) {
	log.Println("Calling Area.SetPriority()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(priority)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_priority", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Area) SetReverbAmount(amount float64) {
	log.Println("Calling Area.SetReverbAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_reverb_amount", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Area) SetReverbBus(name string) {
	log.Println("Calling Area.SetReverbBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_reverb_bus", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Area) SetReverbUniformity(amount float64) {
	log.Println("Calling Area.SetReverbUniformity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_reverb_uniformity", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set the space override mode. This mode controls how an area affects gravity and damp.
				AREA_SPACE_OVERRIDE_DISABLED: This area does not affect gravity/damp. These are generally areas that exist only to detect collisions, and objects entering or exiting them.
				AREA_SPACE_OVERRIDE_COMBINE: This area adds its gravity/damp values to whatever has been calculated so far. This way, many overlapping areas can combine their physics to make interesting effects.
				AREA_SPACE_OVERRIDE_COMBINE_REPLACE: This area adds its gravity/damp values to whatever has been calculated so far. Then stops taking into account the rest of the areas, even the default one.
				AREA_SPACE_OVERRIDE_REPLACE: This area replaces any gravity/damp, even the default one, and stops taking into account the rest of the areas.
				AREA_SPACE_OVERRIDE_REPLACE_COMBINE: This area replaces any gravity/damp calculated so far, but keeps calculating the rest of the areas, down to the default one.
*/
func (o *Area) SetSpaceOverrideMode(enable int64) {
	log.Println("Calling Area.SetSpaceOverrideMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_space_override_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Area) SetUseReverbBus(enable *bool) {
	log.Println("Calling Area.SetUseReverbBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_reverb_bus", goArguments, "")

	log.Println("Got return value!")

}

/*
   AreaImplementer is an interface for Area objects.
   General purpose area detection for 3D physics. Areas can be used for detection of objects that enter/exit them, as well as overriding space parameters (changing gravity, damping, etc). For this, use any space override different from AREA_SPACE_OVERRIDE_DISABLE and point gravity at the center of mass.
*/
type AreaImplementer interface {
	CollisionObjectImplementer

	GetAngularDamp() float64

	GetAudioBus() string

	GetCollisionLayer() int64

	GetCollisionLayerBit(bit int64) *bool

	GetCollisionMask() int64

	GetCollisionMaskBit(bit int64) *bool

	GetGravity() float64

	GetGravityDistanceScale() float64

	GetGravityVector() *Vector3

	GetLinearDamp() float64

	GetOverlappingAreas() *Array

	GetOverlappingBodies() *Array

	GetPriority() float64

	GetReverbAmount() float64

	GetReverbBus() string

	GetReverbUniformity() float64

	GetSpaceOverrideMode() int64

	IsGravityAPoint() *bool

	IsMonitorable() *bool

	IsMonitoring() *bool

	IsOverridingAudioBus() *bool

	IsUsingReverbBus() *bool

	OverlapsArea(area *Node) *bool

	OverlapsBody(body *Node) *bool

	SetAngularDamp(angularDamp float64)

	SetAudioBus(name string)

	SetAudioBusOverride(enable *bool)

	SetCollisionLayer(collisionLayer int64)

	SetCollisionLayerBit(bit int64, value *bool)

	SetCollisionMask(collisionMask int64)

	SetCollisionMaskBit(bit int64, value *bool)

	SetGravity(gravity float64)

	SetGravityDistanceScale(distanceScale float64)

	SetGravityIsPoint(enable *bool)

	SetGravityVector(vector *Vector3)

	SetLinearDamp(linearDamp float64)

	SetMonitorable(enable *bool)

	SetMonitoring(enable *bool)

	SetPriority(priority float64)

	SetReverbAmount(amount float64)

	SetReverbBus(name string)

	SetReverbUniformity(amount float64)

	SetSpaceOverrideMode(enable int64)

	SetUseReverbBus(enable *bool)
}

/*
   General purpose area detection for 2D physics. Areas can be used for detection of objects that enter/exit them, as well as overriding space parameters (changing gravity, damping, etc). For this, use any space override different from AREA_SPACE_OVERRIDE_DISABLE and point gravity at the center of mass.
*/
type Area2D struct {
	CollisionObject2D
}

func (o *Area2D) baseClass() string {
	return "Area2D"
}

/*
   Return the angular damp rate.
*/
func (o *Area2D) GetAngularDamp() float64 {
	log.Println("Calling Area2D.GetAngularDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_angular_damp", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Area2D) GetAudioBus() string {
	log.Println("Calling Area2D.GetAudioBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_audio_bus", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the physics layer this area is in.
*/
func (o *Area2D) GetCollisionLayer() int64 {
	log.Println("Calling Area2D.GetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_layer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return an individual bit on the layer mask.
*/
func (o *Area2D) GetCollisionLayerBit(bit int64) *bool {
	log.Println("Calling Area2D.GetCollisionLayerBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bit)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_layer_bit", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return the physics layers this area can scan for collisions.
*/
func (o *Area2D) GetCollisionMask() int64 {
	log.Println("Calling Area2D.GetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return an individual bit on the collision mask.
*/
func (o *Area2D) GetCollisionMaskBit(bit int64) *bool {
	log.Println("Calling Area2D.GetCollisionMaskBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bit)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_mask_bit", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return the gravity intensity.
*/
func (o *Area2D) GetGravity() float64 {
	log.Println("Calling Area2D.GetGravity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gravity", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the falloff factor for point gravity.
*/
func (o *Area2D) GetGravityDistanceScale() float64 {
	log.Println("Calling Area2D.GetGravityDistanceScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gravity_distance_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the gravity vector. If gravity is a point (see [method is_gravity_a_point]), this will be the attraction center.
*/
func (o *Area2D) GetGravityVector() *Vector2 {
	log.Println("Calling Area2D.GetGravityVector()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gravity_vector", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the linear damp rate.
*/
func (o *Area2D) GetLinearDamp() float64 {
	log.Println("Calling Area2D.GetLinearDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_linear_damp", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return a list of the areas that are totally or partially inside this area.
*/
func (o *Area2D) GetOverlappingAreas() *Array {
	log.Println("Calling Area2D.GetOverlappingAreas()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_overlapping_areas", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Return a list of the bodies ([PhysicsBody2D]) that are totally or partially inside this area.
*/
func (o *Area2D) GetOverlappingBodies() *Array {
	log.Println("Calling Area2D.GetOverlappingBodies()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_overlapping_bodies", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Return the processing order of this area.
*/
func (o *Area2D) GetPriority() float64 {
	log.Println("Calling Area2D.GetPriority()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_priority", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the space override mode.
*/
func (o *Area2D) GetSpaceOverrideMode() int64 {
	log.Println("Calling Area2D.GetSpaceOverrideMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_space_override_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return whether gravity is a point. A point gravity will attract objects towards it, as opposed to a gravity vector, which moves them in a given direction.
*/
func (o *Area2D) IsGravityAPoint() *bool {
	log.Println("Calling Area2D.IsGravityAPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_gravity_a_point", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether this area can be detected by other, monitoring, areas.
*/
func (o *Area2D) IsMonitorable() *bool {
	log.Println("Calling Area2D.IsMonitorable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_monitorable", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether this area detects bodies/areas entering/exiting it.
*/
func (o *Area2D) IsMonitoring() *bool {
	log.Println("Calling Area2D.IsMonitoring()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_monitoring", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Area2D) IsOverridingAudioBus() *bool {
	log.Println("Calling Area2D.IsOverridingAudioBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_overriding_audio_bus", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether the area passed is totally or partially inside this area.
*/
func (o *Area2D) OverlapsArea(area *Node) *bool {
	log.Println("Calling Area2D.OverlapsArea()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "overlaps_area", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether the body passed is totally or partially inside this area.
*/
func (o *Area2D) OverlapsBody(body *Node) *bool {
	log.Println("Calling Area2D.OverlapsBody()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "overlaps_body", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
                Set the rate at which objects stop spinning in this area, if there are not any other forces making it spin. The value is a fraction of its current speed, lost per second. Thus, a value of 1.0 should mean stopping immediately, and 0.0 means the object never stops.
				In practice, as the fraction of speed lost gets smaller with each frame, a value of 1.0 does not mean the object will stop in exactly one second. Only when the physics calculations are done at 1 frame per second, it does stop in a second.
*/
func (o *Area2D) SetAngularDamp(angularDamp float64) {
	log.Println("Calling Area2D.SetAngularDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(angularDamp)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_angular_damp", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Area2D) SetAudioBus(name string) {
	log.Println("Calling Area2D.SetAudioBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_audio_bus", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Area2D) SetAudioBusOverride(enable *bool) {
	log.Println("Calling Area2D.SetAudioBusOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_audio_bus_override", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set the physics layers this area is in.
				Collidable objects can exist in any of 32 different layers. These layers are not visual, but more of a tagging system instead. A collidable can use these layers/tags to select with which objects it can collide, using [method set_collision_mask].
				A contact is detected if object A is in any of the layers that object B scans, or object B is in any layer scanned by object A.
*/
func (o *Area2D) SetCollisionLayer(collisionLayer int64) {
	log.Println("Calling Area2D.SetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collisionLayer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set/clear individual bits on the layer mask. This makes getting an area in/out of only one layer easier.
*/
func (o *Area2D) SetCollisionLayerBit(bit int64, value *bool) {
	log.Println("Calling Area2D.SetCollisionLayerBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(bit)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer_bit", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the physics layers this area can scan for collisions.
*/
func (o *Area2D) SetCollisionMask(collisionMask int64) {
	log.Println("Calling Area2D.SetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collisionMask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_mask", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set/clear individual bits on the collision mask. This makes selecting the areas scanned easier.
*/
func (o *Area2D) SetCollisionMaskBit(bit int64, value *bool) {
	log.Println("Calling Area2D.SetCollisionMaskBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(bit)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_mask_bit", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set the gravity intensity. This is useful to alter the force of gravity without altering its direction.
				This value multiplies the gravity vector, whether it is the given vector ([method set_gravity_vector]), or a calculated one (when using a center of gravity).
*/
func (o *Area2D) SetGravity(gravity float64) {
	log.Println("Calling Area2D.SetGravity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(gravity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the falloff factor for point gravity. The greater this value is, the faster the strength of gravity decreases with the square of distance.
*/
func (o *Area2D) SetGravityDistanceScale(distanceScale float64) {
	log.Println("Calling Area2D.SetGravityDistanceScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(distanceScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity_distance_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   When overriding space parameters, this method sets whether this area has a center of gravity. To set/get the location of the center of gravity, use [method set_gravity_vector]/[method get_gravity_vector].
*/
func (o *Area2D) SetGravityIsPoint(enable *bool) {
	log.Println("Calling Area2D.SetGravityIsPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity_is_point", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set the gravity vector. This vector does not have to be normalized.
				If gravity is a point (see [method is_gravity_a_point]), this will be the attraction center.
*/
func (o *Area2D) SetGravityVector(vector *Vector2) {
	log.Println("Calling Area2D.SetGravityVector()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vector)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity_vector", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set the rate at which objects stop moving in this area, if there are not any other forces moving it. The value is a fraction of its current speed, lost per second. Thus, a value of 1.0 should mean stopping immediately, and 0.0 means the object never stops.
				In practice, as the fraction of speed lost gets smaller with each frame, a value of 1.0 does not mean the object will stop in exactly one second. Only when the physics calculations are done at 1 frame per second, it does stop in a second.
*/
func (o *Area2D) SetLinearDamp(linearDamp float64) {
	log.Println("Calling Area2D.SetLinearDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(linearDamp)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_linear_damp", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether this area can be detected by other, monitoring, areas. Only areas need to be marked as monitorable. Bodies are always so.
*/
func (o *Area2D) SetMonitorable(enable *bool) {
	log.Println("Calling Area2D.SetMonitorable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_monitorable", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether this area can detect bodies/areas entering/exiting it.
*/
func (o *Area2D) SetMonitoring(enable *bool) {
	log.Println("Calling Area2D.SetMonitoring()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_monitoring", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set the order in which the area is processed. Greater values mean the area gets processed first. This is useful for areas which have a space override different from AREA_SPACE_OVERRIDE_DISABLED or AREA_SPACE_OVERRIDE_COMBINE, as they replace values, and are thus order-dependent.
				Areas with the same priority value get evaluated in an unpredictable order, and should be differentiated if evaluation order is to be important.
*/
func (o *Area2D) SetPriority(priority float64) {
	log.Println("Calling Area2D.SetPriority()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(priority)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_priority", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set the space override mode. This mode controls how an area affects gravity and damp.
				AREA_SPACE_OVERRIDE_DISABLED: This area does not affect gravity/damp. These are generally areas that exist only to detect collisions, and objects entering or exiting them.
				AREA_SPACE_OVERRIDE_COMBINE: This area adds its gravity/damp values to whatever has been calculated so far. This way, many overlapping areas can combine their physics to make interesting effects.
				AREA_SPACE_OVERRIDE_COMBINE_REPLACE: This area adds its gravity/damp values to whatever has been calculated so far. Then stops taking into account the rest of the areas, even the default one.
				AREA_SPACE_OVERRIDE_REPLACE: This area replaces any gravity/damp, even the default one, and stops taking into account the rest of the areas.
				AREA_SPACE_OVERRIDE_REPLACE_COMBINE: This area replaces any gravity/damp calculated so far, but keeps calculating the rest of the areas, down to the default one.
*/
func (o *Area2D) SetSpaceOverrideMode(enable int64) {
	log.Println("Calling Area2D.SetSpaceOverrideMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_space_override_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Area2DImplementer is an interface for Area2D objects.
   General purpose area detection for 2D physics. Areas can be used for detection of objects that enter/exit them, as well as overriding space parameters (changing gravity, damping, etc). For this, use any space override different from AREA_SPACE_OVERRIDE_DISABLE and point gravity at the center of mass.
*/
type Area2DImplementer interface {
	CollisionObject2DImplementer

	GetAngularDamp() float64

	GetAudioBus() string

	GetCollisionLayer() int64

	GetCollisionLayerBit(bit int64) *bool

	GetCollisionMask() int64

	GetCollisionMaskBit(bit int64) *bool

	GetGravity() float64

	GetGravityDistanceScale() float64

	GetGravityVector() *Vector2

	GetLinearDamp() float64

	GetOverlappingAreas() *Array

	GetOverlappingBodies() *Array

	GetPriority() float64

	GetSpaceOverrideMode() int64

	IsGravityAPoint() *bool

	IsMonitorable() *bool

	IsMonitoring() *bool

	IsOverridingAudioBus() *bool

	OverlapsArea(area *Node) *bool

	OverlapsBody(body *Node) *bool

	SetAngularDamp(angularDamp float64)

	SetAudioBus(name string)

	SetAudioBusOverride(enable *bool)

	SetCollisionLayer(collisionLayer int64)

	SetCollisionLayerBit(bit int64, value *bool)

	SetCollisionMask(collisionMask int64)

	SetCollisionMaskBit(bit int64, value *bool)

	SetGravity(gravity float64)

	SetGravityDistanceScale(distanceScale float64)

	SetGravityIsPoint(enable *bool)

	SetGravityVector(vector *Vector2)

	SetLinearDamp(linearDamp float64)

	SetMonitorable(enable *bool)

	SetMonitoring(enable *bool)

	SetPriority(priority float64)

	SetSpaceOverrideMode(enable int64)
}

/*

 */
type ArrayMesh struct {
	Mesh
}

func (o *ArrayMesh) baseClass() string {
	return "ArrayMesh"
}

/*

 */
func (o *ArrayMesh) AddBlendShape(name string) {
	log.Println("Calling ArrayMesh.AddBlendShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_blend_shape", goArguments, "")

	log.Println("Got return value!")

}

/*
                Create a new surface ([method get_surface_count] that will become surf_idx for this.
				Surfaces are created to be rendered using a "primitive", which may be PRIMITIVE_POINTS, PRIMITIVE_LINES, PRIMITIVE_LINE_STRIP, PRIMITIVE_LINE_LOOP, PRIMITIVE_TRIANGLES, PRIMITIVE_TRIANGLE_STRIP, PRIMITIVE_TRIANGLE_FAN. (As a note, when using indices, it is recommended to only use just points, lines or triangles).
*/
func (o *ArrayMesh) AddSurfaceFromArrays(primitive int64, arrays *Array, blendShapes *Array, compressFlags int64) {
	log.Println("Calling ArrayMesh.AddSurfaceFromArrays()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(primitive)
	goArguments[1] = reflect.ValueOf(arrays)
	goArguments[2] = reflect.ValueOf(blendShapes)
	goArguments[3] = reflect.ValueOf(compressFlags)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_surface_from_arrays", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ArrayMesh) CenterGeometry() {
	log.Println("Calling ArrayMesh.CenterGeometry()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "center_geometry", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ArrayMesh) ClearBlendShapes() {
	log.Println("Calling ArrayMesh.ClearBlendShapes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_blend_shapes", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ArrayMesh) GetBlendShapeCount() int64 {
	log.Println("Calling ArrayMesh.GetBlendShapeCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_blend_shape_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ArrayMesh) GetBlendShapeMode() int64 {
	log.Println("Calling ArrayMesh.GetBlendShapeMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_blend_shape_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ArrayMesh) GetBlendShapeName(index int64) string {
	log.Println("Calling ArrayMesh.GetBlendShapeName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_blend_shape_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *ArrayMesh) GetCustomAabb() *Rect3 {
	log.Println("Calling ArrayMesh.GetCustomAabb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_custom_aabb", goArguments, "*Rect3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect3)

	return returnValue

}

/*
   Return the amount of surfaces that the [ArrayMesh] holds.
*/
func (o *ArrayMesh) GetSurfaceCount() int64 {
	log.Println("Calling ArrayMesh.GetSurfaceCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_surface_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ArrayMesh) RegenNormalmaps() {
	log.Println("Calling ArrayMesh.RegenNormalmaps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "regen_normalmaps", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ArrayMesh) SetBlendShapeMode(mode int64) {
	log.Println("Calling ArrayMesh.SetBlendShapeMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_blend_shape_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ArrayMesh) SetCustomAabb(aabb *Rect3) {
	log.Println("Calling ArrayMesh.SetCustomAabb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aabb)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_custom_aabb", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the length in indices of the index array in the requested surface (see [method add_surface]).
*/
func (o *ArrayMesh) SurfaceGetArrayIndexLen(surfIdx int64) int64 {
	log.Println("Calling ArrayMesh.SurfaceGetArrayIndexLen()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(surfIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "surface_get_array_index_len", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the length in vertices of the vertex array in the requested surface (see [method add_surface]).
*/
func (o *ArrayMesh) SurfaceGetArrayLen(surfIdx int64) int64 {
	log.Println("Calling ArrayMesh.SurfaceGetArrayLen()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(surfIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "surface_get_array_len", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the format mask of the requested surface (see [method add_surface]).
*/
func (o *ArrayMesh) SurfaceGetFormat(surfIdx int64) int64 {
	log.Println("Calling ArrayMesh.SurfaceGetFormat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(surfIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "surface_get_format", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return a [Material] in a given surface. Surface is rendered using this material.
*/
func (o *ArrayMesh) SurfaceGetMaterial(surfIdx int64) *Material {
	log.Println("Calling ArrayMesh.SurfaceGetMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(surfIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "surface_get_material", goArguments, "*Material")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Material)

	return returnValue

}

/*

 */
func (o *ArrayMesh) SurfaceGetName(surfIdx int64) string {
	log.Println("Calling ArrayMesh.SurfaceGetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(surfIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "surface_get_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the primitive type of the requested surface (see [method add_surface]).
*/
func (o *ArrayMesh) SurfaceGetPrimitiveType(surfIdx int64) int64 {
	log.Println("Calling ArrayMesh.SurfaceGetPrimitiveType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(surfIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "surface_get_primitive_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Remove a surface at position surf_idx, shifting greater surfaces one surf_idx slot down.
*/
func (o *ArrayMesh) SurfaceRemove(surfIdx int64) {
	log.Println("Calling ArrayMesh.SurfaceRemove()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(surfIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "surface_remove", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ArrayMesh) SurfaceSetMaterial(surfIdx int64, material *Material) {
	log.Println("Calling ArrayMesh.SurfaceSetMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(surfIdx)
	goArguments[1] = reflect.ValueOf(material)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "surface_set_material", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set a [Material] for a given surface. Surface will be rendered using this material.
*/
func (o *ArrayMesh) SurfaceSetName(surfIdx int64, name string) {
	log.Println("Calling ArrayMesh.SurfaceSetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(surfIdx)
	goArguments[1] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "surface_set_name", goArguments, "")

	log.Println("Got return value!")

}

/*
   ArrayMeshImplementer is an interface for ArrayMesh objects.

*/
type ArrayMeshImplementer interface {
	MeshImplementer

	AddBlendShape(name string)

	AddSurfaceFromArrays(primitive int64, arrays *Array, blendShapes *Array, compressFlags int64)

	CenterGeometry()

	ClearBlendShapes()

	GetBlendShapeCount() int64

	GetBlendShapeMode() int64

	GetBlendShapeName(index int64) string

	GetCustomAabb() *Rect3

	GetSurfaceCount() int64

	RegenNormalmaps()

	SetBlendShapeMode(mode int64)

	SetCustomAabb(aabb *Rect3)

	SurfaceGetArrayIndexLen(surfIdx int64) int64

	SurfaceGetArrayLen(surfIdx int64) int64

	SurfaceGetFormat(surfIdx int64) int64

	SurfaceGetMaterial(surfIdx int64) *Material

	SurfaceGetName(surfIdx int64) string

	SurfaceGetPrimitiveType(surfIdx int64) int64

	SurfaceRemove(surfIdx int64)

	SurfaceSetMaterial(surfIdx int64, material *Material)

	SurfaceSetName(surfIdx int64, name string)
}

/*

 */
type AtlasTexture struct {
	Texture
}

func (o *AtlasTexture) baseClass() string {
	return "AtlasTexture"
}

/*

 */
func (o *AtlasTexture) GetAtlas() *Texture {
	log.Println("Calling AtlasTexture.GetAtlas()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_atlas", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *AtlasTexture) GetMargin() *Rect2 {
	log.Println("Calling AtlasTexture.GetMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_margin", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*

 */
func (o *AtlasTexture) GetRegion() *Rect2 {
	log.Println("Calling AtlasTexture.GetRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_region", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*

 */
func (o *AtlasTexture) SetAtlas(atlas *Texture) {
	log.Println("Calling AtlasTexture.SetAtlas()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(atlas)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_atlas", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AtlasTexture) SetMargin(margin *Rect2) {
	log.Println("Calling AtlasTexture.SetMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_margin", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AtlasTexture) SetRegion(region *Rect2) {
	log.Println("Calling AtlasTexture.SetRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(region)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_region", goArguments, "")

	log.Println("Got return value!")

}

/*
   AtlasTextureImplementer is an interface for AtlasTexture objects.

*/
type AtlasTextureImplementer interface {
	TextureImplementer

	GetAtlas() *Texture

	GetMargin() *Rect2

	GetRegion() *Rect2

	SetAtlas(atlas *Texture)

	SetMargin(margin *Rect2)

	SetRegion(region *Rect2)
}

/*

 */
type AudioBusLayout struct {
	Resource
}

func (o *AudioBusLayout) baseClass() string {
	return "AudioBusLayout"
}

/*
   AudioBusLayoutImplementer is an interface for AudioBusLayout objects.

*/
type AudioBusLayoutImplementer interface {
	ResourceImplementer
}

/*

 */
type AudioEffect struct {
	Resource
}

func (o *AudioEffect) baseClass() string {
	return "AudioEffect"
}

/*
   AudioEffectImplementer is an interface for AudioEffect objects.

*/
type AudioEffectImplementer interface {
	ResourceImplementer
}

/*

 */
type AudioEffectAmplify struct {
	AudioEffect
}

func (o *AudioEffectAmplify) baseClass() string {
	return "AudioEffectAmplify"
}

/*

 */
func (o *AudioEffectAmplify) GetVolumeDb() float64 {
	log.Println("Calling AudioEffectAmplify.GetVolumeDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_volume_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectAmplify) SetVolumeDb(volume float64) {
	log.Println("Calling AudioEffectAmplify.SetVolumeDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(volume)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_volume_db", goArguments, "")

	log.Println("Got return value!")

}

/*
   AudioEffectAmplifyImplementer is an interface for AudioEffectAmplify objects.

*/
type AudioEffectAmplifyImplementer interface {
	AudioEffectImplementer

	GetVolumeDb() float64

	SetVolumeDb(volume float64)
}

/*

 */
type AudioEffectBandLimitFilter struct {
	AudioEffectFilter
}

func (o *AudioEffectBandLimitFilter) baseClass() string {
	return "AudioEffectBandLimitFilter"
}

/*
   AudioEffectBandLimitFilterImplementer is an interface for AudioEffectBandLimitFilter objects.

*/
type AudioEffectBandLimitFilterImplementer interface {
	AudioEffectFilterImplementer
}

/*

 */
type AudioEffectBandPassFilter struct {
	AudioEffectFilter
}

func (o *AudioEffectBandPassFilter) baseClass() string {
	return "AudioEffectBandPassFilter"
}

/*
   AudioEffectBandPassFilterImplementer is an interface for AudioEffectBandPassFilter objects.

*/
type AudioEffectBandPassFilterImplementer interface {
	AudioEffectFilterImplementer
}

/*

 */
type AudioEffectChorus struct {
	AudioEffect
}

func (o *AudioEffectChorus) baseClass() string {
	return "AudioEffectChorus"
}

/*

 */
func (o *AudioEffectChorus) GetDry() float64 {
	log.Println("Calling AudioEffectChorus.GetDry()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dry", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectChorus) GetVoiceCount() int64 {
	log.Println("Calling AudioEffectChorus.GetVoiceCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_voice_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AudioEffectChorus) GetVoiceCutoffHz(voiceIdx int64) float64 {
	log.Println("Calling AudioEffectChorus.GetVoiceCutoffHz()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(voiceIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_voice_cutoff_hz", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectChorus) GetVoiceDelayMs(voiceIdx int64) float64 {
	log.Println("Calling AudioEffectChorus.GetVoiceDelayMs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(voiceIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_voice_delay_ms", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectChorus) GetVoiceDepthMs(voiceIdx int64) float64 {
	log.Println("Calling AudioEffectChorus.GetVoiceDepthMs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(voiceIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_voice_depth_ms", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectChorus) GetVoiceLevelDb(voiceIdx int64) float64 {
	log.Println("Calling AudioEffectChorus.GetVoiceLevelDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(voiceIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_voice_level_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectChorus) GetVoicePan(voiceIdx int64) float64 {
	log.Println("Calling AudioEffectChorus.GetVoicePan()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(voiceIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_voice_pan", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectChorus) GetVoiceRateHz(voiceIdx int64) float64 {
	log.Println("Calling AudioEffectChorus.GetVoiceRateHz()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(voiceIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_voice_rate_hz", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectChorus) GetWet() float64 {
	log.Println("Calling AudioEffectChorus.GetWet()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_wet", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectChorus) SetDry(amount float64) {
	log.Println("Calling AudioEffectChorus.SetDry()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dry", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectChorus) SetVoiceCount(voices int64) {
	log.Println("Calling AudioEffectChorus.SetVoiceCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(voices)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_voice_count", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectChorus) SetVoiceCutoffHz(voiceIdx int64, cutoffHz float64) {
	log.Println("Calling AudioEffectChorus.SetVoiceCutoffHz()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(voiceIdx)
	goArguments[1] = reflect.ValueOf(cutoffHz)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_voice_cutoff_hz", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectChorus) SetVoiceDelayMs(voiceIdx int64, delayMs float64) {
	log.Println("Calling AudioEffectChorus.SetVoiceDelayMs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(voiceIdx)
	goArguments[1] = reflect.ValueOf(delayMs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_voice_delay_ms", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectChorus) SetVoiceDepthMs(voiceIdx int64, depthMs float64) {
	log.Println("Calling AudioEffectChorus.SetVoiceDepthMs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(voiceIdx)
	goArguments[1] = reflect.ValueOf(depthMs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_voice_depth_ms", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectChorus) SetVoiceLevelDb(voiceIdx int64, levelDb float64) {
	log.Println("Calling AudioEffectChorus.SetVoiceLevelDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(voiceIdx)
	goArguments[1] = reflect.ValueOf(levelDb)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_voice_level_db", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectChorus) SetVoicePan(voiceIdx int64, pan float64) {
	log.Println("Calling AudioEffectChorus.SetVoicePan()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(voiceIdx)
	goArguments[1] = reflect.ValueOf(pan)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_voice_pan", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectChorus) SetVoiceRateHz(voiceIdx int64, rateHz float64) {
	log.Println("Calling AudioEffectChorus.SetVoiceRateHz()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(voiceIdx)
	goArguments[1] = reflect.ValueOf(rateHz)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_voice_rate_hz", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectChorus) SetWet(amount float64) {
	log.Println("Calling AudioEffectChorus.SetWet()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_wet", goArguments, "")

	log.Println("Got return value!")

}

/*
   AudioEffectChorusImplementer is an interface for AudioEffectChorus objects.

*/
type AudioEffectChorusImplementer interface {
	AudioEffectImplementer

	GetDry() float64

	GetVoiceCount() int64

	GetVoiceCutoffHz(voiceIdx int64) float64

	GetVoiceDelayMs(voiceIdx int64) float64

	GetVoiceDepthMs(voiceIdx int64) float64

	GetVoiceLevelDb(voiceIdx int64) float64

	GetVoicePan(voiceIdx int64) float64

	GetVoiceRateHz(voiceIdx int64) float64

	GetWet() float64

	SetDry(amount float64)

	SetVoiceCount(voices int64)

	SetVoiceCutoffHz(voiceIdx int64, cutoffHz float64)

	SetVoiceDelayMs(voiceIdx int64, delayMs float64)

	SetVoiceDepthMs(voiceIdx int64, depthMs float64)

	SetVoiceLevelDb(voiceIdx int64, levelDb float64)

	SetVoicePan(voiceIdx int64, pan float64)

	SetVoiceRateHz(voiceIdx int64, rateHz float64)

	SetWet(amount float64)
}

/*

 */
type AudioEffectCompressor struct {
	AudioEffect
}

func (o *AudioEffectCompressor) baseClass() string {
	return "AudioEffectCompressor"
}

/*

 */
func (o *AudioEffectCompressor) GetAttackUs() float64 {
	log.Println("Calling AudioEffectCompressor.GetAttackUs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_attack_us", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectCompressor) GetGain() float64 {
	log.Println("Calling AudioEffectCompressor.GetGain()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gain", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectCompressor) GetMix() float64 {
	log.Println("Calling AudioEffectCompressor.GetMix()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mix", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectCompressor) GetRatio() float64 {
	log.Println("Calling AudioEffectCompressor.GetRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ratio", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectCompressor) GetReleaseMs() float64 {
	log.Println("Calling AudioEffectCompressor.GetReleaseMs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_release_ms", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectCompressor) GetSidechain() string {
	log.Println("Calling AudioEffectCompressor.GetSidechain()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sidechain", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *AudioEffectCompressor) GetThreshold() float64 {
	log.Println("Calling AudioEffectCompressor.GetThreshold()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_threshold", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectCompressor) SetAttackUs(attackUs float64) {
	log.Println("Calling AudioEffectCompressor.SetAttackUs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(attackUs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_attack_us", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectCompressor) SetGain(gain float64) {
	log.Println("Calling AudioEffectCompressor.SetGain()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(gain)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gain", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectCompressor) SetMix(mix float64) {
	log.Println("Calling AudioEffectCompressor.SetMix()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mix)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mix", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectCompressor) SetRatio(ratio float64) {
	log.Println("Calling AudioEffectCompressor.SetRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ratio)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ratio", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectCompressor) SetReleaseMs(releaseMs float64) {
	log.Println("Calling AudioEffectCompressor.SetReleaseMs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(releaseMs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_release_ms", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectCompressor) SetSidechain(sidechain string) {
	log.Println("Calling AudioEffectCompressor.SetSidechain()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(sidechain)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sidechain", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectCompressor) SetThreshold(threshold float64) {
	log.Println("Calling AudioEffectCompressor.SetThreshold()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(threshold)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_threshold", goArguments, "")

	log.Println("Got return value!")

}

/*
   AudioEffectCompressorImplementer is an interface for AudioEffectCompressor objects.

*/
type AudioEffectCompressorImplementer interface {
	AudioEffectImplementer

	GetAttackUs() float64

	GetGain() float64

	GetMix() float64

	GetRatio() float64

	GetReleaseMs() float64

	GetSidechain() string

	GetThreshold() float64

	SetAttackUs(attackUs float64)

	SetGain(gain float64)

	SetMix(mix float64)

	SetRatio(ratio float64)

	SetReleaseMs(releaseMs float64)

	SetSidechain(sidechain string)

	SetThreshold(threshold float64)
}

/*

 */
type AudioEffectDelay struct {
	AudioEffect
}

func (o *AudioEffectDelay) baseClass() string {
	return "AudioEffectDelay"
}

/*

 */
func (o *AudioEffectDelay) GetDry() float64 {
	log.Println("Calling AudioEffectDelay.GetDry()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dry", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectDelay) GetFeedbackDelayMs() float64 {
	log.Println("Calling AudioEffectDelay.GetFeedbackDelayMs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_feedback_delay_ms", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectDelay) GetFeedbackLevelDb() float64 {
	log.Println("Calling AudioEffectDelay.GetFeedbackLevelDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_feedback_level_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectDelay) GetFeedbackLowpass() float64 {
	log.Println("Calling AudioEffectDelay.GetFeedbackLowpass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_feedback_lowpass", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectDelay) GetTap1DelayMs() float64 {
	log.Println("Calling AudioEffectDelay.GetTap1DelayMs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tap1_delay_ms", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectDelay) GetTap1LevelDb() float64 {
	log.Println("Calling AudioEffectDelay.GetTap1LevelDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tap1_level_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectDelay) GetTap1Pan() float64 {
	log.Println("Calling AudioEffectDelay.GetTap1Pan()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tap1_pan", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectDelay) GetTap2DelayMs() float64 {
	log.Println("Calling AudioEffectDelay.GetTap2DelayMs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tap2_delay_ms", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectDelay) GetTap2LevelDb() float64 {
	log.Println("Calling AudioEffectDelay.GetTap2LevelDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tap2_level_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectDelay) GetTap2Pan() float64 {
	log.Println("Calling AudioEffectDelay.GetTap2Pan()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tap2_pan", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectDelay) IsFeedbackActive() *bool {
	log.Println("Calling AudioEffectDelay.IsFeedbackActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_feedback_active", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *AudioEffectDelay) IsTap1Active() *bool {
	log.Println("Calling AudioEffectDelay.IsTap1Active()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_tap1_active", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *AudioEffectDelay) IsTap2Active() *bool {
	log.Println("Calling AudioEffectDelay.IsTap2Active()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_tap2_active", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *AudioEffectDelay) SetDry(amount float64) {
	log.Println("Calling AudioEffectDelay.SetDry()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dry", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDelay) SetFeedbackActive(amount *bool) {
	log.Println("Calling AudioEffectDelay.SetFeedbackActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_feedback_active", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDelay) SetFeedbackDelayMs(amount float64) {
	log.Println("Calling AudioEffectDelay.SetFeedbackDelayMs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_feedback_delay_ms", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDelay) SetFeedbackLevelDb(amount float64) {
	log.Println("Calling AudioEffectDelay.SetFeedbackLevelDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_feedback_level_db", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDelay) SetFeedbackLowpass(amount float64) {
	log.Println("Calling AudioEffectDelay.SetFeedbackLowpass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_feedback_lowpass", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDelay) SetTap1Active(amount *bool) {
	log.Println("Calling AudioEffectDelay.SetTap1Active()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tap1_active", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDelay) SetTap1DelayMs(amount float64) {
	log.Println("Calling AudioEffectDelay.SetTap1DelayMs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tap1_delay_ms", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDelay) SetTap1LevelDb(amount float64) {
	log.Println("Calling AudioEffectDelay.SetTap1LevelDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tap1_level_db", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDelay) SetTap1Pan(amount float64) {
	log.Println("Calling AudioEffectDelay.SetTap1Pan()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tap1_pan", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDelay) SetTap2Active(amount *bool) {
	log.Println("Calling AudioEffectDelay.SetTap2Active()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tap2_active", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDelay) SetTap2DelayMs(amount float64) {
	log.Println("Calling AudioEffectDelay.SetTap2DelayMs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tap2_delay_ms", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDelay) SetTap2LevelDb(amount float64) {
	log.Println("Calling AudioEffectDelay.SetTap2LevelDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tap2_level_db", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDelay) SetTap2Pan(amount float64) {
	log.Println("Calling AudioEffectDelay.SetTap2Pan()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tap2_pan", goArguments, "")

	log.Println("Got return value!")

}

/*
   AudioEffectDelayImplementer is an interface for AudioEffectDelay objects.

*/
type AudioEffectDelayImplementer interface {
	AudioEffectImplementer

	GetDry() float64

	GetFeedbackDelayMs() float64

	GetFeedbackLevelDb() float64

	GetFeedbackLowpass() float64

	GetTap1DelayMs() float64

	GetTap1LevelDb() float64

	GetTap1Pan() float64

	GetTap2DelayMs() float64

	GetTap2LevelDb() float64

	GetTap2Pan() float64

	IsFeedbackActive() *bool

	IsTap1Active() *bool

	IsTap2Active() *bool

	SetDry(amount float64)

	SetFeedbackActive(amount *bool)

	SetFeedbackDelayMs(amount float64)

	SetFeedbackLevelDb(amount float64)

	SetFeedbackLowpass(amount float64)

	SetTap1Active(amount *bool)

	SetTap1DelayMs(amount float64)

	SetTap1LevelDb(amount float64)

	SetTap1Pan(amount float64)

	SetTap2Active(amount *bool)

	SetTap2DelayMs(amount float64)

	SetTap2LevelDb(amount float64)

	SetTap2Pan(amount float64)
}

/*

 */
type AudioEffectDistortion struct {
	AudioEffect
}

func (o *AudioEffectDistortion) baseClass() string {
	return "AudioEffectDistortion"
}

/*

 */
func (o *AudioEffectDistortion) GetDrive() float64 {
	log.Println("Calling AudioEffectDistortion.GetDrive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_drive", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectDistortion) GetKeepHfHz() float64 {
	log.Println("Calling AudioEffectDistortion.GetKeepHfHz()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_keep_hf_hz", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectDistortion) GetMode() int64 {
	log.Println("Calling AudioEffectDistortion.GetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AudioEffectDistortion) GetPostGain() float64 {
	log.Println("Calling AudioEffectDistortion.GetPostGain()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_post_gain", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectDistortion) GetPreGain() float64 {
	log.Println("Calling AudioEffectDistortion.GetPreGain()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pre_gain", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectDistortion) SetDrive(drive float64) {
	log.Println("Calling AudioEffectDistortion.SetDrive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(drive)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_drive", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDistortion) SetKeepHfHz(keepHfHz float64) {
	log.Println("Calling AudioEffectDistortion.SetKeepHfHz()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(keepHfHz)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_keep_hf_hz", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDistortion) SetMode(mode int64) {
	log.Println("Calling AudioEffectDistortion.SetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDistortion) SetPostGain(postGain float64) {
	log.Println("Calling AudioEffectDistortion.SetPostGain()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(postGain)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_post_gain", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectDistortion) SetPreGain(preGain float64) {
	log.Println("Calling AudioEffectDistortion.SetPreGain()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(preGain)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pre_gain", goArguments, "")

	log.Println("Got return value!")

}

/*
   AudioEffectDistortionImplementer is an interface for AudioEffectDistortion objects.

*/
type AudioEffectDistortionImplementer interface {
	AudioEffectImplementer

	GetDrive() float64

	GetKeepHfHz() float64

	GetMode() int64

	GetPostGain() float64

	GetPreGain() float64

	SetDrive(drive float64)

	SetKeepHfHz(keepHfHz float64)

	SetMode(mode int64)

	SetPostGain(postGain float64)

	SetPreGain(preGain float64)
}

/*

 */
type AudioEffectEQ struct {
	AudioEffect
}

func (o *AudioEffectEQ) baseClass() string {
	return "AudioEffectEQ"
}

/*

 */
func (o *AudioEffectEQ) GetBandCount() int64 {
	log.Println("Calling AudioEffectEQ.GetBandCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_band_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AudioEffectEQ) GetBandGainDb(bandIdx int64) float64 {
	log.Println("Calling AudioEffectEQ.GetBandGainDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bandIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_band_gain_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectEQ) SetBandGainDb(bandIdx int64, volumeDb float64) {
	log.Println("Calling AudioEffectEQ.SetBandGainDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(bandIdx)
	goArguments[1] = reflect.ValueOf(volumeDb)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_band_gain_db", goArguments, "")

	log.Println("Got return value!")

}

/*
   AudioEffectEQImplementer is an interface for AudioEffectEQ objects.

*/
type AudioEffectEQImplementer interface {
	AudioEffectImplementer

	GetBandCount() int64

	GetBandGainDb(bandIdx int64) float64

	SetBandGainDb(bandIdx int64, volumeDb float64)
}

/*

 */
type AudioEffectEQ10 struct {
	AudioEffectEQ
}

func (o *AudioEffectEQ10) baseClass() string {
	return "AudioEffectEQ10"
}

/*
   AudioEffectEQ10Implementer is an interface for AudioEffectEQ10 objects.

*/
type AudioEffectEQ10Implementer interface {
	AudioEffectEQImplementer
}

/*

 */
type AudioEffectEQ21 struct {
	AudioEffectEQ
}

func (o *AudioEffectEQ21) baseClass() string {
	return "AudioEffectEQ21"
}

/*
   AudioEffectEQ21Implementer is an interface for AudioEffectEQ21 objects.

*/
type AudioEffectEQ21Implementer interface {
	AudioEffectEQImplementer
}

/*

 */
type AudioEffectEQ6 struct {
	AudioEffectEQ
}

func (o *AudioEffectEQ6) baseClass() string {
	return "AudioEffectEQ6"
}

/*
   AudioEffectEQ6Implementer is an interface for AudioEffectEQ6 objects.

*/
type AudioEffectEQ6Implementer interface {
	AudioEffectEQImplementer
}

/*

 */
type AudioEffectFilter struct {
	AudioEffect
}

func (o *AudioEffectFilter) baseClass() string {
	return "AudioEffectFilter"
}

/*

 */
func (o *AudioEffectFilter) GetCutoff() float64 {
	log.Println("Calling AudioEffectFilter.GetCutoff()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cutoff", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectFilter) GetDb() int64 {
	log.Println("Calling AudioEffectFilter.GetDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_db", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AudioEffectFilter) GetGain() float64 {
	log.Println("Calling AudioEffectFilter.GetGain()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gain", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectFilter) GetResonance() float64 {
	log.Println("Calling AudioEffectFilter.GetResonance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_resonance", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectFilter) SetCutoff(freq float64) {
	log.Println("Calling AudioEffectFilter.SetCutoff()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(freq)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cutoff", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectFilter) SetDb(amount int64) {
	log.Println("Calling AudioEffectFilter.SetDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_db", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectFilter) SetGain(amount float64) {
	log.Println("Calling AudioEffectFilter.SetGain()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gain", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectFilter) SetResonance(amount float64) {
	log.Println("Calling AudioEffectFilter.SetResonance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_resonance", goArguments, "")

	log.Println("Got return value!")

}

/*
   AudioEffectFilterImplementer is an interface for AudioEffectFilter objects.

*/
type AudioEffectFilterImplementer interface {
	AudioEffectImplementer

	GetCutoff() float64

	GetDb() int64

	GetGain() float64

	GetResonance() float64

	SetCutoff(freq float64)

	SetDb(amount int64)

	SetGain(amount float64)

	SetResonance(amount float64)
}

/*

 */
type AudioEffectHighPassFilter struct {
	AudioEffectFilter
}

func (o *AudioEffectHighPassFilter) baseClass() string {
	return "AudioEffectHighPassFilter"
}

/*
   AudioEffectHighPassFilterImplementer is an interface for AudioEffectHighPassFilter objects.

*/
type AudioEffectHighPassFilterImplementer interface {
	AudioEffectFilterImplementer
}

/*

 */
type AudioEffectHighShelfFilter struct {
	AudioEffectFilter
}

func (o *AudioEffectHighShelfFilter) baseClass() string {
	return "AudioEffectHighShelfFilter"
}

/*
   AudioEffectHighShelfFilterImplementer is an interface for AudioEffectHighShelfFilter objects.

*/
type AudioEffectHighShelfFilterImplementer interface {
	AudioEffectFilterImplementer
}

/*

 */
type AudioEffectLimiter struct {
	AudioEffect
}

func (o *AudioEffectLimiter) baseClass() string {
	return "AudioEffectLimiter"
}

/*

 */
func (o *AudioEffectLimiter) GetCeilingDb() float64 {
	log.Println("Calling AudioEffectLimiter.GetCeilingDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ceiling_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectLimiter) GetSoftClipDb() float64 {
	log.Println("Calling AudioEffectLimiter.GetSoftClipDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_soft_clip_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectLimiter) GetSoftClipRatio() float64 {
	log.Println("Calling AudioEffectLimiter.GetSoftClipRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_soft_clip_ratio", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectLimiter) GetThresholdDb() float64 {
	log.Println("Calling AudioEffectLimiter.GetThresholdDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_threshold_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectLimiter) SetCeilingDb(ceiling float64) {
	log.Println("Calling AudioEffectLimiter.SetCeilingDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ceiling)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ceiling_db", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectLimiter) SetSoftClipDb(softClip float64) {
	log.Println("Calling AudioEffectLimiter.SetSoftClipDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(softClip)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_soft_clip_db", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectLimiter) SetSoftClipRatio(softClip float64) {
	log.Println("Calling AudioEffectLimiter.SetSoftClipRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(softClip)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_soft_clip_ratio", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectLimiter) SetThresholdDb(threshold float64) {
	log.Println("Calling AudioEffectLimiter.SetThresholdDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(threshold)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_threshold_db", goArguments, "")

	log.Println("Got return value!")

}

/*
   AudioEffectLimiterImplementer is an interface for AudioEffectLimiter objects.

*/
type AudioEffectLimiterImplementer interface {
	AudioEffectImplementer

	GetCeilingDb() float64

	GetSoftClipDb() float64

	GetSoftClipRatio() float64

	GetThresholdDb() float64

	SetCeilingDb(ceiling float64)

	SetSoftClipDb(softClip float64)

	SetSoftClipRatio(softClip float64)

	SetThresholdDb(threshold float64)
}

/*

 */
type AudioEffectLowPassFilter struct {
	AudioEffectFilter
}

func (o *AudioEffectLowPassFilter) baseClass() string {
	return "AudioEffectLowPassFilter"
}

/*
   AudioEffectLowPassFilterImplementer is an interface for AudioEffectLowPassFilter objects.

*/
type AudioEffectLowPassFilterImplementer interface {
	AudioEffectFilterImplementer
}

/*

 */
type AudioEffectLowShelfFilter struct {
	AudioEffectFilter
}

func (o *AudioEffectLowShelfFilter) baseClass() string {
	return "AudioEffectLowShelfFilter"
}

/*
   AudioEffectLowShelfFilterImplementer is an interface for AudioEffectLowShelfFilter objects.

*/
type AudioEffectLowShelfFilterImplementer interface {
	AudioEffectFilterImplementer
}

/*

 */
type AudioEffectNotchFilter struct {
	AudioEffectFilter
}

func (o *AudioEffectNotchFilter) baseClass() string {
	return "AudioEffectNotchFilter"
}

/*
   AudioEffectNotchFilterImplementer is an interface for AudioEffectNotchFilter objects.

*/
type AudioEffectNotchFilterImplementer interface {
	AudioEffectFilterImplementer
}

/*

 */
type AudioEffectPanner struct {
	AudioEffect
}

func (o *AudioEffectPanner) baseClass() string {
	return "AudioEffectPanner"
}

/*

 */
func (o *AudioEffectPanner) GetPan() float64 {
	log.Println("Calling AudioEffectPanner.GetPan()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pan", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectPanner) SetPan(cpanume float64) {
	log.Println("Calling AudioEffectPanner.SetPan()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(cpanume)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pan", goArguments, "")

	log.Println("Got return value!")

}

/*
   AudioEffectPannerImplementer is an interface for AudioEffectPanner objects.

*/
type AudioEffectPannerImplementer interface {
	AudioEffectImplementer

	GetPan() float64

	SetPan(cpanume float64)
}

/*

 */
type AudioEffectPhaser struct {
	AudioEffect
}

func (o *AudioEffectPhaser) baseClass() string {
	return "AudioEffectPhaser"
}

/*

 */
func (o *AudioEffectPhaser) GetDepth() float64 {
	log.Println("Calling AudioEffectPhaser.GetDepth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_depth", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectPhaser) GetFeedback() float64 {
	log.Println("Calling AudioEffectPhaser.GetFeedback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_feedback", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectPhaser) GetRangeMaxHz() float64 {
	log.Println("Calling AudioEffectPhaser.GetRangeMaxHz()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_range_max_hz", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectPhaser) GetRangeMinHz() float64 {
	log.Println("Calling AudioEffectPhaser.GetRangeMinHz()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_range_min_hz", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectPhaser) GetRateHz() float64 {
	log.Println("Calling AudioEffectPhaser.GetRateHz()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rate_hz", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectPhaser) SetDepth(depth float64) {
	log.Println("Calling AudioEffectPhaser.SetDepth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(depth)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_depth", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectPhaser) SetFeedback(fbk float64) {
	log.Println("Calling AudioEffectPhaser.SetFeedback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(fbk)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_feedback", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectPhaser) SetRangeMaxHz(hz float64) {
	log.Println("Calling AudioEffectPhaser.SetRangeMaxHz()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(hz)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_range_max_hz", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectPhaser) SetRangeMinHz(hz float64) {
	log.Println("Calling AudioEffectPhaser.SetRangeMinHz()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(hz)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_range_min_hz", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectPhaser) SetRateHz(hz float64) {
	log.Println("Calling AudioEffectPhaser.SetRateHz()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(hz)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rate_hz", goArguments, "")

	log.Println("Got return value!")

}

/*
   AudioEffectPhaserImplementer is an interface for AudioEffectPhaser objects.

*/
type AudioEffectPhaserImplementer interface {
	AudioEffectImplementer

	GetDepth() float64

	GetFeedback() float64

	GetRangeMaxHz() float64

	GetRangeMinHz() float64

	GetRateHz() float64

	SetDepth(depth float64)

	SetFeedback(fbk float64)

	SetRangeMaxHz(hz float64)

	SetRangeMinHz(hz float64)

	SetRateHz(hz float64)
}

/*

 */
type AudioEffectPitchShift struct {
	AudioEffect
}

func (o *AudioEffectPitchShift) baseClass() string {
	return "AudioEffectPitchShift"
}

/*

 */
func (o *AudioEffectPitchShift) GetPitchScale() float64 {
	log.Println("Calling AudioEffectPitchShift.GetPitchScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pitch_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectPitchShift) SetPitchScale(rate float64) {
	log.Println("Calling AudioEffectPitchShift.SetPitchScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rate)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pitch_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   AudioEffectPitchShiftImplementer is an interface for AudioEffectPitchShift objects.

*/
type AudioEffectPitchShiftImplementer interface {
	AudioEffectImplementer

	GetPitchScale() float64

	SetPitchScale(rate float64)
}

/*

 */
type AudioEffectReverb struct {
	AudioEffect
}

func (o *AudioEffectReverb) baseClass() string {
	return "AudioEffectReverb"
}

/*

 */
func (o *AudioEffectReverb) GetDamping() float64 {
	log.Println("Calling AudioEffectReverb.GetDamping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_damping", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectReverb) GetDry() float64 {
	log.Println("Calling AudioEffectReverb.GetDry()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dry", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectReverb) GetHpf() float64 {
	log.Println("Calling AudioEffectReverb.GetHpf()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_hpf", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectReverb) GetPredelayFeedback() float64 {
	log.Println("Calling AudioEffectReverb.GetPredelayFeedback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_predelay_feedback", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectReverb) GetPredelayMsec() float64 {
	log.Println("Calling AudioEffectReverb.GetPredelayMsec()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_predelay_msec", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectReverb) GetRoomSize() float64 {
	log.Println("Calling AudioEffectReverb.GetRoomSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_room_size", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectReverb) GetSpread() float64 {
	log.Println("Calling AudioEffectReverb.GetSpread()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_spread", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectReverb) GetWet() float64 {
	log.Println("Calling AudioEffectReverb.GetWet()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_wet", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectReverb) SetDamping(amount float64) {
	log.Println("Calling AudioEffectReverb.SetDamping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_damping", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectReverb) SetDry(amount float64) {
	log.Println("Calling AudioEffectReverb.SetDry()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dry", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectReverb) SetHpf(amount float64) {
	log.Println("Calling AudioEffectReverb.SetHpf()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_hpf", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectReverb) SetPredelayFeedback(feedback float64) {
	log.Println("Calling AudioEffectReverb.SetPredelayFeedback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(feedback)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_predelay_feedback", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectReverb) SetPredelayMsec(msec float64) {
	log.Println("Calling AudioEffectReverb.SetPredelayMsec()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(msec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_predelay_msec", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectReverb) SetRoomSize(size float64) {
	log.Println("Calling AudioEffectReverb.SetRoomSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_room_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectReverb) SetSpread(amount float64) {
	log.Println("Calling AudioEffectReverb.SetSpread()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_spread", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectReverb) SetWet(amount float64) {
	log.Println("Calling AudioEffectReverb.SetWet()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_wet", goArguments, "")

	log.Println("Got return value!")

}

/*
   AudioEffectReverbImplementer is an interface for AudioEffectReverb objects.

*/
type AudioEffectReverbImplementer interface {
	AudioEffectImplementer

	GetDamping() float64

	GetDry() float64

	GetHpf() float64

	GetPredelayFeedback() float64

	GetPredelayMsec() float64

	GetRoomSize() float64

	GetSpread() float64

	GetWet() float64

	SetDamping(amount float64)

	SetDry(amount float64)

	SetHpf(amount float64)

	SetPredelayFeedback(feedback float64)

	SetPredelayMsec(msec float64)

	SetRoomSize(size float64)

	SetSpread(amount float64)

	SetWet(amount float64)
}

/*

 */
type AudioEffectStereoEnhance struct {
	AudioEffect
}

func (o *AudioEffectStereoEnhance) baseClass() string {
	return "AudioEffectStereoEnhance"
}

/*

 */
func (o *AudioEffectStereoEnhance) GetPanPullout() float64 {
	log.Println("Calling AudioEffectStereoEnhance.GetPanPullout()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pan_pullout", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectStereoEnhance) GetSurround() float64 {
	log.Println("Calling AudioEffectStereoEnhance.GetSurround()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_surround", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectStereoEnhance) GetTimePullout() float64 {
	log.Println("Calling AudioEffectStereoEnhance.GetTimePullout()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_time_pullout", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioEffectStereoEnhance) SetPanPullout(amount float64) {
	log.Println("Calling AudioEffectStereoEnhance.SetPanPullout()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pan_pullout", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectStereoEnhance) SetSurround(amount float64) {
	log.Println("Calling AudioEffectStereoEnhance.SetSurround()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_surround", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioEffectStereoEnhance) SetTimePullout(amount float64) {
	log.Println("Calling AudioEffectStereoEnhance.SetTimePullout()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_time_pullout", goArguments, "")

	log.Println("Got return value!")

}

/*
   AudioEffectStereoEnhanceImplementer is an interface for AudioEffectStereoEnhance objects.

*/
type AudioEffectStereoEnhanceImplementer interface {
	AudioEffectImplementer

	GetPanPullout() float64

	GetSurround() float64

	GetTimePullout() float64

	SetPanPullout(amount float64)

	SetSurround(amount float64)

	SetTimePullout(amount float64)
}

/*
   AudioServer is a low level server interface for audio access. It is in charge of creating sample data (playable audio) as well as its playback via a voice interface.
*/
type AudioServer struct {
	Object
}

func (o *AudioServer) baseClass() string {
	return "AudioServer"
}

/*

 */
func (o *AudioServer) AddBus(atPos int64) {
	log.Println("Calling AudioServer.AddBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(atPos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_bus", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioServer) AddBusEffect(busIdx int64, effect *AudioEffect, atPos int64) {
	log.Println("Calling AudioServer.AddBusEffect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(busIdx)
	goArguments[1] = reflect.ValueOf(effect)
	goArguments[2] = reflect.ValueOf(atPos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_bus_effect", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioServer) GenerateBusLayout() *AudioBusLayout {
	log.Println("Calling AudioServer.GenerateBusLayout()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "generate_bus_layout", goArguments, "*AudioBusLayout")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*AudioBusLayout)

	return returnValue

}

/*

 */
func (o *AudioServer) GetBusCount() int64 {
	log.Println("Calling AudioServer.GetBusCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bus_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AudioServer) GetBusEffect(busIdx int64, effectIdx int64) *AudioEffect {
	log.Println("Calling AudioServer.GetBusEffect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(busIdx)
	goArguments[1] = reflect.ValueOf(effectIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bus_effect", goArguments, "*AudioEffect")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*AudioEffect)

	return returnValue

}

/*

 */
func (o *AudioServer) GetBusEffectCount(busIdx int64) int64 {
	log.Println("Calling AudioServer.GetBusEffectCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(busIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bus_effect_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AudioServer) GetBusIndex(busName string) int64 {
	log.Println("Calling AudioServer.GetBusIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(busName)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bus_index", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AudioServer) GetBusName(busIdx int64) string {
	log.Println("Calling AudioServer.GetBusName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(busIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bus_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *AudioServer) GetBusPeakVolumeLeftDb(busIdx int64, channel int64) float64 {
	log.Println("Calling AudioServer.GetBusPeakVolumeLeftDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(busIdx)
	goArguments[1] = reflect.ValueOf(channel)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bus_peak_volume_left_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioServer) GetBusPeakVolumeRightDb(busIdx int64, channel int64) float64 {
	log.Println("Calling AudioServer.GetBusPeakVolumeRightDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(busIdx)
	goArguments[1] = reflect.ValueOf(channel)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bus_peak_volume_right_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioServer) GetBusSend(busIdx int64) string {
	log.Println("Calling AudioServer.GetBusSend()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(busIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bus_send", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *AudioServer) GetBusVolumeDb(busIdx int64) float64 {
	log.Println("Calling AudioServer.GetBusVolumeDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(busIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bus_volume_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioServer) GetMixRate() float64 {
	log.Println("Calling AudioServer.GetMixRate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mix_rate", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioServer) GetSpeakerMode() int64 {
	log.Println("Calling AudioServer.GetSpeakerMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_speaker_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AudioServer) IsBusBypassingEffects(busIdx int64) *bool {
	log.Println("Calling AudioServer.IsBusBypassingEffects()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(busIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_bus_bypassing_effects", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *AudioServer) IsBusEffectEnabled(busIdx int64, effectIdx int64) *bool {
	log.Println("Calling AudioServer.IsBusEffectEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(busIdx)
	goArguments[1] = reflect.ValueOf(effectIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_bus_effect_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *AudioServer) IsBusMute(busIdx int64) *bool {
	log.Println("Calling AudioServer.IsBusMute()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(busIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_bus_mute", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *AudioServer) IsBusSolo(busIdx int64) *bool {
	log.Println("Calling AudioServer.IsBusSolo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(busIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_bus_solo", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *AudioServer) Lock() {
	log.Println("Calling AudioServer.Lock()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "lock", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioServer) MoveBus(index int64, toIndex int64) {
	log.Println("Calling AudioServer.MoveBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(index)
	goArguments[1] = reflect.ValueOf(toIndex)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "move_bus", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioServer) RemoveBus(index int64) {
	log.Println("Calling AudioServer.RemoveBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_bus", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioServer) RemoveBusEffect(busIdx int64, effectIdx int64) {
	log.Println("Calling AudioServer.RemoveBusEffect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(busIdx)
	goArguments[1] = reflect.ValueOf(effectIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_bus_effect", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioServer) SetBusBypassEffects(busIdx int64, enable *bool) {
	log.Println("Calling AudioServer.SetBusBypassEffects()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(busIdx)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bus_bypass_effects", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioServer) SetBusCount(amount int64) {
	log.Println("Calling AudioServer.SetBusCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bus_count", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioServer) SetBusEffectEnabled(busIdx int64, effectIdx int64, enabled *bool) {
	log.Println("Calling AudioServer.SetBusEffectEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(busIdx)
	goArguments[1] = reflect.ValueOf(effectIdx)
	goArguments[2] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bus_effect_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioServer) SetBusLayout(busLayout *AudioBusLayout) {
	log.Println("Calling AudioServer.SetBusLayout()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(busLayout)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bus_layout", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioServer) SetBusMute(busIdx int64, enable *bool) {
	log.Println("Calling AudioServer.SetBusMute()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(busIdx)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bus_mute", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioServer) SetBusName(busIdx int64, name string) {
	log.Println("Calling AudioServer.SetBusName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(busIdx)
	goArguments[1] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bus_name", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioServer) SetBusSend(busIdx int64, send string) {
	log.Println("Calling AudioServer.SetBusSend()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(busIdx)
	goArguments[1] = reflect.ValueOf(send)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bus_send", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioServer) SetBusSolo(busIdx int64, enable *bool) {
	log.Println("Calling AudioServer.SetBusSolo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(busIdx)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bus_solo", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioServer) SetBusVolumeDb(busIdx int64, volumeDb float64) {
	log.Println("Calling AudioServer.SetBusVolumeDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(busIdx)
	goArguments[1] = reflect.ValueOf(volumeDb)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bus_volume_db", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioServer) SwapBusEffects(busIdx int64, effectIdx int64, byEffectIdx int64) {
	log.Println("Calling AudioServer.SwapBusEffects()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(busIdx)
	goArguments[1] = reflect.ValueOf(effectIdx)
	goArguments[2] = reflect.ValueOf(byEffectIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "swap_bus_effects", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioServer) Unlock() {
	log.Println("Calling AudioServer.Unlock()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "unlock", goArguments, "")

	log.Println("Got return value!")

}

/*
   AudioServerImplementer is an interface for AudioServer objects.
   AudioServer is a low level server interface for audio access. It is in charge of creating sample data (playable audio) as well as its playback via a voice interface.
*/
type AudioServerImplementer interface {
	ObjectImplementer

	AddBus(atPos int64)

	AddBusEffect(busIdx int64, effect *AudioEffect, atPos int64)

	GenerateBusLayout() *AudioBusLayout

	GetBusCount() int64

	GetBusEffect(busIdx int64, effectIdx int64) *AudioEffect

	GetBusEffectCount(busIdx int64) int64

	GetBusIndex(busName string) int64

	GetBusName(busIdx int64) string

	GetBusPeakVolumeLeftDb(busIdx int64, channel int64) float64

	GetBusPeakVolumeRightDb(busIdx int64, channel int64) float64

	GetBusSend(busIdx int64) string

	GetBusVolumeDb(busIdx int64) float64

	GetMixRate() float64

	GetSpeakerMode() int64

	IsBusBypassingEffects(busIdx int64) *bool

	IsBusEffectEnabled(busIdx int64, effectIdx int64) *bool

	IsBusMute(busIdx int64) *bool

	IsBusSolo(busIdx int64) *bool

	Lock()

	MoveBus(index int64, toIndex int64)

	RemoveBus(index int64)

	RemoveBusEffect(busIdx int64, effectIdx int64)

	SetBusBypassEffects(busIdx int64, enable *bool)

	SetBusCount(amount int64)

	SetBusEffectEnabled(busIdx int64, effectIdx int64, enabled *bool)

	SetBusLayout(busLayout *AudioBusLayout)

	SetBusMute(busIdx int64, enable *bool)

	SetBusName(busIdx int64, name string)

	SetBusSend(busIdx int64, send string)

	SetBusSolo(busIdx int64, enable *bool)

	SetBusVolumeDb(busIdx int64, volumeDb float64)

	SwapBusEffects(busIdx int64, effectIdx int64, byEffectIdx int64)

	Unlock()
}

/*
   Base class for audio streams. Audio streams are used for music playback, or other types of streamed sounds that don't fit or require more flexibility than a [Sample].
*/
type AudioStream struct {
	Resource
}

func (o *AudioStream) baseClass() string {
	return "AudioStream"
}

/*
   AudioStreamImplementer is an interface for AudioStream objects.
   Base class for audio streams. Audio streams are used for music playback, or other types of streamed sounds that don't fit or require more flexibility than a [Sample].
*/
type AudioStreamImplementer interface {
	ResourceImplementer
}

/*
   OGG Vorbis audio stream driver.
*/
type AudioStreamOGGVorbis struct {
	AudioStream
}

func (o *AudioStreamOGGVorbis) baseClass() string {
	return "AudioStreamOGGVorbis"
}

/*

 */
func (o *AudioStreamOGGVorbis) GetData() *PoolByteArray {
	log.Println("Calling AudioStreamOGGVorbis.GetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_data", goArguments, "*PoolByteArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolByteArray)

	return returnValue

}

/*

 */
func (o *AudioStreamOGGVorbis) GetLoopOffset() float64 {
	log.Println("Calling AudioStreamOGGVorbis.GetLoopOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_loop_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioStreamOGGVorbis) HasLoop() *bool {
	log.Println("Calling AudioStreamOGGVorbis.HasLoop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_loop", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *AudioStreamOGGVorbis) SetData(data *PoolByteArray) {
	log.Println("Calling AudioStreamOGGVorbis.SetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_data", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamOGGVorbis) SetLoop(enable *bool) {
	log.Println("Calling AudioStreamOGGVorbis.SetLoop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_loop", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamOGGVorbis) SetLoopOffset(seconds float64) {
	log.Println("Calling AudioStreamOGGVorbis.SetLoopOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(seconds)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_loop_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   AudioStreamOGGVorbisImplementer is an interface for AudioStreamOGGVorbis objects.
   OGG Vorbis audio stream driver.
*/
type AudioStreamOGGVorbisImplementer interface {
	AudioStreamImplementer

	GetData() *PoolByteArray

	GetLoopOffset() float64

	HasLoop() *bool

	SetData(data *PoolByteArray)

	SetLoop(enable *bool)

	SetLoopOffset(seconds float64)
}

/*

 */
type AudioStreamPlayback struct {
	Reference
}

func (o *AudioStreamPlayback) baseClass() string {
	return "AudioStreamPlayback"
}

/*
   AudioStreamPlaybackImplementer is an interface for AudioStreamPlayback objects.

*/
type AudioStreamPlaybackImplementer interface {
	ReferenceImplementer
}

/*

 */
type AudioStreamPlayer struct {
	Node
}

func (o *AudioStreamPlayer) baseClass() string {
	return "AudioStreamPlayer"
}

/*

 */
func (o *AudioStreamPlayer) GetBus() string {
	log.Println("Calling AudioStreamPlayer.GetBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bus", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer) GetMixTarget() int64 {
	log.Println("Calling AudioStreamPlayer.GetMixTarget()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mix_target", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer) GetPos() float64 {
	log.Println("Calling AudioStreamPlayer.GetPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pos", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer) GetStream() *AudioStream {
	log.Println("Calling AudioStreamPlayer.GetStream()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stream", goArguments, "*AudioStream")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*AudioStream)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer) GetVolumeDb() float64 {
	log.Println("Calling AudioStreamPlayer.GetVolumeDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_volume_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer) IsAutoplayEnabled() *bool {
	log.Println("Calling AudioStreamPlayer.IsAutoplayEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_autoplay_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer) IsPlaying() *bool {
	log.Println("Calling AudioStreamPlayer.IsPlaying()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_playing", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer) Play(fromPos float64) {
	log.Println("Calling AudioStreamPlayer.Play()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(fromPos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "play", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer) Seek(toPos float64) {
	log.Println("Calling AudioStreamPlayer.Seek()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(toPos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "seek", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer) SetAutoplay(enable *bool) {
	log.Println("Calling AudioStreamPlayer.SetAutoplay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_autoplay", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer) SetBus(bus string) {
	log.Println("Calling AudioStreamPlayer.SetBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bus)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bus", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer) SetMixTarget(mixTarget int64) {
	log.Println("Calling AudioStreamPlayer.SetMixTarget()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mixTarget)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mix_target", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer) SetStream(stream *AudioStream) {
	log.Println("Calling AudioStreamPlayer.SetStream()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(stream)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_stream", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer) SetVolumeDb(volumeDb float64) {
	log.Println("Calling AudioStreamPlayer.SetVolumeDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(volumeDb)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_volume_db", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer) Stop() {
	log.Println("Calling AudioStreamPlayer.Stop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "stop", goArguments, "")

	log.Println("Got return value!")

}

/*
   AudioStreamPlayerImplementer is an interface for AudioStreamPlayer objects.

*/
type AudioStreamPlayerImplementer interface {
	NodeImplementer

	GetBus() string

	GetMixTarget() int64

	GetPos() float64

	GetStream() *AudioStream

	GetVolumeDb() float64

	IsAutoplayEnabled() *bool

	IsPlaying() *bool

	Play(fromPos float64)

	Seek(toPos float64)

	SetAutoplay(enable *bool)

	SetBus(bus string)

	SetMixTarget(mixTarget int64)

	SetStream(stream *AudioStream)

	SetVolumeDb(volumeDb float64)

	Stop()
}

/*

 */
type AudioStreamPlayer2D struct {
	Node2D
}

func (o *AudioStreamPlayer2D) baseClass() string {
	return "AudioStreamPlayer2D"
}

/*

 */
func (o *AudioStreamPlayer2D) GetAreaMask() int64 {
	log.Println("Calling AudioStreamPlayer2D.GetAreaMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_area_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer2D) GetAttenuation() float64 {
	log.Println("Calling AudioStreamPlayer2D.GetAttenuation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_attenuation", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer2D) GetBus() string {
	log.Println("Calling AudioStreamPlayer2D.GetBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bus", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer2D) GetMaxDistance() float64 {
	log.Println("Calling AudioStreamPlayer2D.GetMaxDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_max_distance", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer2D) GetPos() float64 {
	log.Println("Calling AudioStreamPlayer2D.GetPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pos", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer2D) GetStream() *AudioStream {
	log.Println("Calling AudioStreamPlayer2D.GetStream()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stream", goArguments, "*AudioStream")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*AudioStream)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer2D) GetVolumeDb() float64 {
	log.Println("Calling AudioStreamPlayer2D.GetVolumeDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_volume_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer2D) IsAutoplayEnabled() *bool {
	log.Println("Calling AudioStreamPlayer2D.IsAutoplayEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_autoplay_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer2D) IsPlaying() *bool {
	log.Println("Calling AudioStreamPlayer2D.IsPlaying()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_playing", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer2D) Play(fromPos float64) {
	log.Println("Calling AudioStreamPlayer2D.Play()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(fromPos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "play", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer2D) Seek(toPos float64) {
	log.Println("Calling AudioStreamPlayer2D.Seek()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(toPos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "seek", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer2D) SetAreaMask(mask int64) {
	log.Println("Calling AudioStreamPlayer2D.SetAreaMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_area_mask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer2D) SetAttenuation(curve float64) {
	log.Println("Calling AudioStreamPlayer2D.SetAttenuation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(curve)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_attenuation", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer2D) SetAutoplay(enable *bool) {
	log.Println("Calling AudioStreamPlayer2D.SetAutoplay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_autoplay", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer2D) SetBus(bus string) {
	log.Println("Calling AudioStreamPlayer2D.SetBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bus)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bus", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer2D) SetMaxDistance(pixels float64) {
	log.Println("Calling AudioStreamPlayer2D.SetMaxDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pixels)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max_distance", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer2D) SetStream(stream *AudioStream) {
	log.Println("Calling AudioStreamPlayer2D.SetStream()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(stream)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_stream", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer2D) SetVolumeDb(volumeDb float64) {
	log.Println("Calling AudioStreamPlayer2D.SetVolumeDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(volumeDb)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_volume_db", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer2D) Stop() {
	log.Println("Calling AudioStreamPlayer2D.Stop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "stop", goArguments, "")

	log.Println("Got return value!")

}

/*
   AudioStreamPlayer2DImplementer is an interface for AudioStreamPlayer2D objects.

*/
type AudioStreamPlayer2DImplementer interface {
	Node2DImplementer

	GetAreaMask() int64

	GetAttenuation() float64

	GetBus() string

	GetMaxDistance() float64

	GetPos() float64

	GetStream() *AudioStream

	GetVolumeDb() float64

	IsAutoplayEnabled() *bool

	IsPlaying() *bool

	Play(fromPos float64)

	Seek(toPos float64)

	SetAreaMask(mask int64)

	SetAttenuation(curve float64)

	SetAutoplay(enable *bool)

	SetBus(bus string)

	SetMaxDistance(pixels float64)

	SetStream(stream *AudioStream)

	SetVolumeDb(volumeDb float64)

	Stop()
}

/*

 */
type AudioStreamPlayer3D struct {
	Spatial
}

func (o *AudioStreamPlayer3D) baseClass() string {
	return "AudioStreamPlayer3D"
}

/*

 */
func (o *AudioStreamPlayer3D) GetAreaMask() int64 {
	log.Println("Calling AudioStreamPlayer3D.GetAreaMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_area_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) GetAttenuationFilterCutoffHz() float64 {
	log.Println("Calling AudioStreamPlayer3D.GetAttenuationFilterCutoffHz()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_attenuation_filter_cutoff_hz", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) GetAttenuationFilterDb() float64 {
	log.Println("Calling AudioStreamPlayer3D.GetAttenuationFilterDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_attenuation_filter_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) GetAttenuationModel() int64 {
	log.Println("Calling AudioStreamPlayer3D.GetAttenuationModel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_attenuation_model", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) GetBus() string {
	log.Println("Calling AudioStreamPlayer3D.GetBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bus", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) GetDopplerTracking() int64 {
	log.Println("Calling AudioStreamPlayer3D.GetDopplerTracking()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_doppler_tracking", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) GetEmissionAngle() float64 {
	log.Println("Calling AudioStreamPlayer3D.GetEmissionAngle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_emission_angle", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) GetEmissionAngleFilterAttenuationDb() float64 {
	log.Println("Calling AudioStreamPlayer3D.GetEmissionAngleFilterAttenuationDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_emission_angle_filter_attenuation_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) GetMaxDb() float64 {
	log.Println("Calling AudioStreamPlayer3D.GetMaxDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_max_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) GetMaxDistance() float64 {
	log.Println("Calling AudioStreamPlayer3D.GetMaxDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_max_distance", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) GetOutOfRangeMode() int64 {
	log.Println("Calling AudioStreamPlayer3D.GetOutOfRangeMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_out_of_range_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) GetPos() float64 {
	log.Println("Calling AudioStreamPlayer3D.GetPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pos", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) GetStream() *AudioStream {
	log.Println("Calling AudioStreamPlayer3D.GetStream()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stream", goArguments, "*AudioStream")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*AudioStream)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) GetUnitDb() float64 {
	log.Println("Calling AudioStreamPlayer3D.GetUnitDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_unit_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) GetUnitSize() float64 {
	log.Println("Calling AudioStreamPlayer3D.GetUnitSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_unit_size", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) IsAutoplayEnabled() *bool {
	log.Println("Calling AudioStreamPlayer3D.IsAutoplayEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_autoplay_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) IsEmissionAngleEnabled() *bool {
	log.Println("Calling AudioStreamPlayer3D.IsEmissionAngleEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_emission_angle_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) IsPlaying() *bool {
	log.Println("Calling AudioStreamPlayer3D.IsPlaying()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_playing", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *AudioStreamPlayer3D) Play(fromPos float64) {
	log.Println("Calling AudioStreamPlayer3D.Play()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(fromPos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "play", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) Seek(toPos float64) {
	log.Println("Calling AudioStreamPlayer3D.Seek()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(toPos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "seek", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) SetAreaMask(mask int64) {
	log.Println("Calling AudioStreamPlayer3D.SetAreaMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_area_mask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) SetAttenuationFilterCutoffHz(degrees float64) {
	log.Println("Calling AudioStreamPlayer3D.SetAttenuationFilterCutoffHz()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_attenuation_filter_cutoff_hz", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) SetAttenuationFilterDb(db float64) {
	log.Println("Calling AudioStreamPlayer3D.SetAttenuationFilterDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(db)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_attenuation_filter_db", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) SetAttenuationModel(model int64) {
	log.Println("Calling AudioStreamPlayer3D.SetAttenuationModel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(model)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_attenuation_model", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) SetAutoplay(enable *bool) {
	log.Println("Calling AudioStreamPlayer3D.SetAutoplay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_autoplay", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) SetBus(bus string) {
	log.Println("Calling AudioStreamPlayer3D.SetBus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bus)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bus", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) SetDopplerTracking(mode int64) {
	log.Println("Calling AudioStreamPlayer3D.SetDopplerTracking()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_doppler_tracking", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) SetEmissionAngle(degrees float64) {
	log.Println("Calling AudioStreamPlayer3D.SetEmissionAngle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_emission_angle", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) SetEmissionAngleEnabled(enabled *bool) {
	log.Println("Calling AudioStreamPlayer3D.SetEmissionAngleEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_emission_angle_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) SetEmissionAngleFilterAttenuationDb(db float64) {
	log.Println("Calling AudioStreamPlayer3D.SetEmissionAngleFilterAttenuationDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(db)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_emission_angle_filter_attenuation_db", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) SetMaxDb(maxDb float64) {
	log.Println("Calling AudioStreamPlayer3D.SetMaxDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(maxDb)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max_db", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) SetMaxDistance(metres float64) {
	log.Println("Calling AudioStreamPlayer3D.SetMaxDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(metres)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max_distance", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) SetOutOfRangeMode(mode int64) {
	log.Println("Calling AudioStreamPlayer3D.SetOutOfRangeMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_out_of_range_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) SetStream(stream *AudioStream) {
	log.Println("Calling AudioStreamPlayer3D.SetStream()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(stream)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_stream", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) SetUnitDb(unitDb float64) {
	log.Println("Calling AudioStreamPlayer3D.SetUnitDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(unitDb)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_unit_db", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) SetUnitSize(unitSize float64) {
	log.Println("Calling AudioStreamPlayer3D.SetUnitSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(unitSize)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_unit_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamPlayer3D) Stop() {
	log.Println("Calling AudioStreamPlayer3D.Stop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "stop", goArguments, "")

	log.Println("Got return value!")

}

/*
   AudioStreamPlayer3DImplementer is an interface for AudioStreamPlayer3D objects.

*/
type AudioStreamPlayer3DImplementer interface {
	SpatialImplementer

	GetAreaMask() int64

	GetAttenuationFilterCutoffHz() float64

	GetAttenuationFilterDb() float64

	GetAttenuationModel() int64

	GetBus() string

	GetDopplerTracking() int64

	GetEmissionAngle() float64

	GetEmissionAngleFilterAttenuationDb() float64

	GetMaxDb() float64

	GetMaxDistance() float64

	GetOutOfRangeMode() int64

	GetPos() float64

	GetStream() *AudioStream

	GetUnitDb() float64

	GetUnitSize() float64

	IsAutoplayEnabled() *bool

	IsEmissionAngleEnabled() *bool

	IsPlaying() *bool

	Play(fromPos float64)

	Seek(toPos float64)

	SetAreaMask(mask int64)

	SetAttenuationFilterCutoffHz(degrees float64)

	SetAttenuationFilterDb(db float64)

	SetAttenuationModel(model int64)

	SetAutoplay(enable *bool)

	SetBus(bus string)

	SetDopplerTracking(mode int64)

	SetEmissionAngle(degrees float64)

	SetEmissionAngleEnabled(enabled *bool)

	SetEmissionAngleFilterAttenuationDb(db float64)

	SetMaxDb(maxDb float64)

	SetMaxDistance(metres float64)

	SetOutOfRangeMode(mode int64)

	SetStream(stream *AudioStream)

	SetUnitDb(unitDb float64)

	SetUnitSize(unitSize float64)

	Stop()
}

/*

 */
type AudioStreamRandomPitch struct {
	AudioStream
}

func (o *AudioStreamRandomPitch) baseClass() string {
	return "AudioStreamRandomPitch"
}

/*

 */
func (o *AudioStreamRandomPitch) GetAudioStream() *AudioStream {
	log.Println("Calling AudioStreamRandomPitch.GetAudioStream()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_audio_stream", goArguments, "*AudioStream")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*AudioStream)

	return returnValue

}

/*

 */
func (o *AudioStreamRandomPitch) GetRandomPitch() float64 {
	log.Println("Calling AudioStreamRandomPitch.GetRandomPitch()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_random_pitch", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *AudioStreamRandomPitch) SetAudioStream(stream *AudioStream) {
	log.Println("Calling AudioStreamRandomPitch.SetAudioStream()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(stream)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_audio_stream", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamRandomPitch) SetRandomPitch(scale float64) {
	log.Println("Calling AudioStreamRandomPitch.SetRandomPitch()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_random_pitch", goArguments, "")

	log.Println("Got return value!")

}

/*
   AudioStreamRandomPitchImplementer is an interface for AudioStreamRandomPitch objects.

*/
type AudioStreamRandomPitchImplementer interface {
	AudioStreamImplementer

	GetAudioStream() *AudioStream

	GetRandomPitch() float64

	SetAudioStream(stream *AudioStream)

	SetRandomPitch(scale float64)
}

/*

 */
type AudioStreamSample struct {
	AudioStream
}

func (o *AudioStreamSample) baseClass() string {
	return "AudioStreamSample"
}

/*

 */
func (o *AudioStreamSample) GetData() *PoolByteArray {
	log.Println("Calling AudioStreamSample.GetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_data", goArguments, "*PoolByteArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolByteArray)

	return returnValue

}

/*

 */
func (o *AudioStreamSample) GetFormat() int64 {
	log.Println("Calling AudioStreamSample.GetFormat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_format", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AudioStreamSample) GetLoopBegin() int64 {
	log.Println("Calling AudioStreamSample.GetLoopBegin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_loop_begin", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AudioStreamSample) GetLoopEnd() int64 {
	log.Println("Calling AudioStreamSample.GetLoopEnd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_loop_end", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AudioStreamSample) GetLoopMode() int64 {
	log.Println("Calling AudioStreamSample.GetLoopMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_loop_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AudioStreamSample) GetMixRate() int64 {
	log.Println("Calling AudioStreamSample.GetMixRate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mix_rate", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *AudioStreamSample) IsStereo() *bool {
	log.Println("Calling AudioStreamSample.IsStereo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_stereo", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *AudioStreamSample) SetData(data *PoolByteArray) {
	log.Println("Calling AudioStreamSample.SetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_data", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamSample) SetFormat(format int64) {
	log.Println("Calling AudioStreamSample.SetFormat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(format)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_format", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamSample) SetLoopBegin(loopBegin int64) {
	log.Println("Calling AudioStreamSample.SetLoopBegin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(loopBegin)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_loop_begin", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamSample) SetLoopEnd(loopEnd int64) {
	log.Println("Calling AudioStreamSample.SetLoopEnd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(loopEnd)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_loop_end", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamSample) SetLoopMode(loopMode int64) {
	log.Println("Calling AudioStreamSample.SetLoopMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(loopMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_loop_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamSample) SetMixRate(mixRate int64) {
	log.Println("Calling AudioStreamSample.SetMixRate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mixRate)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mix_rate", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *AudioStreamSample) SetStereo(stereo *bool) {
	log.Println("Calling AudioStreamSample.SetStereo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(stereo)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_stereo", goArguments, "")

	log.Println("Got return value!")

}

/*
   AudioStreamSampleImplementer is an interface for AudioStreamSample objects.

*/
type AudioStreamSampleImplementer interface {
	AudioStreamImplementer

	GetData() *PoolByteArray

	GetFormat() int64

	GetLoopBegin() int64

	GetLoopEnd() int64

	GetLoopMode() int64

	GetMixRate() int64

	IsStereo() *bool

	SetData(data *PoolByteArray)

	SetFormat(format int64)

	SetLoopBegin(loopBegin int64)

	SetLoopEnd(loopEnd int64)

	SetLoopMode(loopMode int64)

	SetMixRate(mixRate int64)

	SetStereo(stereo *bool)
}

/*
   Node for back-buffering the currently displayed screen. The region defined in the BackBufferCopy node is bufferized with the content of the screen it covers, or the entire screen according to the copy mode set. Accessing this buffer is done with the texscreen() shader instruction.
*/
type BackBufferCopy struct {
	Node2D
}

func (o *BackBufferCopy) baseClass() string {
	return "BackBufferCopy"
}

/*
   Return the copy mode currently applied to the BackBufferCopy (refer to constants section).
*/
func (o *BackBufferCopy) GetCopyMode() int64 {
	log.Println("Calling BackBufferCopy.GetCopyMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_copy_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the area covered by the BackBufferCopy.
*/
func (o *BackBufferCopy) GetRect() *Rect2 {
	log.Println("Calling BackBufferCopy.GetRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   Set the copy mode of the BackBufferCopy (refer to constants section).
*/
func (o *BackBufferCopy) SetCopyMode(copyMode int64) {
	log.Println("Calling BackBufferCopy.SetCopyMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(copyMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_copy_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Defines the area covered by the BackBufferCopy.
*/
func (o *BackBufferCopy) SetRect(rect *Rect2) {
	log.Println("Calling BackBufferCopy.SetRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rect)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rect", goArguments, "")

	log.Println("Got return value!")

}

/*
   BackBufferCopyImplementer is an interface for BackBufferCopy objects.
   Node for back-buffering the currently displayed screen. The region defined in the BackBufferCopy node is bufferized with the content of the screen it covers, or the entire screen according to the copy mode set. Accessing this buffer is done with the texscreen() shader instruction.
*/
type BackBufferCopyImplementer interface {
	Node2DImplementer

	GetCopyMode() int64

	GetRect() *Rect2

	SetCopyMode(copyMode int64)

	SetRect(rect *Rect2)
}

/*
   BaseButton is the abstract base class for buttons, so it shouldn't be used directly (It doesn't display anything). Other types of buttons inherit from it.
*/
type BaseButton struct {
	Control
}

func (o *BaseButton) baseClass() string {
	return "BaseButton"
}

/*
   Called when button is pressed.
*/
func (o *BaseButton) X_Pressed() {
	log.Println("Calling BaseButton.X_Pressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_pressed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Called when button is toggled (only if toggle_mode is active).
*/
func (o *BaseButton) X_Toggled(pressed *bool) {
	log.Println("Calling BaseButton.X_Toggled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pressed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_toggled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the current mode of action (see [method set_action_mode]) (one of the ACTION_MODE_* constants).
*/
func (o *BaseButton) GetActionMode() int64 {
	log.Println("Calling BaseButton.GetActionMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_action_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *BaseButton) GetButtonGroup() *ButtonGroup {
	log.Println("Calling BaseButton.GetButtonGroup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_button_group", goArguments, "*ButtonGroup")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*ButtonGroup)

	return returnValue

}

/*
   Return the visual state used to draw the button. This is useful mainly when implementing your own draw code by either overriding _draw() or connecting to "draw" signal. The visual state of the button is defined by the DRAW_* enum.
*/
func (o *BaseButton) GetDrawMode() int64 {
	log.Println("Calling BaseButton.GetDrawMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_draw_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns focus access mode used when switching between enabled/disabled (see [method Control.set_focus_mode] and [method set_disabled]).
*/
func (o *BaseButton) GetEnabledFocusMode() int64 {
	log.Println("Calling BaseButton.GetEnabledFocusMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_enabled_focus_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *BaseButton) GetShortcut() *ShortCut {
	log.Println("Calling BaseButton.GetShortcut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shortcut", goArguments, "*ShortCut")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*ShortCut)

	return returnValue

}

/*
   Return whether the button is in disabled state (see [method set_disabled]).
*/
func (o *BaseButton) IsDisabled() *bool {
	log.Println("Calling BaseButton.IsDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_disabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if mouse entered the button before it exit.
*/
func (o *BaseButton) IsHovered() *bool {
	log.Println("Calling BaseButton.IsHovered()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_hovered", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   If toggle_mode is active, return whether the button is toggled. If toggle_mode is not active, return whether the button is pressed down.
*/
func (o *BaseButton) IsPressed() *bool {
	log.Println("Calling BaseButton.IsPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_pressed", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return the toggle_mode property (see [method set_toggle_mode]).
*/
func (o *BaseButton) IsToggleMode() *bool {
	log.Println("Calling BaseButton.IsToggleMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_toggle_mode", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Set the current mode of action, determining when the button is considered clicked (see the ACTION_MODE_* constants).
*/
func (o *BaseButton) SetActionMode(mode int64) {
	log.Println("Calling BaseButton.SetActionMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_action_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *BaseButton) SetButtonGroup(buttonGroup *ButtonGroup) {
	log.Println("Calling BaseButton.SetButtonGroup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(buttonGroup)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_button_group", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the button into disabled state. When a button is disabled, it can't be clicked or toggled.
*/
func (o *BaseButton) SetDisabled(disabled *bool) {
	log.Println("Calling BaseButton.SetDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(disabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_disabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the focus access mode to use when switching between enabled/disabled (see [method Control.set_focus_mode] and [method set_disabled]).
*/
func (o *BaseButton) SetEnabledFocusMode(mode int64) {
	log.Println("Calling BaseButton.SetEnabledFocusMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_enabled_focus_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the button to pressed state (only if toggle_mode is active).
*/
func (o *BaseButton) SetPressed(pressed *bool) {
	log.Println("Calling BaseButton.SetPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pressed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pressed", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *BaseButton) SetShortcut(shortcut *ShortCut) {
	log.Println("Calling BaseButton.SetShortcut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shortcut)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shortcut", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the button toggle_mode property. Toggle mode makes the button flip state between pressed and unpressed each time its area is clicked.
*/
func (o *BaseButton) SetToggleMode(enabled *bool) {
	log.Println("Calling BaseButton.SetToggleMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_toggle_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   BaseButtonImplementer is an interface for BaseButton objects.
   BaseButton is the abstract base class for buttons, so it shouldn't be used directly (It doesn't display anything). Other types of buttons inherit from it.
*/
type BaseButtonImplementer interface {
	ControlImplementer

	X_Pressed()

	X_Toggled(pressed *bool)

	GetActionMode() int64

	GetButtonGroup() *ButtonGroup

	GetDrawMode() int64

	GetEnabledFocusMode() int64

	GetShortcut() *ShortCut

	IsDisabled() *bool

	IsHovered() *bool

	IsPressed() *bool

	IsToggleMode() *bool

	SetActionMode(mode int64)

	SetButtonGroup(buttonGroup *ButtonGroup)

	SetDisabled(disabled *bool)

	SetEnabledFocusMode(mode int64)

	SetPressed(pressed *bool)

	SetShortcut(shortcut *ShortCut)

	SetToggleMode(enabled *bool)
}

/*

 */
type BitMap struct {
	Resource
}

func (o *BitMap) baseClass() string {
	return "BitMap"
}

/*

 */
func (o *BitMap) Create(size *Vector2) {
	log.Println("Calling BitMap.Create()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "create", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *BitMap) CreateFromImageAlpha(image *Image) {
	log.Println("Calling BitMap.CreateFromImageAlpha()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(image)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "create_from_image_alpha", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *BitMap) GetBit(pos *Vector2) *bool {
	log.Println("Calling BitMap.GetBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pos)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bit", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *BitMap) GetSize() *Vector2 {
	log.Println("Calling BitMap.GetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *BitMap) GetTrueBitCount() int64 {
	log.Println("Calling BitMap.GetTrueBitCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_true_bit_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *BitMap) SetBit(pos *Vector2, bit *bool) {
	log.Println("Calling BitMap.SetBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(pos)
	goArguments[1] = reflect.ValueOf(bit)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bit", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *BitMap) SetBitRect(pRect *Rect2, bit *bool) {
	log.Println("Calling BitMap.SetBitRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(pRect)
	goArguments[1] = reflect.ValueOf(bit)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bit_rect", goArguments, "")

	log.Println("Got return value!")

}

/*
   BitMapImplementer is an interface for BitMap objects.

*/
type BitMapImplementer interface {
	ResourceImplementer

	Create(size *Vector2)

	CreateFromImageAlpha(image *Image)

	GetBit(pos *Vector2) *bool

	GetSize() *Vector2

	GetTrueBitCount() int64

	SetBit(pos *Vector2, bit *bool)

	SetBitRect(pRect *Rect2, bit *bool)
}

/*

 */
type BitmapFont struct {
	Font
}

func (o *BitmapFont) baseClass() string {
	return "BitmapFont"
}

/*
   Add a character to the font, where [i]character[/i] is the unicode value, [i]texture[/i] is the texture index, [i]rect[/i] is the region in the texture (in pixels!), [i]align[/i] is the (optional) alignment for the character and [i]advance[/i] is the (optional) advance.
*/
func (o *BitmapFont) AddChar(character int64, texture int64, rect *Rect2, align *Vector2, advance float64) {
	log.Println("Calling BitmapFont.AddChar()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(character)
	goArguments[1] = reflect.ValueOf(texture)
	goArguments[2] = reflect.ValueOf(rect)
	goArguments[3] = reflect.ValueOf(align)
	goArguments[4] = reflect.ValueOf(advance)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_char", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a kerning pair to the [BitmapFont] as a difference. Kerning pairs are special cases where a typeface advance is determined by the next character.
*/
func (o *BitmapFont) AddKerningPair(charA int64, charB int64, kerning int64) {
	log.Println("Calling BitmapFont.AddKerningPair()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(charA)
	goArguments[1] = reflect.ValueOf(charB)
	goArguments[2] = reflect.ValueOf(kerning)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_kerning_pair", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a texture to the [BitmapFont].
*/
func (o *BitmapFont) AddTexture(texture *Texture) {
	log.Println("Calling BitmapFont.AddTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_texture", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear all the font data.
*/
func (o *BitmapFont) Clear() {
	log.Println("Calling BitmapFont.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *BitmapFont) CreateFromFnt(path string) int64 {
	log.Println("Calling BitmapFont.CreateFromFnt()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "create_from_fnt", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the size of a character, optionally taking kerning into account if the next character is provided.
*/
func (o *BitmapFont) GetCharSize(char int64, next int64) *Vector2 {
	log.Println("Calling BitmapFont.GetCharSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(char)
	goArguments[1] = reflect.ValueOf(next)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_char_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *BitmapFont) GetFallback() *BitmapFont {
	log.Println("Calling BitmapFont.GetFallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fallback", goArguments, "*BitmapFont")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*BitmapFont)

	return returnValue

}

/*
   Return a kerning pair as a difference.
*/
func (o *BitmapFont) GetKerningPair(charA int64, charB int64) int64 {
	log.Println("Calling BitmapFont.GetKerningPair()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(charA)
	goArguments[1] = reflect.ValueOf(charB)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_kerning_pair", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *BitmapFont) GetTexture(idx int64) *Texture {
	log.Println("Calling BitmapFont.GetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *BitmapFont) GetTextureCount() int64 {
	log.Println("Calling BitmapFont.GetTextureCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the font ascent (number of pixels above the baseline).
*/
func (o *BitmapFont) SetAscent(px float64) {
	log.Println("Calling BitmapFont.SetAscent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(px)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ascent", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *BitmapFont) SetDistanceFieldHint(enable *bool) {
	log.Println("Calling BitmapFont.SetDistanceFieldHint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_distance_field_hint", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *BitmapFont) SetFallback(fallback *BitmapFont) {
	log.Println("Calling BitmapFont.SetFallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(fallback)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fallback", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the total font height (ascent plus descent) in pixels.
*/
func (o *BitmapFont) SetHeight(px float64) {
	log.Println("Calling BitmapFont.SetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(px)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_height", goArguments, "")

	log.Println("Got return value!")

}

/*
   BitmapFontImplementer is an interface for BitmapFont objects.

*/
type BitmapFontImplementer interface {
	FontImplementer

	AddChar(character int64, texture int64, rect *Rect2, align *Vector2, advance float64)

	AddKerningPair(charA int64, charB int64, kerning int64)

	AddTexture(texture *Texture)

	Clear()

	CreateFromFnt(path string) int64

	GetCharSize(char int64, next int64) *Vector2

	GetFallback() *BitmapFont

	GetKerningPair(charA int64, charB int64) int64

	GetTexture(idx int64) *Texture

	GetTextureCount() int64

	SetAscent(px float64)

	SetDistanceFieldHint(enable *bool)

	SetFallback(fallback *BitmapFont)

	SetHeight(px float64)
}

/*
   This node must be the child of a [Skeleton] node. You can then select a bone for this node to attach to. The BoneAttachment node will copy the transform of the selected bone.
*/
type BoneAttachment struct {
	Spatial
}

func (o *BoneAttachment) baseClass() string {
	return "BoneAttachment"
}

/*

 */
func (o *BoneAttachment) GetBoneName() string {
	log.Println("Calling BoneAttachment.GetBoneName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bone_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *BoneAttachment) SetBoneName(boneName string) {
	log.Println("Calling BoneAttachment.SetBoneName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(boneName)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bone_name", goArguments, "")

	log.Println("Got return value!")

}

/*
   BoneAttachmentImplementer is an interface for BoneAttachment objects.
   This node must be the child of a [Skeleton] node. You can then select a bone for this node to attach to. The BoneAttachment node will copy the transform of the selected bone.
*/
type BoneAttachmentImplementer interface {
	SpatialImplementer

	GetBoneName() string

	SetBoneName(boneName string)
}

/*
   Base class for Box containers. It arranges children controls vertically or horizontally, and rearranges them automatically when their minimum size changes.
*/
type BoxContainer struct {
	Container
}

func (o *BoxContainer) baseClass() string {
	return "BoxContainer"
}

/*
                Add a control to the box as a spacer.
				If [i]begin[/i] is true the spacer control will be inserted in front of other children.
*/
func (o *BoxContainer) AddSpacer(begin *bool) {
	log.Println("Calling BoxContainer.AddSpacer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(begin)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_spacer", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the alignment of children in the container.
*/
func (o *BoxContainer) GetAlignment() int64 {
	log.Println("Calling BoxContainer.GetAlignment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_alignment", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the alignment of children in the container(Must be one of ALIGN_BEGIN, ALIGN_CENTER or ALIGN_END).
*/
func (o *BoxContainer) SetAlignment(alignment int64) {
	log.Println("Calling BoxContainer.SetAlignment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(alignment)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_alignment", goArguments, "")

	log.Println("Got return value!")

}

/*
   BoxContainerImplementer is an interface for BoxContainer objects.
   Base class for Box containers. It arranges children controls vertically or horizontally, and rearranges them automatically when their minimum size changes.
*/
type BoxContainerImplementer interface {
	ContainerImplementer

	AddSpacer(begin *bool)

	GetAlignment() int64

	SetAlignment(alignment int64)
}

/*
   Box shape resource, which can be set into a [PhysicsBody] or area.
*/
type BoxShape struct {
	Shape
}

func (o *BoxShape) baseClass() string {
	return "BoxShape"
}

/*
   Return the half extents of the shape.
*/
func (o *BoxShape) GetExtents() *Vector3 {
	log.Println("Calling BoxShape.GetExtents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_extents", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Set the half extents for the shape.
*/
func (o *BoxShape) SetExtents(extents *Vector3) {
	log.Println("Calling BoxShape.SetExtents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(extents)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_extents", goArguments, "")

	log.Println("Got return value!")

}

/*
   BoxShapeImplementer is an interface for BoxShape objects.
   Box shape resource, which can be set into a [PhysicsBody] or area.
*/
type BoxShapeImplementer interface {
	ShapeImplementer

	GetExtents() *Vector3

	SetExtents(extents *Vector3)
}

/*
   Button is the standard themed button. It can contain text and an icon, and will display them according to the current [Theme].
*/
type Button struct {
	BaseButton
}

func (o *Button) baseClass() string {
	return "Button"
}

/*
   Return the button icon.
*/
func (o *Button) GetButtonIcon() *Texture {
	log.Println("Calling Button.GetButtonIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_button_icon", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   Return the state of the [i]clip_text[/i] property (see [method set_clip_text])
*/
func (o *Button) GetClipText() *bool {
	log.Println("Calling Button.GetClipText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_clip_text", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return the button text.
*/
func (o *Button) GetText() string {
	log.Println("Calling Button.GetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the text alignment policy.
*/
func (o *Button) GetTextAlign() int64 {
	log.Println("Calling Button.GetTextAlign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_text_align", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the state of the [i]flat[/i] property (see [method set_flat]).
*/
func (o *Button) IsFlat() *bool {
	log.Println("Calling Button.IsFlat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_flat", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Set the icon that will be displayed next to the text inside the button area.
*/
func (o *Button) SetButtonIcon(texture *Texture) {
	log.Println("Calling Button.SetButtonIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_button_icon", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the [i]clip_text[/i] property of a Button. When this property is enabled, text that is too large to fit the button is clipped, when disabled (default) the Button will always be wide enough to hold the text.
*/
func (o *Button) SetClipText(enabled *bool) {
	log.Println("Calling Button.SetClipText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_clip_text", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the [i]flat[/i] property of a Button. Flat buttons don't display decoration unless hovered or pressed.
*/
func (o *Button) SetFlat(enabled *bool) {
	log.Println("Calling Button.SetFlat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flat", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the button text, which will be displayed inside the button area.
*/
func (o *Button) SetText(text string) {
	log.Println("Calling Button.SetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_text", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the text alignment policy, using one of the ALIGN_* constants.
*/
func (o *Button) SetTextAlign(align int64) {
	log.Println("Calling Button.SetTextAlign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(align)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_text_align", goArguments, "")

	log.Println("Got return value!")

}

/*
   ButtonImplementer is an interface for Button objects.
   Button is the standard themed button. It can contain text and an icon, and will display them according to the current [Theme].
*/
type ButtonImplementer interface {
	BaseButtonImplementer

	GetButtonIcon() *Texture

	GetClipText() *bool

	GetText() string

	GetTextAlign() int64

	IsFlat() *bool

	SetButtonIcon(texture *Texture)

	SetClipText(enabled *bool)

	SetFlat(enabled *bool)

	SetText(text string)

	SetTextAlign(align int64)
}

/*
   Group of [Button]. All direct and indirect children buttons become radios. Only one allows being pressed.
*/
type ButtonGroup struct {
	Resource
}

func (o *ButtonGroup) baseClass() string {
	return "ButtonGroup"
}

/*
   Return the pressed button.
*/
func (o *ButtonGroup) GetPressedButton() *BaseButton {
	log.Println("Calling ButtonGroup.GetPressedButton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pressed_button", goArguments, "*BaseButton")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*BaseButton)

	return returnValue

}

/*
   ButtonGroupImplementer is an interface for ButtonGroup objects.
   Group of [Button]. All direct and indirect children buttons become radios. Only one allows being pressed.
*/
type ButtonGroupImplementer interface {
	ResourceImplementer

	GetPressedButton() *BaseButton
}

/*
   Camera is a special node that displays what is visible from its current location. Cameras register themselves in the nearest [Viewport] node (when ascending the tree). Only one camera can be active per viewport. If no viewport is available ascending the tree, the Camera will register in the global viewport. In other words, a Camera just provides [i]3D[/i] display capabilities to a [Viewport], and, without one, a scene registered in that [Viewport] (or higher viewports) can't be displayed.
*/
type Camera struct {
	Spatial
}

func (o *Camera) baseClass() string {
	return "Camera"
}

/*

 */
func (o *Camera) ClearCurrent() {
	log.Println("Calling Camera.ClearCurrent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_current", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the camera transform. Subclassed cameras (such as CharacterCamera) may provide different transforms than the [Node] transform.
*/
func (o *Camera) GetCameraTransform() *Transform {
	log.Println("Calling Camera.GetCameraTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_camera_transform", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*

 */
func (o *Camera) GetCullMask() int64 {
	log.Println("Calling Camera.GetCullMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cull_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Camera) GetDopplerTracking() int64 {
	log.Println("Calling Camera.GetDopplerTracking()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_doppler_tracking", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Camera) GetEnvironment() *Environment {
	log.Println("Calling Camera.GetEnvironment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_environment", goArguments, "*Environment")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Environment)

	return returnValue

}

/*

 */
func (o *Camera) GetFov() float64 {
	log.Println("Calling Camera.GetFov()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fov", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Camera) GetHOffset() float64 {
	log.Println("Calling Camera.GetHOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_h_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Camera) GetKeepAspectMode() int64 {
	log.Println("Calling Camera.GetKeepAspectMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_keep_aspect_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Camera) GetProjection() int64 {
	log.Println("Calling Camera.GetProjection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_projection", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Camera) GetSize() float64 {
	log.Println("Calling Camera.GetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_size", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Camera) GetVOffset() float64 {
	log.Println("Calling Camera.GetVOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_v_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Camera) GetZfar() float64 {
	log.Println("Calling Camera.GetZfar()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_zfar", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Camera) GetZnear() float64 {
	log.Println("Calling Camera.GetZnear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_znear", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return whether the Camera is the current one in the [Viewport], or plans to become current (if outside the scene tree).
*/
func (o *Camera) IsCurrent() *bool {
	log.Println("Calling Camera.IsCurrent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_current", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Camera) IsPositionBehind(worldPoint *Vector3) *bool {
	log.Println("Calling Camera.IsPositionBehind()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(worldPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_position_behind", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Make this camera the current Camera for the [Viewport] (see class description). If the Camera Node is outside the scene tree, it will attempt to become current once it's added.
*/
func (o *Camera) MakeCurrent() {
	log.Println("Calling Camera.MakeCurrent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "make_current", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera) ProjectLocalRayNormal(screenPoint *Vector2) *Vector3 {
	log.Println("Calling Camera.ProjectLocalRayNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(screenPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "project_local_ray_normal", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *Camera) ProjectPosition(screenPoint *Vector2) *Vector3 {
	log.Println("Calling Camera.ProjectPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(screenPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "project_position", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Return a normal vector in worldspace, that is the result of projecting a point on the [Viewport] rectangle by the camera projection. This is useful for casting rays in the form of (origin,normal) for object intersection or picking.
*/
func (o *Camera) ProjectRayNormal(screenPoint *Vector2) *Vector3 {
	log.Println("Calling Camera.ProjectRayNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(screenPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "project_ray_normal", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Return a 3D position in worldspace, that is the result of projecting a point on the [Viewport] rectangle by the camera projection. This is useful for casting rays in the form of (origin,normal) for object intersection or picking.
*/
func (o *Camera) ProjectRayOrigin(screenPoint *Vector2) *Vector3 {
	log.Println("Calling Camera.ProjectRayOrigin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(screenPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "project_ray_origin", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *Camera) SetCullMask(mask int64) {
	log.Println("Calling Camera.SetCullMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cull_mask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera) SetDopplerTracking(mode int64) {
	log.Println("Calling Camera.SetDopplerTracking()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_doppler_tracking", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera) SetEnvironment(env *Environment) {
	log.Println("Calling Camera.SetEnvironment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(env)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_environment", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera) SetHOffset(ofs float64) {
	log.Println("Calling Camera.SetHOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ofs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_h_offset", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera) SetKeepAspectMode(mode int64) {
	log.Println("Calling Camera.SetKeepAspectMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_keep_aspect_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the camera projection to orthogonal mode, by specifying a width and the [i]near[/i] and [i]far[/i] clip planes in worldspace units. (As a hint, 2D games often use this projection, with values specified in pixels)
*/
func (o *Camera) SetOrthogonal(size float64, zNear float64, zFar float64) {
	log.Println("Calling Camera.SetOrthogonal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(size)
	goArguments[1] = reflect.ValueOf(zNear)
	goArguments[2] = reflect.ValueOf(zFar)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_orthogonal", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the camera projection to perspective mode, by specifying a [i]FOV[/i] Y angle in degrees (FOV means Field of View), and the [i]near[/i] and [i]far[/i] clip planes in worldspace units.
*/
func (o *Camera) SetPerspective(fov float64, zNear float64, zFar float64) {
	log.Println("Calling Camera.SetPerspective()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(fov)
	goArguments[1] = reflect.ValueOf(zNear)
	goArguments[2] = reflect.ValueOf(zFar)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_perspective", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera) SetVOffset(ofs float64) {
	log.Println("Calling Camera.SetVOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ofs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_v_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return how a 3D point in worldspace maps to a 2D coordinate in the [Viewport] rectangle.
*/
func (o *Camera) UnprojectPosition(worldPoint *Vector3) *Vector2 {
	log.Println("Calling Camera.UnprojectPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(worldPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "unproject_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   CameraImplementer is an interface for Camera objects.
   Camera is a special node that displays what is visible from its current location. Cameras register themselves in the nearest [Viewport] node (when ascending the tree). Only one camera can be active per viewport. If no viewport is available ascending the tree, the Camera will register in the global viewport. In other words, a Camera just provides [i]3D[/i] display capabilities to a [Viewport], and, without one, a scene registered in that [Viewport] (or higher viewports) can't be displayed.
*/
type CameraImplementer interface {
	SpatialImplementer

	ClearCurrent()

	GetCameraTransform() *Transform

	GetCullMask() int64

	GetDopplerTracking() int64

	GetEnvironment() *Environment

	GetFov() float64

	GetHOffset() float64

	GetKeepAspectMode() int64

	GetProjection() int64

	GetSize() float64

	GetVOffset() float64

	GetZfar() float64

	GetZnear() float64

	IsCurrent() *bool

	IsPositionBehind(worldPoint *Vector3) *bool

	MakeCurrent()

	ProjectLocalRayNormal(screenPoint *Vector2) *Vector3

	ProjectPosition(screenPoint *Vector2) *Vector3

	ProjectRayNormal(screenPoint *Vector2) *Vector3

	ProjectRayOrigin(screenPoint *Vector2) *Vector3

	SetCullMask(mask int64)

	SetDopplerTracking(mode int64)

	SetEnvironment(env *Environment)

	SetHOffset(ofs float64)

	SetKeepAspectMode(mode int64)

	SetOrthogonal(size float64, zNear float64, zFar float64)

	SetPerspective(fov float64, zNear float64, zFar float64)

	SetVOffset(ofs float64)

	UnprojectPosition(worldPoint *Vector3) *Vector2
}

/*
        Camera node for 2D scenes. It forces the screen (current layer) to scroll following this node. This makes it easier (and faster) to program scrollable scenes than manually changing the position of [CanvasItem] based nodes.
		This node is intended to be a simple helper get get things going quickly and it may happen often that more functionality is desired to change how the camera works. To make your own custom camera node, simply inherit from [Node2D] and change the transform of the canvas by calling get_viewport().set_canvas_transform(m) in [Viewport].
*/
type Camera2D struct {
	Node2D
}

func (o *Camera2D) baseClass() string {
	return "Camera2D"
}

/*
   Align the camera to the tracked node
*/
func (o *Camera2D) Align() {
	log.Println("Calling Camera2D.Align()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "align", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) ClearCurrent() {
	log.Println("Calling Camera2D.ClearCurrent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_current", goArguments, "")

	log.Println("Got return value!")

}

/*
   Force the camera to update scroll immediately.
*/
func (o *Camera2D) ForceUpdateScroll() {
	log.Println("Calling Camera2D.ForceUpdateScroll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "force_update_scroll", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) GetAnchorMode() int64 {
	log.Println("Calling Camera2D.GetAnchorMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_anchor_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the camera position.
*/
func (o *Camera2D) GetCameraPos() *Vector2 {
	log.Println("Calling Camera2D.GetCameraPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_camera_pos", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Camera2D) GetCameraScreenCenter() *Vector2 {
	log.Println("Calling Camera2D.GetCameraScreenCenter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_camera_screen_center", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Camera2D) GetCustomViewport() *Node {
	log.Println("Calling Camera2D.GetCustomViewport()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_custom_viewport", goArguments, "*Node")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Node)

	return returnValue

}

/*
   Return the margins needed to drag the camera (see [method set_drag_margin]).
*/
func (o *Camera2D) GetDragMargin(margin int64) float64 {
	log.Println("Calling Camera2D.GetDragMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_drag_margin", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Camera2D) GetFollowSmoothing() float64 {
	log.Println("Calling Camera2D.GetFollowSmoothing()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_follow_smoothing", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Camera2D) GetHOffset() float64 {
	log.Println("Calling Camera2D.GetHOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_h_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the scrolling limit in pixels.
*/
func (o *Camera2D) GetLimit(margin int64) int64 {
	log.Println("Calling Camera2D.GetLimit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_limit", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the scroll offset.
*/
func (o *Camera2D) GetOffset() *Vector2 {
	log.Println("Calling Camera2D.GetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Camera2D) GetVOffset() float64 {
	log.Println("Calling Camera2D.GetVOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_v_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Camera2D) GetZoom() *Vector2 {
	log.Println("Calling Camera2D.GetZoom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_zoom", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return true of this is the current camera (see [method make_current]).
*/
func (o *Camera2D) IsCurrent() *bool {
	log.Println("Calling Camera2D.IsCurrent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_current", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Camera2D) IsFollowSmoothingEnabled() *bool {
	log.Println("Calling Camera2D.IsFollowSmoothingEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_follow_smoothing_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Camera2D) IsHDragEnabled() *bool {
	log.Println("Calling Camera2D.IsHDragEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_h_drag_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Camera2D) IsLimitDrawingEnabled() *bool {
	log.Println("Calling Camera2D.IsLimitDrawingEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_limit_drawing_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Camera2D) IsLimitSmoothingEnabled() *bool {
	log.Println("Calling Camera2D.IsLimitSmoothingEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_limit_smoothing_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Camera2D) IsMarginDrawingEnabled() *bool {
	log.Println("Calling Camera2D.IsMarginDrawingEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_margin_drawing_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Camera2D) IsRotating() *bool {
	log.Println("Calling Camera2D.IsRotating()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_rotating", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Camera2D) IsScreenDrawingEnabled() *bool {
	log.Println("Calling Camera2D.IsScreenDrawingEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_screen_drawing_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Camera2D) IsVDragEnabled() *bool {
	log.Println("Calling Camera2D.IsVDragEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_v_drag_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Make this the current 2D camera for the scene (viewport and layer), in case there's many cameras in the scene.
*/
func (o *Camera2D) MakeCurrent() {
	log.Println("Calling Camera2D.MakeCurrent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "make_current", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set the camera's position immediately to its current smoothing destination.
				This has no effect if smoothing is disabled.
*/
func (o *Camera2D) ResetSmoothing() {
	log.Println("Calling Camera2D.ResetSmoothing()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "reset_smoothing", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) SetAnchorMode(anchorMode int64) {
	log.Println("Calling Camera2D.SetAnchorMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(anchorMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_anchor_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) SetCustomViewport(viewport *Node) {
	log.Println("Calling Camera2D.SetCustomViewport()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(viewport)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_custom_viewport", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the margins needed to drag the camera (relative to the screen size). Margin uses the MARGIN_* enum. Drag margins of 0,0,0,0 will keep the camera at the center of the screen, while drag margins of 1,1,1,1 will only move when the camera is at the edges.
*/
func (o *Camera2D) SetDragMargin(margin int64, dragMargin float64) {
	log.Println("Calling Camera2D.SetDragMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(dragMargin)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_drag_margin", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) SetEnableFollowSmoothing(followSmoothing *bool) {
	log.Println("Calling Camera2D.SetEnableFollowSmoothing()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(followSmoothing)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_enable_follow_smoothing", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) SetFollowSmoothing(followSmoothing float64) {
	log.Println("Calling Camera2D.SetFollowSmoothing()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(followSmoothing)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_follow_smoothing", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) SetHDragEnabled(enabled *bool) {
	log.Println("Calling Camera2D.SetHDragEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_h_drag_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) SetHOffset(ofs float64) {
	log.Println("Calling Camera2D.SetHOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ofs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_h_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the scrolling limit in pixels.
*/
func (o *Camera2D) SetLimit(margin int64, limit int64) {
	log.Println("Calling Camera2D.SetLimit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(limit)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_limit", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) SetLimitDrawingEnabled(limitDrawingEnabled *bool) {
	log.Println("Calling Camera2D.SetLimitDrawingEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(limitDrawingEnabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_limit_drawing_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*
                Smooth camera when reaching camera limits.
				This requires camera smoothing being enabled to have a noticeable effect.
*/
func (o *Camera2D) SetLimitSmoothingEnabled(limitSmoothingEnabled *bool) {
	log.Println("Calling Camera2D.SetLimitSmoothingEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(limitSmoothingEnabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_limit_smoothing_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) SetMarginDrawingEnabled(marginDrawingEnabled *bool) {
	log.Println("Calling Camera2D.SetMarginDrawingEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(marginDrawingEnabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_margin_drawing_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the scroll offset. Useful for looking around or camera shake animations.
*/
func (o *Camera2D) SetOffset(offset *Vector2) {
	log.Println("Calling Camera2D.SetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_offset", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) SetRotating(rotating *bool) {
	log.Println("Calling Camera2D.SetRotating()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rotating)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rotating", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) SetScreenDrawingEnabled(screenDrawingEnabled *bool) {
	log.Println("Calling Camera2D.SetScreenDrawingEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(screenDrawingEnabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_screen_drawing_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) SetVDragEnabled(enabled *bool) {
	log.Println("Calling Camera2D.SetVDragEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_v_drag_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) SetVOffset(ofs float64) {
	log.Println("Calling Camera2D.SetVOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ofs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_v_offset", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Camera2D) SetZoom(zoom *Vector2) {
	log.Println("Calling Camera2D.SetZoom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(zoom)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_zoom", goArguments, "")

	log.Println("Got return value!")

}

/*
        Camera2DImplementer is an interface for Camera2D objects.
        Camera node for 2D scenes. It forces the screen (current layer) to scroll following this node. This makes it easier (and faster) to program scrollable scenes than manually changing the position of [CanvasItem] based nodes.
		This node is intended to be a simple helper get get things going quickly and it may happen often that more functionality is desired to change how the camera works. To make your own custom camera node, simply inherit from [Node2D] and change the transform of the canvas by calling get_viewport().set_canvas_transform(m) in [Viewport].
*/
type Camera2DImplementer interface {
	Node2DImplementer

	Align()

	ClearCurrent()

	ForceUpdateScroll()

	GetAnchorMode() int64

	GetCameraPos() *Vector2

	GetCameraScreenCenter() *Vector2

	GetCustomViewport() *Node

	GetDragMargin(margin int64) float64

	GetFollowSmoothing() float64

	GetHOffset() float64

	GetLimit(margin int64) int64

	GetOffset() *Vector2

	GetVOffset() float64

	GetZoom() *Vector2

	IsCurrent() *bool

	IsFollowSmoothingEnabled() *bool

	IsHDragEnabled() *bool

	IsLimitDrawingEnabled() *bool

	IsLimitSmoothingEnabled() *bool

	IsMarginDrawingEnabled() *bool

	IsRotating() *bool

	IsScreenDrawingEnabled() *bool

	IsVDragEnabled() *bool

	MakeCurrent()

	ResetSmoothing()

	SetAnchorMode(anchorMode int64)

	SetCustomViewport(viewport *Node)

	SetDragMargin(margin int64, dragMargin float64)

	SetEnableFollowSmoothing(followSmoothing *bool)

	SetFollowSmoothing(followSmoothing float64)

	SetHDragEnabled(enabled *bool)

	SetHOffset(ofs float64)

	SetLimit(margin int64, limit int64)

	SetLimitDrawingEnabled(limitDrawingEnabled *bool)

	SetLimitSmoothingEnabled(limitSmoothingEnabled *bool)

	SetMarginDrawingEnabled(marginDrawingEnabled *bool)

	SetOffset(offset *Vector2)

	SetRotating(rotating *bool)

	SetScreenDrawingEnabled(screenDrawingEnabled *bool)

	SetVDragEnabled(enabled *bool)

	SetVOffset(ofs float64)

	SetZoom(zoom *Vector2)
}

/*
        Base class of anything 2D. Canvas items are laid out in a tree and children inherit and extend the transform of their parent. CanvasItem is extended by [Control], for anything GUI related, and by [Node2D] for anything 2D engine related.
		Any CanvasItem can draw. For this, the "update" function must be called, then NOTIFICATION_DRAW will be received on idle time to request redraw. Because of this, canvas items don't need to be redraw on every frame, improving the performance significantly. Several functions for drawing on the CanvasItem are provided (see draw_* functions). They can only be used inside the notification, signal or _draw() overrides function, though.
		Canvas items are draw in tree order. By default, children are on top of their parents so a root CanvasItem will be drawn behind everything (this can be changed per item though).
		Canvas items can also be hidden (hiding also their subtree). They provide many means for changing standard parameters such as opacity (for it and the subtree) and self opacity, blend mode.
		Ultimately, a transform notification can be requested, which will notify the node that its global position changed in case the parent tree changed.
*/
type CanvasItem struct {
	Node
}

func (o *CanvasItem) baseClass() string {
	return "CanvasItem"
}

/*
   Called (if exists) to draw the canvas item.
*/
func (o *CanvasItem) X_Draw() {
	log.Println("Calling CanvasItem.X_Draw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_draw", goArguments, "")

	log.Println("Got return value!")

}

/*
   Draw a string character using a custom font. Returns the advance, depending on the char width and kerning with an optional next char.
*/
func (o *CanvasItem) DrawChar(font *Font, pos *Vector2, char string, next string, modulate *Color) float64 {
	log.Println("Calling CanvasItem.DrawChar()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(font)
	goArguments[1] = reflect.ValueOf(pos)
	goArguments[2] = reflect.ValueOf(char)
	goArguments[3] = reflect.ValueOf(next)
	goArguments[4] = reflect.ValueOf(modulate)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "draw_char", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Draw a colored circle.
*/
func (o *CanvasItem) DrawCircle(pos *Vector2, radius float64, color *Color) {
	log.Println("Calling CanvasItem.DrawCircle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(pos)
	goArguments[1] = reflect.ValueOf(radius)
	goArguments[2] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_circle", goArguments, "")

	log.Println("Got return value!")

}

/*
   Draw a colored polygon of any amount of points, convex or concave.
*/
func (o *CanvasItem) DrawColoredPolygon(points *PoolVector2Array, color *Color, uvs *PoolVector2Array, texture *Texture, normalMap *Texture, antialiased *bool) {
	log.Println("Calling CanvasItem.DrawColoredPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 6, 6)
	goArguments[0] = reflect.ValueOf(points)
	goArguments[1] = reflect.ValueOf(color)
	goArguments[2] = reflect.ValueOf(uvs)
	goArguments[3] = reflect.ValueOf(texture)
	goArguments[4] = reflect.ValueOf(normalMap)
	goArguments[5] = reflect.ValueOf(antialiased)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_colored_polygon", goArguments, "")

	log.Println("Got return value!")

}

/*
   Draw a line from a 2D point to another, with a given color and width. It can be optionally antialiased.
*/
func (o *CanvasItem) DrawLine(from *Vector2, to *Vector2, color *Color, width float64, antialiased *bool) {
	log.Println("Calling CanvasItem.DrawLine()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(to)
	goArguments[2] = reflect.ValueOf(color)
	goArguments[3] = reflect.ValueOf(width)
	goArguments[4] = reflect.ValueOf(antialiased)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_line", goArguments, "")

	log.Println("Got return value!")

}

/*
   Draw a polygon of any amount of points, convex or concave.
*/
func (o *CanvasItem) DrawPolygon(points *PoolVector2Array, colors *PoolColorArray, uvs *PoolVector2Array, texture *Texture, normalMap *Texture, antialiased *bool) {
	log.Println("Calling CanvasItem.DrawPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 6, 6)
	goArguments[0] = reflect.ValueOf(points)
	goArguments[1] = reflect.ValueOf(colors)
	goArguments[2] = reflect.ValueOf(uvs)
	goArguments[3] = reflect.ValueOf(texture)
	goArguments[4] = reflect.ValueOf(normalMap)
	goArguments[5] = reflect.ValueOf(antialiased)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_polygon", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CanvasItem) DrawPolyline(points *PoolVector2Array, color *Color, width float64, antialiased *bool) {
	log.Println("Calling CanvasItem.DrawPolyline()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(points)
	goArguments[1] = reflect.ValueOf(color)
	goArguments[2] = reflect.ValueOf(width)
	goArguments[3] = reflect.ValueOf(antialiased)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_polyline", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CanvasItem) DrawPolylineColors(points *PoolVector2Array, colors *PoolColorArray, width float64, antialiased *bool) {
	log.Println("Calling CanvasItem.DrawPolylineColors()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(points)
	goArguments[1] = reflect.ValueOf(colors)
	goArguments[2] = reflect.ValueOf(width)
	goArguments[3] = reflect.ValueOf(antialiased)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_polyline_colors", goArguments, "")

	log.Println("Got return value!")

}

/*
   Draw a custom primitive, 1 point for a point, 2 points for a line, 3 points for a triangle and 4 points for a quad.
*/
func (o *CanvasItem) DrawPrimitive(points *PoolVector2Array, colors *PoolColorArray, uvs *PoolVector2Array, texture *Texture, width float64, normalMap *Texture) {
	log.Println("Calling CanvasItem.DrawPrimitive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 6, 6)
	goArguments[0] = reflect.ValueOf(points)
	goArguments[1] = reflect.ValueOf(colors)
	goArguments[2] = reflect.ValueOf(uvs)
	goArguments[3] = reflect.ValueOf(texture)
	goArguments[4] = reflect.ValueOf(width)
	goArguments[5] = reflect.ValueOf(normalMap)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_primitive", goArguments, "")

	log.Println("Got return value!")

}

/*
   Draw a colored rectangle.
*/
func (o *CanvasItem) DrawRect(rect *Rect2, color *Color, filled *bool) {
	log.Println("Calling CanvasItem.DrawRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(rect)
	goArguments[1] = reflect.ValueOf(color)
	goArguments[2] = reflect.ValueOf(filled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_rect", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set a custom transform for drawing. Anything drawn afterwards will be transformed by this.
*/
func (o *CanvasItem) DrawSetTransform(pos *Vector2, rot float64, scale *Vector2) {
	log.Println("Calling CanvasItem.DrawSetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(pos)
	goArguments[1] = reflect.ValueOf(rot)
	goArguments[2] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_set_transform", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CanvasItem) DrawSetTransformMatrix(xform *Transform2D) {
	log.Println("Calling CanvasItem.DrawSetTransformMatrix()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(xform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_set_transform_matrix", goArguments, "")

	log.Println("Got return value!")

}

/*
   Draw a string using a custom font.
*/
func (o *CanvasItem) DrawString(font *Font, pos *Vector2, text string, modulate *Color, clipW int64) {
	log.Println("Calling CanvasItem.DrawString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(font)
	goArguments[1] = reflect.ValueOf(pos)
	goArguments[2] = reflect.ValueOf(text)
	goArguments[3] = reflect.ValueOf(modulate)
	goArguments[4] = reflect.ValueOf(clipW)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_string", goArguments, "")

	log.Println("Got return value!")

}

/*
   Draw a styled rectangle.
*/
func (o *CanvasItem) DrawStyleBox(styleBox *StyleBox, rect *Rect2) {
	log.Println("Calling CanvasItem.DrawStyleBox()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(styleBox)
	goArguments[1] = reflect.ValueOf(rect)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_style_box", goArguments, "")

	log.Println("Got return value!")

}

/*
   Draw a texture at a given position.
*/
func (o *CanvasItem) DrawTexture(texture *Texture, pos *Vector2, modulate *Color, normalMap *Texture) {
	log.Println("Calling CanvasItem.DrawTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(texture)
	goArguments[1] = reflect.ValueOf(pos)
	goArguments[2] = reflect.ValueOf(modulate)
	goArguments[3] = reflect.ValueOf(normalMap)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_texture", goArguments, "")

	log.Println("Got return value!")

}

/*
   Draw a textured rectangle at a given position, optionally modulated by a color. Transpose swaps the x and y coordinates when reading the texture.
*/
func (o *CanvasItem) DrawTextureRect(texture *Texture, rect *Rect2, tile *bool, modulate *Color, transpose *bool, normalMap *Texture) {
	log.Println("Calling CanvasItem.DrawTextureRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 6, 6)
	goArguments[0] = reflect.ValueOf(texture)
	goArguments[1] = reflect.ValueOf(rect)
	goArguments[2] = reflect.ValueOf(tile)
	goArguments[3] = reflect.ValueOf(modulate)
	goArguments[4] = reflect.ValueOf(transpose)
	goArguments[5] = reflect.ValueOf(normalMap)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_texture_rect", goArguments, "")

	log.Println("Got return value!")

}

/*
   Draw a textured rectangle region at a given position, optionally modulated by a color. Transpose swaps the x and y coordinates when reading the texture.
*/
func (o *CanvasItem) DrawTextureRectRegion(texture *Texture, rect *Rect2, srcRect *Rect2, modulate *Color, transpose *bool, normalMap *Texture, clipUv *bool) {
	log.Println("Calling CanvasItem.DrawTextureRectRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 7, 7)
	goArguments[0] = reflect.ValueOf(texture)
	goArguments[1] = reflect.ValueOf(rect)
	goArguments[2] = reflect.ValueOf(srcRect)
	goArguments[3] = reflect.ValueOf(modulate)
	goArguments[4] = reflect.ValueOf(transpose)
	goArguments[5] = reflect.ValueOf(normalMap)
	goArguments[6] = reflect.ValueOf(clipUv)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_texture_rect_region", goArguments, "")

	log.Println("Got return value!")

}

/*
   Used for editing, returns an opaque value representing the transform state.
*/
func (o *CanvasItem) EditGetState() *Variant {
	log.Println("Calling CanvasItem.EditGetState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "edit_get_state", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Used for editing, handle rotation.
*/
func (o *CanvasItem) EditRotate(degrees float64) {
	log.Println("Calling CanvasItem.EditRotate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "edit_rotate", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CanvasItem) EditSetRect(rect *Rect2) {
	log.Println("Calling CanvasItem.EditSetRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rect)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "edit_set_rect", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the transform state of this CanvasItem. For [Node2D], this is an [Array] with (in order) a [Vector2] for position, a float for rotation (radians) and another [Vector2] for scale. For [Control] this is a [Rect2] with the position and size.
*/
func (o *CanvasItem) EditSetState(state *Variant) {
	log.Println("Calling CanvasItem.EditSetState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(state)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "edit_set_state", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the [RID] of the [World2D] canvas where this item is in.
*/
func (o *CanvasItem) GetCanvas() *RID {
	log.Println("Calling CanvasItem.GetCanvas()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_canvas", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Return the canvas item RID used by [VisualServer] for this item.
*/
func (o *CanvasItem) GetCanvasItem() *RID {
	log.Println("Calling CanvasItem.GetCanvasItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_canvas_item", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Get the transform matrix of this item's canvas.
*/
func (o *CanvasItem) GetCanvasTransform() *Transform2D {
	log.Println("Calling CanvasItem.GetCanvasTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_canvas_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Get the global position of the mouse.
*/
func (o *CanvasItem) GetGlobalMousePosition() *Vector2 {
	log.Println("Calling CanvasItem.GetGlobalMousePosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_global_mouse_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Get the global transform matrix of this item.
*/
func (o *CanvasItem) GetGlobalTransform() *Transform2D {
	log.Println("Calling CanvasItem.GetGlobalTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_global_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Get the global transform matrix of this item in relation to the canvas.
*/
func (o *CanvasItem) GetGlobalTransformWithCanvas() *Transform2D {
	log.Println("Calling CanvasItem.GetGlobalTransformWithCanvas()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_global_transform_with_canvas", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Get a [Rect2] with the boundaries of this item and its children.
*/
func (o *CanvasItem) GetItemAndChildrenRect() *Rect2 {
	log.Println("Calling CanvasItem.GetItemAndChildrenRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_and_children_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   Return a rect containing the editable boundaries of the item.
*/
func (o *CanvasItem) GetItemRect() *Rect2 {
	log.Println("Calling CanvasItem.GetItemRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   Get this item's light mask number.
*/
func (o *CanvasItem) GetLightMask() int64 {
	log.Println("Calling CanvasItem.GetLightMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_light_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the mouse position relative to this item's position.
*/
func (o *CanvasItem) GetLocalMousePos() *Vector2 {
	log.Println("Calling CanvasItem.GetLocalMousePos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_local_mouse_pos", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Get the material of this item.
*/
func (o *CanvasItem) GetMaterial() *Material {
	log.Println("Calling CanvasItem.GetMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_material", goArguments, "*Material")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Material)

	return returnValue

}

/*
   Get the modulate of the CanvasItem, which affects children items too.
*/
func (o *CanvasItem) GetModulate() *Color {
	log.Println("Calling CanvasItem.GetModulate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_modulate", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   Get the self-modulate of the CanvasItem.
*/
func (o *CanvasItem) GetSelfModulate() *Color {
	log.Println("Calling CanvasItem.GetSelfModulate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_self_modulate", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   Get the transform matrix of this item.
*/
func (o *CanvasItem) GetTransform() *Transform2D {
	log.Println("Calling CanvasItem.GetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Get whether this item uses its parent's material.
*/
func (o *CanvasItem) GetUseParentMaterial() *bool {
	log.Println("Calling CanvasItem.GetUseParentMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_use_parent_material", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Get the viewport's boundaries as a [Rect2].
*/
func (o *CanvasItem) GetViewportRect() *Rect2 {
	log.Println("Calling CanvasItem.GetViewportRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_viewport_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   Get this item's transform in relation to the viewport.
*/
func (o *CanvasItem) GetViewportTransform() *Transform2D {
	log.Println("Calling CanvasItem.GetViewportTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_viewport_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Get the [World2D] where this item is in.
*/
func (o *CanvasItem) GetWorld2D() *World2D {
	log.Println("Calling CanvasItem.GetWorld2D()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_world_2d", goArguments, "*World2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*World2D)

	return returnValue

}

/*
   Hide the CanvasItem currently visible.
*/
func (o *CanvasItem) Hide() {
	log.Println("Calling CanvasItem.Hide()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "hide", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether the item is drawn behind its parent.
*/
func (o *CanvasItem) IsDrawBehindParentEnabled() *bool {
	log.Println("Calling CanvasItem.IsDrawBehindParentEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_draw_behind_parent_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *CanvasItem) IsLocalTransformNotificationEnabled() *bool {
	log.Println("Calling CanvasItem.IsLocalTransformNotificationEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_local_transform_notification_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return if set as toplevel. See [method set_as_toplevel].
*/
func (o *CanvasItem) IsSetAsToplevel() *bool {
	log.Println("Calling CanvasItem.IsSetAsToplevel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_set_as_toplevel", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *CanvasItem) IsTransformNotificationEnabled() *bool {
	log.Println("Calling CanvasItem.IsTransformNotificationEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_transform_notification_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if this CanvasItem is visible. It may be invisible because itself or a parent canvas item is hidden.
*/
func (o *CanvasItem) IsVisible() *bool {
	log.Println("Calling CanvasItem.IsVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_visible", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *CanvasItem) IsVisibleInTree() *bool {
	log.Println("Calling CanvasItem.IsVisibleInTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_visible_in_tree", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *CanvasItem) MakeCanvasPosLocal(screenPoint *Vector2) *Vector2 {
	log.Println("Calling CanvasItem.MakeCanvasPosLocal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(screenPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "make_canvas_pos_local", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *CanvasItem) MakeInputLocal(event *InputEvent) *InputEvent {
	log.Println("Calling CanvasItem.MakeInputLocal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(event)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "make_input_local", goArguments, "*InputEvent")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*InputEvent)

	return returnValue

}

/*
   Set as top level. This means that it will not inherit transform from parent canvas items.
*/
func (o *CanvasItem) SetAsToplevel(enable *bool) {
	log.Println("Calling CanvasItem.SetAsToplevel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_as_toplevel", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether the canvas item is drawn behind its parent.
*/
func (o *CanvasItem) SetDrawBehindParent(enable *bool) {
	log.Println("Calling CanvasItem.SetDrawBehindParent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_draw_behind_parent", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the ligtht mask number of this item.
*/
func (o *CanvasItem) SetLightMask(lightMask int64) {
	log.Println("Calling CanvasItem.SetLightMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(lightMask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_light_mask", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the material of this item.
*/
func (o *CanvasItem) SetMaterial(material *Material) {
	log.Println("Calling CanvasItem.SetMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(material)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_material", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the modulate of the CanvasItem. This [i]affects[/i] the modulation of children items.
*/
func (o *CanvasItem) SetModulate(modulate *Color) {
	log.Println("Calling CanvasItem.SetModulate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(modulate)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_modulate", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CanvasItem) SetNotifyLocalTransform(enable *bool) {
	log.Println("Calling CanvasItem.SetNotifyLocalTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_notify_local_transform", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CanvasItem) SetNotifyTransform(enable *bool) {
	log.Println("Calling CanvasItem.SetNotifyTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_notify_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the self-modulate of the CanvasItem. This does not affect the modulation of children items.
*/
func (o *CanvasItem) SetSelfModulate(selfModulate *Color) {
	log.Println("Calling CanvasItem.SetSelfModulate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(selfModulate)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_self_modulate", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether or not this item should use its parent's material.
*/
func (o *CanvasItem) SetUseParentMaterial(enable *bool) {
	log.Println("Calling CanvasItem.SetUseParentMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_parent_material", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set whether this item should be visible or not.
				Note that a hidden CanvasItem will make all children hidden too, so no matter what is set here this item won't be shown if its parent or grandparents nodes are hidden.
*/
func (o *CanvasItem) SetVisible(visible *bool) {
	log.Println("Calling CanvasItem.SetVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(visible)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_visible", goArguments, "")

	log.Println("Got return value!")

}

/*
   Show the CanvasItem currently hidden.
*/
func (o *CanvasItem) Show() {
	log.Println("Calling CanvasItem.Show()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "show", goArguments, "")

	log.Println("Got return value!")

}

/*
   Queue the CanvasItem for update. [code]NOTIFICATION_DRAW[/code] will be called on idle time to request redraw.
*/
func (o *CanvasItem) Update() {
	log.Println("Calling CanvasItem.Update()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "update", goArguments, "")

	log.Println("Got return value!")

}

/*
        CanvasItemImplementer is an interface for CanvasItem objects.
        Base class of anything 2D. Canvas items are laid out in a tree and children inherit and extend the transform of their parent. CanvasItem is extended by [Control], for anything GUI related, and by [Node2D] for anything 2D engine related.
		Any CanvasItem can draw. For this, the "update" function must be called, then NOTIFICATION_DRAW will be received on idle time to request redraw. Because of this, canvas items don't need to be redraw on every frame, improving the performance significantly. Several functions for drawing on the CanvasItem are provided (see draw_* functions). They can only be used inside the notification, signal or _draw() overrides function, though.
		Canvas items are draw in tree order. By default, children are on top of their parents so a root CanvasItem will be drawn behind everything (this can be changed per item though).
		Canvas items can also be hidden (hiding also their subtree). They provide many means for changing standard parameters such as opacity (for it and the subtree) and self opacity, blend mode.
		Ultimately, a transform notification can be requested, which will notify the node that its global position changed in case the parent tree changed.
*/
type CanvasItemImplementer interface {
	NodeImplementer

	X_Draw()

	DrawChar(font *Font, pos *Vector2, char string, next string, modulate *Color) float64

	DrawCircle(pos *Vector2, radius float64, color *Color)

	DrawColoredPolygon(points *PoolVector2Array, color *Color, uvs *PoolVector2Array, texture *Texture, normalMap *Texture, antialiased *bool)

	DrawLine(from *Vector2, to *Vector2, color *Color, width float64, antialiased *bool)

	DrawPolygon(points *PoolVector2Array, colors *PoolColorArray, uvs *PoolVector2Array, texture *Texture, normalMap *Texture, antialiased *bool)

	DrawPolyline(points *PoolVector2Array, color *Color, width float64, antialiased *bool)

	DrawPolylineColors(points *PoolVector2Array, colors *PoolColorArray, width float64, antialiased *bool)

	DrawPrimitive(points *PoolVector2Array, colors *PoolColorArray, uvs *PoolVector2Array, texture *Texture, width float64, normalMap *Texture)

	DrawRect(rect *Rect2, color *Color, filled *bool)

	DrawSetTransform(pos *Vector2, rot float64, scale *Vector2)

	DrawSetTransformMatrix(xform *Transform2D)

	DrawString(font *Font, pos *Vector2, text string, modulate *Color, clipW int64)

	DrawStyleBox(styleBox *StyleBox, rect *Rect2)

	DrawTexture(texture *Texture, pos *Vector2, modulate *Color, normalMap *Texture)

	DrawTextureRect(texture *Texture, rect *Rect2, tile *bool, modulate *Color, transpose *bool, normalMap *Texture)

	DrawTextureRectRegion(texture *Texture, rect *Rect2, srcRect *Rect2, modulate *Color, transpose *bool, normalMap *Texture, clipUv *bool)

	EditGetState() *Variant

	EditRotate(degrees float64)

	EditSetRect(rect *Rect2)

	EditSetState(state *Variant)

	GetCanvas() *RID

	GetCanvasItem() *RID

	GetCanvasTransform() *Transform2D

	GetGlobalMousePosition() *Vector2

	GetGlobalTransform() *Transform2D

	GetGlobalTransformWithCanvas() *Transform2D

	GetItemAndChildrenRect() *Rect2

	GetItemRect() *Rect2

	GetLightMask() int64

	GetLocalMousePos() *Vector2

	GetMaterial() *Material

	GetModulate() *Color

	GetSelfModulate() *Color

	GetTransform() *Transform2D

	GetUseParentMaterial() *bool

	GetViewportRect() *Rect2

	GetViewportTransform() *Transform2D

	GetWorld2D() *World2D

	Hide()

	IsDrawBehindParentEnabled() *bool

	IsLocalTransformNotificationEnabled() *bool

	IsSetAsToplevel() *bool

	IsTransformNotificationEnabled() *bool

	IsVisible() *bool

	IsVisibleInTree() *bool

	MakeCanvasPosLocal(screenPoint *Vector2) *Vector2

	MakeInputLocal(event *InputEvent) *InputEvent

	SetAsToplevel(enable *bool)

	SetDrawBehindParent(enable *bool)

	SetLightMask(lightMask int64)

	SetMaterial(material *Material)

	SetModulate(modulate *Color)

	SetNotifyLocalTransform(enable *bool)

	SetNotifyTransform(enable *bool)

	SetSelfModulate(selfModulate *Color)

	SetUseParentMaterial(enable *bool)

	SetVisible(visible *bool)

	Show()

	Update()
}

/*

 */
type CanvasItemMaterial struct {
	Material
}

func (o *CanvasItemMaterial) baseClass() string {
	return "CanvasItemMaterial"
}

/*

 */
func (o *CanvasItemMaterial) GetBlendMode() int64 {
	log.Println("Calling CanvasItemMaterial.GetBlendMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_blend_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *CanvasItemMaterial) GetLightMode() int64 {
	log.Println("Calling CanvasItemMaterial.GetLightMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_light_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *CanvasItemMaterial) SetBlendMode(blendMode int64) {
	log.Println("Calling CanvasItemMaterial.SetBlendMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(blendMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_blend_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CanvasItemMaterial) SetLightMode(lightMode int64) {
	log.Println("Calling CanvasItemMaterial.SetLightMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(lightMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_light_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   CanvasItemMaterialImplementer is an interface for CanvasItemMaterial objects.

*/
type CanvasItemMaterialImplementer interface {
	MaterialImplementer

	GetBlendMode() int64

	GetLightMode() int64

	SetBlendMode(blendMode int64)

	SetLightMode(lightMode int64)
}

/*
   Canvas Item layer. [CanvasItem] nodes that are direct or indirect children of a [CanvasLayer] will be drawn in that layer. The layer is a numeric index that defines the draw order. The default 2D scene renders with index 0, so a [CanvasLayer] with index -1 will be drawn below, and one with index 1 will be drawn above. This is very useful for HUDs (in layer 1+ or above), or backgrounds (in layer -1 or below).
*/
type CanvasLayer struct {
	Node
}

func (o *CanvasLayer) baseClass() string {
	return "CanvasLayer"
}

/*

 */
func (o *CanvasLayer) GetCustomViewport() *Node {
	log.Println("Calling CanvasLayer.GetCustomViewport()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_custom_viewport", goArguments, "*Node")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Node)

	return returnValue

}

/*
   Return the layer index, determines the draw order, a lower value will be below a higher one.
*/
func (o *CanvasLayer) GetLayer() int64 {
	log.Println("Calling CanvasLayer.GetLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_layer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the base offset for this layer (helper).
*/
func (o *CanvasLayer) GetOffset() *Vector2 {
	log.Println("Calling CanvasLayer.GetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the base rotation for this layer in radians (helper).
*/
func (o *CanvasLayer) GetRotation() float64 {
	log.Println("Calling CanvasLayer.GetRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rotation", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the base rotation for this layer in degrees.
*/
func (o *CanvasLayer) GetRotationd() float64 {
	log.Println("Calling CanvasLayer.GetRotationd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rotationd", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the base scale for this layer (helper).
*/
func (o *CanvasLayer) GetScale() *Vector2 {
	log.Println("Calling CanvasLayer.GetScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scale", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the base transform for this layer.
*/
func (o *CanvasLayer) GetTransform() *Transform2D {
	log.Println("Calling CanvasLayer.GetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Return the [World2D] used by this layer.
*/
func (o *CanvasLayer) GetWorld2D() *World2D {
	log.Println("Calling CanvasLayer.GetWorld2D()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_world_2d", goArguments, "*World2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*World2D)

	return returnValue

}

/*

 */
func (o *CanvasLayer) SetCustomViewport(viewport *Node) {
	log.Println("Calling CanvasLayer.SetCustomViewport()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(viewport)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_custom_viewport", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the layer index, determines the draw order, a lower value will be below a higher one.
*/
func (o *CanvasLayer) SetLayer(layer int64) {
	log.Println("Calling CanvasLayer.SetLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_layer", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the base offset for this layer (helper).
*/
func (o *CanvasLayer) SetOffset(offset *Vector2) {
	log.Println("Calling CanvasLayer.SetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the base rotation for this layer in radians (helper).
*/
func (o *CanvasLayer) SetRotation(radians float64) {
	log.Println("Calling CanvasLayer.SetRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radians)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rotation", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the base rotation for this layer in degrees (helper).
*/
func (o *CanvasLayer) SetRotationd(degrees float64) {
	log.Println("Calling CanvasLayer.SetRotationd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rotationd", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the base scale for this layer (helper).
*/
func (o *CanvasLayer) SetScale(scale *Vector2) {
	log.Println("Calling CanvasLayer.SetScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the base transform for this layer.
*/
func (o *CanvasLayer) SetTransform(transform *Transform2D) {
	log.Println("Calling CanvasLayer.SetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   CanvasLayerImplementer is an interface for CanvasLayer objects.
   Canvas Item layer. [CanvasItem] nodes that are direct or indirect children of a [CanvasLayer] will be drawn in that layer. The layer is a numeric index that defines the draw order. The default 2D scene renders with index 0, so a [CanvasLayer] with index -1 will be drawn below, and one with index 1 will be drawn above. This is very useful for HUDs (in layer 1+ or above), or backgrounds (in layer -1 or below).
*/
type CanvasLayerImplementer interface {
	NodeImplementer

	GetCustomViewport() *Node

	GetLayer() int64

	GetOffset() *Vector2

	GetRotation() float64

	GetRotationd() float64

	GetScale() *Vector2

	GetTransform() *Transform2D

	GetWorld2D() *World2D

	SetCustomViewport(viewport *Node)

	SetLayer(layer int64)

	SetOffset(offset *Vector2)

	SetRotation(radians float64)

	SetRotationd(degrees float64)

	SetScale(scale *Vector2)

	SetTransform(transform *Transform2D)
}

/*
   CanvasModulate tints the canvas elements using its assigned color
*/
type CanvasModulate struct {
	Node2D
}

func (o *CanvasModulate) baseClass() string {
	return "CanvasModulate"
}

/*
   Gets the canvas tint color
*/
func (o *CanvasModulate) GetColor() *Color {
	log.Println("Calling CanvasModulate.GetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   Sets the canvas tint color
*/
func (o *CanvasModulate) SetColor(color *Color) {
	log.Println("Calling CanvasModulate.SetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_color", goArguments, "")

	log.Println("Got return value!")

}

/*
   CanvasModulateImplementer is an interface for CanvasModulate objects.
   CanvasModulate tints the canvas elements using its assigned color
*/
type CanvasModulateImplementer interface {
	Node2DImplementer

	GetColor() *Color

	SetColor(color *Color)
}

/*

 */
type CapsuleMesh struct {
	PrimitiveMesh
}

func (o *CapsuleMesh) baseClass() string {
	return "CapsuleMesh"
}

/*

 */
func (o *CapsuleMesh) GetMidHeight() float64 {
	log.Println("Calling CapsuleMesh.GetMidHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mid_height", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *CapsuleMesh) GetRadialSegments() int64 {
	log.Println("Calling CapsuleMesh.GetRadialSegments()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_radial_segments", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *CapsuleMesh) GetRadius() float64 {
	log.Println("Calling CapsuleMesh.GetRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_radius", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *CapsuleMesh) GetRings() int64 {
	log.Println("Calling CapsuleMesh.GetRings()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rings", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *CapsuleMesh) SetMidHeight(midHeight float64) {
	log.Println("Calling CapsuleMesh.SetMidHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(midHeight)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mid_height", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CapsuleMesh) SetRadialSegments(segments int64) {
	log.Println("Calling CapsuleMesh.SetRadialSegments()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(segments)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_radial_segments", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CapsuleMesh) SetRadius(radius float64) {
	log.Println("Calling CapsuleMesh.SetRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radius)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_radius", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CapsuleMesh) SetRings(rings int64) {
	log.Println("Calling CapsuleMesh.SetRings()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rings)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rings", goArguments, "")

	log.Println("Got return value!")

}

/*
   CapsuleMeshImplementer is an interface for CapsuleMesh objects.

*/
type CapsuleMeshImplementer interface {
	PrimitiveMeshImplementer

	GetMidHeight() float64

	GetRadialSegments() int64

	GetRadius() float64

	GetRings() int64

	SetMidHeight(midHeight float64)

	SetRadialSegments(segments int64)

	SetRadius(radius float64)

	SetRings(rings int64)
}

/*
   Capsule shape resource, which can be set into a [PhysicsBody] or area.
*/
type CapsuleShape struct {
	Shape
}

func (o *CapsuleShape) baseClass() string {
	return "CapsuleShape"
}

/*
   Return the capsule height.
*/
func (o *CapsuleShape) GetHeight() float64 {
	log.Println("Calling CapsuleShape.GetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_height", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the capsule radius.
*/
func (o *CapsuleShape) GetRadius() float64 {
	log.Println("Calling CapsuleShape.GetRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_radius", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the capsule height.
*/
func (o *CapsuleShape) SetHeight(height float64) {
	log.Println("Calling CapsuleShape.SetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(height)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_height", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the capsule radius.
*/
func (o *CapsuleShape) SetRadius(radius float64) {
	log.Println("Calling CapsuleShape.SetRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radius)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_radius", goArguments, "")

	log.Println("Got return value!")

}

/*
   CapsuleShapeImplementer is an interface for CapsuleShape objects.
   Capsule shape resource, which can be set into a [PhysicsBody] or area.
*/
type CapsuleShapeImplementer interface {
	ShapeImplementer

	GetHeight() float64

	GetRadius() float64

	SetHeight(height float64)

	SetRadius(radius float64)
}

/*
   Capsule 2D shape resource for physics. A capsule (or sometimes called "pill") is like a line grown in all directions. It has a radius and a height, and is often useful for modeling biped characters.
*/
type CapsuleShape2D struct {
	Shape2D
}

func (o *CapsuleShape2D) baseClass() string {
	return "CapsuleShape2D"
}

/*
   Return the height of the [CapsuleShape2D].
*/
func (o *CapsuleShape2D) GetHeight() float64 {
	log.Println("Calling CapsuleShape2D.GetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_height", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the radius of the [CapsuleShape2D].
*/
func (o *CapsuleShape2D) GetRadius() float64 {
	log.Println("Calling CapsuleShape2D.GetRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_radius", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the height of the [CapsuleShape2D].
*/
func (o *CapsuleShape2D) SetHeight(height float64) {
	log.Println("Calling CapsuleShape2D.SetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(height)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_height", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the radius of the [CapsuleShape2D].
*/
func (o *CapsuleShape2D) SetRadius(radius float64) {
	log.Println("Calling CapsuleShape2D.SetRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radius)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_radius", goArguments, "")

	log.Println("Got return value!")

}

/*
   CapsuleShape2DImplementer is an interface for CapsuleShape2D objects.
   Capsule 2D shape resource for physics. A capsule (or sometimes called "pill") is like a line grown in all directions. It has a radius and a height, and is often useful for modeling biped characters.
*/
type CapsuleShape2DImplementer interface {
	Shape2DImplementer

	GetHeight() float64

	GetRadius() float64

	SetHeight(height float64)

	SetRadius(radius float64)
}

/*
   CenterContainer Keeps children controls centered. This container keeps all children to their minimum size, in the center.
*/
type CenterContainer struct {
	Container
}

func (o *CenterContainer) baseClass() string {
	return "CenterContainer"
}

/*
   Should put children to the top left corner instead of center of the container.
*/
func (o *CenterContainer) IsUsingTopLeft() *bool {
	log.Println("Calling CenterContainer.IsUsingTopLeft()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_using_top_left", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   This function will anchor the container children to the top left corner of the the container boundaries, moving all its children to that position, (the children new center will be the top left corner of the container).
*/
func (o *CenterContainer) SetUseTopLeft(enable *bool) {
	log.Println("Calling CenterContainer.SetUseTopLeft()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_top_left", goArguments, "")

	log.Println("Got return value!")

}

/*
   CenterContainerImplementer is an interface for CenterContainer objects.
   CenterContainer Keeps children controls centered. This container keeps all children to their minimum size, in the center.
*/
type CenterContainerImplementer interface {
	ContainerImplementer

	IsUsingTopLeft() *bool

	SetUseTopLeft(enable *bool)
}

/*
   A checkbox allows the user to make a binary choice (choosing only one of two posible options), for example Answer 'yes' or 'no'.
*/
type CheckBox struct {
	Button
}

func (o *CheckBox) baseClass() string {
	return "CheckBox"
}

/*
   CheckBoxImplementer is an interface for CheckBox objects.
   A checkbox allows the user to make a binary choice (choosing only one of two posible options), for example Answer 'yes' or 'no'.
*/
type CheckBoxImplementer interface {
	ButtonImplementer
}

/*
   CheckButton is a toggle button displayed as a check field.
*/
type CheckButton struct {
	Button
}

func (o *CheckButton) baseClass() string {
	return "CheckButton"
}

/*
   CheckButtonImplementer is an interface for CheckButton objects.
   CheckButton is a toggle button displayed as a check field.
*/
type CheckButtonImplementer interface {
	ButtonImplementer
}

/*
   Circular Shape for 2D Physics. This shape is useful for modeling balls or small characters and its collision detection with everything else is very fast.
*/
type CircleShape2D struct {
	Shape2D
}

func (o *CircleShape2D) baseClass() string {
	return "CircleShape2D"
}

/*
   Return the radius of the circle shape.
*/
func (o *CircleShape2D) GetRadius() float64 {
	log.Println("Calling CircleShape2D.GetRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_radius", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the radius of the circle shape.
*/
func (o *CircleShape2D) SetRadius(radius float64) {
	log.Println("Calling CircleShape2D.SetRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radius)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_radius", goArguments, "")

	log.Println("Got return value!")

}

/*
   CircleShape2DImplementer is an interface for CircleShape2D objects.
   Circular Shape for 2D Physics. This shape is useful for modeling balls or small characters and its collision detection with everything else is very fast.
*/
type CircleShape2DImplementer interface {
	Shape2DImplementer

	GetRadius() float64

	SetRadius(radius float64)
}

/*

 */
type ClassDB struct {
	Object
}

func (o *ClassDB) baseClass() string {
	return "ClassDB"
}

/*

 */
func (o *ClassDB) CanInstance(class string) *bool {
	log.Println("Calling ClassDB.CanInstance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(class)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "can_instance", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ClassDB) ClassExists(class string) *bool {
	log.Println("Calling ClassDB.ClassExists()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(class)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "class_exists", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ClassDB) ClassGetCategory(class string) string {
	log.Println("Calling ClassDB.ClassGetCategory()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(class)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "class_get_category", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *ClassDB) ClassGetIntegerConstant(class string, name string) int64 {
	log.Println("Calling ClassDB.ClassGetIntegerConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(class)
	goArguments[1] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "class_get_integer_constant", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ClassDB) ClassGetIntegerConstantList(class string, noInheritance *bool) *PoolStringArray {
	log.Println("Calling ClassDB.ClassGetIntegerConstantList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(class)
	goArguments[1] = reflect.ValueOf(noInheritance)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "class_get_integer_constant_list", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*

 */
func (o *ClassDB) ClassGetMethodList(class string, noInheritance *bool) *Array {
	log.Println("Calling ClassDB.ClassGetMethodList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(class)
	goArguments[1] = reflect.ValueOf(noInheritance)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "class_get_method_list", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *ClassDB) ClassGetProperty(object *Object, property string) *Variant {
	log.Println("Calling ClassDB.ClassGetProperty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(property)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "class_get_property", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *ClassDB) ClassGetPropertyList(class string, noInheritance *bool) *Array {
	log.Println("Calling ClassDB.ClassGetPropertyList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(class)
	goArguments[1] = reflect.ValueOf(noInheritance)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "class_get_property_list", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *ClassDB) ClassGetSignal(class string, signal string) *Dictionary {
	log.Println("Calling ClassDB.ClassGetSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(class)
	goArguments[1] = reflect.ValueOf(signal)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "class_get_signal", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*

 */
func (o *ClassDB) ClassGetSignalList(class string, noInheritance *bool) *Array {
	log.Println("Calling ClassDB.ClassGetSignalList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(class)
	goArguments[1] = reflect.ValueOf(noInheritance)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "class_get_signal_list", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *ClassDB) ClassHasIntegerConstant(class string, name string) *bool {
	log.Println("Calling ClassDB.ClassHasIntegerConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(class)
	goArguments[1] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "class_has_integer_constant", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ClassDB) ClassHasMethod(class string, method string, noInheritance *bool) *bool {
	log.Println("Calling ClassDB.ClassHasMethod()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(class)
	goArguments[1] = reflect.ValueOf(method)
	goArguments[2] = reflect.ValueOf(noInheritance)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "class_has_method", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ClassDB) ClassHasSignal(class string, signal string) *bool {
	log.Println("Calling ClassDB.ClassHasSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(class)
	goArguments[1] = reflect.ValueOf(signal)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "class_has_signal", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ClassDB) ClassSetProperty(object *Object, property string, value *Variant) int64 {
	log.Println("Calling ClassDB.ClassSetProperty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(property)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "class_set_property", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ClassDB) GetClassList() *PoolStringArray {
	log.Println("Calling ClassDB.GetClassList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_class_list", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*

 */
func (o *ClassDB) GetInheritersFromClass(class string) *PoolStringArray {
	log.Println("Calling ClassDB.GetInheritersFromClass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(class)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_inheriters_from_class", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*

 */
func (o *ClassDB) GetParentClass(class string) string {
	log.Println("Calling ClassDB.GetParentClass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(class)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_parent_class", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *ClassDB) Instance(class string) *Variant {
	log.Println("Calling ClassDB.Instance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(class)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "instance", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *ClassDB) IsClassEnabled(class string) *bool {
	log.Println("Calling ClassDB.IsClassEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(class)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_class_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ClassDB) IsParentClass(class string, inherits string) *bool {
	log.Println("Calling ClassDB.IsParentClass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(class)
	goArguments[1] = reflect.ValueOf(inherits)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_parent_class", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   ClassDBImplementer is an interface for ClassDB objects.

*/
type ClassDBImplementer interface {
	ObjectImplementer

	CanInstance(class string) *bool

	ClassExists(class string) *bool

	ClassGetCategory(class string) string

	ClassGetIntegerConstant(class string, name string) int64

	ClassGetIntegerConstantList(class string, noInheritance *bool) *PoolStringArray

	ClassGetMethodList(class string, noInheritance *bool) *Array

	ClassGetProperty(object *Object, property string) *Variant

	ClassGetPropertyList(class string, noInheritance *bool) *Array

	ClassGetSignal(class string, signal string) *Dictionary

	ClassGetSignalList(class string, noInheritance *bool) *Array

	ClassHasIntegerConstant(class string, name string) *bool

	ClassHasMethod(class string, method string, noInheritance *bool) *bool

	ClassHasSignal(class string, signal string) *bool

	ClassSetProperty(object *Object, property string, value *Variant) int64

	GetClassList() *PoolStringArray

	GetInheritersFromClass(class string) *PoolStringArray

	GetParentClass(class string) string

	Instance(class string) *Variant

	IsClassEnabled(class string) *bool

	IsParentClass(class string, inherits string) *bool
}

/*

 */
type CollisionObject struct {
	Spatial
}

func (o *CollisionObject) baseClass() string {
	return "CollisionObject"
}

/*

 */
func (o *CollisionObject) X_InputEvent(camera *Object, event *InputEvent, clickPos *Vector3, clickNormal *Vector3, shapeIdx int64) {
	log.Println("Calling CollisionObject.X_InputEvent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(camera)
	goArguments[1] = reflect.ValueOf(event)
	goArguments[2] = reflect.ValueOf(clickPos)
	goArguments[3] = reflect.ValueOf(clickNormal)
	goArguments[4] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_input_event", goArguments, "")

	log.Println("Got return value!")

}

/*
   Creates new holder for the shapes. Argument is a [CollisionShape] node. It will return owner_id which usually you will want to save for later use.
*/
func (o *CollisionObject) CreateShapeOwner(owner *Object) int64 {
	log.Println("Calling CollisionObject.CreateShapeOwner()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(owner)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "create_shape_owner", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *CollisionObject) GetCaptureInputOnDrag() *bool {
	log.Println("Calling CollisionObject.GetCaptureInputOnDrag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_capture_input_on_drag", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *CollisionObject) GetRid() *RID {
	log.Println("Calling CollisionObject.GetRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rid", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Shape owner is a node which is holding concrete shape resources. This method will return an array which is holding an integer numbers that are representing unique ID of each owner. You can use those ids when you are using others shape_owner methods.
*/
func (o *CollisionObject) GetShapeOwners() *Array {
	log.Println("Calling CollisionObject.GetShapeOwners()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shape_owners", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *CollisionObject) IsRayPickable() *bool {
	log.Println("Calling CollisionObject.IsRayPickable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_ray_pickable", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *CollisionObject) IsShapeOwnerDisabled(ownerId int64) *bool {
	log.Println("Calling CollisionObject.IsShapeOwnerDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ownerId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_shape_owner_disabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *CollisionObject) RemoveShapeOwner(ownerId int64) {
	log.Println("Calling CollisionObject.RemoveShapeOwner()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ownerId)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_shape_owner", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionObject) SetCaptureInputOnDrag(enable *bool) {
	log.Println("Calling CollisionObject.SetCaptureInputOnDrag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_capture_input_on_drag", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionObject) SetRayPickable(rayPickable *bool) {
	log.Println("Calling CollisionObject.SetRayPickable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rayPickable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ray_pickable", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionObject) ShapeFindOwner(shapeIndex int64) int64 {
	log.Println("Calling CollisionObject.ShapeFindOwner()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shapeIndex)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_find_owner", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *CollisionObject) ShapeOwnerAddShape(ownerId int64, shape *Shape) {
	log.Println("Calling CollisionObject.ShapeOwnerAddShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ownerId)
	goArguments[1] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "shape_owner_add_shape", goArguments, "")

	log.Println("Got return value!")

}

/*
   Will remove all the shapes associated with given owner.
*/
func (o *CollisionObject) ShapeOwnerClearShapes(ownerId int64) {
	log.Println("Calling CollisionObject.ShapeOwnerClearShapes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ownerId)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "shape_owner_clear_shapes", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionObject) ShapeOwnerGetOwner(ownerId int64) *Object {
	log.Println("Calling CollisionObject.ShapeOwnerGetOwner()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ownerId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_owner_get_owner", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*
   Will return a [Shape]. First argument owner_id is an integer that can be obtained from [method get_shape_owners]. Shape_id is a position of the shape inside owner; it's a value in range from 0 to [method shape_owner_get_shape_count].
*/
func (o *CollisionObject) ShapeOwnerGetShape(ownerId int64, shapeId int64) *Shape {
	log.Println("Calling CollisionObject.ShapeOwnerGetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ownerId)
	goArguments[1] = reflect.ValueOf(shapeId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_owner_get_shape", goArguments, "*Shape")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Shape)

	return returnValue

}

/*
   Returns number of shapes to which given owner is associated to.
*/
func (o *CollisionObject) ShapeOwnerGetShapeCount(ownerId int64) int64 {
	log.Println("Calling CollisionObject.ShapeOwnerGetShapeCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ownerId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_owner_get_shape_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *CollisionObject) ShapeOwnerGetShapeIndex(ownerId int64, shapeId int64) int64 {
	log.Println("Calling CollisionObject.ShapeOwnerGetShapeIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ownerId)
	goArguments[1] = reflect.ValueOf(shapeId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_owner_get_shape_index", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Will return [Transform] of an owner node.
*/
func (o *CollisionObject) ShapeOwnerGetTransform(ownerId int64) *Transform {
	log.Println("Calling CollisionObject.ShapeOwnerGetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ownerId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_owner_get_transform", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*
   Removes related shape from the owner.
*/
func (o *CollisionObject) ShapeOwnerRemoveShape(ownerId int64, shapeId int64) {
	log.Println("Calling CollisionObject.ShapeOwnerRemoveShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ownerId)
	goArguments[1] = reflect.ValueOf(shapeId)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "shape_owner_remove_shape", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionObject) ShapeOwnerSetDisabled(ownerId int64, disabled *bool) {
	log.Println("Calling CollisionObject.ShapeOwnerSetDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ownerId)
	goArguments[1] = reflect.ValueOf(disabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "shape_owner_set_disabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionObject) ShapeOwnerSetTransform(ownerId int64, transform *Transform) {
	log.Println("Calling CollisionObject.ShapeOwnerSetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ownerId)
	goArguments[1] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "shape_owner_set_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   CollisionObjectImplementer is an interface for CollisionObject objects.

*/
type CollisionObjectImplementer interface {
	SpatialImplementer

	X_InputEvent(camera *Object, event *InputEvent, clickPos *Vector3, clickNormal *Vector3, shapeIdx int64)

	CreateShapeOwner(owner *Object) int64

	GetCaptureInputOnDrag() *bool

	GetRid() *RID

	GetShapeOwners() *Array

	IsRayPickable() *bool

	IsShapeOwnerDisabled(ownerId int64) *bool

	RemoveShapeOwner(ownerId int64)

	SetCaptureInputOnDrag(enable *bool)

	SetRayPickable(rayPickable *bool)

	ShapeFindOwner(shapeIndex int64) int64

	ShapeOwnerAddShape(ownerId int64, shape *Shape)

	ShapeOwnerClearShapes(ownerId int64)

	ShapeOwnerGetOwner(ownerId int64) *Object

	ShapeOwnerGetShape(ownerId int64, shapeId int64) *Shape

	ShapeOwnerGetShapeCount(ownerId int64) int64

	ShapeOwnerGetShapeIndex(ownerId int64, shapeId int64) int64

	ShapeOwnerGetTransform(ownerId int64) *Transform

	ShapeOwnerRemoveShape(ownerId int64, shapeId int64)

	ShapeOwnerSetDisabled(ownerId int64, disabled *bool)

	ShapeOwnerSetTransform(ownerId int64, transform *Transform)
}

/*
   CollisionObject2D is the base class for 2D physics collisionables. They can hold any number of 2D collision shapes. Usually, they are edited by placing [CollisionShape2D] and/or [CollisionPolygon2D] nodes as children. Such nodes are for reference and not present outside the editor, so code should use the regular shape API.
*/
type CollisionObject2D struct {
	Node2D
}

func (o *CollisionObject2D) baseClass() string {
	return "CollisionObject2D"
}

/*

 */
func (o *CollisionObject2D) X_InputEvent(viewport *Object, event *InputEvent, shapeIdx int64) {
	log.Println("Calling CollisionObject2D.X_InputEvent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(viewport)
	goArguments[1] = reflect.ValueOf(event)
	goArguments[2] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_input_event", goArguments, "")

	log.Println("Got return value!")

}

/*
   Creates new holder for the shapes. Argument is a [CollisionShape2D] node. It will return owner_id which usually you will want to save for later use.
*/
func (o *CollisionObject2D) CreateShapeOwner(owner *Object) int64 {
	log.Println("Calling CollisionObject2D.CreateShapeOwner()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(owner)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "create_shape_owner", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the RID of this object.
*/
func (o *CollisionObject2D) GetRid() *RID {
	log.Println("Calling CollisionObject2D.GetRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rid", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Shape owner is a node which is holding concrete shape resources. This method will return an array which is holding an integer numbers that are representing unique ID of each owner. You can use those ids when you are using others shape_owner methods.
*/
func (o *CollisionObject2D) GetShapeOwners() *Array {
	log.Println("Calling CollisionObject2D.GetShapeOwners()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shape_owners", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Return whether this object is pickable.
*/
func (o *CollisionObject2D) IsPickable() *bool {
	log.Println("Calling CollisionObject2D.IsPickable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_pickable", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *CollisionObject2D) IsShapeOwnerDisabled(ownerId int64) *bool {
	log.Println("Calling CollisionObject2D.IsShapeOwnerDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ownerId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_shape_owner_disabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *CollisionObject2D) IsShapeOwnerOneWayCollisionEnabled(ownerId int64) *bool {
	log.Println("Calling CollisionObject2D.IsShapeOwnerOneWayCollisionEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ownerId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_shape_owner_one_way_collision_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *CollisionObject2D) RemoveShapeOwner(ownerId int64) {
	log.Println("Calling CollisionObject2D.RemoveShapeOwner()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ownerId)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_shape_owner", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether this object is pickable. A pickable object can detect the mouse pointer enter/leave it and, if the mouse is inside it, report input events.
*/
func (o *CollisionObject2D) SetPickable(enabled *bool) {
	log.Println("Calling CollisionObject2D.SetPickable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pickable", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionObject2D) ShapeFindOwner(shapeIndex int64) int64 {
	log.Println("Calling CollisionObject2D.ShapeFindOwner()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shapeIndex)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_find_owner", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *CollisionObject2D) ShapeOwnerAddShape(ownerId int64, shape *Shape2D) {
	log.Println("Calling CollisionObject2D.ShapeOwnerAddShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ownerId)
	goArguments[1] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "shape_owner_add_shape", goArguments, "")

	log.Println("Got return value!")

}

/*
   Will remove all the shapes associated with given owner.
*/
func (o *CollisionObject2D) ShapeOwnerClearShapes(ownerId int64) {
	log.Println("Calling CollisionObject2D.ShapeOwnerClearShapes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ownerId)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "shape_owner_clear_shapes", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionObject2D) ShapeOwnerGetOwner(ownerId int64) *Object {
	log.Println("Calling CollisionObject2D.ShapeOwnerGetOwner()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ownerId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_owner_get_owner", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*
   Will return a [Shape2D]. First argument owner_id is an integer that can be obtained from [method get_shape_owners]. Shape_id is a position of the shape inside owner; it's a value in range from 0 to [method shape_owner_get_shape_count].
*/
func (o *CollisionObject2D) ShapeOwnerGetShape(ownerId int64, shapeId int64) *Shape2D {
	log.Println("Calling CollisionObject2D.ShapeOwnerGetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ownerId)
	goArguments[1] = reflect.ValueOf(shapeId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_owner_get_shape", goArguments, "*Shape2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Shape2D)

	return returnValue

}

/*
   Returns number of shapes to which given owner is associated to.
*/
func (o *CollisionObject2D) ShapeOwnerGetShapeCount(ownerId int64) int64 {
	log.Println("Calling CollisionObject2D.ShapeOwnerGetShapeCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ownerId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_owner_get_shape_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *CollisionObject2D) ShapeOwnerGetShapeIndex(ownerId int64, shapeId int64) int64 {
	log.Println("Calling CollisionObject2D.ShapeOwnerGetShapeIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ownerId)
	goArguments[1] = reflect.ValueOf(shapeId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_owner_get_shape_index", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Will return [Transform2D] of an owner node.
*/
func (o *CollisionObject2D) ShapeOwnerGetTransform(ownerId int64) *Transform2D {
	log.Println("Calling CollisionObject2D.ShapeOwnerGetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ownerId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_owner_get_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Removes related shape from the owner.
*/
func (o *CollisionObject2D) ShapeOwnerRemoveShape(ownerId int64, shapeId int64) {
	log.Println("Calling CollisionObject2D.ShapeOwnerRemoveShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ownerId)
	goArguments[1] = reflect.ValueOf(shapeId)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "shape_owner_remove_shape", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionObject2D) ShapeOwnerSetDisabled(ownerId int64, disabled *bool) {
	log.Println("Calling CollisionObject2D.ShapeOwnerSetDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ownerId)
	goArguments[1] = reflect.ValueOf(disabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "shape_owner_set_disabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionObject2D) ShapeOwnerSetOneWayCollision(ownerId int64, enable *bool) {
	log.Println("Calling CollisionObject2D.ShapeOwnerSetOneWayCollision()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ownerId)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "shape_owner_set_one_way_collision", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionObject2D) ShapeOwnerSetTransform(ownerId int64, transform *Transform2D) {
	log.Println("Calling CollisionObject2D.ShapeOwnerSetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ownerId)
	goArguments[1] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "shape_owner_set_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   CollisionObject2DImplementer is an interface for CollisionObject2D objects.
   CollisionObject2D is the base class for 2D physics collisionables. They can hold any number of 2D collision shapes. Usually, they are edited by placing [CollisionShape2D] and/or [CollisionPolygon2D] nodes as children. Such nodes are for reference and not present outside the editor, so code should use the regular shape API.
*/
type CollisionObject2DImplementer interface {
	Node2DImplementer

	X_InputEvent(viewport *Object, event *InputEvent, shapeIdx int64)

	CreateShapeOwner(owner *Object) int64

	GetRid() *RID

	GetShapeOwners() *Array

	IsPickable() *bool

	IsShapeOwnerDisabled(ownerId int64) *bool

	IsShapeOwnerOneWayCollisionEnabled(ownerId int64) *bool

	RemoveShapeOwner(ownerId int64)

	SetPickable(enabled *bool)

	ShapeFindOwner(shapeIndex int64) int64

	ShapeOwnerAddShape(ownerId int64, shape *Shape2D)

	ShapeOwnerClearShapes(ownerId int64)

	ShapeOwnerGetOwner(ownerId int64) *Object

	ShapeOwnerGetShape(ownerId int64, shapeId int64) *Shape2D

	ShapeOwnerGetShapeCount(ownerId int64) int64

	ShapeOwnerGetShapeIndex(ownerId int64, shapeId int64) int64

	ShapeOwnerGetTransform(ownerId int64) *Transform2D

	ShapeOwnerRemoveShape(ownerId int64, shapeId int64)

	ShapeOwnerSetDisabled(ownerId int64, disabled *bool)

	ShapeOwnerSetOneWayCollision(ownerId int64, enable *bool)

	ShapeOwnerSetTransform(ownerId int64, transform *Transform2D)
}

/*

 */
type CollisionPolygon struct {
	Spatial
}

func (o *CollisionPolygon) baseClass() string {
	return "CollisionPolygon"
}

/*

 */
func (o *CollisionPolygon) GetDepth() float64 {
	log.Println("Calling CollisionPolygon.GetDepth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_depth", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *CollisionPolygon) GetPolygon() *PoolVector2Array {
	log.Println("Calling CollisionPolygon.GetPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_polygon", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*

 */
func (o *CollisionPolygon) IsDisabled() *bool {
	log.Println("Calling CollisionPolygon.IsDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_disabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *CollisionPolygon) SetDepth(depth float64) {
	log.Println("Calling CollisionPolygon.SetDepth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(depth)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_depth", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionPolygon) SetDisabled(disabled *bool) {
	log.Println("Calling CollisionPolygon.SetDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(disabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_disabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionPolygon) SetPolygon(polygon *PoolVector2Array) {
	log.Println("Calling CollisionPolygon.SetPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(polygon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_polygon", goArguments, "")

	log.Println("Got return value!")

}

/*
   CollisionPolygonImplementer is an interface for CollisionPolygon objects.

*/
type CollisionPolygonImplementer interface {
	SpatialImplementer

	GetDepth() float64

	GetPolygon() *PoolVector2Array

	IsDisabled() *bool

	SetDepth(depth float64)

	SetDisabled(disabled *bool)

	SetPolygon(polygon *PoolVector2Array)
}

/*
   Editor-only class. This is not present when running the game. It's used in the editor to properly edit and position collision shapes in [CollisionObject2D]. This is not accessible from regular code. This class is for editing custom shape polygons.
*/
type CollisionPolygon2D struct {
	Node2D
}

func (o *CollisionPolygon2D) baseClass() string {
	return "CollisionPolygon2D"
}

/*
   Return whether the polygon is a [ConvexPolygonShape2D] ([code]build_mode==0[/code]), or a [ConcavePolygonShape2D] ([code]build_mode==1[/code]).
*/
func (o *CollisionPolygon2D) GetBuildMode() int64 {
	log.Println("Calling CollisionPolygon2D.GetBuildMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_build_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the list of points that define the polygon.
*/
func (o *CollisionPolygon2D) GetPolygon() *PoolVector2Array {
	log.Println("Calling CollisionPolygon2D.GetPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_polygon", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*

 */
func (o *CollisionPolygon2D) IsDisabled() *bool {
	log.Println("Calling CollisionPolygon2D.IsDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_disabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *CollisionPolygon2D) IsOneWayCollisionEnabled() *bool {
	log.Println("Calling CollisionPolygon2D.IsOneWayCollisionEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_one_way_collision_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Set whether the polygon is to be a [ConvexPolygonShape2D] ([code]build_mode==0[/code]), or a [ConcavePolygonShape2D] ([code]build_mode==1[/code]).
*/
func (o *CollisionPolygon2D) SetBuildMode(buildMode int64) {
	log.Println("Calling CollisionPolygon2D.SetBuildMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(buildMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_build_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionPolygon2D) SetDisabled(disabled *bool) {
	log.Println("Calling CollisionPolygon2D.SetDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(disabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_disabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionPolygon2D) SetOneWayCollision(enabled *bool) {
	log.Println("Calling CollisionPolygon2D.SetOneWayCollision()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_one_way_collision", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set the array of points forming the polygon.
				When editing the point list via the editor, depending on [method get_build_mode], it has to be a list of points (for [code]build_mode==0[/code]), or a list of lines (for [code]build_mode==1[/code]). In the second case, the even elements of the array define the start point of the line, and the odd elements the end point.
*/
func (o *CollisionPolygon2D) SetPolygon(polygon *PoolVector2Array) {
	log.Println("Calling CollisionPolygon2D.SetPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(polygon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_polygon", goArguments, "")

	log.Println("Got return value!")

}

/*
   CollisionPolygon2DImplementer is an interface for CollisionPolygon2D objects.
   Editor-only class. This is not present when running the game. It's used in the editor to properly edit and position collision shapes in [CollisionObject2D]. This is not accessible from regular code. This class is for editing custom shape polygons.
*/
type CollisionPolygon2DImplementer interface {
	Node2DImplementer

	GetBuildMode() int64

	GetPolygon() *PoolVector2Array

	IsDisabled() *bool

	IsOneWayCollisionEnabled() *bool

	SetBuildMode(buildMode int64)

	SetDisabled(disabled *bool)

	SetOneWayCollision(enabled *bool)

	SetPolygon(polygon *PoolVector2Array)
}

/*

 */
type CollisionShape struct {
	Spatial
}

func (o *CollisionShape) baseClass() string {
	return "CollisionShape"
}

/*

 */
func (o *CollisionShape) GetShape() *Shape {
	log.Println("Calling CollisionShape.GetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shape", goArguments, "*Shape")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Shape)

	return returnValue

}

/*

 */
func (o *CollisionShape) IsDisabled() *bool {
	log.Println("Calling CollisionShape.IsDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_disabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *CollisionShape) MakeConvexFromBrothers() {
	log.Println("Calling CollisionShape.MakeConvexFromBrothers()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "make_convex_from_brothers", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionShape) ResourceChanged(resource *Resource) {
	log.Println("Calling CollisionShape.ResourceChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(resource)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "resource_changed", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionShape) SetDisabled(enable *bool) {
	log.Println("Calling CollisionShape.SetDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_disabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionShape) SetShape(shape *Shape) {
	log.Println("Calling CollisionShape.SetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shape", goArguments, "")

	log.Println("Got return value!")

}

/*
   CollisionShapeImplementer is an interface for CollisionShape objects.

*/
type CollisionShapeImplementer interface {
	SpatialImplementer

	GetShape() *Shape

	IsDisabled() *bool

	MakeConvexFromBrothers()

	ResourceChanged(resource *Resource)

	SetDisabled(enable *bool)

	SetShape(shape *Shape)
}

/*
   Editor-only class. This is not present when running the game. It's used in the editor to properly edit and position collision shapes in [CollisionObject2D]. This is not accessible from regular code.
*/
type CollisionShape2D struct {
	Node2D
}

func (o *CollisionShape2D) baseClass() string {
	return "CollisionShape2D"
}

/*
   Return this shape's [Shape2D].
*/
func (o *CollisionShape2D) GetShape() *Shape2D {
	log.Println("Calling CollisionShape2D.GetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shape", goArguments, "*Shape2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Shape2D)

	return returnValue

}

/*

 */
func (o *CollisionShape2D) IsDisabled() *bool {
	log.Println("Calling CollisionShape2D.IsDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_disabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *CollisionShape2D) IsOneWayCollisionEnabled() *bool {
	log.Println("Calling CollisionShape2D.IsOneWayCollisionEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_one_way_collision_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *CollisionShape2D) SetDisabled(disabled *bool) {
	log.Println("Calling CollisionShape2D.SetDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(disabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_disabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CollisionShape2D) SetOneWayCollision(enabled *bool) {
	log.Println("Calling CollisionShape2D.SetOneWayCollision()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_one_way_collision", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set this shape's [Shape2D]. This will not appear as a node, but can be directly edited as a property.
*/
func (o *CollisionShape2D) SetShape(shape *Shape2D) {
	log.Println("Calling CollisionShape2D.SetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shape", goArguments, "")

	log.Println("Got return value!")

}

/*
   CollisionShape2DImplementer is an interface for CollisionShape2D objects.
   Editor-only class. This is not present when running the game. It's used in the editor to properly edit and position collision shapes in [CollisionObject2D]. This is not accessible from regular code.
*/
type CollisionShape2DImplementer interface {
	Node2DImplementer

	GetShape() *Shape2D

	IsDisabled() *bool

	IsOneWayCollisionEnabled() *bool

	SetDisabled(disabled *bool)

	SetOneWayCollision(enabled *bool)

	SetShape(shape *Shape2D)
}

/*
   This is a simple color picker [Control]. It's useful for selecting a color from an RGB/RGBA colorspace.
*/
type ColorPicker struct {
	BoxContainer
}

func (o *ColorPicker) baseClass() string {
	return "ColorPicker"
}

/*
   Adds the current selected to color to a list of colors (presets), the presets will be displayed in the color picker and the user will be able to select them, notice that the presets list is only for this color picker.
*/
func (o *ColorPicker) AddPreset(color *Color) {
	log.Println("Calling ColorPicker.AddPreset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_preset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Gets the current color.
*/
func (o *ColorPicker) GetPickColor() *Color {
	log.Println("Calling ColorPicker.GetPickColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pick_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   Returns whether the color has transparency or not.
*/
func (o *ColorPicker) IsEditingAlpha() *bool {
	log.Println("Calling ColorPicker.IsEditingAlpha()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_editing_alpha", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns whether this color picker is in raw mode or not, raw mode will allow the color R, G, B component values to go beyond 1, you have to consider that the max value for color components is 1, going beyond that value will not have effect in the color, but can be used for special operations that require it (like tinting without darkening or rendering sprites in HDR).
*/
func (o *ColorPicker) IsRawMode() *bool {
	log.Println("Calling ColorPicker.IsRawMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_raw_mode", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Set true if you want the color to have an alpha channel (transparency), or false if you want a solid color.
*/
func (o *ColorPicker) SetEditAlpha(show *bool) {
	log.Println("Calling ColorPicker.SetEditAlpha()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(show)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_edit_alpha", goArguments, "")

	log.Println("Got return value!")

}

/*
   Select the current color.
*/
func (o *ColorPicker) SetPickColor(color *Color) {
	log.Println("Calling ColorPicker.SetPickColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pick_color", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether this color picker is using raw mode or not, see [method is_raw_mode].
*/
func (o *ColorPicker) SetRawMode(mode *bool) {
	log.Println("Calling ColorPicker.SetRawMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_raw_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   ColorPickerImplementer is an interface for ColorPicker objects.
   This is a simple color picker [Control]. It's useful for selecting a color from an RGB/RGBA colorspace.
*/
type ColorPickerImplementer interface {
	BoxContainerImplementer

	AddPreset(color *Color)

	GetPickColor() *Color

	IsEditingAlpha() *bool

	IsRawMode() *bool

	SetEditAlpha(show *bool)

	SetPickColor(color *Color)

	SetRawMode(mode *bool)
}

/*
   Encapsulates a [ColorPicker] making it accesible by pressing a button, pressing the button will toggle the [ColorPicker] visibility
*/
type ColorPickerButton struct {
	Button
}

func (o *ColorPickerButton) baseClass() string {
	return "ColorPickerButton"
}

/*

 */
func (o *ColorPickerButton) GetPickColor() *Color {
	log.Println("Calling ColorPickerButton.GetPickColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pick_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *ColorPickerButton) GetPicker() *ColorPicker {
	log.Println("Calling ColorPickerButton.GetPicker()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_picker", goArguments, "*ColorPicker")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*ColorPicker)

	return returnValue

}

/*
   See [method ColorPicker.is_edit_alpha]
*/
func (o *ColorPickerButton) IsEditingAlpha() *bool {
	log.Println("Calling ColorPickerButton.IsEditingAlpha()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_editing_alpha", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   See [method ColorPicker.set_edit_alpha]
*/
func (o *ColorPickerButton) SetEditAlpha(show *bool) {
	log.Println("Calling ColorPickerButton.SetEditAlpha()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(show)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_edit_alpha", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ColorPickerButton) SetPickColor(color *Color) {
	log.Println("Calling ColorPickerButton.SetPickColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pick_color", goArguments, "")

	log.Println("Got return value!")

}

/*
   ColorPickerButtonImplementer is an interface for ColorPickerButton objects.
   Encapsulates a [ColorPicker] making it accesible by pressing a button, pressing the button will toggle the [ColorPicker] visibility
*/
type ColorPickerButtonImplementer interface {
	ButtonImplementer

	GetPickColor() *Color

	GetPicker() *ColorPicker

	IsEditingAlpha() *bool

	SetEditAlpha(show *bool)

	SetPickColor(color *Color)
}

/*

 */
type ColorRect struct {
	Control
}

func (o *ColorRect) baseClass() string {
	return "ColorRect"
}

/*

 */
func (o *ColorRect) GetFrameColor() *Color {
	log.Println("Calling ColorRect.GetFrameColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_frame_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *ColorRect) SetFrameColor(color *Color) {
	log.Println("Calling ColorRect.SetFrameColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_frame_color", goArguments, "")

	log.Println("Got return value!")

}

/*
   ColorRectImplementer is an interface for ColorRect objects.

*/
type ColorRectImplementer interface {
	ControlImplementer

	GetFrameColor() *Color

	SetFrameColor(color *Color)
}

/*
   Concave polygon shape resource, which can be set into a [PhysicsBody] or area. This shape is created by feeding a list of triangles.
*/
type ConcavePolygonShape struct {
	Shape
}

func (o *ConcavePolygonShape) baseClass() string {
	return "ConcavePolygonShape"
}

/*
   Return the faces (an array of triangles).
*/
func (o *ConcavePolygonShape) GetFaces() *PoolVector3Array {
	log.Println("Calling ConcavePolygonShape.GetFaces()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_faces", goArguments, "*PoolVector3Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector3Array)

	return returnValue

}

/*
   Set the faces (an array of triangles).
*/
func (o *ConcavePolygonShape) SetFaces(faces *PoolVector3Array) {
	log.Println("Calling ConcavePolygonShape.SetFaces()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(faces)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_faces", goArguments, "")

	log.Println("Got return value!")

}

/*
   ConcavePolygonShapeImplementer is an interface for ConcavePolygonShape objects.
   Concave polygon shape resource, which can be set into a [PhysicsBody] or area. This shape is created by feeding a list of triangles.
*/
type ConcavePolygonShapeImplementer interface {
	ShapeImplementer

	GetFaces() *PoolVector3Array

	SetFaces(faces *PoolVector3Array)
}

/*
        Concave polygon 2D shape resource for physics. It is made out of segments and is very optimal for complex polygonal concave collisions. It is really not advised to use for [RigidBody2D] nodes. A CollisionPolygon2D in convex decomposition mode (solids) or several convex objects are advised for that instead. Otherwise, a concave polygon 2D shape is better for static collisions.
		The main difference between a [ConvexPolygonShape2D] and a [ConcavePolygonShape2D] is that a concave polygon assumes it is concave and uses a more complex method of collision detection, and a convex one forces itself to be convex in order to speed up collision detection.
*/
type ConcavePolygonShape2D struct {
	Shape2D
}

func (o *ConcavePolygonShape2D) baseClass() string {
	return "ConcavePolygonShape2D"
}

/*
   Return the array of segments.
*/
func (o *ConcavePolygonShape2D) GetSegments() *PoolVector2Array {
	log.Println("Calling ConcavePolygonShape2D.GetSegments()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_segments", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*
   Set the array of segments.
*/
func (o *ConcavePolygonShape2D) SetSegments(segments *PoolVector2Array) {
	log.Println("Calling ConcavePolygonShape2D.SetSegments()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(segments)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_segments", goArguments, "")

	log.Println("Got return value!")

}

/*
        ConcavePolygonShape2DImplementer is an interface for ConcavePolygonShape2D objects.
        Concave polygon 2D shape resource for physics. It is made out of segments and is very optimal for complex polygonal concave collisions. It is really not advised to use for [RigidBody2D] nodes. A CollisionPolygon2D in convex decomposition mode (solids) or several convex objects are advised for that instead. Otherwise, a concave polygon 2D shape is better for static collisions.
		The main difference between a [ConvexPolygonShape2D] and a [ConcavePolygonShape2D] is that a concave polygon assumes it is concave and uses a more complex method of collision detection, and a convex one forces itself to be convex in order to speed up collision detection.
*/
type ConcavePolygonShape2DImplementer interface {
	Shape2DImplementer

	GetSegments() *PoolVector2Array

	SetSegments(segments *PoolVector2Array)
}

/*

 */
type ConeTwistJoint struct {
	Joint
}

func (o *ConeTwistJoint) baseClass() string {
	return "ConeTwistJoint"
}

/*

 */
func (o *ConeTwistJoint) GetParam(param int64) float64 {
	log.Println("Calling ConeTwistJoint.GetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ConeTwistJoint) SetParam(param int64, value float64) {
	log.Println("Calling ConeTwistJoint.SetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(param)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_param", goArguments, "")

	log.Println("Got return value!")

}

/*
   ConeTwistJointImplementer is an interface for ConeTwistJoint objects.

*/
type ConeTwistJointImplementer interface {
	JointImplementer

	GetParam(param int64) float64

	SetParam(param int64, value float64)
}

/*
        This helper class can be used to store [Variant] values on the filesystem using an INI-style formatting. The stored values as referenced by a section and a key. The stored data can be saved to or parsed from a file, though ConfigFile objects can also be used directly with accessing the filesystem.
		The following example shows how to parse a INI-style file from the system, read its contents and store new values in it:
		[codeblock]
		var config = ConfigFile.new()
		var err = config.load("user://settings.cfg")
		if err == OK: # if not, something went wrong with the file loading
		    # Look for the display/width pair, and default to 1024 if missing
		    var screen_width = get_value("display", "width", 1024)
		    # Store a variable if and only it hasn't been defined yet
		    if not config.has_section_key("audio", "mute"):
		        config.set_value("audio", "mute", false)
		    # Save the changes by overwriting the previous file
		    config.save("user://settings.cfg")
		[/codeblock]
*/
type ConfigFile struct {
	Reference
}

func (o *ConfigFile) baseClass() string {
	return "ConfigFile"
}

/*

 */
func (o *ConfigFile) EraseSection(section string) {
	log.Println("Calling ConfigFile.EraseSection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(section)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "erase_section", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return an array of all defined key identifiers in the specified section.
*/
func (o *ConfigFile) GetSectionKeys(section string) *PoolStringArray {
	log.Println("Calling ConfigFile.GetSectionKeys()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(section)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_section_keys", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   Return an array of all defined section identifiers.
*/
func (o *ConfigFile) GetSections() *PoolStringArray {
	log.Println("Calling ConfigFile.GetSections()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sections", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   Return the current value for the specified section and key. If the section and/or the key do not exist, the method returns the value of the optional [i]default[/i] argument (and thus [code]NULL[/code] if not specified).
*/
func (o *ConfigFile) GetValue(section string, key string, aDefault *Variant) *Variant {
	log.Println("Calling ConfigFile.GetValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(section)
	goArguments[1] = reflect.ValueOf(key)
	goArguments[2] = reflect.ValueOf(aDefault)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_value", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Check if the specified section exists.
*/
func (o *ConfigFile) HasSection(section string) *bool {
	log.Println("Calling ConfigFile.HasSection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(section)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_section", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Check if the specified section-key pair exists.
*/
func (o *ConfigFile) HasSectionKey(section string, key string) *bool {
	log.Println("Calling ConfigFile.HasSectionKey()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(section)
	goArguments[1] = reflect.ValueOf(key)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_section_key", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Load the config file specified as a parameter. The file's contents are parsed and loaded in the ConfigFile object from which the method was called. The return value is one of the OK, FAILED or ERR_* constants listed in [@Global Scope] (if the load was successful, it returns OK).
*/
func (o *ConfigFile) Load(path string) int64 {
	log.Println("Calling ConfigFile.Load()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "load", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
                Save the contents of the ConfigFile object to the file specified as a parameter. The output file uses an INI-style structure.
				The return value is one of the OK, FAILED or ERR_* constants listed in [@Global Scope] (if the save was successful, it returns OK).
*/
func (o *ConfigFile) Save(path string) int64 {
	log.Println("Calling ConfigFile.Save()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "save", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Assign a value to the specified key of the the specified section. If the section and/or the key do not exist, they are created. Passing a [code]NULL[/code] value deletes the specified key if it exists (and deletes the section if it ends up empty once the key has been removed).
*/
func (o *ConfigFile) SetValue(section string, key string, value *Variant) {
	log.Println("Calling ConfigFile.SetValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(section)
	goArguments[1] = reflect.ValueOf(key)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_value", goArguments, "")

	log.Println("Got return value!")

}

/*
        ConfigFileImplementer is an interface for ConfigFile objects.
        This helper class can be used to store [Variant] values on the filesystem using an INI-style formatting. The stored values as referenced by a section and a key. The stored data can be saved to or parsed from a file, though ConfigFile objects can also be used directly with accessing the filesystem.
		The following example shows how to parse a INI-style file from the system, read its contents and store new values in it:
		[codeblock]
		var config = ConfigFile.new()
		var err = config.load("user://settings.cfg")
		if err == OK: # if not, something went wrong with the file loading
		    # Look for the display/width pair, and default to 1024 if missing
		    var screen_width = get_value("display", "width", 1024)
		    # Store a variable if and only it hasn't been defined yet
		    if not config.has_section_key("audio", "mute"):
		        config.set_value("audio", "mute", false)
		    # Save the changes by overwriting the previous file
		    config.save("user://settings.cfg")
		[/codeblock]
*/
type ConfigFileImplementer interface {
	ReferenceImplementer

	EraseSection(section string)

	GetSectionKeys(section string) *PoolStringArray

	GetSections() *PoolStringArray

	GetValue(section string, key string, aDefault *Variant) *Variant

	HasSection(section string) *bool

	HasSectionKey(section string, key string) *bool

	Load(path string) int64

	Save(path string) int64

	SetValue(section string, key string, value *Variant)
}

/*
   Dialog for confirmation of actions. This dialog inherits from [AcceptDialog], but has by default an OK and Cancel button (in host OS order).
*/
type ConfirmationDialog struct {
	AcceptDialog
}

func (o *ConfirmationDialog) baseClass() string {
	return "ConfirmationDialog"
}

/*
   Return the cancel button.
*/
func (o *ConfirmationDialog) GetCancel() *Button {
	log.Println("Calling ConfirmationDialog.GetCancel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cancel", goArguments, "*Button")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Button)

	return returnValue

}

/*
   ConfirmationDialogImplementer is an interface for ConfirmationDialog objects.
   Dialog for confirmation of actions. This dialog inherits from [AcceptDialog], but has by default an OK and Cancel button (in host OS order).
*/
type ConfirmationDialogImplementer interface {
	AcceptDialogImplementer

	GetCancel() *Button
}

/*
        Base node for containers. A [Container] contains other controls and automatically arranges them in a certain way.
		A Control can inherit this to create custom container classes.
*/
type Container struct {
	Control
}

func (o *Container) baseClass() string {
	return "Container"
}

/*
   Fit a child control in a given rect. This is mainly a helper for creating custom container classes.
*/
func (o *Container) FitChildInRect(child *Control, rect *Rect2) {
	log.Println("Calling Container.FitChildInRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(child)
	goArguments[1] = reflect.ValueOf(rect)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "fit_child_in_rect", goArguments, "")

	log.Println("Got return value!")

}

/*
   Queue resort of the contained children. This is called automatically anyway, but can be called upon request.
*/
func (o *Container) QueueSort() {
	log.Println("Calling Container.QueueSort()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "queue_sort", goArguments, "")

	log.Println("Got return value!")

}

/*
        ContainerImplementer is an interface for Container objects.
        Base node for containers. A [Container] contains other controls and automatically arranges them in a certain way.
		A Control can inherit this to create custom container classes.
*/
type ContainerImplementer interface {
	ControlImplementer

	FitChildInRect(child *Control, rect *Rect2)

	QueueSort()
}

/*
        Control is the base class Node for all the GUI components. Every GUI component inherits from it, directly or indirectly. In this way, sections of the scene tree made of contiguous control nodes, become user interfaces.
		Controls are relative to the parent position and size by using anchors and margins. This ensures that they can adapt easily in most situation to changing dialog and screen sizes. When more flexibility is desired, [Container] derived nodes can be used.
		Anchors work by defining which margin do they follow, and a value relative to it. Allowed anchoring modes are ANCHOR_BEGIN, where the margin is relative to the top or left margins of the parent (in pixels), ANCHOR_END for the right and bottom margins of the parent and ANCHOR_RATIO, which is a ratio from 0 to 1 in the parent range.
		Input device events are first sent to the root controls via the [method Node._input], which distribute it through the tree, then delivers them to the adequate one (under cursor or keyboard focus based) by calling [method MainLoop._input_event]. There is no need to enable input processing on controls to receive such events. To ensure that no one else will receive the event (not even [method Node._unhandled_input]), the control can accept it by calling [method accept_event].
		Only one control can hold the keyboard focus (receiving keyboard events), for that the control must define the focus mode with [method set_focus_mode]. Focus is lost when another control gains it, or the current focus owner is hidden.
		It is sometimes desired for a control to ignore mouse/pointer events. This is often the case when placing other controls on top of a button, in such cases. Calling [method set_ignore_mouse] enables this function.
		Finally, controls are skinned according to a [Theme]. Setting a [Theme] on a control will propagate all the skinning down the tree. Optionally, skinning can be overridden per each control by calling the add_*_override functions, or from the editor.
*/
type Control struct {
	CanvasItem
}

func (o *Control) baseClass() string {
	return "Control"
}

/*
   Return the minimum size this Control can shrink to. A control will never be displayed or resized smaller than its minimum size.
*/
func (o *Control) X_GetMinimumSize() *Vector2 {
	log.Println("Calling Control.X_GetMinimumSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_minimum_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Control) X_GuiInput(event *InputEvent) {
	log.Println("Calling Control.X_GuiInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(event)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_gui_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Handles the event, no other control will receive it and it will not be sent to nodes waiting on [method Node._unhandled_input] or [method Node._unhandled_key_input].
*/
func (o *Control) AcceptEvent() {
	log.Println("Calling Control.AcceptEvent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "accept_event", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) AddColorOverride(name string, color *Color) {
	log.Println("Calling Control.AddColorOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_color_override", goArguments, "")

	log.Println("Got return value!")

}

/*
   Override a single constant (integer) in the theme of this Control. If constant equals Theme.INVALID_CONSTANT, override is cleared.
*/
func (o *Control) AddConstantOverride(name string, constant int64) {
	log.Println("Calling Control.AddConstantOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(constant)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_constant_override", goArguments, "")

	log.Println("Got return value!")

}

/*
   Override a single font (font) in the theme of this Control. If font is empty, override is cleared.
*/
func (o *Control) AddFontOverride(name string, font *Font) {
	log.Println("Calling Control.AddFontOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(font)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_font_override", goArguments, "")

	log.Println("Got return value!")

}

/*
   Override a single icon ([Texture]) in the theme of this Control. If texture is empty, override is cleared.
*/
func (o *Control) AddIconOverride(name string, texture *Texture) {
	log.Println("Calling Control.AddIconOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_icon_override", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) AddShaderOverride(name string, shader *Shader) {
	log.Println("Calling Control.AddShaderOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(shader)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_shader_override", goArguments, "")

	log.Println("Got return value!")

}

/*
   Override a single stylebox ([Stylebox]) in the theme of this Control. If stylebox is empty, override is cleared.
*/
func (o *Control) AddStyleOverride(name string, stylebox *StyleBox) {
	log.Println("Calling Control.AddStyleOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(stylebox)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_style_override", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) CanDropData(pos *Vector2, data *Variant) *bool {
	log.Println("Calling Control.CanDropData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(pos)
	goArguments[1] = reflect.ValueOf(data)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "can_drop_data", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Control) DropData(pos *Vector2, data *Variant) {
	log.Println("Calling Control.DropData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(pos)
	goArguments[1] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "drop_data", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) ForceDrag(data *Variant, preview *Control) {
	log.Println("Calling Control.ForceDrag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(data)
	goArguments[1] = reflect.ValueOf(preview)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "force_drag", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the anchor type (ANCHOR_BEGIN, ANCHOR_END, ANCHOR_RATIO) for a given margin (MARGIN_LEFT, MARGIN_TOP, MARGIN_RIGHT, MARGIN_BOTTOM).
*/
func (o *Control) GetAnchor(margin int64) float64 {
	log.Println("Calling Control.GetAnchor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_anchor", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Control) GetBegin() *Vector2 {
	log.Println("Calling Control.GetBegin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_begin", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Control) GetColor(name string, aType string) *Color {
	log.Println("Calling Control.GetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *Control) GetCombinedMinimumSize() *Vector2 {
	log.Println("Calling Control.GetCombinedMinimumSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_combined_minimum_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Control) GetConstant(name string, aType string) int64 {
	log.Println("Calling Control.GetConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_constant", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the cursor shape at a certain position in the control.
*/
func (o *Control) GetCursorShape(pos *Vector2) int64 {
	log.Println("Calling Control.GetCursorShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pos)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cursor_shape", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Control) GetCustomMinimumSize() *Vector2 {
	log.Println("Calling Control.GetCustomMinimumSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_custom_minimum_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the default cursor shape for this control. See enum CURSOR_* for the list of shapes.
*/
func (o *Control) GetDefaultCursorShape() int64 {
	log.Println("Calling Control.GetDefaultCursorShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_default_cursor_shape", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Control) GetDragData(pos *Vector2) *Object {
	log.Println("Calling Control.GetDragData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pos)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_drag_data", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*
   Returns MARGIN_LEFT and MARGIN_TOP at the same time. This is a helper (see [method set_margin]).
*/
func (o *Control) GetEnd() *Vector2 {
	log.Println("Calling Control.GetEnd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_end", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Returns the focus access mode for the control (FOCUS_NONE, FOCUS_CLICK, FOCUS_ALL) (see [method set_focus_mode]).
*/
func (o *Control) GetFocusMode() int64 {
	log.Println("Calling Control.GetFocusMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_focus_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the forced neighbour for moving the input focus to. When pressing TAB or directional/joypad directions focus is moved to the next control in that direction. However, the neighbour to move to can be forced with this function.
*/
func (o *Control) GetFocusNeighbour(margin int64) *NodePath {
	log.Println("Calling Control.GetFocusNeighbour()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_focus_neighbour", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*
   Return which control is owning the keyboard focus, or null if no one.
*/
func (o *Control) GetFocusOwner() *Control {
	log.Println("Calling Control.GetFocusOwner()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_focus_owner", goArguments, "*Control")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Control)

	return returnValue

}

/*

 */
func (o *Control) GetFont(name string, aType string) *Font {
	log.Println("Calling Control.GetFont()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_font", goArguments, "*Font")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Font)

	return returnValue

}

/*
   Returns the Control position, relative to the top-left corner of the parent Control and independent of the anchor mode.
*/
func (o *Control) GetGlobalPosition() *Vector2 {
	log.Println("Calling Control.GetGlobalPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_global_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return position and size of the Control, relative to the top-left corner of the [i]window[/i] Control. This is a helper (see [method get_global_position], [method get_size]).
*/
func (o *Control) GetGlobalRect() *Rect2 {
	log.Println("Calling Control.GetGlobalRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_global_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*

 */
func (o *Control) GetHGrowDirection() int64 {
	log.Println("Calling Control.GetHGrowDirection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_h_grow_direction", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Hint for containers, return horizontal positioning flags.
*/
func (o *Control) GetHSizeFlags() int64 {
	log.Println("Calling Control.GetHSizeFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_h_size_flags", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Control) GetIcon(name string, aType string) *Texture {
	log.Println("Calling Control.GetIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_icon", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   Return a margin offset. Margin can be one of (MARGIN_LEFT, MARGIN_TOP, MARGIN_RIGHT, MARGIN_BOTTOM). Offset value being returned depends on the anchor mode.
*/
func (o *Control) GetMargin(margin int64) float64 {
	log.Println("Calling Control.GetMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_margin", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the minimum size this Control can shrink to. A control will never be displayed or resized smaller than its minimum size.
*/
func (o *Control) GetMinimumSize() *Vector2 {
	log.Println("Calling Control.GetMinimumSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_minimum_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return when the control is ignoring mouse events (even touchpad events send mouse events).
*/
func (o *Control) GetMouseFilter() int64 {
	log.Println("Calling Control.GetMouseFilter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mouse_filter", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Control) GetParentAreaSize() *Vector2 {
	log.Println("Calling Control.GetParentAreaSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_parent_area_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Control) GetParentControl() *Control {
	log.Println("Calling Control.GetParentControl()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_parent_control", goArguments, "*Control")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Control)

	return returnValue

}

/*

 */
func (o *Control) GetPivotOffset() *Vector2 {
	log.Println("Calling Control.GetPivotOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pivot_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Returns the Control position, relative to the top-left corner of the parent Control and independent of the anchor mode.
*/
func (o *Control) GetPosition() *Vector2 {
	log.Println("Calling Control.GetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return position and size of the Control, relative to the top-left corner of the parent Control. This is a helper (see [method get_position], [method get_size]).
*/
func (o *Control) GetRect() *Rect2 {
	log.Println("Calling Control.GetRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   Return the rotation (in radians)
*/
func (o *Control) GetRotation() float64 {
	log.Println("Calling Control.GetRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rotation", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the rotation (in degrees)
*/
func (o *Control) GetRotationDeg() float64 {
	log.Println("Calling Control.GetRotationDeg()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rotation_deg", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Control) GetScale() *Vector2 {
	log.Println("Calling Control.GetScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scale", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Returns the size of the Control, computed from all margins, however the size returned will [b]never be smaller than the minimum size reported by[/b] [method get_minimum_size]. This means that even if end position of the Control rectangle is smaller than the begin position, the Control will still display and interact correctly. (see description, [method get_minimum_size], [method set_margin], [method set_anchor]).
*/
func (o *Control) GetSize() *Vector2 {
	log.Println("Calling Control.GetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Hint for containers, return the stretch ratio. This value is relative to other stretch ratio, so if this control has 2 and another has 1, this one will be twice as big.
*/
func (o *Control) GetStretchRatio() float64 {
	log.Println("Calling Control.GetStretchRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stretch_ratio", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Control) GetStylebox(name string, aType string) *StyleBox {
	log.Println("Calling Control.GetStylebox()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stylebox", goArguments, "*StyleBox")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*StyleBox)

	return returnValue

}

/*
   Return a [Theme] override, if one exists (see [method set_theme]).
*/
func (o *Control) GetTheme() *Theme {
	log.Println("Calling Control.GetTheme()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_theme", goArguments, "*Theme")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Theme)

	return returnValue

}

/*
   Return the tooltip, which will appear when the cursor is resting over this control.
*/
func (o *Control) GetTooltip(atpos *Vector2) string {
	log.Println("Calling Control.GetTooltip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(atpos)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tooltip", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *Control) GetVGrowDirection() int64 {
	log.Println("Calling Control.GetVGrowDirection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_v_grow_direction", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Hint for containers, return vertical positioning flags.
*/
func (o *Control) GetVSizeFlags() int64 {
	log.Println("Calling Control.GetVSizeFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_v_size_flags", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Control) GrabClickFocus() {
	log.Println("Calling Control.GrabClickFocus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "grab_click_focus", goArguments, "")

	log.Println("Got return value!")

}

/*
   Steal the focus from another control and become the focused control (see [method set_focus_mode]).
*/
func (o *Control) GrabFocus() {
	log.Println("Calling Control.GrabFocus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "grab_focus", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) HasColor(name string, aType string) *bool {
	log.Println("Calling Control.HasColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_color", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Control) HasColorOverride(name string) *bool {
	log.Println("Calling Control.HasColorOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_color_override", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Control) HasConstant(name string, aType string) *bool {
	log.Println("Calling Control.HasConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_constant", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Control) HasConstantOverride(name string) *bool {
	log.Println("Calling Control.HasConstantOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_constant_override", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether the Control is the current focused control (see [method set_focus_mode]).
*/
func (o *Control) HasFocus() *bool {
	log.Println("Calling Control.HasFocus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_focus", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Control) HasFont(name string, aType string) *bool {
	log.Println("Calling Control.HasFont()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_font", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Control) HasFontOverride(name string) *bool {
	log.Println("Calling Control.HasFontOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_font_override", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Control) HasIcon(name string, aType string) *bool {
	log.Println("Calling Control.HasIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_icon", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Control) HasIconOverride(name string) *bool {
	log.Println("Calling Control.HasIconOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_icon_override", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Control) HasPoint(point *Vector2) *bool {
	log.Println("Calling Control.HasPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(point)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_point", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Control) HasStylebox(name string, aType string) *bool {
	log.Println("Calling Control.HasStylebox()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_stylebox", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Control) HasStyleboxOverride(name string) *bool {
	log.Println("Calling Control.HasStyleboxOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_stylebox_override", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Control) IsClippingContents() *bool {
	log.Println("Calling Control.IsClippingContents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_clipping_contents", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Control) MinimumSizeChanged() {
	log.Println("Calling Control.MinimumSizeChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "minimum_size_changed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Give up the focus, no other control will be able to receive keyboard input.
*/
func (o *Control) ReleaseFocus() {
	log.Println("Calling Control.ReleaseFocus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "release_focus", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) SetAnchor(margin int64, anchor float64, keepMargin *bool, pushOppositeAnchor *bool) {
	log.Println("Calling Control.SetAnchor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(anchor)
	goArguments[2] = reflect.ValueOf(keepMargin)
	goArguments[3] = reflect.ValueOf(pushOppositeAnchor)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_anchor", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) SetAnchorAndMargin(margin int64, anchor float64, offset float64, pushOppositeAnchor *bool) {
	log.Println("Calling Control.SetAnchorAndMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(anchor)
	goArguments[2] = reflect.ValueOf(offset)
	goArguments[3] = reflect.ValueOf(pushOppositeAnchor)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_anchor_and_margin", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) SetAnchorsPreset(preset int64, keepMargin *bool) {
	log.Println("Calling Control.SetAnchorsPreset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(preset)
	goArguments[1] = reflect.ValueOf(keepMargin)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_anchors_preset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Change all margins and anchors, so this Control always takes up the same area as the parent Control. This is a helper (see [method set_anchor], [method set_margin]).
*/
func (o *Control) SetAreaAsParentRect(margin int64) {
	log.Println("Calling Control.SetAreaAsParentRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_area_as_parent_rect", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets MARGIN_LEFT and MARGIN_TOP at the same time. This is a helper (see [method set_margin]).
*/
func (o *Control) SetBegin(pos *Vector2) {
	log.Println("Calling Control.SetBegin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_begin", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) SetClipContents(enable *bool) {
	log.Println("Calling Control.SetClipContents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_clip_contents", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) SetCustomMinimumSize(size *Vector2) {
	log.Println("Calling Control.SetCustomMinimumSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_custom_minimum_size", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the default cursor shape for this control. See enum CURSOR_* for the list of shapes.
*/
func (o *Control) SetDefaultCursorShape(shape int64) {
	log.Println("Calling Control.SetDefaultCursorShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_default_cursor_shape", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) SetDragForwarding(target *Control) {
	log.Println("Calling Control.SetDragForwarding()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(target)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_drag_forwarding", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) SetDragPreview(control *Control) {
	log.Println("Calling Control.SetDragPreview()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(control)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_drag_preview", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets MARGIN_RIGHT and MARGIN_BOTTOM at the same time. This is a helper (see [method set_margin]).
*/
func (o *Control) SetEnd(pos *Vector2) {
	log.Println("Calling Control.SetEnd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_end", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the focus access mode for the control (FOCUS_NONE, FOCUS_CLICK, FOCUS_ALL). Only one Control can be focused at the same time, and it will receive keyboard signals.
*/
func (o *Control) SetFocusMode(mode int64) {
	log.Println("Calling Control.SetFocusMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_focus_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Force a neighbour for moving the input focus to. When pressing TAB or directional/joypad directions focus is moved to the next control in that direction. However, the neighbour to move to can be forced with this function.
*/
func (o *Control) SetFocusNeighbour(margin int64, neighbour *NodePath) {
	log.Println("Calling Control.SetFocusNeighbour()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(neighbour)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_focus_neighbour", goArguments, "")

	log.Println("Got return value!")

}

/*
   Move the Control to a new position, relative to the top-left corner of the [i]window[/i] Control, and without changing current anchor mode. (see [method set_margin]).
*/
func (o *Control) SetGlobalPosition(pos *Vector2) {
	log.Println("Calling Control.SetGlobalPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_global_position", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) SetHGrowDirection(direction int64) {
	log.Println("Calling Control.SetHGrowDirection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(direction)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_h_grow_direction", goArguments, "")

	log.Println("Got return value!")

}

/*
   Hint for containers, set horizontal positioning flags.
*/
func (o *Control) SetHSizeFlags(flags int64) {
	log.Println("Calling Control.SetHSizeFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flags)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_h_size_flags", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set a margin offset. Margin can be one of (MARGIN_LEFT, MARGIN_TOP, MARGIN_RIGHT, MARGIN_BOTTOM). Offset value being set depends on the anchor mode.
*/
func (o *Control) SetMargin(margin int64, offset float64) {
	log.Println("Calling Control.SetMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_margin", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set when the control is ignoring mouse events (even touchpad events send mouse events). (see the MOUSE_FILTER_* constants)
*/
func (o *Control) SetMouseFilter(filter int64) {
	log.Println("Calling Control.SetMouseFilter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(filter)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mouse_filter", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) SetPivotOffset(pivotOffset *Vector2) {
	log.Println("Calling Control.SetPivotOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pivotOffset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pivot_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Move the Control to a new position, relative to the top-left corner of the parent Control, changing all margins if needed and without changing current anchor mode. This is a helper (see [method set_margin]).
*/
func (o *Control) SetPosition(pos *Vector2) {
	log.Println("Calling Control.SetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_position", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the rotation (in radians).
*/
func (o *Control) SetRotation(radians float64) {
	log.Println("Calling Control.SetRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radians)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rotation", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the rotation (in degrees).
*/
func (o *Control) SetRotationDeg(degrees float64) {
	log.Println("Calling Control.SetRotationDeg()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rotation_deg", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) SetScale(scale *Vector2) {
	log.Println("Calling Control.SetScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Changes MARGIN_RIGHT and MARGIN_BOTTOM to fit a given size. This is a helper (see [method set_margin]).
*/
func (o *Control) SetSize(size *Vector2) {
	log.Println("Calling Control.SetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_size", goArguments, "")

	log.Println("Got return value!")

}

/*
   Hint for containers, set the stretch ratio. This value is relative to other stretch ratio, so if this control has 2 and another has 1, this one will be twice as big.
*/
func (o *Control) SetStretchRatio(ratio float64) {
	log.Println("Calling Control.SetStretchRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ratio)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_stretch_ratio", goArguments, "")

	log.Println("Got return value!")

}

/*
   Override whole the [Theme] for this Control and all its children controls.
*/
func (o *Control) SetTheme(theme *Theme) {
	log.Println("Calling Control.SetTheme()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(theme)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_theme", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set a tooltip, which will appear when the cursor is resting over this control.
*/
func (o *Control) SetTooltip(tooltip string) {
	log.Println("Calling Control.SetTooltip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tooltip)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tooltip", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) SetVGrowDirection(direction int64) {
	log.Println("Calling Control.SetVGrowDirection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(direction)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_v_grow_direction", goArguments, "")

	log.Println("Got return value!")

}

/*
   Hint for containers, set vertical positioning flags.
*/
func (o *Control) SetVSizeFlags(flags int64) {
	log.Println("Calling Control.SetVSizeFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flags)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_v_size_flags", goArguments, "")

	log.Println("Got return value!")

}

/*
   Display a Control as modal. Control must be a subwindow. Modal controls capture the input signals until closed or the area outside them is accessed. When a modal control loses focus, or the ESC key is pressed, they automatically hide. Modal controls are used extensively for popup dialogs and menus.
*/
func (o *Control) ShowModal(exclusive *bool) {
	log.Println("Calling Control.ShowModal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(exclusive)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "show_modal", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Control) WarpMouse(toPos *Vector2) {
	log.Println("Calling Control.WarpMouse()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(toPos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "warp_mouse", goArguments, "")

	log.Println("Got return value!")

}

/*
        ControlImplementer is an interface for Control objects.
        Control is the base class Node for all the GUI components. Every GUI component inherits from it, directly or indirectly. In this way, sections of the scene tree made of contiguous control nodes, become user interfaces.
		Controls are relative to the parent position and size by using anchors and margins. This ensures that they can adapt easily in most situation to changing dialog and screen sizes. When more flexibility is desired, [Container] derived nodes can be used.
		Anchors work by defining which margin do they follow, and a value relative to it. Allowed anchoring modes are ANCHOR_BEGIN, where the margin is relative to the top or left margins of the parent (in pixels), ANCHOR_END for the right and bottom margins of the parent and ANCHOR_RATIO, which is a ratio from 0 to 1 in the parent range.
		Input device events are first sent to the root controls via the [method Node._input], which distribute it through the tree, then delivers them to the adequate one (under cursor or keyboard focus based) by calling [method MainLoop._input_event]. There is no need to enable input processing on controls to receive such events. To ensure that no one else will receive the event (not even [method Node._unhandled_input]), the control can accept it by calling [method accept_event].
		Only one control can hold the keyboard focus (receiving keyboard events), for that the control must define the focus mode with [method set_focus_mode]. Focus is lost when another control gains it, or the current focus owner is hidden.
		It is sometimes desired for a control to ignore mouse/pointer events. This is often the case when placing other controls on top of a button, in such cases. Calling [method set_ignore_mouse] enables this function.
		Finally, controls are skinned according to a [Theme]. Setting a [Theme] on a control will propagate all the skinning down the tree. Optionally, skinning can be overridden per each control by calling the add_*_override functions, or from the editor.
*/
type ControlImplementer interface {
	CanvasItemImplementer

	X_GetMinimumSize() *Vector2

	X_GuiInput(event *InputEvent)

	AcceptEvent()

	AddColorOverride(name string, color *Color)

	AddConstantOverride(name string, constant int64)

	AddFontOverride(name string, font *Font)

	AddIconOverride(name string, texture *Texture)

	AddShaderOverride(name string, shader *Shader)

	AddStyleOverride(name string, stylebox *StyleBox)

	CanDropData(pos *Vector2, data *Variant) *bool

	DropData(pos *Vector2, data *Variant)

	ForceDrag(data *Variant, preview *Control)

	GetAnchor(margin int64) float64

	GetBegin() *Vector2

	GetColor(name string, aType string) *Color

	GetCombinedMinimumSize() *Vector2

	GetConstant(name string, aType string) int64

	GetCursorShape(pos *Vector2) int64

	GetCustomMinimumSize() *Vector2

	GetDefaultCursorShape() int64

	GetDragData(pos *Vector2) *Object

	GetEnd() *Vector2

	GetFocusMode() int64

	GetFocusNeighbour(margin int64) *NodePath

	GetFocusOwner() *Control

	GetFont(name string, aType string) *Font

	GetGlobalPosition() *Vector2

	GetGlobalRect() *Rect2

	GetHGrowDirection() int64

	GetHSizeFlags() int64

	GetIcon(name string, aType string) *Texture

	GetMargin(margin int64) float64

	GetMinimumSize() *Vector2

	GetMouseFilter() int64

	GetParentAreaSize() *Vector2

	GetParentControl() *Control

	GetPivotOffset() *Vector2

	GetPosition() *Vector2

	GetRect() *Rect2

	GetRotation() float64

	GetRotationDeg() float64

	GetScale() *Vector2

	GetSize() *Vector2

	GetStretchRatio() float64

	GetStylebox(name string, aType string) *StyleBox

	GetTheme() *Theme

	GetTooltip(atpos *Vector2) string

	GetVGrowDirection() int64

	GetVSizeFlags() int64

	GrabClickFocus()

	GrabFocus()

	HasColor(name string, aType string) *bool

	HasColorOverride(name string) *bool

	HasConstant(name string, aType string) *bool

	HasConstantOverride(name string) *bool

	HasFocus() *bool

	HasFont(name string, aType string) *bool

	HasFontOverride(name string) *bool

	HasIcon(name string, aType string) *bool

	HasIconOverride(name string) *bool

	HasPoint(point *Vector2) *bool

	HasStylebox(name string, aType string) *bool

	HasStyleboxOverride(name string) *bool

	IsClippingContents() *bool

	MinimumSizeChanged()

	ReleaseFocus()

	SetAnchor(margin int64, anchor float64, keepMargin *bool, pushOppositeAnchor *bool)

	SetAnchorAndMargin(margin int64, anchor float64, offset float64, pushOppositeAnchor *bool)

	SetAnchorsPreset(preset int64, keepMargin *bool)

	SetAreaAsParentRect(margin int64)

	SetBegin(pos *Vector2)

	SetClipContents(enable *bool)

	SetCustomMinimumSize(size *Vector2)

	SetDefaultCursorShape(shape int64)

	SetDragForwarding(target *Control)

	SetDragPreview(control *Control)

	SetEnd(pos *Vector2)

	SetFocusMode(mode int64)

	SetFocusNeighbour(margin int64, neighbour *NodePath)

	SetGlobalPosition(pos *Vector2)

	SetHGrowDirection(direction int64)

	SetHSizeFlags(flags int64)

	SetMargin(margin int64, offset float64)

	SetMouseFilter(filter int64)

	SetPivotOffset(pivotOffset *Vector2)

	SetPosition(pos *Vector2)

	SetRotation(radians float64)

	SetRotationDeg(degrees float64)

	SetScale(scale *Vector2)

	SetSize(size *Vector2)

	SetStretchRatio(ratio float64)

	SetTheme(theme *Theme)

	SetTooltip(tooltip string)

	SetVGrowDirection(direction int64)

	SetVSizeFlags(flags int64)

	ShowModal(exclusive *bool)

	WarpMouse(toPos *Vector2)
}

/*
   Convex polygon shape resource, which can be set into a [PhysicsBody] or area.
*/
type ConvexPolygonShape struct {
	Shape
}

func (o *ConvexPolygonShape) baseClass() string {
	return "ConvexPolygonShape"
}

/*

 */
func (o *ConvexPolygonShape) GetPoints() *PoolVector3Array {
	log.Println("Calling ConvexPolygonShape.GetPoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_points", goArguments, "*PoolVector3Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector3Array)

	return returnValue

}

/*

 */
func (o *ConvexPolygonShape) SetPoints(points *PoolVector3Array) {
	log.Println("Calling ConvexPolygonShape.SetPoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(points)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_points", goArguments, "")

	log.Println("Got return value!")

}

/*
   ConvexPolygonShapeImplementer is an interface for ConvexPolygonShape objects.
   Convex polygon shape resource, which can be set into a [PhysicsBody] or area.
*/
type ConvexPolygonShapeImplementer interface {
	ShapeImplementer

	GetPoints() *PoolVector3Array

	SetPoints(points *PoolVector3Array)
}

/*
        Convex Polygon Shape for 2D physics. A convex polygon, whatever its shape, is internally decomposed into as many convex polygons as needed to ensure all collision checks against it are always done on convex polygons (which are faster to check).
		The main difference between a [ConvexPolygonShape2D] and a [ConcavePolygonShape2D] is that a concave polygon assumes it is concave and uses a more complex method of collision detection, and a convex one forces itself to be convex in order to speed up collision detection.
*/
type ConvexPolygonShape2D struct {
	Shape2D
}

func (o *ConvexPolygonShape2D) baseClass() string {
	return "ConvexPolygonShape2D"
}

/*
   Return a list of points in either clockwise or counter clockwise order, forming a convex polygon.
*/
func (o *ConvexPolygonShape2D) GetPoints() *PoolVector2Array {
	log.Println("Calling ConvexPolygonShape2D.GetPoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_points", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*
   Currently, this method does nothing.
*/
func (o *ConvexPolygonShape2D) SetPointCloud(pointCloud *PoolVector2Array) {
	log.Println("Calling ConvexPolygonShape2D.SetPointCloud()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pointCloud)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_cloud", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set a list of points in either clockwise or counter clockwise order, forming a convex polygon.
*/
func (o *ConvexPolygonShape2D) SetPoints(points *PoolVector2Array) {
	log.Println("Calling ConvexPolygonShape2D.SetPoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(points)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_points", goArguments, "")

	log.Println("Got return value!")

}

/*
        ConvexPolygonShape2DImplementer is an interface for ConvexPolygonShape2D objects.
        Convex Polygon Shape for 2D physics. A convex polygon, whatever its shape, is internally decomposed into as many convex polygons as needed to ensure all collision checks against it are always done on convex polygons (which are faster to check).
		The main difference between a [ConvexPolygonShape2D] and a [ConcavePolygonShape2D] is that a concave polygon assumes it is concave and uses a more complex method of collision detection, and a convex one forces itself to be convex in order to speed up collision detection.
*/
type ConvexPolygonShape2DImplementer interface {
	Shape2DImplementer

	GetPoints() *PoolVector2Array

	SetPointCloud(pointCloud *PoolVector2Array)

	SetPoints(points *PoolVector2Array)
}

/*

 */
type CubeMap struct {
	Resource
}

func (o *CubeMap) baseClass() string {
	return "CubeMap"
}

/*

 */
func (o *CubeMap) GetFlags() int64 {
	log.Println("Calling CubeMap.GetFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_flags", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *CubeMap) GetHeight() int64 {
	log.Println("Calling CubeMap.GetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_height", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *CubeMap) GetLossyStorageQuality() float64 {
	log.Println("Calling CubeMap.GetLossyStorageQuality()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_lossy_storage_quality", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *CubeMap) GetSide(side int64) *Image {
	log.Println("Calling CubeMap.GetSide()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(side)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_side", goArguments, "*Image")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Image)

	return returnValue

}

/*

 */
func (o *CubeMap) GetStorage() int64 {
	log.Println("Calling CubeMap.GetStorage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_storage", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *CubeMap) GetWidth() int64 {
	log.Println("Calling CubeMap.GetWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_width", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *CubeMap) SetFlags(flags int64) {
	log.Println("Calling CubeMap.SetFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flags)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flags", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CubeMap) SetLossyStorageQuality(quality float64) {
	log.Println("Calling CubeMap.SetLossyStorageQuality()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(quality)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_lossy_storage_quality", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CubeMap) SetSide(side int64, image *Image) {
	log.Println("Calling CubeMap.SetSide()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(side)
	goArguments[1] = reflect.ValueOf(image)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_side", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CubeMap) SetStorage(mode int64) {
	log.Println("Calling CubeMap.SetStorage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_storage", goArguments, "")

	log.Println("Got return value!")

}

/*
   CubeMapImplementer is an interface for CubeMap objects.

*/
type CubeMapImplementer interface {
	ResourceImplementer

	GetFlags() int64

	GetHeight() int64

	GetLossyStorageQuality() float64

	GetSide(side int64) *Image

	GetStorage() int64

	GetWidth() int64

	SetFlags(flags int64)

	SetLossyStorageQuality(quality float64)

	SetSide(side int64, image *Image)

	SetStorage(mode int64)
}

/*

 */
type CubeMesh struct {
	PrimitiveMesh
}

func (o *CubeMesh) baseClass() string {
	return "CubeMesh"
}

/*

 */
func (o *CubeMesh) GetSize() *Vector3 {
	log.Println("Calling CubeMesh.GetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_size", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *CubeMesh) GetSubdivideDepth() int64 {
	log.Println("Calling CubeMesh.GetSubdivideDepth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_subdivide_depth", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *CubeMesh) GetSubdivideHeight() int64 {
	log.Println("Calling CubeMesh.GetSubdivideHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_subdivide_height", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *CubeMesh) GetSubdivideWidth() int64 {
	log.Println("Calling CubeMesh.GetSubdivideWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_subdivide_width", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *CubeMesh) SetSize(size *Vector3) {
	log.Println("Calling CubeMesh.SetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CubeMesh) SetSubdivideDepth(divisions int64) {
	log.Println("Calling CubeMesh.SetSubdivideDepth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(divisions)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_subdivide_depth", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CubeMesh) SetSubdivideHeight(divisions int64) {
	log.Println("Calling CubeMesh.SetSubdivideHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(divisions)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_subdivide_height", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CubeMesh) SetSubdivideWidth(subdivide int64) {
	log.Println("Calling CubeMesh.SetSubdivideWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(subdivide)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_subdivide_width", goArguments, "")

	log.Println("Got return value!")

}

/*
   CubeMeshImplementer is an interface for CubeMesh objects.

*/
type CubeMeshImplementer interface {
	PrimitiveMeshImplementer

	GetSize() *Vector3

	GetSubdivideDepth() int64

	GetSubdivideHeight() int64

	GetSubdivideWidth() int64

	SetSize(size *Vector3)

	SetSubdivideDepth(divisions int64)

	SetSubdivideHeight(divisions int64)

	SetSubdivideWidth(subdivide int64)
}

/*

 */
type Curve struct {
	Resource
}

func (o *Curve) baseClass() string {
	return "Curve"
}

/*

 */
func (o *Curve) AddPoint(pos *Vector2, leftTangent float64, rightTangent float64, leftMode int64, rightMode int64) int64 {
	log.Println("Calling Curve.AddPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(pos)
	goArguments[1] = reflect.ValueOf(leftTangent)
	goArguments[2] = reflect.ValueOf(rightTangent)
	goArguments[3] = reflect.ValueOf(leftMode)
	goArguments[4] = reflect.ValueOf(rightMode)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "add_point", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Curve) Bake() {
	log.Println("Calling Curve.Bake()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "bake", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Curve) CleanDupes() {
	log.Println("Calling Curve.CleanDupes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clean_dupes", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Curve) ClearPoints() {
	log.Println("Calling Curve.ClearPoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_points", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Curve) GetBakeResolution() int64 {
	log.Println("Calling Curve.GetBakeResolution()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bake_resolution", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Curve) GetMaxValue() float64 {
	log.Println("Calling Curve.GetMaxValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_max_value", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Curve) GetMinValue() float64 {
	log.Println("Calling Curve.GetMinValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_min_value", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Curve) GetPointLeftMode(index int64) int64 {
	log.Println("Calling Curve.GetPointLeftMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_left_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Curve) GetPointLeftTangent(index int64) float64 {
	log.Println("Calling Curve.GetPointLeftTangent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_left_tangent", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Curve) GetPointPos(index int64) *Vector2 {
	log.Println("Calling Curve.GetPointPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_pos", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Curve) GetPointRightMode(index int64) int64 {
	log.Println("Calling Curve.GetPointRightMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_right_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Curve) GetPointRightTangent(index int64) float64 {
	log.Println("Calling Curve.GetPointRightTangent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_right_tangent", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Curve) Interpolate(offset float64) float64 {
	log.Println("Calling Curve.Interpolate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "interpolate", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Curve) InterpolateBaked(offset float64) float64 {
	log.Println("Calling Curve.InterpolateBaked()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "interpolate_baked", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Curve) RemovePoint(index int64) {
	log.Println("Calling Curve.RemovePoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_point", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Curve) SetBakeResolution(resolution int64) {
	log.Println("Calling Curve.SetBakeResolution()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(resolution)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bake_resolution", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Curve) SetMaxValue(max float64) {
	log.Println("Calling Curve.SetMaxValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(max)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max_value", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Curve) SetMinValue(min float64) {
	log.Println("Calling Curve.SetMinValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(min)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_min_value", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Curve) SetPointLeftMode(index int64, mode int64) {
	log.Println("Calling Curve.SetPointLeftMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(index)
	goArguments[1] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_left_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Curve) SetPointLeftTangent(index int64, tangent float64) {
	log.Println("Calling Curve.SetPointLeftTangent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(index)
	goArguments[1] = reflect.ValueOf(tangent)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_left_tangent", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Curve) SetPointOffset(index int64, offset float64) {
	log.Println("Calling Curve.SetPointOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(index)
	goArguments[1] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_offset", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Curve) SetPointRightMode(index int64, mode int64) {
	log.Println("Calling Curve.SetPointRightMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(index)
	goArguments[1] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_right_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Curve) SetPointRightTangent(index int64, tangent float64) {
	log.Println("Calling Curve.SetPointRightTangent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(index)
	goArguments[1] = reflect.ValueOf(tangent)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_right_tangent", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Curve) SetPointValue(index int64, y float64) {
	log.Println("Calling Curve.SetPointValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(index)
	goArguments[1] = reflect.ValueOf(y)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_value", goArguments, "")

	log.Println("Got return value!")

}

/*
   CurveImplementer is an interface for Curve objects.

*/
type CurveImplementer interface {
	ResourceImplementer

	AddPoint(pos *Vector2, leftTangent float64, rightTangent float64, leftMode int64, rightMode int64) int64

	Bake()

	CleanDupes()

	ClearPoints()

	GetBakeResolution() int64

	GetMaxValue() float64

	GetMinValue() float64

	GetPointLeftMode(index int64) int64

	GetPointLeftTangent(index int64) float64

	GetPointPos(index int64) *Vector2

	GetPointRightMode(index int64) int64

	GetPointRightTangent(index int64) float64

	Interpolate(offset float64) float64

	InterpolateBaked(offset float64) float64

	RemovePoint(index int64)

	SetBakeResolution(resolution int64)

	SetMaxValue(max float64)

	SetMinValue(min float64)

	SetPointLeftMode(index int64, mode int64)

	SetPointLeftTangent(index int64, tangent float64)

	SetPointOffset(index int64, offset float64)

	SetPointRightMode(index int64, mode int64)

	SetPointRightTangent(index int64, tangent float64)

	SetPointValue(index int64, y float64)
}

/*
        This class describes a Bezier curve in 2D space. It is mainly used to give a shape to a [Path2D], but can be manually sampled for other purposes.
		It keeps a cache of precalculated points along the curve, to speed further calculations up.
*/
type Curve2D struct {
	Resource
}

func (o *Curve2D) baseClass() string {
	return "Curve2D"
}

/*
                Adds a point to a curve, at position "pos", with control points "in" and "out".
				If "atpos" is given, the point is inserted before the point number "atpos", moving that point (and every point after) after the inserted point. If "atpos" is not given, or is an illegal value (atpos <0 or atpos >= [method get_point_count]), the point will be appended at the end of the point list.
*/
func (o *Curve2D) AddPoint(pos *Vector2, in *Vector2, out *Vector2, atpos int64) {
	log.Println("Calling Curve2D.AddPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(pos)
	goArguments[1] = reflect.ValueOf(in)
	goArguments[2] = reflect.ValueOf(out)
	goArguments[3] = reflect.ValueOf(atpos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_point", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Curve2D) ClearPoints() {
	log.Println("Calling Curve2D.ClearPoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_points", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the distance between two adjacent cached points.
*/
func (o *Curve2D) GetBakeInterval() float64 {
	log.Println("Calling Curve2D.GetBakeInterval()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bake_interval", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns the total length of the curve, based on the cached points. Given enough density (see [method set_bake_interval]), it should be approximate enough.
*/
func (o *Curve2D) GetBakedLength() float64 {
	log.Println("Calling Curve2D.GetBakedLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_baked_length", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns the cache of points as a [PoolVector2Array].
*/
func (o *Curve2D) GetBakedPoints() *PoolVector2Array {
	log.Println("Calling Curve2D.GetBakedPoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_baked_points", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*
   Returns the number of points describing the curve.
*/
func (o *Curve2D) GetPointCount() int64 {
	log.Println("Calling Curve2D.GetPointCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the position of the control point leading to the vertex "idx". If the index is out of bounds, the function sends an error to the console, and returns (0, 0).
*/
func (o *Curve2D) GetPointIn(idx int64) *Vector2 {
	log.Println("Calling Curve2D.GetPointIn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_in", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Returns the position of the control point leading out of the vertex "idx". If the index is out of bounds, the function sends an error to the console, and returns (0, 0).
*/
func (o *Curve2D) GetPointOut(idx int64) *Vector2 {
	log.Println("Calling Curve2D.GetPointOut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_out", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Returns the position of the vertex "idx". If the index is out of bounds, the function sends an error to the console, and returns (0, 0).
*/
func (o *Curve2D) GetPointPos(idx int64) *Vector2 {
	log.Println("Calling Curve2D.GetPointPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_pos", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
                Returns the position between the vertex "idx" and the vertex "idx"+1, where "t" controls if the point is the first vertex (t = 0.0), the last vertex (t = 1.0), or in between. Values of "t" outside the range (0.0 >= t  <=1) give strange, but predictable results.
				If "idx" is out of bounds it is truncated to the first or last vertex, and "t" is ignored. If the curve has no points, the function sends an error to the console, and returns (0, 0).
*/
func (o *Curve2D) Interpolate(idx int64, t float64) *Vector2 {
	log.Println("Calling Curve2D.Interpolate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(t)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "interpolate", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
                Returns a point within the curve at position "offset", where "offset" is measured as a pixel distance along the curve.
				To do that, it finds the two cached points where the "offset" lies between, then interpolates the values. This interpolation is cubic if "cubic" is set to true, or linear if set to false.
				Cubic interpolation tends to follow the curves better, but linear is faster (and often, precise enough).
*/
func (o *Curve2D) InterpolateBaked(offset float64, cubic *bool) *Vector2 {
	log.Println("Calling Curve2D.InterpolateBaked()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(offset)
	goArguments[1] = reflect.ValueOf(cubic)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "interpolate_baked", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Returns the position at the vertex "fofs". It calls [method interpolate] using the integer part of fofs as "idx", and its fractional part as "t".
*/
func (o *Curve2D) Interpolatef(fofs float64) *Vector2 {
	log.Println("Calling Curve2D.Interpolatef()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(fofs)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "interpolatef", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Deletes the point "idx" from the curve. Sends an error to the console if "idx" is out of bounds.
*/
func (o *Curve2D) RemovePoint(idx int64) {
	log.Println("Calling Curve2D.RemovePoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_point", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the distance in pixels between two adjacent cached points. Changing it forces the cache to be recomputed the next time a xxx_baked_xxx function is called. The less distance, the more points the cache will have, and the more memory it will consume, so use with care.
*/
func (o *Curve2D) SetBakeInterval(distance float64) {
	log.Println("Calling Curve2D.SetBakeInterval()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(distance)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bake_interval", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the position of the control point leading to the vertex "idx". If the index is out of bounds, the function sends an error to the console.
*/
func (o *Curve2D) SetPointIn(idx int64, pos *Vector2) {
	log.Println("Calling Curve2D.SetPointIn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(pos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_in", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the position of the control point leading out of the vertex "idx". If the index is out of bounds, the function sends an error to the console.
*/
func (o *Curve2D) SetPointOut(idx int64, pos *Vector2) {
	log.Println("Calling Curve2D.SetPointOut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(pos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_out", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the position for the vertex "idx". If the index is out of bounds, the function sends an error to the console.
*/
func (o *Curve2D) SetPointPos(idx int64, pos *Vector2) {
	log.Println("Calling Curve2D.SetPointPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(pos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_pos", goArguments, "")

	log.Println("Got return value!")

}

/*
                Returns a list of points along the curve, with a curvature controlled point density. That is, the curvier parts will have more points than the straighter parts.
				This approximation makes straight segments between each point, then subdivides those segments until the resulting shape is similar enough.
				"max_stages" controls how many subdivisions a curve segment may face before it is considered approximate enough. Each subdivision splits the segment in half, so the default 5 stages may mean up to 32 subdivisions per curve segment. Increase with care!
				"tolerance_degrees" controls how many degrees the midpoint of a segment may deviate from the real curve, before the segment has to be subdivided.
*/
func (o *Curve2D) Tessellate(maxStages int64, toleranceDegrees float64) *PoolVector2Array {
	log.Println("Calling Curve2D.Tessellate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(maxStages)
	goArguments[1] = reflect.ValueOf(toleranceDegrees)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tessellate", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*
        Curve2DImplementer is an interface for Curve2D objects.
        This class describes a Bezier curve in 2D space. It is mainly used to give a shape to a [Path2D], but can be manually sampled for other purposes.
		It keeps a cache of precalculated points along the curve, to speed further calculations up.
*/
type Curve2DImplementer interface {
	ResourceImplementer

	AddPoint(pos *Vector2, in *Vector2, out *Vector2, atpos int64)

	ClearPoints()

	GetBakeInterval() float64

	GetBakedLength() float64

	GetBakedPoints() *PoolVector2Array

	GetPointCount() int64

	GetPointIn(idx int64) *Vector2

	GetPointOut(idx int64) *Vector2

	GetPointPos(idx int64) *Vector2

	Interpolate(idx int64, t float64) *Vector2

	InterpolateBaked(offset float64, cubic *bool) *Vector2

	Interpolatef(fofs float64) *Vector2

	RemovePoint(idx int64)

	SetBakeInterval(distance float64)

	SetPointIn(idx int64, pos *Vector2)

	SetPointOut(idx int64, pos *Vector2)

	SetPointPos(idx int64, pos *Vector2)

	Tessellate(maxStages int64, toleranceDegrees float64) *PoolVector2Array
}

/*
        This class describes a Bezier curve in 3D space. It is mainly used to give a shape to a [Path], but can be manually sampled for other purposes.
		It keeps a cache of precalculated points along the curve, to speed further calculations up.
*/
type Curve3D struct {
	Resource
}

func (o *Curve3D) baseClass() string {
	return "Curve3D"
}

/*
                Adds a point to a curve, at position "pos", with control points "in" and "out".
				If "atpos" is given, the point is inserted before the point number "atpos", moving that point (and every point after) after the inserted point. If "atpos" is not given, or is an illegal value (atpos <0 or atpos >= [method get_point_count]), the point will be appended at the end of the point list.
*/
func (o *Curve3D) AddPoint(pos *Vector3, in *Vector3, out *Vector3, atpos int64) {
	log.Println("Calling Curve3D.AddPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(pos)
	goArguments[1] = reflect.ValueOf(in)
	goArguments[2] = reflect.ValueOf(out)
	goArguments[3] = reflect.ValueOf(atpos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_point", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Curve3D) ClearPoints() {
	log.Println("Calling Curve3D.ClearPoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_points", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the distance between two adjacent cached points.
*/
func (o *Curve3D) GetBakeInterval() float64 {
	log.Println("Calling Curve3D.GetBakeInterval()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bake_interval", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns the total length of the curve, based on the cached points. Given enough density (see [method set_bake_interval]), it should be approximate enough.
*/
func (o *Curve3D) GetBakedLength() float64 {
	log.Println("Calling Curve3D.GetBakedLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_baked_length", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns the cache of points as a [PoolVector3Array].
*/
func (o *Curve3D) GetBakedPoints() *PoolVector3Array {
	log.Println("Calling Curve3D.GetBakedPoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_baked_points", goArguments, "*PoolVector3Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector3Array)

	return returnValue

}

/*
   Returns the cache of tilts as a [RealArray].
*/
func (o *Curve3D) GetBakedTilts() *PoolRealArray {
	log.Println("Calling Curve3D.GetBakedTilts()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_baked_tilts", goArguments, "*PoolRealArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolRealArray)

	return returnValue

}

/*
   Returns the number of points describing the curve.
*/
func (o *Curve3D) GetPointCount() int64 {
	log.Println("Calling Curve3D.GetPointCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the position of the control point leading to the vertex "idx". If the index is out of bounds, the function sends an error to the console, and returns (0, 0, 0).
*/
func (o *Curve3D) GetPointIn(idx int64) *Vector3 {
	log.Println("Calling Curve3D.GetPointIn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_in", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Returns the position of the control point leading out of the vertex "idx". If the index is out of bounds, the function sends an error to the console, and returns (0, 0, 0).
*/
func (o *Curve3D) GetPointOut(idx int64) *Vector3 {
	log.Println("Calling Curve3D.GetPointOut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_out", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Returns the position of the vertex "idx". If the index is out of bounds, the function sends an error to the console, and returns (0, 0, 0).
*/
func (o *Curve3D) GetPointPos(idx int64) *Vector3 {
	log.Println("Calling Curve3D.GetPointPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_pos", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Returns the tilt angle in radians for the point "idx". If the index is out of bounds, the function sends an error to the console, and returns 0.
*/
func (o *Curve3D) GetPointTilt(idx int64) float64 {
	log.Println("Calling Curve3D.GetPointTilt()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_tilt", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
                Returns the position between the vertex "idx" and the vertex "idx"+1, where "t" controls if the point is the first vertex (t = 0.0), the last vertex (t = 1.0), or in between. Values of "t" outside the range (0.0 >= t  <=1) give strange, but predictable results.
				If "idx" is out of bounds it is truncated to the first or last vertex, and "t" is ignored. If the curve has no points, the function sends an error to the console, and returns (0, 0, 0).
*/
func (o *Curve3D) Interpolate(idx int64, t float64) *Vector3 {
	log.Println("Calling Curve3D.Interpolate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(t)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "interpolate", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
                Returns a point within the curve at position "offset", where "offset" is measured as a distance in 3D units along the curve.
				To do that, it finds the two cached points where the "offset" lies between, then interpolates the values. This interpolation is cubic if "cubic" is set to true, or linear if set to false.
				Cubic interpolation tends to follow the curves better, but linear is faster (and often, precise enough).
*/
func (o *Curve3D) InterpolateBaked(offset float64, cubic *bool) *Vector3 {
	log.Println("Calling Curve3D.InterpolateBaked()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(offset)
	goArguments[1] = reflect.ValueOf(cubic)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "interpolate_baked", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Returns the position at the vertex "fofs". It calls [method interpolate] using the integer part of fofs as "idx", and its fractional part as "t".
*/
func (o *Curve3D) Interpolatef(fofs float64) *Vector3 {
	log.Println("Calling Curve3D.Interpolatef()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(fofs)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "interpolatef", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Deletes the point "idx" from the curve. Sends an error to the console if "idx" is out of bounds.
*/
func (o *Curve3D) RemovePoint(idx int64) {
	log.Println("Calling Curve3D.RemovePoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_point", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the distance in 3D units between two adjacent cached points. Changing it forces the cache to be recomputed the next time a xxx_baked_xxx function is called. The less distance, the more points the cache will have, and the more memory it will consume, so use with care.
*/
func (o *Curve3D) SetBakeInterval(distance float64) {
	log.Println("Calling Curve3D.SetBakeInterval()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(distance)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bake_interval", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the position of the control point leading to the vertex "idx". If the index is out of bounds, the function sends an error to the console.
*/
func (o *Curve3D) SetPointIn(idx int64, pos *Vector3) {
	log.Println("Calling Curve3D.SetPointIn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(pos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_in", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the position of the control point leading out of the vertex "idx". If the index is out of bounds, the function sends an error to the console.
*/
func (o *Curve3D) SetPointOut(idx int64, pos *Vector3) {
	log.Println("Calling Curve3D.SetPointOut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(pos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_out", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the position for the vertex "idx". If the index is out of bounds, the function sends an error to the console.
*/
func (o *Curve3D) SetPointPos(idx int64, pos *Vector3) {
	log.Println("Calling Curve3D.SetPointPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(pos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_pos", goArguments, "")

	log.Println("Got return value!")

}

/*
                Sets the tilt angle in radians for the point "idx". If the index is out of bounds, the function sends an error to the console.
				The tilt controls the rotation along the look-at axis an object traveling the path would have. In the case of a curve controlling a [PathFollow], this tilt is an offset over the natural tilt the PathFollow calculates.
*/
func (o *Curve3D) SetPointTilt(idx int64, tilt float64) {
	log.Println("Calling Curve3D.SetPointTilt()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(tilt)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_tilt", goArguments, "")

	log.Println("Got return value!")

}

/*
                Returns a list of points along the curve, with a curvature controlled point density. That is, the curvier parts will have more points than the straighter parts.
				This approximation makes straight segments between each point, then subdivides those segments until the resulting shape is similar enough.
				"max_stages" controls how many subdivisions a curve segment may face before it is considered approximate enough. Each subdivision splits the segment in half, so the default 5 stages may mean up to 32 subdivisions per curve segment. Increase with care!
				"tolerance_degrees" controls how many degrees the midpoint of a segment may deviate from the real curve, before the segment has to be subdivided.
*/
func (o *Curve3D) Tessellate(maxStages int64, toleranceDegrees float64) *PoolVector3Array {
	log.Println("Calling Curve3D.Tessellate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(maxStages)
	goArguments[1] = reflect.ValueOf(toleranceDegrees)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tessellate", goArguments, "*PoolVector3Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector3Array)

	return returnValue

}

/*
        Curve3DImplementer is an interface for Curve3D objects.
        This class describes a Bezier curve in 3D space. It is mainly used to give a shape to a [Path], but can be manually sampled for other purposes.
		It keeps a cache of precalculated points along the curve, to speed further calculations up.
*/
type Curve3DImplementer interface {
	ResourceImplementer

	AddPoint(pos *Vector3, in *Vector3, out *Vector3, atpos int64)

	ClearPoints()

	GetBakeInterval() float64

	GetBakedLength() float64

	GetBakedPoints() *PoolVector3Array

	GetBakedTilts() *PoolRealArray

	GetPointCount() int64

	GetPointIn(idx int64) *Vector3

	GetPointOut(idx int64) *Vector3

	GetPointPos(idx int64) *Vector3

	GetPointTilt(idx int64) float64

	Interpolate(idx int64, t float64) *Vector3

	InterpolateBaked(offset float64, cubic *bool) *Vector3

	Interpolatef(fofs float64) *Vector3

	RemovePoint(idx int64)

	SetBakeInterval(distance float64)

	SetPointIn(idx int64, pos *Vector3)

	SetPointOut(idx int64, pos *Vector3)

	SetPointPos(idx int64, pos *Vector3)

	SetPointTilt(idx int64, tilt float64)

	Tessellate(maxStages int64, toleranceDegrees float64) *PoolVector3Array
}

/*

 */
type CurveTexture struct {
	Texture
}

func (o *CurveTexture) baseClass() string {
	return "CurveTexture"
}

/*

 */
func (o *CurveTexture) GetCurve() *Curve {
	log.Println("Calling CurveTexture.GetCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_curve", goArguments, "*Curve")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Curve)

	return returnValue

}

/*

 */
func (o *CurveTexture) SetCurve(curve *Curve) {
	log.Println("Calling CurveTexture.SetCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(curve)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_curve", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CurveTexture) SetWidth(width int64) {
	log.Println("Calling CurveTexture.SetWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(width)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_width", goArguments, "")

	log.Println("Got return value!")

}

/*
   CurveTextureImplementer is an interface for CurveTexture objects.

*/
type CurveTextureImplementer interface {
	TextureImplementer

	GetCurve() *Curve

	SetCurve(curve *Curve)

	SetWidth(width int64)
}

/*

 */
type CylinderMesh struct {
	PrimitiveMesh
}

func (o *CylinderMesh) baseClass() string {
	return "CylinderMesh"
}

/*

 */
func (o *CylinderMesh) GetBottomRadius() float64 {
	log.Println("Calling CylinderMesh.GetBottomRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bottom_radius", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *CylinderMesh) GetHeight() float64 {
	log.Println("Calling CylinderMesh.GetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_height", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *CylinderMesh) GetRadialSegments() int64 {
	log.Println("Calling CylinderMesh.GetRadialSegments()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_radial_segments", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *CylinderMesh) GetRings() int64 {
	log.Println("Calling CylinderMesh.GetRings()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rings", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *CylinderMesh) GetTopRadius() float64 {
	log.Println("Calling CylinderMesh.GetTopRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_top_radius", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *CylinderMesh) SetBottomRadius(radius float64) {
	log.Println("Calling CylinderMesh.SetBottomRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radius)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bottom_radius", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CylinderMesh) SetHeight(height float64) {
	log.Println("Calling CylinderMesh.SetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(height)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_height", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CylinderMesh) SetRadialSegments(segments int64) {
	log.Println("Calling CylinderMesh.SetRadialSegments()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(segments)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_radial_segments", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CylinderMesh) SetRings(rings int64) {
	log.Println("Calling CylinderMesh.SetRings()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rings)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rings", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *CylinderMesh) SetTopRadius(radius float64) {
	log.Println("Calling CylinderMesh.SetTopRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radius)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_top_radius", goArguments, "")

	log.Println("Got return value!")

}

/*
   CylinderMeshImplementer is an interface for CylinderMesh objects.

*/
type CylinderMeshImplementer interface {
	PrimitiveMeshImplementer

	GetBottomRadius() float64

	GetHeight() float64

	GetRadialSegments() int64

	GetRings() int64

	GetTopRadius() float64

	SetBottomRadius(radius float64)

	SetHeight(height float64)

	SetRadialSegments(segments int64)

	SetRings(rings int64)

	SetTopRadius(radius float64)
}

/*
   Damped spring constraint for 2D physics. This resembles a spring joint that always wants to go back to a given length.
*/
type DampedSpringJoint2D struct {
	Joint2D
}

func (o *DampedSpringJoint2D) baseClass() string {
	return "DampedSpringJoint2D"
}

/*
   Return the damping ratio of the spring joint. A value of 0 indicates an undamped spring, while 1 causes the system to reach equilibrium as fast as possible (critical damping).
*/
func (o *DampedSpringJoint2D) GetDamping() float64 {
	log.Println("Calling DampedSpringJoint2D.GetDamping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_damping", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the maximum length of the spring joint.
*/
func (o *DampedSpringJoint2D) GetLength() float64 {
	log.Println("Calling DampedSpringJoint2D.GetLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_length", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the resting length of the spring joint. The joint will always try to go to back this length when pulled apart.
*/
func (o *DampedSpringJoint2D) GetRestLength() float64 {
	log.Println("Calling DampedSpringJoint2D.GetRestLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rest_length", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the stiffness of the spring joint. The joint applies a force equal to the stiffness times the distance from its resting length.
*/
func (o *DampedSpringJoint2D) GetStiffness() float64 {
	log.Println("Calling DampedSpringJoint2D.GetStiffness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stiffness", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the damping ratio of the spring joint. A value of 0 indicates an undamped spring, while 1 causes the system to reach equilibrium as fast as possible (critical damping).
*/
func (o *DampedSpringJoint2D) SetDamping(damping float64) {
	log.Println("Calling DampedSpringJoint2D.SetDamping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(damping)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_damping", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the maximum length of the spring joint.
*/
func (o *DampedSpringJoint2D) SetLength(length float64) {
	log.Println("Calling DampedSpringJoint2D.SetLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(length)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_length", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the resting length of the spring joint. The joint will always try to go to back this length when pulled apart.
*/
func (o *DampedSpringJoint2D) SetRestLength(restLength float64) {
	log.Println("Calling DampedSpringJoint2D.SetRestLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(restLength)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rest_length", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the stiffness of the spring joint. The joint applies a force equal to the stiffness times the distance from its resting length.
*/
func (o *DampedSpringJoint2D) SetStiffness(stiffness float64) {
	log.Println("Calling DampedSpringJoint2D.SetStiffness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(stiffness)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_stiffness", goArguments, "")

	log.Println("Got return value!")

}

/*
   DampedSpringJoint2DImplementer is an interface for DampedSpringJoint2D objects.
   Damped spring constraint for 2D physics. This resembles a spring joint that always wants to go back to a given length.
*/
type DampedSpringJoint2DImplementer interface {
	Joint2DImplementer

	GetDamping() float64

	GetLength() float64

	GetRestLength() float64

	GetStiffness() float64

	SetDamping(damping float64)

	SetLength(length float64)

	SetRestLength(restLength float64)

	SetStiffness(stiffness float64)
}

/*
   A DirectionalLight is a type of [Light] node that emits light constantly in one direction (the negative z axis of the node). It is used lights with strong intensity that are located far away from the scene to model sunlight or moonlight. The worldspace location of the DirectionalLight transform (origin) is ignored, only the basis is used do determine light direction.
*/
type DirectionalLight struct {
	Light
}

func (o *DirectionalLight) baseClass() string {
	return "DirectionalLight"
}

/*

 */
func (o *DirectionalLight) GetShadowMode() int64 {
	log.Println("Calling DirectionalLight.GetShadowMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shadow_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *DirectionalLight) IsBlendSplitsEnabled() *bool {
	log.Println("Calling DirectionalLight.IsBlendSplitsEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_blend_splits_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *DirectionalLight) SetBlendSplits(enabled *bool) {
	log.Println("Calling DirectionalLight.SetBlendSplits()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_blend_splits", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *DirectionalLight) SetShadowMode(mode int64) {
	log.Println("Calling DirectionalLight.SetShadowMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   DirectionalLightImplementer is an interface for DirectionalLight objects.
   A DirectionalLight is a type of [Light] node that emits light constantly in one direction (the negative z axis of the node). It is used lights with strong intensity that are located far away from the scene to model sunlight or moonlight. The worldspace location of the DirectionalLight transform (origin) is ignored, only the basis is used do determine light direction.
*/
type DirectionalLightImplementer interface {
	LightImplementer

	GetShadowMode() int64

	IsBlendSplitsEnabled() *bool

	SetBlendSplits(enabled *bool)

	SetShadowMode(mode int64)
}

/*
        Directory type. It is used to manage directories and their content (not restricted to the project folder).
		Here is an example on how to iterate through the files of a directory:
		[codeblock]
		func dir_contents(path):
		    var dir = Directory.new()
		    if dir.open(path) == OK:
		        dir.list_dir_begin()
		        var file_name = dir.get_next()
		        while (file_name != ""):
		            if dir.current_is_dir():
		                print("Found directory: " + file_name)
		            else:
		                print("Found file: " + file_name)
		            file_name = dir.get_next()
		    else:
		        print("An error occurred when trying to access the path.")
		[/codeblock]
*/
type Directory struct {
	Reference
}

func (o *Directory) baseClass() string {
	return "Directory"
}

/*
                Change the currently opened directory to the one passed as an argument. The argument can be relative to the current directory (e.g. [code]newdir[/code] or [code]../newdir[/code]), or an absolute path (e.g. [code]/tmp/newdir[/code] or [code]res://somedir/newdir[/code]).
				The method returns one of the error code constants defined in [@Global Scope] (OK or ERR_*).
*/
func (o *Directory) ChangeDir(todir string) int64 {
	log.Println("Calling Directory.ChangeDir()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(todir)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "change_dir", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
                Copy the [i]from[/i] file to the [i]to[/i] destination. Both arguments should be paths to files, either relative or absolute. If the destination file exists and is not access-protected, it will be overwritten.
				Returns one of the error code constants defined in [@Global Scope] (OK, FAILED or ERR_*).
*/
func (o *Directory) Copy(from string, to string) int64 {
	log.Println("Calling Directory.Copy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(to)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "copy", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return whether the current item processed with the last [method get_next] call is a directory ([code].[/code] and [code]..[/code] are considered directories).
*/
func (o *Directory) CurrentIsDir() *bool {
	log.Println("Calling Directory.CurrentIsDir()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "current_is_dir", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether the target directory exists. The argument can be relative to the current directory, or an absolute path.
*/
func (o *Directory) DirExists(path string) *bool {
	log.Println("Calling Directory.DirExists()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "dir_exists", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether the target file exists. The argument can be relative to the current directory, or an absolute path.
*/
func (o *Directory) FileExists(path string) *bool {
	log.Println("Calling Directory.FileExists()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "file_exists", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return the absolute path to the currently opened directory (e.g. [code]res://folder[/code] or [code]C:\tmp\folder[/code]).
*/
func (o *Directory) GetCurrentDir() string {
	log.Println("Calling Directory.GetCurrentDir()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_dir", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *Directory) GetCurrentDrive() int64 {
	log.Println("Calling Directory.GetCurrentDrive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_drive", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   On Windows, return the name of the drive (partition) passed as an argument (e.g. [code]C:[/code]). On other platforms, or if the requested drive does not existed, the method returns an empty String.
*/
func (o *Directory) GetDrive(idx int64) string {
	log.Println("Calling Directory.GetDrive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_drive", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   On Windows, return the number of drives (partitions) mounted on the current filesystem. On other platforms, the method returns 0.
*/
func (o *Directory) GetDriveCount() int64 {
	log.Println("Calling Directory.GetDriveCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_drive_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
                Return the next element (file or directory) in the current directory (including [code].[/code] and [code]..[/code], unless [code]skip_navigational[/code] was given to [method list_dir_begin]).
				The name of the file or directory is returned (and not its full path). Once the stream has been fully processed, the method returns an empty String and closes the stream automatically (i.e. [method list_dir_end] would not be mandatory in such a case).
*/
func (o *Directory) GetNext() string {
	log.Println("Calling Directory.GetNext()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_next", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   On Unix desktop systems, return the available space on the current directory's disk. On other platforms, this information is not available and the method returns 0 or -1.
*/
func (o *Directory) GetSpaceLeft() int64 {
	log.Println("Calling Directory.GetSpaceLeft()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_space_left", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
                Initialise the stream used to list all files and directories using the [method get_next] function, closing the current opened stream if needed. Once the stream has been processed, it should typically be closed with [method list_dir_end].
				If you pass [code]skip_navigational[/code], then [code].[/code] and [code]..[/code] would be filtered out.
				If you pass [code]skip_hidden[/code], then hidden files would be filtered out.
*/
func (o *Directory) ListDirBegin(skipNavigational *bool, skipHidden *bool) int64 {
	log.Println("Calling Directory.ListDirBegin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(skipNavigational)
	goArguments[1] = reflect.ValueOf(skipHidden)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "list_dir_begin", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Close the current stream opened with [method list_dir_begin] (whether it has been fully processed with [method get_next] or not does not matter).
*/
func (o *Directory) ListDirEnd() {
	log.Println("Calling Directory.ListDirEnd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "list_dir_end", goArguments, "")

	log.Println("Got return value!")

}

/*
                Create a directory. The argument can be relative to the current directory, or an absolute path. The target directory should be placed in an already existing directory (to create the full path recursively, see [method make_dir_recursive]).
				The method returns one of the error code constants defined in [@Global Scope] (OK, FAILED or ERR_*).
*/
func (o *Directory) MakeDir(path string) int64 {
	log.Println("Calling Directory.MakeDir()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "make_dir", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
                Create a target directory and all necessary intermediate directories in its path, by calling [method make_dir] recursively. The argument can be relative to the current directory, or an absolute path.
				Return one of the error code constants defined in [@Global Scope] (OK, FAILED or ERR_*).
*/
func (o *Directory) MakeDirRecursive(path string) int64 {
	log.Println("Calling Directory.MakeDirRecursive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "make_dir_recursive", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
                Open an existing directory of the filesystem. The [i]path[/i] argument can be within the project tree ([code]res://folder[/code]), the user directory ([code]user://folder[/code]) or an absolute path of the user filesystem (e.g. [code]/tmp/folder[/code] or [code]C:\tmp\folder[/code]).
				The method returns one of the error code constants defined in [@Global Scope] (OK or ERR_*).
*/
func (o *Directory) Open(path string) int64 {
	log.Println("Calling Directory.Open()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "open", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
                Delete the target file or an empty directory. The argument can be relative to the current directory, or an absolute path. If the target directory is not empty, the operation will fail.
				Return one of the error code constants defined in [@Global Scope] (OK or FAILED).
*/
func (o *Directory) Remove(path string) int64 {
	log.Println("Calling Directory.Remove()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "remove", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
                Rename (move) the [i]from[/i] file to the [i]to[/i] destination. Both arguments should be paths to files, either relative or absolute. If the destination file exists and is not access-protected, it will be overwritten.
				Return one of the error code constants defined in [@Global Scope] (OK or FAILED).
*/
func (o *Directory) Rename(from string, to string) int64 {
	log.Println("Calling Directory.Rename()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(to)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "rename", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
        DirectoryImplementer is an interface for Directory objects.
        Directory type. It is used to manage directories and their content (not restricted to the project folder).
		Here is an example on how to iterate through the files of a directory:
		[codeblock]
		func dir_contents(path):
		    var dir = Directory.new()
		    if dir.open(path) == OK:
		        dir.list_dir_begin()
		        var file_name = dir.get_next()
		        while (file_name != ""):
		            if dir.current_is_dir():
		                print("Found directory: " + file_name)
		            else:
		                print("Found file: " + file_name)
		            file_name = dir.get_next()
		    else:
		        print("An error occurred when trying to access the path.")
		[/codeblock]
*/
type DirectoryImplementer interface {
	ReferenceImplementer

	ChangeDir(todir string) int64

	Copy(from string, to string) int64

	CurrentIsDir() *bool

	DirExists(path string) *bool

	FileExists(path string) *bool

	GetCurrentDir() string

	GetCurrentDrive() int64

	GetDrive(idx int64) string

	GetDriveCount() int64

	GetNext() string

	GetSpaceLeft() int64

	ListDirBegin(skipNavigational *bool, skipHidden *bool) int64

	ListDirEnd()

	MakeDir(path string) int64

	MakeDirRecursive(path string) int64

	Open(path string) int64

	Remove(path string) int64

	Rename(from string, to string) int64
}

/*

 */
type DynamicFont struct {
	Font
}

func (o *DynamicFont) baseClass() string {
	return "DynamicFont"
}

/*

 */
func (o *DynamicFont) AddFallback(data *DynamicFontData) {
	log.Println("Calling DynamicFont.AddFallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_fallback", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *DynamicFont) GetFallback(idx int64) *DynamicFontData {
	log.Println("Calling DynamicFont.GetFallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fallback", goArguments, "*DynamicFontData")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*DynamicFontData)

	return returnValue

}

/*

 */
func (o *DynamicFont) GetFallbackCount() int64 {
	log.Println("Calling DynamicFont.GetFallbackCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fallback_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *DynamicFont) GetFontData() *DynamicFontData {
	log.Println("Calling DynamicFont.GetFontData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_font_data", goArguments, "*DynamicFontData")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*DynamicFontData)

	return returnValue

}

/*

 */
func (o *DynamicFont) GetSize() int64 {
	log.Println("Calling DynamicFont.GetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *DynamicFont) GetSpacing(aType int64) int64 {
	log.Println("Calling DynamicFont.GetSpacing()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_spacing", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *DynamicFont) GetUseFilter() *bool {
	log.Println("Calling DynamicFont.GetUseFilter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_use_filter", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *DynamicFont) GetUseMipmaps() *bool {
	log.Println("Calling DynamicFont.GetUseMipmaps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_use_mipmaps", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *DynamicFont) RemoveFallback(idx int64) {
	log.Println("Calling DynamicFont.RemoveFallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_fallback", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *DynamicFont) SetFallback(idx int64, data *DynamicFontData) {
	log.Println("Calling DynamicFont.SetFallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fallback", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *DynamicFont) SetFontData(data *DynamicFontData) {
	log.Println("Calling DynamicFont.SetFontData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_font_data", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *DynamicFont) SetSize(data int64) {
	log.Println("Calling DynamicFont.SetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *DynamicFont) SetSpacing(aType int64, value int64) {
	log.Println("Calling DynamicFont.SetSpacing()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(aType)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_spacing", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *DynamicFont) SetUseFilter(enable *bool) {
	log.Println("Calling DynamicFont.SetUseFilter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_filter", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *DynamicFont) SetUseMipmaps(enable *bool) {
	log.Println("Calling DynamicFont.SetUseMipmaps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_mipmaps", goArguments, "")

	log.Println("Got return value!")

}

/*
   DynamicFontImplementer is an interface for DynamicFont objects.

*/
type DynamicFontImplementer interface {
	FontImplementer

	AddFallback(data *DynamicFontData)

	GetFallback(idx int64) *DynamicFontData

	GetFallbackCount() int64

	GetFontData() *DynamicFontData

	GetSize() int64

	GetSpacing(aType int64) int64

	GetUseFilter() *bool

	GetUseMipmaps() *bool

	RemoveFallback(idx int64)

	SetFallback(idx int64, data *DynamicFontData)

	SetFontData(data *DynamicFontData)

	SetSize(data int64)

	SetSpacing(aType int64, value int64)

	SetUseFilter(enable *bool)

	SetUseMipmaps(enable *bool)
}

/*

 */
type DynamicFontData struct {
	Resource
}

func (o *DynamicFontData) baseClass() string {
	return "DynamicFontData"
}

/*

 */
func (o *DynamicFontData) GetFontPath() string {
	log.Println("Calling DynamicFontData.GetFontPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_font_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *DynamicFontData) SetFontPath(path string) {
	log.Println("Calling DynamicFontData.SetFontPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_font_path", goArguments, "")

	log.Println("Got return value!")

}

/*
   DynamicFontDataImplementer is an interface for DynamicFontData objects.

*/
type DynamicFontDataImplementer interface {
	ResourceImplementer

	GetFontPath() string

	SetFontPath(path string)
}

/*

 */
type EditorFileDialog struct {
	ConfirmationDialog
}

func (o *EditorFileDialog) baseClass() string {
	return "EditorFileDialog"
}

/*

 */
func (o *EditorFileDialog) AddFilter(filter string) {
	log.Println("Calling EditorFileDialog.AddFilter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(filter)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_filter", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorFileDialog) ClearFilters() {
	log.Println("Calling EditorFileDialog.ClearFilters()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_filters", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorFileDialog) GetAccess() int64 {
	log.Println("Calling EditorFileDialog.GetAccess()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_access", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *EditorFileDialog) GetCurrentDir() string {
	log.Println("Calling EditorFileDialog.GetCurrentDir()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_dir", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *EditorFileDialog) GetCurrentFile() string {
	log.Println("Calling EditorFileDialog.GetCurrentFile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_file", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *EditorFileDialog) GetCurrentPath() string {
	log.Println("Calling EditorFileDialog.GetCurrentPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *EditorFileDialog) GetDisplayMode() int64 {
	log.Println("Calling EditorFileDialog.GetDisplayMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_display_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *EditorFileDialog) GetMode() int64 {
	log.Println("Calling EditorFileDialog.GetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *EditorFileDialog) GetVbox() *VBoxContainer {
	log.Println("Calling EditorFileDialog.GetVbox()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vbox", goArguments, "*VBoxContainer")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*VBoxContainer)

	return returnValue

}

/*

 */
func (o *EditorFileDialog) Invalidate() {
	log.Println("Calling EditorFileDialog.Invalidate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "invalidate", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorFileDialog) IsOverwriteWarningDisabled() *bool {
	log.Println("Calling EditorFileDialog.IsOverwriteWarningDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_overwrite_warning_disabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *EditorFileDialog) IsShowingHiddenFiles() *bool {
	log.Println("Calling EditorFileDialog.IsShowingHiddenFiles()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_showing_hidden_files", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *EditorFileDialog) SetAccess(access int64) {
	log.Println("Calling EditorFileDialog.SetAccess()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(access)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_access", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorFileDialog) SetCurrentDir(dir string) {
	log.Println("Calling EditorFileDialog.SetCurrentDir()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(dir)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_current_dir", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorFileDialog) SetCurrentFile(file string) {
	log.Println("Calling EditorFileDialog.SetCurrentFile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(file)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_current_file", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorFileDialog) SetCurrentPath(path string) {
	log.Println("Calling EditorFileDialog.SetCurrentPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_current_path", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorFileDialog) SetDisableOverwriteWarning(disable *bool) {
	log.Println("Calling EditorFileDialog.SetDisableOverwriteWarning()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(disable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_disable_overwrite_warning", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorFileDialog) SetDisplayMode(mode int64) {
	log.Println("Calling EditorFileDialog.SetDisplayMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_display_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorFileDialog) SetMode(mode int64) {
	log.Println("Calling EditorFileDialog.SetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorFileDialog) SetShowHiddenFiles(show *bool) {
	log.Println("Calling EditorFileDialog.SetShowHiddenFiles()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(show)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_show_hidden_files", goArguments, "")

	log.Println("Got return value!")

}

/*
   EditorFileDialogImplementer is an interface for EditorFileDialog objects.

*/
type EditorFileDialogImplementer interface {
	ConfirmationDialogImplementer

	AddFilter(filter string)

	ClearFilters()

	GetAccess() int64

	GetCurrentDir() string

	GetCurrentFile() string

	GetCurrentPath() string

	GetDisplayMode() int64

	GetMode() int64

	GetVbox() *VBoxContainer

	Invalidate()

	IsOverwriteWarningDisabled() *bool

	IsShowingHiddenFiles() *bool

	SetAccess(access int64)

	SetCurrentDir(dir string)

	SetCurrentFile(file string)

	SetCurrentPath(path string)

	SetDisableOverwriteWarning(disable *bool)

	SetDisplayMode(mode int64)

	SetMode(mode int64)

	SetShowHiddenFiles(show *bool)
}

/*
   This object holds information of all resources in the filesystem, their types, etc.
*/
type EditorFileSystem struct {
	Node
}

func (o *EditorFileSystem) baseClass() string {
	return "EditorFileSystem"
}

/*
   Get the type of the file, given the full path.
*/
func (o *EditorFileSystem) GetFileType(path string) string {
	log.Println("Calling EditorFileSystem.GetFileType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_file_type", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the root directory object.
*/
func (o *EditorFileSystem) GetFilesystem() *EditorFileSystemDirectory {
	log.Println("Calling EditorFileSystem.GetFilesystem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_filesystem", goArguments, "*EditorFileSystemDirectory")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*EditorFileSystemDirectory)

	return returnValue

}

/*

 */
func (o *EditorFileSystem) GetFilesystemPath(path string) *EditorFileSystemDirectory {
	log.Println("Calling EditorFileSystem.GetFilesystemPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_filesystem_path", goArguments, "*EditorFileSystemDirectory")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*EditorFileSystemDirectory)

	return returnValue

}

/*
   Return the scan progress for 0 to 1 if the FS is being scanned.
*/
func (o *EditorFileSystem) GetScanningProgress() float64 {
	log.Println("Calling EditorFileSystem.GetScanningProgress()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scanning_progress", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return true of the filesystem is being scanned.
*/
func (o *EditorFileSystem) IsScanning() *bool {
	log.Println("Calling EditorFileSystem.IsScanning()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_scanning", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Scan the filesystem for changes.
*/
func (o *EditorFileSystem) Scan() {
	log.Println("Calling EditorFileSystem.Scan()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "scan", goArguments, "")

	log.Println("Got return value!")

}

/*
   Check if the source of any imported resource changed.
*/
func (o *EditorFileSystem) ScanSources() {
	log.Println("Calling EditorFileSystem.ScanSources()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "scan_sources", goArguments, "")

	log.Println("Got return value!")

}

/*
   Update a file information. Call this if an external program (not Godot) modified the file.
*/
func (o *EditorFileSystem) UpdateFile(path string) {
	log.Println("Calling EditorFileSystem.UpdateFile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "update_file", goArguments, "")

	log.Println("Got return value!")

}

/*
   EditorFileSystemImplementer is an interface for EditorFileSystem objects.
   This object holds information of all resources in the filesystem, their types, etc.
*/
type EditorFileSystemImplementer interface {
	NodeImplementer

	GetFileType(path string) string

	GetFilesystem() *EditorFileSystemDirectory

	GetFilesystemPath(path string) *EditorFileSystemDirectory

	GetScanningProgress() float64

	IsScanning() *bool

	Scan()

	ScanSources()

	UpdateFile(path string)
}

/*

 */
type EditorFileSystemDirectory struct {
	Object
}

func (o *EditorFileSystemDirectory) baseClass() string {
	return "EditorFileSystemDirectory"
}

/*

 */
func (o *EditorFileSystemDirectory) FindDirIndex(name string) int64 {
	log.Println("Calling EditorFileSystemDirectory.FindDirIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "find_dir_index", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *EditorFileSystemDirectory) FindFileIndex(name string) int64 {
	log.Println("Calling EditorFileSystemDirectory.FindFileIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "find_file_index", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *EditorFileSystemDirectory) GetFile(idx int64) string {
	log.Println("Calling EditorFileSystemDirectory.GetFile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_file", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *EditorFileSystemDirectory) GetFileCount() int64 {
	log.Println("Calling EditorFileSystemDirectory.GetFileCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_file_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *EditorFileSystemDirectory) GetFileImportIsValid(idx int64) *bool {
	log.Println("Calling EditorFileSystemDirectory.GetFileImportIsValid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_file_import_is_valid", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *EditorFileSystemDirectory) GetFilePath(idx int64) string {
	log.Println("Calling EditorFileSystemDirectory.GetFilePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_file_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *EditorFileSystemDirectory) GetFileType(idx int64) string {
	log.Println("Calling EditorFileSystemDirectory.GetFileType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_file_type", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *EditorFileSystemDirectory) GetName() string {
	log.Println("Calling EditorFileSystemDirectory.GetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *EditorFileSystemDirectory) GetParent() *EditorFileSystemDirectory {
	log.Println("Calling EditorFileSystemDirectory.GetParent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_parent", goArguments, "*EditorFileSystemDirectory")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*EditorFileSystemDirectory)

	return returnValue

}

/*

 */
func (o *EditorFileSystemDirectory) GetPath() string {
	log.Println("Calling EditorFileSystemDirectory.GetPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *EditorFileSystemDirectory) GetSubdir(idx int64) *EditorFileSystemDirectory {
	log.Println("Calling EditorFileSystemDirectory.GetSubdir()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_subdir", goArguments, "*EditorFileSystemDirectory")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*EditorFileSystemDirectory)

	return returnValue

}

/*

 */
func (o *EditorFileSystemDirectory) GetSubdirCount() int64 {
	log.Println("Calling EditorFileSystemDirectory.GetSubdirCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_subdir_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   EditorFileSystemDirectoryImplementer is an interface for EditorFileSystemDirectory objects.

*/
type EditorFileSystemDirectoryImplementer interface {
	ObjectImplementer

	FindDirIndex(name string) int64

	FindFileIndex(name string) int64

	GetFile(idx int64) string

	GetFileCount() int64

	GetFileImportIsValid(idx int64) *bool

	GetFilePath(idx int64) string

	GetFileType(idx int64) string

	GetName() string

	GetParent() *EditorFileSystemDirectory

	GetPath() string

	GetSubdir(idx int64) *EditorFileSystemDirectory

	GetSubdirCount() int64
}

/*

 */
type EditorImportPlugin struct {
	Reference
}

func (o *EditorImportPlugin) baseClass() string {
	return "EditorImportPlugin"
}

/*

 */
func (o *EditorImportPlugin) GetImportOptions(preset int64) *Array {
	log.Println("Calling EditorImportPlugin.GetImportOptions()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(preset)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_import_options", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *EditorImportPlugin) GetImporterName() string {
	log.Println("Calling EditorImportPlugin.GetImporterName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_importer_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *EditorImportPlugin) GetOptionVisibility(option string, options *Dictionary) *bool {
	log.Println("Calling EditorImportPlugin.GetOptionVisibility()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(option)
	goArguments[1] = reflect.ValueOf(options)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_option_visibility", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *EditorImportPlugin) GetPresetCount() int64 {
	log.Println("Calling EditorImportPlugin.GetPresetCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_preset_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *EditorImportPlugin) GetPresetName(preset int64) string {
	log.Println("Calling EditorImportPlugin.GetPresetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(preset)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_preset_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *EditorImportPlugin) GetRecognizedExtensions() *Array {
	log.Println("Calling EditorImportPlugin.GetRecognizedExtensions()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_recognized_extensions", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *EditorImportPlugin) GetResourceType() string {
	log.Println("Calling EditorImportPlugin.GetResourceType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_resource_type", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *EditorImportPlugin) GetSaveExtension() string {
	log.Println("Calling EditorImportPlugin.GetSaveExtension()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_save_extension", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *EditorImportPlugin) GetVisibleName() string {
	log.Println("Calling EditorImportPlugin.GetVisibleName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_visible_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *EditorImportPlugin) Import(sourceFile string, savePath string, options *Dictionary, rPlatformVariants *Array, rGenFiles *Array) int64 {
	log.Println("Calling EditorImportPlugin.Import()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(sourceFile)
	goArguments[1] = reflect.ValueOf(savePath)
	goArguments[2] = reflect.ValueOf(options)
	goArguments[3] = reflect.ValueOf(rPlatformVariants)
	goArguments[4] = reflect.ValueOf(rGenFiles)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "import", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   EditorImportPluginImplementer is an interface for EditorImportPlugin objects.

*/
type EditorImportPluginImplementer interface {
	ReferenceImplementer

	GetImportOptions(preset int64) *Array

	GetImporterName() string

	GetOptionVisibility(option string, options *Dictionary) *bool

	GetPresetCount() int64

	GetPresetName(preset int64) string

	GetRecognizedExtensions() *Array

	GetResourceType() string

	GetSaveExtension() string

	GetVisibleName() string

	Import(sourceFile string, savePath string, options *Dictionary, rPlatformVariants *Array, rGenFiles *Array) int64
}

/*

 */
type EditorInterface struct {
	Node
}

func (o *EditorInterface) baseClass() string {
	return "EditorInterface"
}

/*

 */
func (o *EditorInterface) EditResource(resource *Resource) {
	log.Println("Calling EditorInterface.EditResource()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(resource)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "edit_resource", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorInterface) GetBaseControl() *Control {
	log.Println("Calling EditorInterface.GetBaseControl()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_control", goArguments, "*Control")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Control)

	return returnValue

}

/*

 */
func (o *EditorInterface) GetEditedSceneRoot() *Node {
	log.Println("Calling EditorInterface.GetEditedSceneRoot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_edited_scene_root", goArguments, "*Node")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Node)

	return returnValue

}

/*

 */
func (o *EditorInterface) GetEditorSettings() *EditorSettings {
	log.Println("Calling EditorInterface.GetEditorSettings()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_editor_settings", goArguments, "*EditorSettings")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*EditorSettings)

	return returnValue

}

/*

 */
func (o *EditorInterface) GetEditorViewport() *Control {
	log.Println("Calling EditorInterface.GetEditorViewport()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_editor_viewport", goArguments, "*Control")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Control)

	return returnValue

}

/*

 */
func (o *EditorInterface) GetOpenScenes() *Array {
	log.Println("Calling EditorInterface.GetOpenScenes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_open_scenes", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *EditorInterface) GetResourceFilesystem() *EditorFileSystem {
	log.Println("Calling EditorInterface.GetResourceFilesystem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_resource_filesystem", goArguments, "*EditorFileSystem")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*EditorFileSystem)

	return returnValue

}

/*

 */
func (o *EditorInterface) GetResourcePreviewer() *EditorResourcePreview {
	log.Println("Calling EditorInterface.GetResourcePreviewer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_resource_previewer", goArguments, "*EditorResourcePreview")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*EditorResourcePreview)

	return returnValue

}

/*

 */
func (o *EditorInterface) GetScriptEditor() *ScriptEditor {
	log.Println("Calling EditorInterface.GetScriptEditor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_script_editor", goArguments, "*ScriptEditor")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*ScriptEditor)

	return returnValue

}

/*

 */
func (o *EditorInterface) GetSelection() *EditorSelection {
	log.Println("Calling EditorInterface.GetSelection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_selection", goArguments, "*EditorSelection")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*EditorSelection)

	return returnValue

}

/*

 */
func (o *EditorInterface) InspectObject(object *Object, forProperty string) {
	log.Println("Calling EditorInterface.InspectObject()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(forProperty)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "inspect_object", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorInterface) MakeMeshPreviews(arg0 *Array, arg1 int64) *Array {
	log.Println("Calling EditorInterface.MakeMeshPreviews()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(arg0)
	goArguments[1] = reflect.ValueOf(arg1)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "make_mesh_previews", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *EditorInterface) OpenSceneFromPath(sceneFilepath string) {
	log.Println("Calling EditorInterface.OpenSceneFromPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(sceneFilepath)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "open_scene_from_path", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorInterface) ReloadSceneFromPath(sceneFilepath string) {
	log.Println("Calling EditorInterface.ReloadSceneFromPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(sceneFilepath)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "reload_scene_from_path", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorInterface) SaveScene() int64 {
	log.Println("Calling EditorInterface.SaveScene()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "save_scene", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *EditorInterface) SaveSceneAs(path string, withPreview *bool) {
	log.Println("Calling EditorInterface.SaveSceneAs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(path)
	goArguments[1] = reflect.ValueOf(withPreview)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "save_scene_as", goArguments, "")

	log.Println("Got return value!")

}

/*
   EditorInterfaceImplementer is an interface for EditorInterface objects.

*/
type EditorInterfaceImplementer interface {
	NodeImplementer

	EditResource(resource *Resource)

	GetBaseControl() *Control

	GetEditedSceneRoot() *Node

	GetEditorSettings() *EditorSettings

	GetEditorViewport() *Control

	GetOpenScenes() *Array

	GetResourceFilesystem() *EditorFileSystem

	GetResourcePreviewer() *EditorResourcePreview

	GetScriptEditor() *ScriptEditor

	GetSelection() *EditorSelection

	InspectObject(object *Object, forProperty string)

	MakeMeshPreviews(arg0 *Array, arg1 int64) *Array

	OpenSceneFromPath(sceneFilepath string)

	ReloadSceneFromPath(sceneFilepath string)

	SaveScene() int64

	SaveSceneAs(path string, withPreview *bool)
}

/*
   Plugins are used by the editor to extend functionality. The most common types of plugins are those which edit a given node or resource type, import plugins and export plugins.
*/
type EditorPlugin struct {
	Node
}

func (o *EditorPlugin) baseClass() string {
	return "EditorPlugin"
}

/*
   Add a control to the bottom panel (together with Output, Debug, Animation, etc). Returns a reference to the button added. It's up to you to hide/show the button when needed. If your plugin is being removed, also make sure to remove your control by calling [method remove_control_from_bottom_panel].
*/
func (o *EditorPlugin) AddControlToBottomPanel(control *Control, title string) *ToolButton {
	log.Println("Calling EditorPlugin.AddControlToBottomPanel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(control)
	goArguments[1] = reflect.ValueOf(title)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "add_control_to_bottom_panel", goArguments, "*ToolButton")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*ToolButton)

	return returnValue

}

/*
                Add a custom control to a container (see CONTAINER_* enum). There are many locations where custom controls can be added in the editor UI.
				Please remember that you have to manage the visibility of your custom controls yourself (and likely hide it after adding it).
				If your plugin is being removed, also make sure to remove your custom controls too.
*/
func (o *EditorPlugin) AddControlToContainer(container int64, control *Control) {
	log.Println("Calling EditorPlugin.AddControlToContainer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(container)
	goArguments[1] = reflect.ValueOf(control)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_control_to_container", goArguments, "")

	log.Println("Got return value!")

}

/*
                Add the control to a specific dock slot (see DOCK_* enum for options).
				If the dock is repositioned and as long as the plugin is active, the editor will save the dock position on further sessions.
				If your plugin is being removed, also make sure to remove your control by calling [method remove_control_from_docks].
*/
func (o *EditorPlugin) AddControlToDock(slot int64, control *Control) {
	log.Println("Calling EditorPlugin.AddControlToDock()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(slot)
	goArguments[1] = reflect.ValueOf(control)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_control_to_dock", goArguments, "")

	log.Println("Got return value!")

}

/*
                Add a custom type, which will appear in the list of nodes or resources. An icon can be optionally passed.
				When given node or resource is selected, the base type will be instanced (ie, "Spatial", "Control", "Resource"), then the script will be loaded and set to this object.
				You can use the [method EditorPlugin.handles] to check if your custom object is being edited by checking the script or using 'is' keyword.
				During run-time, this will be a simple object with a script so this function does not need to be called then.
*/
func (o *EditorPlugin) AddCustomType(aType string, base string, script *Script, icon *Texture) {
	log.Println("Calling EditorPlugin.AddCustomType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(aType)
	goArguments[1] = reflect.ValueOf(base)
	goArguments[2] = reflect.ValueOf(script)
	goArguments[3] = reflect.ValueOf(icon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_custom_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorPlugin) AddImportPlugin(importer *EditorImportPlugin) {
	log.Println("Calling EditorPlugin.AddImportPlugin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(importer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_import_plugin", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorPlugin) AddToolSubmenuItem(name string, submenu *Object) {
	log.Println("Calling EditorPlugin.AddToolSubmenuItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(submenu)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_tool_submenu_item", goArguments, "")

	log.Println("Got return value!")

}

/*
                This method is called when the editor is about to save the project, switch to another tab, etc. It asks the plugin to apply any pending state changes to ensure consistency.
				This is used, for example, in shader editors to let the plugin know that it must apply the shader code being written by the user to the object.
*/
func (o *EditorPlugin) ApplyChanges() {
	log.Println("Calling EditorPlugin.ApplyChanges()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "apply_changes", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear all the state and reset the object being edited to zero. This ensures your plugin does not keep editing a currently existing node, or a node from the wrong scene.
*/
func (o *EditorPlugin) Clear() {
	log.Println("Calling EditorPlugin.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   This is used for plugins that create gizmos used by the spatial editor. Just check that the node passed in the "for_spatial" argument matches your plugin.
*/
func (o *EditorPlugin) CreateSpatialGizmo(forSpatial *Spatial) *EditorSpatialGizmo {
	log.Println("Calling EditorPlugin.CreateSpatialGizmo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(forSpatial)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "create_spatial_gizmo", goArguments, "*EditorSpatialGizmo")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*EditorSpatialGizmo)

	return returnValue

}

/*
   This function is used for plugins that edit specific object types (nodes or resources). It requests the editor to edit the given object.
*/
func (o *EditorPlugin) Edit(object *Object) {
	log.Println("Calling EditorPlugin.Edit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(object)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "edit", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorPlugin) ForwardCanvasGuiInput(canvasXform *Transform2D, event *InputEvent) *bool {
	log.Println("Calling EditorPlugin.ForwardCanvasGuiInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(canvasXform)
	goArguments[1] = reflect.ValueOf(event)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "forward_canvas_gui_input", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   This function is called every time the 2D canvas editor draws (which overlays over the edited scene). Drawing over the supplied control will draw over the edited scene. To convert from control coordinates to edited scene coordinates (including zoom and offset), a transform is also provided. If you require this control to be redraw, call [method update_canvas].
*/
func (o *EditorPlugin) ForwardDrawOverCanvas(canvasXform *Transform2D, canvas *Control) {
	log.Println("Calling EditorPlugin.ForwardDrawOverCanvas()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(canvasXform)
	goArguments[1] = reflect.ValueOf(canvas)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "forward_draw_over_canvas", goArguments, "")

	log.Println("Got return value!")

}

/*
                Implement this function if you are interested in 3D view screen input events. It will be called only if currently selected node is handled by your plugin.
				If you would like to always gets those input events then additionally use [method set_input_forwarding_always_enabled].
*/
func (o *EditorPlugin) ForwardSpatialGuiInput(camera *Camera, event *InputEvent) *bool {
	log.Println("Calling EditorPlugin.ForwardSpatialGuiInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(camera)
	goArguments[1] = reflect.ValueOf(event)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "forward_spatial_gui_input", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   This is for editors that edit script based objects. You can return a list of breakpoints in the format (script:line), for example: res://path_to_script.gd:25
*/
func (o *EditorPlugin) GetBreakpoints() *PoolStringArray {
	log.Println("Calling EditorPlugin.GetBreakpoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_breakpoints", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*

 */
func (o *EditorPlugin) GetEditorInterface() *EditorInterface {
	log.Println("Calling EditorPlugin.GetEditorInterface()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_editor_interface", goArguments, "*EditorInterface")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*EditorInterface)

	return returnValue

}

/*

 */
func (o *EditorPlugin) GetPluginName() string {
	log.Println("Calling EditorPlugin.GetPluginName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_plugin_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the state of your plugin editor. This is used when saving the scene (so state is kept when opening it again) and for switching tabs (so state can be restored when the tab returns).
*/
func (o *EditorPlugin) GetState() *Dictionary {
	log.Println("Calling EditorPlugin.GetState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_state", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*
   Get the undo/redo object. Most actions in the editor can be undoable, so use this object to make sure this happens when it's worth it.
*/
func (o *EditorPlugin) GetUndoRedo() *UndoRedo {
	log.Println("Calling EditorPlugin.GetUndoRedo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_undo_redo", goArguments, "*UndoRedo")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*UndoRedo)

	return returnValue

}

/*
   Get the GUI layout of the plugin. This is used to save the project's editor layout when the [method EditorPlugin.queue_save_layout] is called or the editor layout was changed(For example changing the position of a dock).
*/
func (o *EditorPlugin) GetWindowLayout(layout *ConfigFile) {
	log.Println("Calling EditorPlugin.GetWindowLayout()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(layout)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "get_window_layout", goArguments, "")

	log.Println("Got return value!")

}

/*
   Implement this function if your plugin edits a specific type of object (Resource or Node). If you return true, then you will get the functions [method EditorPlugin.edit] and [method EditorPlugin.make_visible] called when the editor requests them.
*/
func (o *EditorPlugin) Handles(object *Object) *bool {
	log.Println("Calling EditorPlugin.Handles()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(object)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "handles", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if this is a main screen editor plugin (it goes in the main screen selector together with 2D, 3D, Script).
*/
func (o *EditorPlugin) HasMainScreen() *bool {
	log.Println("Calling EditorPlugin.HasMainScreen()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_main_screen", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *EditorPlugin) HideBottomPanel() {
	log.Println("Calling EditorPlugin.HideBottomPanel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "hide_bottom_panel", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorPlugin) MakeBottomPanelItemVisible(item *Control) {
	log.Println("Calling EditorPlugin.MakeBottomPanelItemVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(item)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "make_bottom_panel_item_visible", goArguments, "")

	log.Println("Got return value!")

}

/*
                This function will be called when the editor is requested to become visible. It is used for plugins that edit a specific object type.
				Remember that you have to manage the visibility of all your editor controls manually.
*/
func (o *EditorPlugin) MakeVisible(visible *bool) {
	log.Println("Calling EditorPlugin.MakeVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(visible)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "make_visible", goArguments, "")

	log.Println("Got return value!")

}

/*
   Queue save the project's editor layout.
*/
func (o *EditorPlugin) QueueSaveLayout() {
	log.Println("Calling EditorPlugin.QueueSaveLayout()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "queue_save_layout", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove the control from the bottom panel. Don't forget to call this if you added one, so the editor can remove it cleanly.
*/
func (o *EditorPlugin) RemoveControlFromBottomPanel(control *Control) {
	log.Println("Calling EditorPlugin.RemoveControlFromBottomPanel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(control)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_control_from_bottom_panel", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove the control from the dock. Don't forget to call this if you added one, so the editor can save the layout and remove it cleanly.
*/
func (o *EditorPlugin) RemoveControlFromDocks(control *Control) {
	log.Println("Calling EditorPlugin.RemoveControlFromDocks()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(control)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_control_from_docks", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove a custom type added by [method EditorPlugin.add_custom_type]
*/
func (o *EditorPlugin) RemoveCustomType(aType string) {
	log.Println("Calling EditorPlugin.RemoveCustomType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_custom_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorPlugin) RemoveImportPlugin(importer *EditorImportPlugin) {
	log.Println("Calling EditorPlugin.RemoveImportPlugin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(importer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_import_plugin", goArguments, "")

	log.Println("Got return value!")

}

/*
   This method is called after the editor saves the project or when it's closed. It asks the plugin to save edited external scenes/resources.
*/
func (o *EditorPlugin) SaveExternalData() {
	log.Println("Calling EditorPlugin.SaveExternalData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "save_external_data", goArguments, "")

	log.Println("Got return value!")

}

/*
   Use this method if you always want to receive inputs from 3D view screen inside [method forward_spatial_gui_input]. It might be especially usable if your plugin will want to use raycast in the scene.
*/
func (o *EditorPlugin) SetInputEventForwardingAlwaysEnabled() {
	log.Println("Calling EditorPlugin.SetInputEventForwardingAlwaysEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_input_event_forwarding_always_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Restore the state saved by [method EditorPlugin.get_state].
*/
func (o *EditorPlugin) SetState(state *Dictionary) {
	log.Println("Calling EditorPlugin.SetState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(state)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_state", goArguments, "")

	log.Println("Got return value!")

}

/*
   Restore the plugin GUI layout saved by [method EditorPlugin.get_window_layout].
*/
func (o *EditorPlugin) SetWindowLayout(layout *ConfigFile) {
	log.Println("Calling EditorPlugin.SetWindowLayout()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(layout)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_window_layout", goArguments, "")

	log.Println("Got return value!")

}

/*
   Updates the control used to draw the edited scene over the 2D canvas. This is used together with [method forward_canvas_input_event].
*/
func (o *EditorPlugin) UpdateCanvas() {
	log.Println("Calling EditorPlugin.UpdateCanvas()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "update_canvas", goArguments, "")

	log.Println("Got return value!")

}

/*
   EditorPluginImplementer is an interface for EditorPlugin objects.
   Plugins are used by the editor to extend functionality. The most common types of plugins are those which edit a given node or resource type, import plugins and export plugins.
*/
type EditorPluginImplementer interface {
	NodeImplementer

	AddControlToBottomPanel(control *Control, title string) *ToolButton

	AddControlToContainer(container int64, control *Control)

	AddControlToDock(slot int64, control *Control)

	AddCustomType(aType string, base string, script *Script, icon *Texture)

	AddImportPlugin(importer *EditorImportPlugin)

	AddToolSubmenuItem(name string, submenu *Object)

	ApplyChanges()

	Clear()

	CreateSpatialGizmo(forSpatial *Spatial) *EditorSpatialGizmo

	Edit(object *Object)

	ForwardCanvasGuiInput(canvasXform *Transform2D, event *InputEvent) *bool

	ForwardDrawOverCanvas(canvasXform *Transform2D, canvas *Control)

	ForwardSpatialGuiInput(camera *Camera, event *InputEvent) *bool

	GetBreakpoints() *PoolStringArray

	GetEditorInterface() *EditorInterface

	GetPluginName() string

	GetState() *Dictionary

	GetUndoRedo() *UndoRedo

	GetWindowLayout(layout *ConfigFile)

	Handles(object *Object) *bool

	HasMainScreen() *bool

	HideBottomPanel()

	MakeBottomPanelItemVisible(item *Control)

	MakeVisible(visible *bool)

	QueueSaveLayout()

	RemoveControlFromBottomPanel(control *Control)

	RemoveControlFromDocks(control *Control)

	RemoveCustomType(aType string)

	RemoveImportPlugin(importer *EditorImportPlugin)

	SaveExternalData()

	SetInputEventForwardingAlwaysEnabled()

	SetState(state *Dictionary)

	SetWindowLayout(layout *ConfigFile)

	UpdateCanvas()
}

/*
   This object is used to generate previews for resources of files.
*/
type EditorResourcePreview struct {
	Node
}

func (o *EditorResourcePreview) baseClass() string {
	return "EditorResourcePreview"
}

/*
   Create an own, custom preview generator.
*/
func (o *EditorResourcePreview) AddPreviewGenerator(generator *EditorResourcePreviewGenerator) {
	log.Println("Calling EditorResourcePreview.AddPreviewGenerator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(generator)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_preview_generator", goArguments, "")

	log.Println("Got return value!")

}

/*
   Check if the resource changed, if so it will be invalidated and the corresponding signal emitted.
*/
func (o *EditorResourcePreview) CheckForInvalidation(path string) {
	log.Println("Calling EditorResourcePreview.CheckForInvalidation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "check_for_invalidation", goArguments, "")

	log.Println("Got return value!")

}

/*
   Queue a resource being edited for preview (using an instance). Once the preview is ready, your receiver.receiver_func will be called either containing the preview texture or an empty texure (if no preview was possible). Callback must have the format: (path,texture,userdata). Userdata can be anything.
*/
func (o *EditorResourcePreview) QueueEditedResourcePreview(resource *Resource, receiver *Object, receiverFunc string, userdata *Variant) {
	log.Println("Calling EditorResourcePreview.QueueEditedResourcePreview()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(resource)
	goArguments[1] = reflect.ValueOf(receiver)
	goArguments[2] = reflect.ValueOf(receiverFunc)
	goArguments[3] = reflect.ValueOf(userdata)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "queue_edited_resource_preview", goArguments, "")

	log.Println("Got return value!")

}

/*
   Queue a resource file for preview (using a path). Once the preview is ready, your receiver.receiver_func will be called either containing the preview texture or an empty texure (if no preview was possible). Callback must have the format: (path,texture,userdata). Userdata can be anything.
*/
func (o *EditorResourcePreview) QueueResourcePreview(path string, receiver *Object, receiverFunc string, userdata *Variant) {
	log.Println("Calling EditorResourcePreview.QueueResourcePreview()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(path)
	goArguments[1] = reflect.ValueOf(receiver)
	goArguments[2] = reflect.ValueOf(receiverFunc)
	goArguments[3] = reflect.ValueOf(userdata)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "queue_resource_preview", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove a custom preview generator.
*/
func (o *EditorResourcePreview) RemovePreviewGenerator(generator *EditorResourcePreviewGenerator) {
	log.Println("Calling EditorResourcePreview.RemovePreviewGenerator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(generator)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_preview_generator", goArguments, "")

	log.Println("Got return value!")

}

/*
   EditorResourcePreviewImplementer is an interface for EditorResourcePreview objects.
   This object is used to generate previews for resources of files.
*/
type EditorResourcePreviewImplementer interface {
	NodeImplementer

	AddPreviewGenerator(generator *EditorResourcePreviewGenerator)

	CheckForInvalidation(path string)

	QueueEditedResourcePreview(resource *Resource, receiver *Object, receiverFunc string, userdata *Variant)

	QueueResourcePreview(path string, receiver *Object, receiverFunc string, userdata *Variant)

	RemovePreviewGenerator(generator *EditorResourcePreviewGenerator)
}

/*
   Custom code to generate previews. Please check "file_dialog/thumbnail_size" in EditorSettings to find out the right size to do previews at.
*/
type EditorResourcePreviewGenerator struct {
	Reference
}

func (o *EditorResourcePreviewGenerator) baseClass() string {
	return "EditorResourcePreviewGenerator"
}

/*
                Generate a preview from a given resource. This must be always implemented.
			Returning an empty texture is an OK way to fail and let another generator take care.
			Care must be taken because this function is always called from a thread (not the main thread).
*/
func (o *EditorResourcePreviewGenerator) Generate(from *Resource) *Texture {
	log.Println("Calling EditorResourcePreviewGenerator.Generate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(from)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "generate", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
                Generate a preview directly from a path, implementing this is optional, as default code will load and call generate()
			Returning an empty texture is an OK way to fail and let another generator take care.
			Care must be taken because this function is always called from a thread (not the main thread).
*/
func (o *EditorResourcePreviewGenerator) GenerateFromPath(path string) *Texture {
	log.Println("Calling EditorResourcePreviewGenerator.GenerateFromPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "generate_from_path", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   Return if your generator supports this resource type.
*/
func (o *EditorResourcePreviewGenerator) Handles(aType string) *bool {
	log.Println("Calling EditorResourcePreviewGenerator.Handles()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "handles", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   EditorResourcePreviewGeneratorImplementer is an interface for EditorResourcePreviewGenerator objects.
   Custom code to generate previews. Please check "file_dialog/thumbnail_size" in EditorSettings to find out the right size to do previews at.
*/
type EditorResourcePreviewGeneratorImplementer interface {
	ReferenceImplementer

	Generate(from *Resource) *Texture

	GenerateFromPath(path string) *Texture

	Handles(aType string) *bool
}

/*
   This script can be run from the Scene -> Run Script menu option.
*/
type EditorScript struct {
	Reference
}

func (o *EditorScript) baseClass() string {
	return "EditorScript"
}

/*

 */
func (o *EditorScript) X_Run() {
	log.Println("Calling EditorScript.X_Run()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_run", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorScript) AddRootNode(node *Node) {
	log.Println("Calling EditorScript.AddRootNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_root_node", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorScript) GetEditorInterface() *EditorInterface {
	log.Println("Calling EditorScript.GetEditorInterface()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_editor_interface", goArguments, "*EditorInterface")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*EditorInterface)

	return returnValue

}

/*

 */
func (o *EditorScript) GetScene() *Node {
	log.Println("Calling EditorScript.GetScene()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scene", goArguments, "*Node")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Node)

	return returnValue

}

/*
   EditorScriptImplementer is an interface for EditorScript objects.
   This script can be run from the Scene -> Run Script menu option.
*/
type EditorScriptImplementer interface {
	ReferenceImplementer

	X_Run()

	AddRootNode(node *Node)

	GetEditorInterface() *EditorInterface

	GetScene() *Node
}

/*
   This object manages the SceneTree selection in the editor.
*/
type EditorSelection struct {
	Object
}

func (o *EditorSelection) baseClass() string {
	return "EditorSelection"
}

/*
   Add a node to the selection.
*/
func (o *EditorSelection) AddNode(node *Node) {
	log.Println("Calling EditorSelection.AddNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_node", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear the selection.
*/
func (o *EditorSelection) Clear() {
	log.Println("Calling EditorSelection.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the list of selectes nodes.
*/
func (o *EditorSelection) GetSelectedNodes() *Array {
	log.Println("Calling EditorSelection.GetSelectedNodes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_selected_nodes", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Get the list of selected nodes, optimized for transform operations (ie, moving them, rotating, etc). This list avoids situations where a node is selected and also chid/grandchild.
*/
func (o *EditorSelection) GetTransformableSelectedNodes() *Array {
	log.Println("Calling EditorSelection.GetTransformableSelectedNodes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_transformable_selected_nodes", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Remove a node from the selection.
*/
func (o *EditorSelection) RemoveNode(node *Node) {
	log.Println("Calling EditorSelection.RemoveNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_node", goArguments, "")

	log.Println("Got return value!")

}

/*
   EditorSelectionImplementer is an interface for EditorSelection objects.
   This object manages the SceneTree selection in the editor.
*/
type EditorSelectionImplementer interface {
	ObjectImplementer

	AddNode(node *Node)

	Clear()

	GetSelectedNodes() *Array

	GetTransformableSelectedNodes() *Array

	RemoveNode(node *Node)
}

/*
        Object that holds the project-independent editor settings. These settings are generally visible in the Editor Settings menu.
		Accessing the settings is done by using the regular [Object] API, such as:
		[codeblock]
		settings.set(prop,value)
		settings.get(prop)
		list_of_settings = settings.get_property_list()
		[/codeblock]
*/
type EditorSettings struct {
	Resource
}

func (o *EditorSettings) baseClass() string {
	return "EditorSettings"
}

/*
                Add a custom property info to a property. The dictionary must contain: name:[String](the name of the property) and type:[int](see TYPE_* in [@Global Scope]), and optionally hint:[int](see PROPERTY_HINT_* in [@Global Scope]), hint_string:[String].
				Example:
				[codeblock]
				editor_settings.set("category/property_name", 0)

				var property_info = {
				    "name": "category/property_name",
				    "type": TYPE_INT,
				    "hint": PROPERTY_HINT_ENUM,
				    "hint_string": "one,two,three"
				}

				editor_settings.add_property_info(property_info)
				[/codeblock]
*/
func (o *EditorSettings) AddPropertyInfo(info *Dictionary) {
	log.Println("Calling EditorSettings.AddPropertyInfo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(info)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_property_info", goArguments, "")

	log.Println("Got return value!")

}

/*
   Erase a given setting (pass full property path).
*/
func (o *EditorSettings) Erase(property string) {
	log.Println("Calling EditorSettings.Erase()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(property)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "erase", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the list of favorite directories for this project.
*/
func (o *EditorSettings) GetFavoriteDirs() *PoolStringArray {
	log.Println("Calling EditorSettings.GetFavoriteDirs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_favorite_dirs", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   Get the specific project settings path. Projects all have a unique sub-directory inside the settings path where project specific settings are saved.
*/
func (o *EditorSettings) GetProjectSettingsPath() string {
	log.Println("Calling EditorSettings.GetProjectSettingsPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_project_settings_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the list of recently visited folders in the file dialog for this project.
*/
func (o *EditorSettings) GetRecentDirs() *PoolStringArray {
	log.Println("Calling EditorSettings.GetRecentDirs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_recent_dirs", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
                Get the global settings path for the engine. Inside this path you can find some standard paths such as:
				settings/tmp - used for temporary storage of files
				settings/templates - where export templates are located
*/
func (o *EditorSettings) GetSettingsPath() string {
	log.Println("Calling EditorSettings.GetSettingsPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_settings_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Set the list of favorite directories for this project.
*/
func (o *EditorSettings) SetFavoriteDirs(dirs *PoolStringArray) {
	log.Println("Calling EditorSettings.SetFavoriteDirs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(dirs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_favorite_dirs", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the list of recently visited folders in the file dialog for this project.
*/
func (o *EditorSettings) SetRecentDirs(dirs *PoolStringArray) {
	log.Println("Calling EditorSettings.SetRecentDirs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(dirs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_recent_dirs", goArguments, "")

	log.Println("Got return value!")

}

/*
        EditorSettingsImplementer is an interface for EditorSettings objects.
        Object that holds the project-independent editor settings. These settings are generally visible in the Editor Settings menu.
		Accessing the settings is done by using the regular [Object] API, such as:
		[codeblock]
		settings.set(prop,value)
		settings.get(prop)
		list_of_settings = settings.get_property_list()
		[/codeblock]
*/
type EditorSettingsImplementer interface {
	ResourceImplementer

	AddPropertyInfo(info *Dictionary)

	Erase(property string)

	GetFavoriteDirs() *PoolStringArray

	GetProjectSettingsPath() string

	GetRecentDirs() *PoolStringArray

	GetSettingsPath() string

	SetFavoriteDirs(dirs *PoolStringArray)

	SetRecentDirs(dirs *PoolStringArray)
}

/*
   Custom gizmo that is used for providing custom visualization and editing (handles) for 3D Spatial objects. These are created by [method EditorPlugin.create_spatial_gizmo].
*/
type EditorSpatialGizmo struct {
	SpatialGizmo
}

func (o *EditorSpatialGizmo) baseClass() string {
	return "EditorSpatialGizmo"
}

/*

 */
func (o *EditorSpatialGizmo) AddCollisionSegments(segments *PoolVector3Array) {
	log.Println("Calling EditorSpatialGizmo.AddCollisionSegments()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(segments)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_collision_segments", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add collision triangles to the gizmo for picking. A [TriangleMesh] can be generated from a regular [Mesh] too. Call this function during [method redraw].
*/
func (o *EditorSpatialGizmo) AddCollisionTriangles(triangles *TriangleMesh) {
	log.Println("Calling EditorSpatialGizmo.AddCollisionTriangles()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(triangles)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_collision_triangles", goArguments, "")

	log.Println("Got return value!")

}

/*
                Add a list of handles (points) which can be used to deform the object being edited.
				There are virtual functions which will be called upon editing of these handles. Call this function during [method redraw].
*/
func (o *EditorSpatialGizmo) AddHandles(handles *PoolVector3Array, billboard *bool, secondary *bool) {
	log.Println("Calling EditorSpatialGizmo.AddHandles()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(handles)
	goArguments[1] = reflect.ValueOf(billboard)
	goArguments[2] = reflect.ValueOf(secondary)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_handles", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add lines to the gizmo (as sets of 2 points), with a given material. The lines are used for visualizing the gizmo. Call this function during [method redraw].
*/
func (o *EditorSpatialGizmo) AddLines(lines *PoolVector3Array, material *Material, billboard *bool) {
	log.Println("Calling EditorSpatialGizmo.AddLines()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(lines)
	goArguments[1] = reflect.ValueOf(material)
	goArguments[2] = reflect.ValueOf(billboard)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_lines", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorSpatialGizmo) AddMesh(mesh *ArrayMesh, billboard *bool, skeleton *RID) {
	log.Println("Calling EditorSpatialGizmo.AddMesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(mesh)
	goArguments[1] = reflect.ValueOf(billboard)
	goArguments[2] = reflect.ValueOf(skeleton)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_mesh", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add an unscaled billboard for visualization. Call this function during [method redraw].
*/
func (o *EditorSpatialGizmo) AddUnscaledBillboard(material *Material, defaultScale float64) {
	log.Println("Calling EditorSpatialGizmo.AddUnscaledBillboard()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(material)
	goArguments[1] = reflect.ValueOf(defaultScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_unscaled_billboard", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorSpatialGizmo) Clear() {
	log.Println("Calling EditorSpatialGizmo.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
                Commit a handle being edited (handles must have been prevously added by [method add_handles]).
				If the cancel parameter is true, an option to restore the edited value to the original is provided.
*/
func (o *EditorSpatialGizmo) CommitHandle(index int64, restore *Variant, cancel *bool) {
	log.Println("Calling EditorSpatialGizmo.CommitHandle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(index)
	goArguments[1] = reflect.ValueOf(restore)
	goArguments[2] = reflect.ValueOf(cancel)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "commit_handle", goArguments, "")

	log.Println("Got return value!")

}

/*
                Get the name of an edited handle (handles must have been previously added by [method add_handles]).
				Handles can be named for reference to the user when editing.
*/
func (o *EditorSpatialGizmo) GetHandleName(index int64) string {
	log.Println("Calling EditorSpatialGizmo.GetHandleName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_handle_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get actual value of a handle. This value can be anything and used for eventually undoing the motion when calling [method commit_handle]
*/
func (o *EditorSpatialGizmo) GetHandleValue(index int64) *Variant {
	log.Println("Calling EditorSpatialGizmo.GetHandleValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_handle_value", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   This function is called when the Spatial this gizmo refers to changes (the [method Spatial.update_gizmo] is called).
*/
func (o *EditorSpatialGizmo) Redraw() {
	log.Println("Calling EditorSpatialGizmo.Redraw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "redraw", goArguments, "")

	log.Println("Got return value!")

}

/*
                This function is used when the user drags a gizmo handle (previously added with [method add_handles]) in screen coordinates.
				The [Camera] is also provided so screen coordinates can be converted to raycasts.
*/
func (o *EditorSpatialGizmo) SetHandle(index int64, camera *Camera, point *Vector2) {
	log.Println("Calling EditorSpatialGizmo.SetHandle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(index)
	goArguments[1] = reflect.ValueOf(camera)
	goArguments[2] = reflect.ValueOf(point)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_handle", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *EditorSpatialGizmo) SetSpatialNode(node *Node) {
	log.Println("Calling EditorSpatialGizmo.SetSpatialNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_spatial_node", goArguments, "")

	log.Println("Got return value!")

}

/*
   EditorSpatialGizmoImplementer is an interface for EditorSpatialGizmo objects.
   Custom gizmo that is used for providing custom visualization and editing (handles) for 3D Spatial objects. These are created by [method EditorPlugin.create_spatial_gizmo].
*/
type EditorSpatialGizmoImplementer interface {
	SpatialGizmoImplementer

	AddCollisionSegments(segments *PoolVector3Array)

	AddCollisionTriangles(triangles *TriangleMesh)

	AddHandles(handles *PoolVector3Array, billboard *bool, secondary *bool)

	AddLines(lines *PoolVector3Array, material *Material, billboard *bool)

	AddMesh(mesh *ArrayMesh, billboard *bool, skeleton *RID)

	AddUnscaledBillboard(material *Material, defaultScale float64)

	Clear()

	CommitHandle(index int64, restore *Variant, cancel *bool)

	GetHandleName(index int64) string

	GetHandleValue(index int64) *Variant

	Redraw()

	SetHandle(index int64, camera *Camera, point *Vector2)

	SetSpatialNode(node *Node)
}

/*

 */
type EncodedObjectAsID struct {
	Reference
}

func (o *EncodedObjectAsID) baseClass() string {
	return "EncodedObjectAsID"
}

/*

 */
func (o *EncodedObjectAsID) GetObjectId() int64 {
	log.Println("Calling EncodedObjectAsID.GetObjectId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_object_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *EncodedObjectAsID) SetObjectId(id int64) {
	log.Println("Calling EncodedObjectAsID.SetObjectId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_object_id", goArguments, "")

	log.Println("Got return value!")

}

/*
   EncodedObjectAsIDImplementer is an interface for EncodedObjectAsID objects.

*/
type EncodedObjectAsIDImplementer interface {
	ReferenceImplementer

	GetObjectId() int64

	SetObjectId(id int64)
}

/*

 */
type Engine struct {
	Object
}

func (o *Engine) baseClass() string {
	return "Engine"
}

/*
   Return the total amount of frames drawn.
*/
func (o *Engine) GetFramesDrawn() int64 {
	log.Println("Calling Engine.GetFramesDrawn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_frames_drawn", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the frames per second of the running game.
*/
func (o *Engine) GetFramesPerSecond() float64 {
	log.Println("Calling Engine.GetFramesPerSecond()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_frames_per_second", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the amount of fixed iterations per second (for fixed process and physics).
*/
func (o *Engine) GetIterationsPerSecond() int64 {
	log.Println("Calling Engine.GetIterationsPerSecond()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_iterations_per_second", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the main loop object (see [MainLoop] and [SceneTree]).
*/
func (o *Engine) GetMainLoop() *MainLoop {
	log.Println("Calling Engine.GetMainLoop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_main_loop", goArguments, "*MainLoop")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*MainLoop)

	return returnValue

}

/*

 */
func (o *Engine) GetTargetFps() float64 {
	log.Println("Calling Engine.GetTargetFps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_target_fps", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Engine) GetTimeScale() float64 {
	log.Println("Calling Engine.GetTimeScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_time_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
                Returns the current engine version information in a Dictionary.

				"major"    - Holds the major version number as a String
				"minor"    - Holds the minor version number as a String
				"patch"    - Holds the patch version number as a String
				"status"   - Holds the status (e.g. "beta", "rc1", "rc2", ... "stable") as a String
				"revision" - Holds the revision (e.g. "custom-build") as a String
				"string"   - major + minor + patch + status + revision in a single String
*/
func (o *Engine) GetVersionInfo() *Dictionary {
	log.Println("Calling Engine.GetVersionInfo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_version_info", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*

 */
func (o *Engine) IsEditorHint() *bool {
	log.Println("Calling Engine.IsEditorHint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_editor_hint", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Engine) IsInFixedFrame() *bool {
	log.Println("Calling Engine.IsInFixedFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_in_fixed_frame", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Engine) SetEditorHint(enabled *bool) {
	log.Println("Calling Engine.SetEditorHint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_editor_hint", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the amount of fixed iterations per second (for fixed process and physics).
*/
func (o *Engine) SetIterationsPerSecond(iterationsPerSecond int64) {
	log.Println("Calling Engine.SetIterationsPerSecond()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(iterationsPerSecond)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_iterations_per_second", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Engine) SetTargetFps(targetFps int64) {
	log.Println("Calling Engine.SetTargetFps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(targetFps)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_target_fps", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Engine) SetTimeScale(timeScale float64) {
	log.Println("Calling Engine.SetTimeScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(timeScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_time_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   EngineImplementer is an interface for Engine objects.

*/
type EngineImplementer interface {
	ObjectImplementer

	GetFramesDrawn() int64

	GetFramesPerSecond() float64

	GetIterationsPerSecond() int64

	GetMainLoop() *MainLoop

	GetTargetFps() float64

	GetTimeScale() float64

	GetVersionInfo() *Dictionary

	IsEditorHint() *bool

	IsInFixedFrame() *bool

	SetEditorHint(enabled *bool)

	SetIterationsPerSecond(iterationsPerSecond int64)

	SetTargetFps(targetFps int64)

	SetTimeScale(timeScale float64)
}

/*

 */
type Environment struct {
	Resource
}

func (o *Environment) baseClass() string {
	return "Environment"
}

/*

 */
func (o *Environment) GetAdjustmentBrightness() float64 {
	log.Println("Calling Environment.GetAdjustmentBrightness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_adjustment_brightness", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetAdjustmentColorCorrection() *Texture {
	log.Println("Calling Environment.GetAdjustmentColorCorrection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_adjustment_color_correction", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *Environment) GetAdjustmentContrast() float64 {
	log.Println("Calling Environment.GetAdjustmentContrast()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_adjustment_contrast", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetAdjustmentSaturation() float64 {
	log.Println("Calling Environment.GetAdjustmentSaturation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_adjustment_saturation", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetAmbientLightColor() *Color {
	log.Println("Calling Environment.GetAmbientLightColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ambient_light_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *Environment) GetAmbientLightEnergy() float64 {
	log.Println("Calling Environment.GetAmbientLightEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ambient_light_energy", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetAmbientLightSkyContribution() float64 {
	log.Println("Calling Environment.GetAmbientLightSkyContribution()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ambient_light_sky_contribution", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetBackground() int64 {
	log.Println("Calling Environment.GetBackground()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_background", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Environment) GetBgColor() *Color {
	log.Println("Calling Environment.GetBgColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bg_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *Environment) GetBgEnergy() float64 {
	log.Println("Calling Environment.GetBgEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bg_energy", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetCanvasMaxLayer() int64 {
	log.Println("Calling Environment.GetCanvasMaxLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_canvas_max_layer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Environment) GetDofBlurFarAmount() float64 {
	log.Println("Calling Environment.GetDofBlurFarAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dof_blur_far_amount", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetDofBlurFarDistance() float64 {
	log.Println("Calling Environment.GetDofBlurFarDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dof_blur_far_distance", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetDofBlurFarQuality() int64 {
	log.Println("Calling Environment.GetDofBlurFarQuality()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dof_blur_far_quality", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Environment) GetDofBlurFarTransition() float64 {
	log.Println("Calling Environment.GetDofBlurFarTransition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dof_blur_far_transition", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetDofBlurNearAmount() float64 {
	log.Println("Calling Environment.GetDofBlurNearAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dof_blur_near_amount", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetDofBlurNearDistance() float64 {
	log.Println("Calling Environment.GetDofBlurNearDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dof_blur_near_distance", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetDofBlurNearQuality() int64 {
	log.Println("Calling Environment.GetDofBlurNearQuality()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dof_blur_near_quality", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Environment) GetDofBlurNearTransition() float64 {
	log.Println("Calling Environment.GetDofBlurNearTransition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dof_blur_near_transition", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetFogColor() *Color {
	log.Println("Calling Environment.GetFogColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fog_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *Environment) GetFogDepthBegin() float64 {
	log.Println("Calling Environment.GetFogDepthBegin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fog_depth_begin", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetFogDepthCurve() float64 {
	log.Println("Calling Environment.GetFogDepthCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fog_depth_curve", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetFogHeightCurve() float64 {
	log.Println("Calling Environment.GetFogHeightCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fog_height_curve", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetFogHeightMax() float64 {
	log.Println("Calling Environment.GetFogHeightMax()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fog_height_max", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetFogHeightMin() float64 {
	log.Println("Calling Environment.GetFogHeightMin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fog_height_min", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetFogSunAmount() float64 {
	log.Println("Calling Environment.GetFogSunAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fog_sun_amount", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetFogSunColor() *Color {
	log.Println("Calling Environment.GetFogSunColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fog_sun_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *Environment) GetFogTransmitCurve() float64 {
	log.Println("Calling Environment.GetFogTransmitCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fog_transmit_curve", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetGlowBlendMode() int64 {
	log.Println("Calling Environment.GetGlowBlendMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_glow_blend_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Environment) GetGlowBloom() float64 {
	log.Println("Calling Environment.GetGlowBloom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_glow_bloom", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetGlowHdrBleedScale() float64 {
	log.Println("Calling Environment.GetGlowHdrBleedScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_glow_hdr_bleed_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetGlowHdrBleedThreshold() float64 {
	log.Println("Calling Environment.GetGlowHdrBleedThreshold()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_glow_hdr_bleed_threshold", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetGlowIntensity() float64 {
	log.Println("Calling Environment.GetGlowIntensity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_glow_intensity", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetGlowStrength() float64 {
	log.Println("Calling Environment.GetGlowStrength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_glow_strength", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetSky() *Sky {
	log.Println("Calling Environment.GetSky()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sky", goArguments, "*Sky")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Sky)

	return returnValue

}

/*

 */
func (o *Environment) GetSkyScale() float64 {
	log.Println("Calling Environment.GetSkyScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sky_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetSsaoBias() float64 {
	log.Println("Calling Environment.GetSsaoBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ssao_bias", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetSsaoColor() *Color {
	log.Println("Calling Environment.GetSsaoColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ssao_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *Environment) GetSsaoDirectLightAffect() float64 {
	log.Println("Calling Environment.GetSsaoDirectLightAffect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ssao_direct_light_affect", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetSsaoIntensity() float64 {
	log.Println("Calling Environment.GetSsaoIntensity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ssao_intensity", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetSsaoIntensity2() float64 {
	log.Println("Calling Environment.GetSsaoIntensity2()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ssao_intensity2", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetSsaoRadius() float64 {
	log.Println("Calling Environment.GetSsaoRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ssao_radius", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetSsaoRadius2() float64 {
	log.Println("Calling Environment.GetSsaoRadius2()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ssao_radius2", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetSsrDepthTolerance() float64 {
	log.Println("Calling Environment.GetSsrDepthTolerance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ssr_depth_tolerance", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetSsrFadeIn() float64 {
	log.Println("Calling Environment.GetSsrFadeIn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ssr_fade_in", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetSsrFadeOut() float64 {
	log.Println("Calling Environment.GetSsrFadeOut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ssr_fade_out", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetSsrMaxSteps() int64 {
	log.Println("Calling Environment.GetSsrMaxSteps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ssr_max_steps", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Environment) GetTonemapAutoExposure() *bool {
	log.Println("Calling Environment.GetTonemapAutoExposure()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tonemap_auto_exposure", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Environment) GetTonemapAutoExposureGrey() float64 {
	log.Println("Calling Environment.GetTonemapAutoExposureGrey()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tonemap_auto_exposure_grey", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetTonemapAutoExposureMax() float64 {
	log.Println("Calling Environment.GetTonemapAutoExposureMax()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tonemap_auto_exposure_max", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetTonemapAutoExposureMin() float64 {
	log.Println("Calling Environment.GetTonemapAutoExposureMin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tonemap_auto_exposure_min", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetTonemapAutoExposureSpeed() float64 {
	log.Println("Calling Environment.GetTonemapAutoExposureSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tonemap_auto_exposure_speed", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetTonemapExposure() float64 {
	log.Println("Calling Environment.GetTonemapExposure()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tonemap_exposure", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetTonemapWhite() float64 {
	log.Println("Calling Environment.GetTonemapWhite()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tonemap_white", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Environment) GetTonemapper() int64 {
	log.Println("Calling Environment.GetTonemapper()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tonemapper", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Environment) IsAdjustmentEnabled() *bool {
	log.Println("Calling Environment.IsAdjustmentEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_adjustment_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Environment) IsDofBlurFarEnabled() *bool {
	log.Println("Calling Environment.IsDofBlurFarEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_dof_blur_far_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Environment) IsDofBlurNearEnabled() *bool {
	log.Println("Calling Environment.IsDofBlurNearEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_dof_blur_near_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Environment) IsFogDepthEnabled() *bool {
	log.Println("Calling Environment.IsFogDepthEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_fog_depth_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Environment) IsFogEnabled() *bool {
	log.Println("Calling Environment.IsFogEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_fog_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Environment) IsFogHeightEnabled() *bool {
	log.Println("Calling Environment.IsFogHeightEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_fog_height_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Environment) IsFogTransmitEnabled() *bool {
	log.Println("Calling Environment.IsFogTransmitEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_fog_transmit_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Environment) IsGlowBicubicUpscaleEnabled() *bool {
	log.Println("Calling Environment.IsGlowBicubicUpscaleEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_glow_bicubic_upscale_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Environment) IsGlowEnabled() *bool {
	log.Println("Calling Environment.IsGlowEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_glow_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Environment) IsGlowLevelEnabled(idx int64) *bool {
	log.Println("Calling Environment.IsGlowLevelEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_glow_level_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Environment) IsSsaoBlurEnabled() *bool {
	log.Println("Calling Environment.IsSsaoBlurEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_ssao_blur_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Environment) IsSsaoEnabled() *bool {
	log.Println("Calling Environment.IsSsaoEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_ssao_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Environment) IsSsrEnabled() *bool {
	log.Println("Calling Environment.IsSsrEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_ssr_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Environment) IsSsrRough() *bool {
	log.Println("Calling Environment.IsSsrRough()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_ssr_rough", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Environment) SetAdjustmentBrightness(brightness float64) {
	log.Println("Calling Environment.SetAdjustmentBrightness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(brightness)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_adjustment_brightness", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetAdjustmentColorCorrection(colorCorrection *Texture) {
	log.Println("Calling Environment.SetAdjustmentColorCorrection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(colorCorrection)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_adjustment_color_correction", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetAdjustmentContrast(contrast float64) {
	log.Println("Calling Environment.SetAdjustmentContrast()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contrast)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_adjustment_contrast", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetAdjustmentEnable(enabled *bool) {
	log.Println("Calling Environment.SetAdjustmentEnable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_adjustment_enable", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetAdjustmentSaturation(saturation float64) {
	log.Println("Calling Environment.SetAdjustmentSaturation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(saturation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_adjustment_saturation", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetAmbientLightColor(color *Color) {
	log.Println("Calling Environment.SetAmbientLightColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ambient_light_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetAmbientLightEnergy(energy float64) {
	log.Println("Calling Environment.SetAmbientLightEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(energy)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ambient_light_energy", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetAmbientLightSkyContribution(energy float64) {
	log.Println("Calling Environment.SetAmbientLightSkyContribution()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(energy)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ambient_light_sky_contribution", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetBackground(mode int64) {
	log.Println("Calling Environment.SetBackground()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_background", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetBgColor(color *Color) {
	log.Println("Calling Environment.SetBgColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bg_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetBgEnergy(energy float64) {
	log.Println("Calling Environment.SetBgEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(energy)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bg_energy", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetCanvasMaxLayer(layer int64) {
	log.Println("Calling Environment.SetCanvasMaxLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_canvas_max_layer", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetDofBlurFarAmount(intensity float64) {
	log.Println("Calling Environment.SetDofBlurFarAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(intensity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dof_blur_far_amount", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetDofBlurFarDistance(intensity float64) {
	log.Println("Calling Environment.SetDofBlurFarDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(intensity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dof_blur_far_distance", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetDofBlurFarEnabled(enabled *bool) {
	log.Println("Calling Environment.SetDofBlurFarEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dof_blur_far_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetDofBlurFarQuality(intensity int64) {
	log.Println("Calling Environment.SetDofBlurFarQuality()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(intensity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dof_blur_far_quality", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetDofBlurFarTransition(intensity float64) {
	log.Println("Calling Environment.SetDofBlurFarTransition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(intensity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dof_blur_far_transition", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetDofBlurNearAmount(intensity float64) {
	log.Println("Calling Environment.SetDofBlurNearAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(intensity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dof_blur_near_amount", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetDofBlurNearDistance(intensity float64) {
	log.Println("Calling Environment.SetDofBlurNearDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(intensity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dof_blur_near_distance", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetDofBlurNearEnabled(enabled *bool) {
	log.Println("Calling Environment.SetDofBlurNearEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dof_blur_near_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetDofBlurNearQuality(level int64) {
	log.Println("Calling Environment.SetDofBlurNearQuality()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(level)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dof_blur_near_quality", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetDofBlurNearTransition(intensity float64) {
	log.Println("Calling Environment.SetDofBlurNearTransition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(intensity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dof_blur_near_transition", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetFogColor(color *Color) {
	log.Println("Calling Environment.SetFogColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fog_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetFogDepthBegin(distance float64) {
	log.Println("Calling Environment.SetFogDepthBegin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(distance)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fog_depth_begin", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetFogDepthCurve(curve float64) {
	log.Println("Calling Environment.SetFogDepthCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(curve)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fog_depth_curve", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetFogDepthEnabled(enabled *bool) {
	log.Println("Calling Environment.SetFogDepthEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fog_depth_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetFogEnabled(enabled *bool) {
	log.Println("Calling Environment.SetFogEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fog_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetFogHeightCurve(curve float64) {
	log.Println("Calling Environment.SetFogHeightCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(curve)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fog_height_curve", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetFogHeightEnabled(enabled *bool) {
	log.Println("Calling Environment.SetFogHeightEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fog_height_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetFogHeightMax(height float64) {
	log.Println("Calling Environment.SetFogHeightMax()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(height)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fog_height_max", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetFogHeightMin(height float64) {
	log.Println("Calling Environment.SetFogHeightMin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(height)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fog_height_min", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetFogSunAmount(amount float64) {
	log.Println("Calling Environment.SetFogSunAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fog_sun_amount", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetFogSunColor(color *Color) {
	log.Println("Calling Environment.SetFogSunColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fog_sun_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetFogTransmitCurve(curve float64) {
	log.Println("Calling Environment.SetFogTransmitCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(curve)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fog_transmit_curve", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetFogTransmitEnabled(enabled *bool) {
	log.Println("Calling Environment.SetFogTransmitEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fog_transmit_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetGlowBicubicUpscale(enabled *bool) {
	log.Println("Calling Environment.SetGlowBicubicUpscale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_glow_bicubic_upscale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetGlowBlendMode(mode int64) {
	log.Println("Calling Environment.SetGlowBlendMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_glow_blend_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetGlowBloom(amount float64) {
	log.Println("Calling Environment.SetGlowBloom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_glow_bloom", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetGlowEnabled(enabled *bool) {
	log.Println("Calling Environment.SetGlowEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_glow_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetGlowHdrBleedScale(scale float64) {
	log.Println("Calling Environment.SetGlowHdrBleedScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_glow_hdr_bleed_scale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetGlowHdrBleedThreshold(threshold float64) {
	log.Println("Calling Environment.SetGlowHdrBleedThreshold()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(threshold)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_glow_hdr_bleed_threshold", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetGlowIntensity(intensity float64) {
	log.Println("Calling Environment.SetGlowIntensity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(intensity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_glow_intensity", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetGlowLevel(idx int64, enabled *bool) {
	log.Println("Calling Environment.SetGlowLevel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_glow_level", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetGlowStrength(strength float64) {
	log.Println("Calling Environment.SetGlowStrength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(strength)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_glow_strength", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetSky(sky *Sky) {
	log.Println("Calling Environment.SetSky()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(sky)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sky", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetSkyScale(scale float64) {
	log.Println("Calling Environment.SetSkyScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sky_scale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetSsaoBias(bias float64) {
	log.Println("Calling Environment.SetSsaoBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bias)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssao_bias", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetSsaoBlur(enabled *bool) {
	log.Println("Calling Environment.SetSsaoBlur()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssao_blur", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetSsaoColor(color *Color) {
	log.Println("Calling Environment.SetSsaoColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssao_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetSsaoDirectLightAffect(amount float64) {
	log.Println("Calling Environment.SetSsaoDirectLightAffect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssao_direct_light_affect", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetSsaoEnabled(enabled *bool) {
	log.Println("Calling Environment.SetSsaoEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssao_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetSsaoIntensity(intensity float64) {
	log.Println("Calling Environment.SetSsaoIntensity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(intensity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssao_intensity", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetSsaoIntensity2(intensity float64) {
	log.Println("Calling Environment.SetSsaoIntensity2()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(intensity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssao_intensity2", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetSsaoRadius(radius float64) {
	log.Println("Calling Environment.SetSsaoRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radius)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssao_radius", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetSsaoRadius2(radius float64) {
	log.Println("Calling Environment.SetSsaoRadius2()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radius)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssao_radius2", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetSsrDepthTolerance(depthTolerance float64) {
	log.Println("Calling Environment.SetSsrDepthTolerance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(depthTolerance)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssr_depth_tolerance", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetSsrEnabled(enabled *bool) {
	log.Println("Calling Environment.SetSsrEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssr_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetSsrFadeIn(fadeIn float64) {
	log.Println("Calling Environment.SetSsrFadeIn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(fadeIn)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssr_fade_in", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetSsrFadeOut(fadeOut float64) {
	log.Println("Calling Environment.SetSsrFadeOut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(fadeOut)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssr_fade_out", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetSsrMaxSteps(maxSteps int64) {
	log.Println("Calling Environment.SetSsrMaxSteps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(maxSteps)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssr_max_steps", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetSsrRough(rough *bool) {
	log.Println("Calling Environment.SetSsrRough()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rough)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ssr_rough", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetTonemapAutoExposure(autoExposure *bool) {
	log.Println("Calling Environment.SetTonemapAutoExposure()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(autoExposure)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tonemap_auto_exposure", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetTonemapAutoExposureGrey(exposureGrey float64) {
	log.Println("Calling Environment.SetTonemapAutoExposureGrey()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(exposureGrey)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tonemap_auto_exposure_grey", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetTonemapAutoExposureMax(exposureMax float64) {
	log.Println("Calling Environment.SetTonemapAutoExposureMax()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(exposureMax)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tonemap_auto_exposure_max", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetTonemapAutoExposureMin(exposureMin float64) {
	log.Println("Calling Environment.SetTonemapAutoExposureMin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(exposureMin)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tonemap_auto_exposure_min", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetTonemapAutoExposureSpeed(exposureSpeed float64) {
	log.Println("Calling Environment.SetTonemapAutoExposureSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(exposureSpeed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tonemap_auto_exposure_speed", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetTonemapExposure(exposure float64) {
	log.Println("Calling Environment.SetTonemapExposure()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(exposure)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tonemap_exposure", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetTonemapWhite(white float64) {
	log.Println("Calling Environment.SetTonemapWhite()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(white)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tonemap_white", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Environment) SetTonemapper(mode int64) {
	log.Println("Calling Environment.SetTonemapper()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tonemapper", goArguments, "")

	log.Println("Got return value!")

}

/*
   EnvironmentImplementer is an interface for Environment objects.

*/
type EnvironmentImplementer interface {
	ResourceImplementer

	GetAdjustmentBrightness() float64

	GetAdjustmentColorCorrection() *Texture

	GetAdjustmentContrast() float64

	GetAdjustmentSaturation() float64

	GetAmbientLightColor() *Color

	GetAmbientLightEnergy() float64

	GetAmbientLightSkyContribution() float64

	GetBackground() int64

	GetBgColor() *Color

	GetBgEnergy() float64

	GetCanvasMaxLayer() int64

	GetDofBlurFarAmount() float64

	GetDofBlurFarDistance() float64

	GetDofBlurFarQuality() int64

	GetDofBlurFarTransition() float64

	GetDofBlurNearAmount() float64

	GetDofBlurNearDistance() float64

	GetDofBlurNearQuality() int64

	GetDofBlurNearTransition() float64

	GetFogColor() *Color

	GetFogDepthBegin() float64

	GetFogDepthCurve() float64

	GetFogHeightCurve() float64

	GetFogHeightMax() float64

	GetFogHeightMin() float64

	GetFogSunAmount() float64

	GetFogSunColor() *Color

	GetFogTransmitCurve() float64

	GetGlowBlendMode() int64

	GetGlowBloom() float64

	GetGlowHdrBleedScale() float64

	GetGlowHdrBleedThreshold() float64

	GetGlowIntensity() float64

	GetGlowStrength() float64

	GetSky() *Sky

	GetSkyScale() float64

	GetSsaoBias() float64

	GetSsaoColor() *Color

	GetSsaoDirectLightAffect() float64

	GetSsaoIntensity() float64

	GetSsaoIntensity2() float64

	GetSsaoRadius() float64

	GetSsaoRadius2() float64

	GetSsrDepthTolerance() float64

	GetSsrFadeIn() float64

	GetSsrFadeOut() float64

	GetSsrMaxSteps() int64

	GetTonemapAutoExposure() *bool

	GetTonemapAutoExposureGrey() float64

	GetTonemapAutoExposureMax() float64

	GetTonemapAutoExposureMin() float64

	GetTonemapAutoExposureSpeed() float64

	GetTonemapExposure() float64

	GetTonemapWhite() float64

	GetTonemapper() int64

	IsAdjustmentEnabled() *bool

	IsDofBlurFarEnabled() *bool

	IsDofBlurNearEnabled() *bool

	IsFogDepthEnabled() *bool

	IsFogEnabled() *bool

	IsFogHeightEnabled() *bool

	IsFogTransmitEnabled() *bool

	IsGlowBicubicUpscaleEnabled() *bool

	IsGlowEnabled() *bool

	IsGlowLevelEnabled(idx int64) *bool

	IsSsaoBlurEnabled() *bool

	IsSsaoEnabled() *bool

	IsSsrEnabled() *bool

	IsSsrRough() *bool

	SetAdjustmentBrightness(brightness float64)

	SetAdjustmentColorCorrection(colorCorrection *Texture)

	SetAdjustmentContrast(contrast float64)

	SetAdjustmentEnable(enabled *bool)

	SetAdjustmentSaturation(saturation float64)

	SetAmbientLightColor(color *Color)

	SetAmbientLightEnergy(energy float64)

	SetAmbientLightSkyContribution(energy float64)

	SetBackground(mode int64)

	SetBgColor(color *Color)

	SetBgEnergy(energy float64)

	SetCanvasMaxLayer(layer int64)

	SetDofBlurFarAmount(intensity float64)

	SetDofBlurFarDistance(intensity float64)

	SetDofBlurFarEnabled(enabled *bool)

	SetDofBlurFarQuality(intensity int64)

	SetDofBlurFarTransition(intensity float64)

	SetDofBlurNearAmount(intensity float64)

	SetDofBlurNearDistance(intensity float64)

	SetDofBlurNearEnabled(enabled *bool)

	SetDofBlurNearQuality(level int64)

	SetDofBlurNearTransition(intensity float64)

	SetFogColor(color *Color)

	SetFogDepthBegin(distance float64)

	SetFogDepthCurve(curve float64)

	SetFogDepthEnabled(enabled *bool)

	SetFogEnabled(enabled *bool)

	SetFogHeightCurve(curve float64)

	SetFogHeightEnabled(enabled *bool)

	SetFogHeightMax(height float64)

	SetFogHeightMin(height float64)

	SetFogSunAmount(amount float64)

	SetFogSunColor(color *Color)

	SetFogTransmitCurve(curve float64)

	SetFogTransmitEnabled(enabled *bool)

	SetGlowBicubicUpscale(enabled *bool)

	SetGlowBlendMode(mode int64)

	SetGlowBloom(amount float64)

	SetGlowEnabled(enabled *bool)

	SetGlowHdrBleedScale(scale float64)

	SetGlowHdrBleedThreshold(threshold float64)

	SetGlowIntensity(intensity float64)

	SetGlowLevel(idx int64, enabled *bool)

	SetGlowStrength(strength float64)

	SetSky(sky *Sky)

	SetSkyScale(scale float64)

	SetSsaoBias(bias float64)

	SetSsaoBlur(enabled *bool)

	SetSsaoColor(color *Color)

	SetSsaoDirectLightAffect(amount float64)

	SetSsaoEnabled(enabled *bool)

	SetSsaoIntensity(intensity float64)

	SetSsaoIntensity2(intensity float64)

	SetSsaoRadius(radius float64)

	SetSsaoRadius2(radius float64)

	SetSsrDepthTolerance(depthTolerance float64)

	SetSsrEnabled(enabled *bool)

	SetSsrFadeIn(fadeIn float64)

	SetSsrFadeOut(fadeOut float64)

	SetSsrMaxSteps(maxSteps int64)

	SetSsrRough(rough *bool)

	SetTonemapAutoExposure(autoExposure *bool)

	SetTonemapAutoExposureGrey(exposureGrey float64)

	SetTonemapAutoExposureMax(exposureMax float64)

	SetTonemapAutoExposureMin(exposureMin float64)

	SetTonemapAutoExposureSpeed(exposureSpeed float64)

	SetTonemapExposure(exposure float64)

	SetTonemapWhite(white float64)

	SetTonemapper(mode int64)
}

/*
        File type. This is used to permanently store data into the user device's file system and to read from it. This can be used to store game save data or player configuration files, for example.
		Here's a sample on how to write and read from a file:
		[codeblock]
		func save(content):
		    var file = File.new()
		    file.open("user://save_game.dat", file.WRITE)
		    file.store_string(content)
		    file.close()

		func load():
		    var file = File.new()
		    file.open("user://save_game.dat", file.READ)
		    var content = file.get_as_text()
		    file.close()
		    return content
		[/codeblock]
*/
type File struct {
	Reference
}

func (o *File) baseClass() string {
	return "File"
}

/*
   Close the currently opened file.
*/
func (o *File) Close() {
	log.Println("Calling File.Close()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "close", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether the file cursor reached the end of the file.
*/
func (o *File) EofReached() *bool {
	log.Println("Calling File.EofReached()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "eof_reached", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Get whether or not the file in the specified path exists.
*/
func (o *File) FileExists(path string) *bool {
	log.Println("Calling File.FileExists()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "file_exists", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Get the next 16 bits from the file as an integer.
*/
func (o *File) Get16() int64 {
	log.Println("Calling File.Get16()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_16", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the next 32 bits from the file as an integer.
*/
func (o *File) Get32() int64 {
	log.Println("Calling File.Get32()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_32", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the next 64 bits from the file as an integer.
*/
func (o *File) Get64() int64 {
	log.Println("Calling File.Get64()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_64", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the next 8 bits from the file as an integer.
*/
func (o *File) Get8() int64 {
	log.Println("Calling File.Get8()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_8", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the whole file as a [String].
*/
func (o *File) GetAsText() string {
	log.Println("Calling File.GetAsText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_as_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get next len bytes of the file as a [PoolByteArray].
*/
func (o *File) GetBuffer(len int64) *PoolByteArray {
	log.Println("Calling File.GetBuffer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(len)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_buffer", goArguments, "*PoolByteArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolByteArray)

	return returnValue

}

/*
   Get the next value of the file in CSV (Comma Separated Values) format. You can pass a different delimiter to use other than the default "," (comma).
*/
func (o *File) GetCsvLine(delim string) *PoolStringArray {
	log.Println("Calling File.GetCsvLine()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(delim)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_csv_line", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   Get the next 64 bits from the file as a floating point number.
*/
func (o *File) GetDouble() float64 {
	log.Println("Calling File.GetDouble()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_double", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Get whether endian swap is enabled for this file.
*/
func (o *File) GetEndianSwap() *bool {
	log.Println("Calling File.GetEndianSwap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_endian_swap", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Get the last error that happened when trying to perform operations. Compare with the [code]ERR_FILE_*[/code] constants from [@Global Scope].
*/
func (o *File) GetError() int64 {
	log.Println("Calling File.GetError()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_error", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the next 32 bits from the file as a floating point number.
*/
func (o *File) GetFloat() float64 {
	log.Println("Calling File.GetFloat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_float", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the size of the file in bytes.
*/
func (o *File) GetLen() int64 {
	log.Println("Calling File.GetLen()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_len", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the next line of the file as a [String].
*/
func (o *File) GetLine() string {
	log.Println("Calling File.GetLine()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_line", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return a md5 String representing the file at the given path or an empty [String] on failure.
*/
func (o *File) GetMd5(path string) string {
	log.Println("Calling File.GetMd5()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_md5", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *File) GetModifiedTime(file string) int64 {
	log.Println("Calling File.GetModifiedTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(file)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_modified_time", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get a [String] saved in Pascal format from the file.
*/
func (o *File) GetPascalString() string {
	log.Println("Calling File.GetPascalString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pascal_string", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the file cursor position.
*/
func (o *File) GetPos() int64 {
	log.Println("Calling File.GetPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pos", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the next bits from the file as a floating point number.
*/
func (o *File) GetReal() float64 {
	log.Println("Calling File.GetReal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_real", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return a sha256 String representing the file at the given path or an empty [String] on failure.
*/
func (o *File) GetSha256(path string) string {
	log.Println("Calling File.GetSha256()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sha256", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the next Variant value from the file.
*/
func (o *File) GetVar() *Variant {
	log.Println("Calling File.GetVar()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_var", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Return whether the file is currently opened.
*/
func (o *File) IsOpen() *bool {
	log.Println("Calling File.IsOpen()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_open", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Open the file for writing or reading, depending on the flags.
*/
func (o *File) Open(path string, flags int64) int64 {
	log.Println("Calling File.Open()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(path)
	goArguments[1] = reflect.ValueOf(flags)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "open", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Open a compressed file for reading or writing. The compression_mode can be set as one of the COMPRESSION_* constants.
*/
func (o *File) OpenCompressed(path string, modeFlags int64, compressionMode int64) int64 {
	log.Println("Calling File.OpenCompressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(path)
	goArguments[1] = reflect.ValueOf(modeFlags)
	goArguments[2] = reflect.ValueOf(compressionMode)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "open_compressed", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Open an encrypted file in write or read mode. You need to pass a binary key to encrypt/decrypt it.
*/
func (o *File) OpenEncrypted(path string, modeFlags int64, key *PoolByteArray) int64 {
	log.Println("Calling File.OpenEncrypted()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(path)
	goArguments[1] = reflect.ValueOf(modeFlags)
	goArguments[2] = reflect.ValueOf(key)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "open_encrypted", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Open an encrypted file in write or read mode. You need to pass a password to encrypt/decrypt it.
*/
func (o *File) OpenEncryptedWithPass(path string, modeFlags int64, pass string) int64 {
	log.Println("Calling File.OpenEncryptedWithPass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(path)
	goArguments[1] = reflect.ValueOf(modeFlags)
	goArguments[2] = reflect.ValueOf(pass)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "open_encrypted_with_pass", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Change the file reading/writing cursor to the specified position (in bytes from the beginning of the file).
*/
func (o *File) Seek(pos int64) {
	log.Println("Calling File.Seek()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "seek", goArguments, "")

	log.Println("Got return value!")

}

/*
   Change the file reading/writing cursor to the specified position (in bytes from the end of the file). Note that this is an offset, so you should use negative numbers or the cursor will be at the end of the file.
*/
func (o *File) SeekEnd(pos int64) {
	log.Println("Calling File.SeekEnd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "seek_end", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set whether to swap the endianness of the file. Enable this if you're dealing with files written in big endian machines.
				Note that this is about the file format, not CPU type. This is always reseted to [code]false[/code] whenever you open the file.
*/
func (o *File) SetEndianSwap(enable *bool) {
	log.Println("Calling File.SetEndianSwap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_endian_swap", goArguments, "")

	log.Println("Got return value!")

}

/*
   Store an integer as 16 bits in the file.
*/
func (o *File) Store16(value int64) {
	log.Println("Calling File.Store16()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "store_16", goArguments, "")

	log.Println("Got return value!")

}

/*
   Store an integer as 32 bits in the file.
*/
func (o *File) Store32(value int64) {
	log.Println("Calling File.Store32()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "store_32", goArguments, "")

	log.Println("Got return value!")

}

/*
   Store an integer as 64 bits in the file.
*/
func (o *File) Store64(value int64) {
	log.Println("Calling File.Store64()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "store_64", goArguments, "")

	log.Println("Got return value!")

}

/*
   Store an integer as 8 bits in the file.
*/
func (o *File) Store8(value int64) {
	log.Println("Calling File.Store8()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "store_8", goArguments, "")

	log.Println("Got return value!")

}

/*
   Store the given array of bytes in the file.
*/
func (o *File) StoreBuffer(buffer *PoolByteArray) {
	log.Println("Calling File.StoreBuffer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(buffer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "store_buffer", goArguments, "")

	log.Println("Got return value!")

}

/*
   Store a floating point number as 64 bits in the file.
*/
func (o *File) StoreDouble(value float64) {
	log.Println("Calling File.StoreDouble()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "store_double", goArguments, "")

	log.Println("Got return value!")

}

/*
   Store a floating point number as 32 bits in the file.
*/
func (o *File) StoreFloat(value float64) {
	log.Println("Calling File.StoreFloat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "store_float", goArguments, "")

	log.Println("Got return value!")

}

/*
   Store the given [String] as a line in the file.
*/
func (o *File) StoreLine(line string) {
	log.Println("Calling File.StoreLine()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(line)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "store_line", goArguments, "")

	log.Println("Got return value!")

}

/*
   Store the given [String] as a line in the file in Pascal format (i.e. also store the length of the string).
*/
func (o *File) StorePascalString(string string) {
	log.Println("Calling File.StorePascalString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(string)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "store_pascal_string", goArguments, "")

	log.Println("Got return value!")

}

/*
   Store a floating point number in the file.
*/
func (o *File) StoreReal(value float64) {
	log.Println("Calling File.StoreReal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "store_real", goArguments, "")

	log.Println("Got return value!")

}

/*
   Store the given [String] in the file.
*/
func (o *File) StoreString(string string) {
	log.Println("Calling File.StoreString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(string)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "store_string", goArguments, "")

	log.Println("Got return value!")

}

/*
   Store any Variant value in the file.
*/
func (o *File) StoreVar(value *Variant) {
	log.Println("Calling File.StoreVar()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "store_var", goArguments, "")

	log.Println("Got return value!")

}

/*
        FileImplementer is an interface for File objects.
        File type. This is used to permanently store data into the user device's file system and to read from it. This can be used to store game save data or player configuration files, for example.
		Here's a sample on how to write and read from a file:
		[codeblock]
		func save(content):
		    var file = File.new()
		    file.open("user://save_game.dat", file.WRITE)
		    file.store_string(content)
		    file.close()

		func load():
		    var file = File.new()
		    file.open("user://save_game.dat", file.READ)
		    var content = file.get_as_text()
		    file.close()
		    return content
		[/codeblock]
*/
type FileImplementer interface {
	ReferenceImplementer

	Close()

	EofReached() *bool

	FileExists(path string) *bool

	Get16() int64

	Get32() int64

	Get64() int64

	Get8() int64

	GetAsText() string

	GetBuffer(len int64) *PoolByteArray

	GetCsvLine(delim string) *PoolStringArray

	GetDouble() float64

	GetEndianSwap() *bool

	GetError() int64

	GetFloat() float64

	GetLen() int64

	GetLine() string

	GetMd5(path string) string

	GetModifiedTime(file string) int64

	GetPascalString() string

	GetPos() int64

	GetReal() float64

	GetSha256(path string) string

	GetVar() *Variant

	IsOpen() *bool

	Open(path string, flags int64) int64

	OpenCompressed(path string, modeFlags int64, compressionMode int64) int64

	OpenEncrypted(path string, modeFlags int64, key *PoolByteArray) int64

	OpenEncryptedWithPass(path string, modeFlags int64, pass string) int64

	Seek(pos int64)

	SeekEnd(pos int64)

	SetEndianSwap(enable *bool)

	Store16(value int64)

	Store32(value int64)

	Store64(value int64)

	Store8(value int64)

	StoreBuffer(buffer *PoolByteArray)

	StoreDouble(value float64)

	StoreFloat(value float64)

	StoreLine(line string)

	StorePascalString(string string)

	StoreReal(value float64)

	StoreString(string string)

	StoreVar(value *Variant)
}

/*
   FileDialog is a preset dialog used to choose files and directories in the filesystem. It supports filter masks.
*/
type FileDialog struct {
	ConfirmationDialog
}

func (o *FileDialog) baseClass() string {
	return "FileDialog"
}

/*
   Add a custom filter. Filter format is: "mask ; description", example (C++): dialog->add_filter("*.png ; PNG Images");
*/
func (o *FileDialog) AddFilter(filter string) {
	log.Println("Calling FileDialog.AddFilter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(filter)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_filter", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear all the added filters in the dialog.
*/
func (o *FileDialog) ClearFilters() {
	log.Println("Calling FileDialog.ClearFilters()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_filters", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the file access permission of the dialog.
*/
func (o *FileDialog) GetAccess() int64 {
	log.Println("Calling FileDialog.GetAccess()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_access", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the current working directory of the file dialog.
*/
func (o *FileDialog) GetCurrentDir() string {
	log.Println("Calling FileDialog.GetCurrentDir()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_dir", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the current selected file of the file dialog (empty if none).
*/
func (o *FileDialog) GetCurrentFile() string {
	log.Println("Calling FileDialog.GetCurrentFile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_file", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the current selected path (directory and file) of the file dialog (empty if none).
*/
func (o *FileDialog) GetCurrentPath() string {
	log.Println("Calling FileDialog.GetCurrentPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *FileDialog) GetFilters() *PoolStringArray {
	log.Println("Calling FileDialog.GetFilters()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_filters", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   Get the file dialog mode from the MODE_* enum.
*/
func (o *FileDialog) GetMode() int64 {
	log.Println("Calling FileDialog.GetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the vertical box container of the dialog, custom controls can be added to it.
*/
func (o *FileDialog) GetVbox() *VBoxContainer {
	log.Println("Calling FileDialog.GetVbox()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vbox", goArguments, "*VBoxContainer")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*VBoxContainer)

	return returnValue

}

/*
   Invalidate and update the current dialog content list.
*/
func (o *FileDialog) Invalidate() {
	log.Println("Calling FileDialog.Invalidate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "invalidate", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if the diaog allows show hidden files.
*/
func (o *FileDialog) IsShowingHiddenFiles() *bool {
	log.Println("Calling FileDialog.IsShowingHiddenFiles()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_showing_hidden_files", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Set the file access permission of the dialog(Must be one of [ACCESS_RESOURCES], [ACCESS_USERDATA] or [ACCESS_FILESYSTEM]).
*/
func (o *FileDialog) SetAccess(access int64) {
	log.Println("Calling FileDialog.SetAccess()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(access)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_access", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the current working directory of the file dialog.
*/
func (o *FileDialog) SetCurrentDir(dir string) {
	log.Println("Calling FileDialog.SetCurrentDir()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(dir)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_current_dir", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the current selected file name of the file dialog.
*/
func (o *FileDialog) SetCurrentFile(file string) {
	log.Println("Calling FileDialog.SetCurrentFile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(file)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_current_file", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the current selected file path of the file dialog.
*/
func (o *FileDialog) SetCurrentPath(path string) {
	log.Println("Calling FileDialog.SetCurrentPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_current_path", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *FileDialog) SetFilters(filters *PoolStringArray) {
	log.Println("Calling FileDialog.SetFilters()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(filters)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_filters", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the file dialog mode from the MODE_* enum.
*/
func (o *FileDialog) SetMode(mode int64) {
	log.Println("Calling FileDialog.SetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the dialog should show hidden files.
*/
func (o *FileDialog) SetShowHiddenFiles(show *bool) {
	log.Println("Calling FileDialog.SetShowHiddenFiles()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(show)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_show_hidden_files", goArguments, "")

	log.Println("Got return value!")

}

/*
   FileDialogImplementer is an interface for FileDialog objects.
   FileDialog is a preset dialog used to choose files and directories in the filesystem. It supports filter masks.
*/
type FileDialogImplementer interface {
	ConfirmationDialogImplementer

	AddFilter(filter string)

	ClearFilters()

	GetAccess() int64

	GetCurrentDir() string

	GetCurrentFile() string

	GetCurrentPath() string

	GetFilters() *PoolStringArray

	GetMode() int64

	GetVbox() *VBoxContainer

	Invalidate()

	IsShowingHiddenFiles() *bool

	SetAccess(access int64)

	SetCurrentDir(dir string)

	SetCurrentFile(file string)

	SetCurrentPath(path string)

	SetFilters(filters *PoolStringArray)

	SetMode(mode int64)

	SetShowHiddenFiles(show *bool)
}

/*
   Font contains a unicode compatible character set, as well as the ability to draw it with variable width, ascent, descent and kerning. For creating fonts from TTF files (or other font formats), see the editor support for fonts. TODO check wikipedia for graph of ascent/baseline/descent/height/etc.
*/
type Font struct {
	Resource
}

func (o *Font) baseClass() string {
	return "Font"
}

/*
   Draw "string" into a canvas item using the font at a given "pos" position, with "modulate" color, and optionally clipping the width. "pos" specifies the baseline, not the top. To draw from the top, [i]ascent[/i] must be added to the Y axis.
*/
func (o *Font) Draw(canvasItem *RID, pos *Vector2, string string, modulate *Color, clipW int64) {
	log.Println("Calling Font.Draw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(canvasItem)
	goArguments[1] = reflect.ValueOf(pos)
	goArguments[2] = reflect.ValueOf(string)
	goArguments[3] = reflect.ValueOf(modulate)
	goArguments[4] = reflect.ValueOf(clipW)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw", goArguments, "")

	log.Println("Got return value!")

}

/*
   Draw character "char" into a canvas item using the font at a given "pos" position, with "modulate" color, and optionally kerning if "next" is passed. clipping the width. "pos" specifies the baseline, not the top. To draw from the top, [i]ascent[/i] must be added to the Y axis. The width used by the character is returned, making this function useful for drawing strings character by character.
*/
func (o *Font) DrawChar(canvasItem *RID, pos *Vector2, char int64, next int64, modulate *Color) float64 {
	log.Println("Calling Font.DrawChar()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(canvasItem)
	goArguments[1] = reflect.ValueOf(pos)
	goArguments[2] = reflect.ValueOf(char)
	goArguments[3] = reflect.ValueOf(next)
	goArguments[4] = reflect.ValueOf(modulate)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "draw_char", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the font ascent (number of pixels above the baseline).
*/
func (o *Font) GetAscent() float64 {
	log.Println("Calling Font.GetAscent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ascent", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the font descent (number of pixels below the baseline).
*/
func (o *Font) GetDescent() float64 {
	log.Println("Calling Font.GetDescent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_descent", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the total font height (ascent plus descent) in pixels.
*/
func (o *Font) GetHeight() float64 {
	log.Println("Calling Font.GetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_height", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the size of a string, taking kerning and advance into account.
*/
func (o *Font) GetStringSize(string string) *Vector2 {
	log.Println("Calling Font.GetStringSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(string)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_string_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Font) IsDistanceFieldHint() *bool {
	log.Println("Calling Font.IsDistanceFieldHint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_distance_field_hint", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   After editing a font (changing size, ascent, char rects, etc.). Call this function to propagate changes to controls that might use it.
*/
func (o *Font) UpdateChanges() {
	log.Println("Calling Font.UpdateChanges()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "update_changes", goArguments, "")

	log.Println("Got return value!")

}

/*
   FontImplementer is an interface for Font objects.
   Font contains a unicode compatible character set, as well as the ability to draw it with variable width, ascent, descent and kerning. For creating fonts from TTF files (or other font formats), see the editor support for fonts. TODO check wikipedia for graph of ascent/baseline/descent/height/etc.
*/
type FontImplementer interface {
	ResourceImplementer

	Draw(canvasItem *RID, pos *Vector2, string string, modulate *Color, clipW int64)

	DrawChar(canvasItem *RID, pos *Vector2, char int64, next int64, modulate *Color) float64

	GetAscent() float64

	GetDescent() float64

	GetHeight() float64

	GetStringSize(string string) *Vector2

	IsDistanceFieldHint() *bool

	UpdateChanges()
}

/*
        In GDScript, functions are not [i]first-class objects[/i]. This means it is impossible to store them directly as variables, return them from another function, or pass them as arguments.
		However, by creating a [FuncRef] using the [method @GDScript.funcref] function, a reference to a function in a given object can be created, passed around and called.
*/
type FuncRef struct {
	Reference
}

func (o *FuncRef) baseClass() string {
	return "FuncRef"
}

/*

 */
func (o *FuncRef) CallFunc() *Variant {
	log.Println("Calling FuncRef.CallFunc()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "call_func", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Set the name of the function to call on the object, without parentheses or any parameters.
*/
func (o *FuncRef) SetFunction(name string) {
	log.Println("Calling FuncRef.SetFunction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_function", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the object on which to call the referenced function. This object must be of a type actually inheriting from [Object], not a built-in type such as [int], [Vector2] or [Dictionary].
*/
func (o *FuncRef) SetInstance(instance *Object) {
	log.Println("Calling FuncRef.SetInstance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(instance)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_instance", goArguments, "")

	log.Println("Got return value!")

}

/*
        FuncRefImplementer is an interface for FuncRef objects.
        In GDScript, functions are not [i]first-class objects[/i]. This means it is impossible to store them directly as variables, return them from another function, or pass them as arguments.
		However, by creating a [FuncRef] using the [method @GDScript.funcref] function, a reference to a function in a given object can be created, passed around and called.
*/
type FuncRefImplementer interface {
	ReferenceImplementer

	CallFunc() *Variant

	SetFunction(name string)

	SetInstance(instance *Object)
}

/*
   Calling [method @GDScript.yield] within a function will cause that function to yield and return its current state as an object of this type. The yielded function call can then be resumed later by calling [method resume] on this state object.
*/
type GDFunctionState struct {
	Reference
}

func (o *GDFunctionState) baseClass() string {
	return "GDFunctionState"
}

/*
                Check whether the function call may be resumed. This is not the case if the function state was already resumed.
				If [code]extended_check[/code] is enabled, it also checks if the associated script and object still exist. The extended check is done in debug mode as part of [method GDFunctionState.resume], but you can use this if you know you may be trying to resume without knowing for sure the object and/or script have survived up to that point.
*/
func (o *GDFunctionState) IsValid(extendedCheck *bool) *bool {
	log.Println("Calling GDFunctionState.IsValid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(extendedCheck)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_valid", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
                Resume execution of the yielded function call.
				If handed an argument, return the argument from the [method @GDScript.yield] call in the yielded function call. You can pass e.g. an [Array] to hand multiple arguments.
				This function returns what the resumed function call returns, possibly another function state if yielded again.
*/
func (o *GDFunctionState) Resume(arg *Variant) *Variant {
	log.Println("Calling GDFunctionState.Resume()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "resume", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   GDFunctionStateImplementer is an interface for GDFunctionState objects.
   Calling [method @GDScript.yield] within a function will cause that function to yield and return its current state as an object of this type. The yielded function call can then be resumed later by calling [method resume] on this state object.
*/
type GDFunctionStateImplementer interface {
	ReferenceImplementer

	IsValid(extendedCheck *bool) *bool

	Resume(arg *Variant) *Variant
}

/*

 */
type GDNative struct {
	Reference
}

func (o *GDNative) baseClass() string {
	return "GDNative"
}

/*

 */
func (o *GDNative) CallNative(procedureName string, arguments string, arg2 *Array) *Variant {
	log.Println("Calling GDNative.CallNative()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(procedureName)
	goArguments[1] = reflect.ValueOf(arguments)
	goArguments[2] = reflect.ValueOf(arg2)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "call_native", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *GDNative) GetLibrary() *GDNativeLibrary {
	log.Println("Calling GDNative.GetLibrary()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_library", goArguments, "*GDNativeLibrary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*GDNativeLibrary)

	return returnValue

}

/*

 */
func (o *GDNative) Initialize() *bool {
	log.Println("Calling GDNative.Initialize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "initialize", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *GDNative) SetLibrary(library *GDNativeLibrary) {
	log.Println("Calling GDNative.SetLibrary()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(library)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_library", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GDNative) Terminate() *bool {
	log.Println("Calling GDNative.Terminate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "terminate", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   GDNativeImplementer is an interface for GDNative objects.

*/
type GDNativeImplementer interface {
	ReferenceImplementer

	CallNative(procedureName string, arguments string, arg2 *Array) *Variant

	GetLibrary() *GDNativeLibrary

	Initialize() *bool

	SetLibrary(library *GDNativeLibrary)

	Terminate() *bool
}

/*

 */
type GDNativeClass struct {
	Reference
}

func (o *GDNativeClass) baseClass() string {
	return "GDNativeClass"
}

/*

 */
func (o *GDNativeClass) New() *Variant {
	log.Println("Calling GDNativeClass.New()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "new", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   GDNativeClassImplementer is an interface for GDNativeClass objects.

*/
type GDNativeClassImplementer interface {
	ReferenceImplementer

	New() *Variant
}

/*

 */
type GDNativeLibrary struct {
	Resource
}

func (o *GDNativeLibrary) baseClass() string {
	return "GDNativeLibrary"
}

/*

 */
func (o *GDNativeLibrary) GetLibraryPath(platform string) string {
	log.Println("Calling GDNativeLibrary.GetLibraryPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(platform)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_library_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *GDNativeLibrary) SetLibraryPath(platform string, path string) {
	log.Println("Calling GDNativeLibrary.SetLibraryPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(platform)
	goArguments[1] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_library_path", goArguments, "")

	log.Println("Got return value!")

}

/*
   GDNativeLibraryImplementer is an interface for GDNativeLibrary objects.

*/
type GDNativeLibraryImplementer interface {
	ResourceImplementer

	GetLibraryPath(platform string) string

	SetLibraryPath(platform string, path string)
}

/*

 */
type GDScript struct {
	Script
}

func (o *GDScript) baseClass() string {
	return "GDScript"
}

/*

 */
func (o *GDScript) GetAsByteCode() *PoolByteArray {
	log.Println("Calling GDScript.GetAsByteCode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_as_byte_code", goArguments, "*PoolByteArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolByteArray)

	return returnValue

}

/*

 */
func (o *GDScript) New() *Object {
	log.Println("Calling GDScript.New()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "new", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*
   GDScriptImplementer is an interface for GDScript objects.

*/
type GDScriptImplementer interface {
	ScriptImplementer

	GetAsByteCode() *PoolByteArray

	New() *Object
}

/*

 */
type GIProbe struct {
	VisualInstance
}

func (o *GIProbe) baseClass() string {
	return "GIProbe"
}

/*

 */
func (o *GIProbe) Bake(fromNode *Node, createVisualDebug *bool) {
	log.Println("Calling GIProbe.Bake()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(fromNode)
	goArguments[1] = reflect.ValueOf(createVisualDebug)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "bake", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbe) DebugBake() {
	log.Println("Calling GIProbe.DebugBake()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "debug_bake", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbe) GetBias() float64 {
	log.Println("Calling GIProbe.GetBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bias", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *GIProbe) GetDynamicRange() int64 {
	log.Println("Calling GIProbe.GetDynamicRange()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dynamic_range", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *GIProbe) GetEnergy() float64 {
	log.Println("Calling GIProbe.GetEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_energy", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *GIProbe) GetExtents() *Vector3 {
	log.Println("Calling GIProbe.GetExtents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_extents", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *GIProbe) GetNormalBias() float64 {
	log.Println("Calling GIProbe.GetNormalBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_normal_bias", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *GIProbe) GetProbeData() *GIProbeData {
	log.Println("Calling GIProbe.GetProbeData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_probe_data", goArguments, "*GIProbeData")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*GIProbeData)

	return returnValue

}

/*

 */
func (o *GIProbe) GetPropagation() float64 {
	log.Println("Calling GIProbe.GetPropagation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_propagation", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *GIProbe) GetSubdiv() int64 {
	log.Println("Calling GIProbe.GetSubdiv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_subdiv", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *GIProbe) IsCompressed() *bool {
	log.Println("Calling GIProbe.IsCompressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_compressed", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *GIProbe) IsInterior() *bool {
	log.Println("Calling GIProbe.IsInterior()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_interior", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *GIProbe) SetBias(max float64) {
	log.Println("Calling GIProbe.SetBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(max)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bias", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbe) SetCompress(enable *bool) {
	log.Println("Calling GIProbe.SetCompress()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_compress", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbe) SetDynamicRange(max int64) {
	log.Println("Calling GIProbe.SetDynamicRange()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(max)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dynamic_range", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbe) SetEnergy(max float64) {
	log.Println("Calling GIProbe.SetEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(max)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_energy", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbe) SetExtents(extents *Vector3) {
	log.Println("Calling GIProbe.SetExtents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(extents)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_extents", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbe) SetInterior(enable *bool) {
	log.Println("Calling GIProbe.SetInterior()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_interior", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbe) SetNormalBias(max float64) {
	log.Println("Calling GIProbe.SetNormalBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(max)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_normal_bias", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbe) SetProbeData(data *GIProbeData) {
	log.Println("Calling GIProbe.SetProbeData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_probe_data", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbe) SetPropagation(max float64) {
	log.Println("Calling GIProbe.SetPropagation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(max)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_propagation", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbe) SetSubdiv(subdiv int64) {
	log.Println("Calling GIProbe.SetSubdiv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(subdiv)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_subdiv", goArguments, "")

	log.Println("Got return value!")

}

/*
   GIProbeImplementer is an interface for GIProbe objects.

*/
type GIProbeImplementer interface {
	VisualInstanceImplementer

	Bake(fromNode *Node, createVisualDebug *bool)

	DebugBake()

	GetBias() float64

	GetDynamicRange() int64

	GetEnergy() float64

	GetExtents() *Vector3

	GetNormalBias() float64

	GetProbeData() *GIProbeData

	GetPropagation() float64

	GetSubdiv() int64

	IsCompressed() *bool

	IsInterior() *bool

	SetBias(max float64)

	SetCompress(enable *bool)

	SetDynamicRange(max int64)

	SetEnergy(max float64)

	SetExtents(extents *Vector3)

	SetInterior(enable *bool)

	SetNormalBias(max float64)

	SetProbeData(data *GIProbeData)

	SetPropagation(max float64)

	SetSubdiv(subdiv int64)
}

/*

 */
type GIProbeData struct {
	Resource
}

func (o *GIProbeData) baseClass() string {
	return "GIProbeData"
}

/*

 */
func (o *GIProbeData) GetBias() float64 {
	log.Println("Calling GIProbeData.GetBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bias", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *GIProbeData) GetBounds() *Rect3 {
	log.Println("Calling GIProbeData.GetBounds()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bounds", goArguments, "*Rect3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect3)

	return returnValue

}

/*

 */
func (o *GIProbeData) GetCellSize() float64 {
	log.Println("Calling GIProbeData.GetCellSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cell_size", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *GIProbeData) GetDynamicData() *PoolIntArray {
	log.Println("Calling GIProbeData.GetDynamicData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dynamic_data", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*

 */
func (o *GIProbeData) GetDynamicRange() int64 {
	log.Println("Calling GIProbeData.GetDynamicRange()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dynamic_range", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *GIProbeData) GetEnergy() float64 {
	log.Println("Calling GIProbeData.GetEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_energy", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *GIProbeData) GetNormalBias() float64 {
	log.Println("Calling GIProbeData.GetNormalBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_normal_bias", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *GIProbeData) GetPropagation() float64 {
	log.Println("Calling GIProbeData.GetPropagation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_propagation", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *GIProbeData) GetToCellXform() *Transform {
	log.Println("Calling GIProbeData.GetToCellXform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_to_cell_xform", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*

 */
func (o *GIProbeData) IsCompressed() *bool {
	log.Println("Calling GIProbeData.IsCompressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_compressed", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *GIProbeData) IsInterior() *bool {
	log.Println("Calling GIProbeData.IsInterior()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_interior", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *GIProbeData) SetBias(bias float64) {
	log.Println("Calling GIProbeData.SetBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bias)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bias", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbeData) SetBounds(bounds *Rect3) {
	log.Println("Calling GIProbeData.SetBounds()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bounds)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bounds", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbeData) SetCellSize(cellSize float64) {
	log.Println("Calling GIProbeData.SetCellSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(cellSize)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cell_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbeData) SetCompress(compress *bool) {
	log.Println("Calling GIProbeData.SetCompress()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(compress)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_compress", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbeData) SetDynamicData(dynamicData *PoolIntArray) {
	log.Println("Calling GIProbeData.SetDynamicData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(dynamicData)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dynamic_data", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbeData) SetDynamicRange(dynamicRange int64) {
	log.Println("Calling GIProbeData.SetDynamicRange()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(dynamicRange)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dynamic_range", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbeData) SetEnergy(energy float64) {
	log.Println("Calling GIProbeData.SetEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(energy)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_energy", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbeData) SetInterior(interior *bool) {
	log.Println("Calling GIProbeData.SetInterior()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(interior)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_interior", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbeData) SetNormalBias(bias float64) {
	log.Println("Calling GIProbeData.SetNormalBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bias)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_normal_bias", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbeData) SetPropagation(propagation float64) {
	log.Println("Calling GIProbeData.SetPropagation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(propagation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_propagation", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GIProbeData) SetToCellXform(toCellXform *Transform) {
	log.Println("Calling GIProbeData.SetToCellXform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(toCellXform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_to_cell_xform", goArguments, "")

	log.Println("Got return value!")

}

/*
   GIProbeDataImplementer is an interface for GIProbeData objects.

*/
type GIProbeDataImplementer interface {
	ResourceImplementer

	GetBias() float64

	GetBounds() *Rect3

	GetCellSize() float64

	GetDynamicData() *PoolIntArray

	GetDynamicRange() int64

	GetEnergy() float64

	GetNormalBias() float64

	GetPropagation() float64

	GetToCellXform() *Transform

	IsCompressed() *bool

	IsInterior() *bool

	SetBias(bias float64)

	SetBounds(bounds *Rect3)

	SetCellSize(cellSize float64)

	SetCompress(compress *bool)

	SetDynamicData(dynamicData *PoolIntArray)

	SetDynamicRange(dynamicRange int64)

	SetEnergy(energy float64)

	SetInterior(interior *bool)

	SetNormalBias(bias float64)

	SetPropagation(propagation float64)

	SetToCellXform(toCellXform *Transform)
}

/*

 */
type Generic6DOFJoint struct {
	Joint
}

func (o *Generic6DOFJoint) baseClass() string {
	return "Generic6DOFJoint"
}

/*

 */
func (o *Generic6DOFJoint) GetFlagX(flag int64) *bool {
	log.Println("Calling Generic6DOFJoint.GetFlagX()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flag)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_flag_x", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Generic6DOFJoint) GetFlagY(flag int64) *bool {
	log.Println("Calling Generic6DOFJoint.GetFlagY()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flag)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_flag_y", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Generic6DOFJoint) GetFlagZ(flag int64) *bool {
	log.Println("Calling Generic6DOFJoint.GetFlagZ()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flag)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_flag_z", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Generic6DOFJoint) GetParamX(param int64) float64 {
	log.Println("Calling Generic6DOFJoint.GetParamX()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_param_x", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Generic6DOFJoint) GetParamY(param int64) float64 {
	log.Println("Calling Generic6DOFJoint.GetParamY()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_param_y", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Generic6DOFJoint) GetParamZ(param int64) float64 {
	log.Println("Calling Generic6DOFJoint.GetParamZ()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_param_z", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Generic6DOFJoint) SetFlagX(flag int64, value *bool) {
	log.Println("Calling Generic6DOFJoint.SetFlagX()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(flag)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flag_x", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Generic6DOFJoint) SetFlagY(flag int64, value *bool) {
	log.Println("Calling Generic6DOFJoint.SetFlagY()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(flag)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flag_y", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Generic6DOFJoint) SetFlagZ(flag int64, value *bool) {
	log.Println("Calling Generic6DOFJoint.SetFlagZ()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(flag)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flag_z", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Generic6DOFJoint) SetParamX(param int64, value float64) {
	log.Println("Calling Generic6DOFJoint.SetParamX()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(param)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_param_x", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Generic6DOFJoint) SetParamY(param int64, value float64) {
	log.Println("Calling Generic6DOFJoint.SetParamY()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(param)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_param_y", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Generic6DOFJoint) SetParamZ(param int64, value float64) {
	log.Println("Calling Generic6DOFJoint.SetParamZ()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(param)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_param_z", goArguments, "")

	log.Println("Got return value!")

}

/*
   Generic6DOFJointImplementer is an interface for Generic6DOFJoint objects.

*/
type Generic6DOFJointImplementer interface {
	JointImplementer

	GetFlagX(flag int64) *bool

	GetFlagY(flag int64) *bool

	GetFlagZ(flag int64) *bool

	GetParamX(param int64) float64

	GetParamY(param int64) float64

	GetParamZ(param int64) float64

	SetFlagX(flag int64, value *bool)

	SetFlagY(flag int64, value *bool)

	SetFlagZ(flag int64, value *bool)

	SetParamX(param int64, value float64)

	SetParamY(param int64, value float64)

	SetParamZ(param int64, value float64)
}

/*

 */
type Geometry struct {
	Object
}

func (o *Geometry) baseClass() string {
	return "Geometry"
}

/*

 */
func (o *Geometry) BuildBoxPlanes(extents *Vector3) *Array {
	log.Println("Calling Geometry.BuildBoxPlanes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(extents)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "build_box_planes", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *Geometry) BuildCapsulePlanes(radius float64, height float64, sides int64, lats int64, axis int64) *Array {
	log.Println("Calling Geometry.BuildCapsulePlanes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(radius)
	goArguments[1] = reflect.ValueOf(height)
	goArguments[2] = reflect.ValueOf(sides)
	goArguments[3] = reflect.ValueOf(lats)
	goArguments[4] = reflect.ValueOf(axis)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "build_capsule_planes", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *Geometry) BuildCylinderPlanes(radius float64, height float64, sides int64, axis int64) *Array {
	log.Println("Calling Geometry.BuildCylinderPlanes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(radius)
	goArguments[1] = reflect.ValueOf(height)
	goArguments[2] = reflect.ValueOf(sides)
	goArguments[3] = reflect.ValueOf(axis)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "build_cylinder_planes", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *Geometry) GetClosestPointToSegment(point *Vector3, s1 *Vector3, s2 *Vector3) *Vector3 {
	log.Println("Calling Geometry.GetClosestPointToSegment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(point)
	goArguments[1] = reflect.ValueOf(s1)
	goArguments[2] = reflect.ValueOf(s2)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_point_to_segment", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *Geometry) GetClosestPointToSegment2D(point *Vector2, s1 *Vector2, s2 *Vector2) *Vector2 {
	log.Println("Calling Geometry.GetClosestPointToSegment2D()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(point)
	goArguments[1] = reflect.ValueOf(s1)
	goArguments[2] = reflect.ValueOf(s2)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_point_to_segment_2d", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Geometry) GetClosestPointToSegmentUncapped(point *Vector3, s1 *Vector3, s2 *Vector3) *Vector3 {
	log.Println("Calling Geometry.GetClosestPointToSegmentUncapped()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(point)
	goArguments[1] = reflect.ValueOf(s1)
	goArguments[2] = reflect.ValueOf(s2)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_point_to_segment_uncapped", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *Geometry) GetClosestPointToSegmentUncapped2D(point *Vector2, s1 *Vector2, s2 *Vector2) *Vector2 {
	log.Println("Calling Geometry.GetClosestPointToSegmentUncapped2D()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(point)
	goArguments[1] = reflect.ValueOf(s1)
	goArguments[2] = reflect.ValueOf(s2)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_point_to_segment_uncapped_2d", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Geometry) GetClosestPointsBetweenSegments(p1 *Vector3, p2 *Vector3, q1 *Vector3, q2 *Vector3) *PoolVector3Array {
	log.Println("Calling Geometry.GetClosestPointsBetweenSegments()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(p1)
	goArguments[1] = reflect.ValueOf(p2)
	goArguments[2] = reflect.ValueOf(q1)
	goArguments[3] = reflect.ValueOf(q2)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_points_between_segments", goArguments, "*PoolVector3Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector3Array)

	return returnValue

}

/*

 */
func (o *Geometry) GetClosestPointsBetweenSegments2D(p1 *Vector2, q1 *Vector2, p2 *Vector2, q2 *Vector2) *PoolVector2Array {
	log.Println("Calling Geometry.GetClosestPointsBetweenSegments2D()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(p1)
	goArguments[1] = reflect.ValueOf(q1)
	goArguments[2] = reflect.ValueOf(p2)
	goArguments[3] = reflect.ValueOf(q2)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_points_between_segments_2d", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*

 */
func (o *Geometry) GetUv84NormalBit(normal *Vector3) int64 {
	log.Println("Calling Geometry.GetUv84NormalBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(normal)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_uv84_normal_bit", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Geometry) MakeAtlas(sizes *PoolVector2Array) *Dictionary {
	log.Println("Calling Geometry.MakeAtlas()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(sizes)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "make_atlas", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*

 */
func (o *Geometry) PointIsInsideTriangle(point *Vector2, a *Vector2, b *Vector2, c *Vector2) *bool {
	log.Println("Calling Geometry.PointIsInsideTriangle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(point)
	goArguments[1] = reflect.ValueOf(a)
	goArguments[2] = reflect.ValueOf(b)
	goArguments[3] = reflect.ValueOf(c)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "point_is_inside_triangle", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Geometry) RayIntersectsTriangle(from *Vector3, dir *Vector3, a *Vector3, b *Vector3, c *Vector3) *Variant {
	log.Println("Calling Geometry.RayIntersectsTriangle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(dir)
	goArguments[2] = reflect.ValueOf(a)
	goArguments[3] = reflect.ValueOf(b)
	goArguments[4] = reflect.ValueOf(c)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "ray_intersects_triangle", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *Geometry) SegmentIntersectsCircle(segmentFrom *Vector2, segmentTo *Vector2, circlePos *Vector2, circleRadius float64) float64 {
	log.Println("Calling Geometry.SegmentIntersectsCircle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(segmentFrom)
	goArguments[1] = reflect.ValueOf(segmentTo)
	goArguments[2] = reflect.ValueOf(circlePos)
	goArguments[3] = reflect.ValueOf(circleRadius)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "segment_intersects_circle", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Geometry) SegmentIntersectsConvex(from *Vector3, to *Vector3, planes *Array) *PoolVector3Array {
	log.Println("Calling Geometry.SegmentIntersectsConvex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(to)
	goArguments[2] = reflect.ValueOf(planes)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "segment_intersects_convex", goArguments, "*PoolVector3Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector3Array)

	return returnValue

}

/*

 */
func (o *Geometry) SegmentIntersectsCylinder(from *Vector3, to *Vector3, height float64, radius float64) *PoolVector3Array {
	log.Println("Calling Geometry.SegmentIntersectsCylinder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(to)
	goArguments[2] = reflect.ValueOf(height)
	goArguments[3] = reflect.ValueOf(radius)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "segment_intersects_cylinder", goArguments, "*PoolVector3Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector3Array)

	return returnValue

}

/*

 */
func (o *Geometry) SegmentIntersectsSegment2D(fromA *Vector2, toA *Vector2, fromB *Vector2, toB *Vector2) *Variant {
	log.Println("Calling Geometry.SegmentIntersectsSegment2D()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(fromA)
	goArguments[1] = reflect.ValueOf(toA)
	goArguments[2] = reflect.ValueOf(fromB)
	goArguments[3] = reflect.ValueOf(toB)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "segment_intersects_segment_2d", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *Geometry) SegmentIntersectsSphere(from *Vector3, to *Vector3, spos *Vector3, sradius float64) *PoolVector3Array {
	log.Println("Calling Geometry.SegmentIntersectsSphere()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(to)
	goArguments[2] = reflect.ValueOf(spos)
	goArguments[3] = reflect.ValueOf(sradius)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "segment_intersects_sphere", goArguments, "*PoolVector3Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector3Array)

	return returnValue

}

/*

 */
func (o *Geometry) SegmentIntersectsTriangle(from *Vector3, to *Vector3, a *Vector3, b *Vector3, c *Vector3) *Variant {
	log.Println("Calling Geometry.SegmentIntersectsTriangle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(to)
	goArguments[2] = reflect.ValueOf(a)
	goArguments[3] = reflect.ValueOf(b)
	goArguments[4] = reflect.ValueOf(c)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "segment_intersects_triangle", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *Geometry) TriangulatePolygon(polygon *PoolVector2Array) *PoolIntArray {
	log.Println("Calling Geometry.TriangulatePolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(polygon)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "triangulate_polygon", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*
   GeometryImplementer is an interface for Geometry objects.

*/
type GeometryImplementer interface {
	ObjectImplementer

	BuildBoxPlanes(extents *Vector3) *Array

	BuildCapsulePlanes(radius float64, height float64, sides int64, lats int64, axis int64) *Array

	BuildCylinderPlanes(radius float64, height float64, sides int64, axis int64) *Array

	GetClosestPointToSegment(point *Vector3, s1 *Vector3, s2 *Vector3) *Vector3

	GetClosestPointToSegment2D(point *Vector2, s1 *Vector2, s2 *Vector2) *Vector2

	GetClosestPointToSegmentUncapped(point *Vector3, s1 *Vector3, s2 *Vector3) *Vector3

	GetClosestPointToSegmentUncapped2D(point *Vector2, s1 *Vector2, s2 *Vector2) *Vector2

	GetClosestPointsBetweenSegments(p1 *Vector3, p2 *Vector3, q1 *Vector3, q2 *Vector3) *PoolVector3Array

	GetClosestPointsBetweenSegments2D(p1 *Vector2, q1 *Vector2, p2 *Vector2, q2 *Vector2) *PoolVector2Array

	GetUv84NormalBit(normal *Vector3) int64

	MakeAtlas(sizes *PoolVector2Array) *Dictionary

	PointIsInsideTriangle(point *Vector2, a *Vector2, b *Vector2, c *Vector2) *bool

	RayIntersectsTriangle(from *Vector3, dir *Vector3, a *Vector3, b *Vector3, c *Vector3) *Variant

	SegmentIntersectsCircle(segmentFrom *Vector2, segmentTo *Vector2, circlePos *Vector2, circleRadius float64) float64

	SegmentIntersectsConvex(from *Vector3, to *Vector3, planes *Array) *PoolVector3Array

	SegmentIntersectsCylinder(from *Vector3, to *Vector3, height float64, radius float64) *PoolVector3Array

	SegmentIntersectsSegment2D(fromA *Vector2, toA *Vector2, fromB *Vector2, toB *Vector2) *Variant

	SegmentIntersectsSphere(from *Vector3, to *Vector3, spos *Vector3, sradius float64) *PoolVector3Array

	SegmentIntersectsTriangle(from *Vector3, to *Vector3, a *Vector3, b *Vector3, c *Vector3) *Variant

	TriangulatePolygon(polygon *PoolVector2Array) *PoolIntArray
}

/*
   Base node for geometry based visual instances. Shares some common functionality like visibility and custom materials.
*/
type GeometryInstance struct {
	VisualInstance
}

func (o *GeometryInstance) baseClass() string {
	return "GeometryInstance"
}

/*

 */
func (o *GeometryInstance) GetCastShadowsSetting() int64 {
	log.Println("Calling GeometryInstance.GetCastShadowsSetting()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cast_shadows_setting", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *GeometryInstance) GetExtraCullMargin() float64 {
	log.Println("Calling GeometryInstance.GetExtraCullMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_extra_cull_margin", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *GeometryInstance) GetFlag(flag int64) *bool {
	log.Println("Calling GeometryInstance.GetFlag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flag)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_flag", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *GeometryInstance) GetLodMaxDistance() float64 {
	log.Println("Calling GeometryInstance.GetLodMaxDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_lod_max_distance", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *GeometryInstance) GetLodMaxHysteresis() float64 {
	log.Println("Calling GeometryInstance.GetLodMaxHysteresis()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_lod_max_hysteresis", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *GeometryInstance) GetLodMinDistance() float64 {
	log.Println("Calling GeometryInstance.GetLodMinDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_lod_min_distance", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *GeometryInstance) GetLodMinHysteresis() float64 {
	log.Println("Calling GeometryInstance.GetLodMinHysteresis()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_lod_min_hysteresis", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the material override for the whole geometry.
*/
func (o *GeometryInstance) GetMaterialOverride() *Material {
	log.Println("Calling GeometryInstance.GetMaterialOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_material_override", goArguments, "*Material")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Material)

	return returnValue

}

/*

 */
func (o *GeometryInstance) SetCastShadowsSetting(shadowCastingSetting int64) {
	log.Println("Calling GeometryInstance.SetCastShadowsSetting()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shadowCastingSetting)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cast_shadows_setting", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GeometryInstance) SetExtraCullMargin(margin float64) {
	log.Println("Calling GeometryInstance.SetExtraCullMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_extra_cull_margin", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GeometryInstance) SetFlag(flag int64, value *bool) {
	log.Println("Calling GeometryInstance.SetFlag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(flag)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flag", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GeometryInstance) SetLodMaxDistance(mode float64) {
	log.Println("Calling GeometryInstance.SetLodMaxDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_lod_max_distance", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GeometryInstance) SetLodMaxHysteresis(mode float64) {
	log.Println("Calling GeometryInstance.SetLodMaxHysteresis()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_lod_max_hysteresis", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GeometryInstance) SetLodMinDistance(mode float64) {
	log.Println("Calling GeometryInstance.SetLodMinDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_lod_min_distance", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GeometryInstance) SetLodMinHysteresis(mode float64) {
	log.Println("Calling GeometryInstance.SetLodMinHysteresis()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_lod_min_hysteresis", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the material override for the whole geometry.
*/
func (o *GeometryInstance) SetMaterialOverride(material *Material) {
	log.Println("Calling GeometryInstance.SetMaterialOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(material)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_material_override", goArguments, "")

	log.Println("Got return value!")

}

/*
   GeometryInstanceImplementer is an interface for GeometryInstance objects.
   Base node for geometry based visual instances. Shares some common functionality like visibility and custom materials.
*/
type GeometryInstanceImplementer interface {
	VisualInstanceImplementer

	GetCastShadowsSetting() int64

	GetExtraCullMargin() float64

	GetFlag(flag int64) *bool

	GetLodMaxDistance() float64

	GetLodMaxHysteresis() float64

	GetLodMinDistance() float64

	GetLodMinHysteresis() float64

	GetMaterialOverride() *Material

	SetCastShadowsSetting(shadowCastingSetting int64)

	SetExtraCullMargin(margin float64)

	SetFlag(flag int64, value *bool)

	SetLodMaxDistance(mode float64)

	SetLodMaxHysteresis(mode float64)

	SetLodMinDistance(mode float64)

	SetLodMinHysteresis(mode float64)

	SetMaterialOverride(material *Material)
}

/*
   Given a set of colors, this node will interpolate them in order, meaning, that if you have color 1, color 2 and color3, the ramp will interpolate (generate the colors between two colors) from color 1 to color 2 and from color 2 to color 3. Initially the ramp will have 2 colors (black and white), one (black) at ramp lower offset offset 0 and the other (white) at the ramp higher offset 1.
*/
type Gradient struct {
	Resource
}

func (o *Gradient) baseClass() string {
	return "Gradient"
}

/*
   Adds the specified color to the end of the ramp, with the specified offset
*/
func (o *Gradient) AddPoint(offset float64, color *Color) {
	log.Println("Calling Gradient.AddPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(offset)
	goArguments[1] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_point", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns the color of the ramp color at index [i]point[/i]
*/
func (o *Gradient) GetColor(point int64) *Color {
	log.Println("Calling Gradient.GetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(point)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   Returns the colors in the ramp
*/
func (o *Gradient) GetColors() *PoolColorArray {
	log.Println("Calling Gradient.GetColors()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_colors", goArguments, "*PoolColorArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolColorArray)

	return returnValue

}

/*
   Returns the offset of the ramp color at index [i]point[/i]
*/
func (o *Gradient) GetOffset(point int64) float64 {
	log.Println("Calling Gradient.GetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(point)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns the offsets for the colors in this ramp
*/
func (o *Gradient) GetOffsets() *PoolRealArray {
	log.Println("Calling Gradient.GetOffsets()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_offsets", goArguments, "*PoolRealArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolRealArray)

	return returnValue

}

/*
   Returns the number of colors in the ramp
*/
func (o *Gradient) GetPointCount() int64 {
	log.Println("Calling Gradient.GetPointCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the interpolated color specified by [i]offset[/i]
*/
func (o *Gradient) Interpolate(offset float64) *Color {
	log.Println("Calling Gradient.Interpolate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "interpolate", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   Removes the color at the index [i]offset[/i]
*/
func (o *Gradient) RemovePoint(offset int64) {
	log.Println("Calling Gradient.RemovePoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_point", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the color of the ramp color at index [i]point[/i]
*/
func (o *Gradient) SetColor(point int64, color *Color) {
	log.Println("Calling Gradient.SetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(point)
	goArguments[1] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_color", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the colors for the specified amount of elements. Calling this function with a different number of elements than previously defined causes the ramp to resize its colors and offsets array to accommodate the new elements.
*/
func (o *Gradient) SetColors(colors *PoolColorArray) {
	log.Println("Calling Gradient.SetColors()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(colors)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_colors", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the offset for the ramp color at index [i]point[/i]
*/
func (o *Gradient) SetOffset(point int64, offset float64) {
	log.Println("Calling Gradient.SetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(point)
	goArguments[1] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the offset for the specified amount of elements. Calling this function with a different number of elements than previously defined causes the ramp to resize its colors and offsets array to accommodate the new elements, all new colors will be black by default.
*/
func (o *Gradient) SetOffsets(offsets *PoolRealArray) {
	log.Println("Calling Gradient.SetOffsets()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offsets)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_offsets", goArguments, "")

	log.Println("Got return value!")

}

/*
   GradientImplementer is an interface for Gradient objects.
   Given a set of colors, this node will interpolate them in order, meaning, that if you have color 1, color 2 and color3, the ramp will interpolate (generate the colors between two colors) from color 1 to color 2 and from color 2 to color 3. Initially the ramp will have 2 colors (black and white), one (black) at ramp lower offset offset 0 and the other (white) at the ramp higher offset 1.
*/
type GradientImplementer interface {
	ResourceImplementer

	AddPoint(offset float64, color *Color)

	GetColor(point int64) *Color

	GetColors() *PoolColorArray

	GetOffset(point int64) float64

	GetOffsets() *PoolRealArray

	GetPointCount() int64

	Interpolate(offset float64) *Color

	RemovePoint(offset int64)

	SetColor(point int64, color *Color)

	SetColors(colors *PoolColorArray)

	SetOffset(point int64, offset float64)

	SetOffsets(offsets *PoolRealArray)
}

/*

 */
type GradientTexture struct {
	Texture
}

func (o *GradientTexture) baseClass() string {
	return "GradientTexture"
}

/*

 */
func (o *GradientTexture) GetGradient() *Gradient {
	log.Println("Calling GradientTexture.GetGradient()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gradient", goArguments, "*Gradient")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Gradient)

	return returnValue

}

/*

 */
func (o *GradientTexture) SetGradient(gradient *Gradient) {
	log.Println("Calling GradientTexture.SetGradient()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(gradient)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gradient", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GradientTexture) SetWidth(width int64) {
	log.Println("Calling GradientTexture.SetWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(width)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_width", goArguments, "")

	log.Println("Got return value!")

}

/*
   GradientTextureImplementer is an interface for GradientTexture objects.

*/
type GradientTextureImplementer interface {
	TextureImplementer

	GetGradient() *Gradient

	SetGradient(gradient *Gradient)

	SetWidth(width int64)
}

/*
        GraphEdit manages the showing of GraphNodes it contains, as well as connections and disconnections between them. Signals are sent for each of these two events. Disconnection between GraphNodes slots is disabled by default.
		It is greatly advised to enable low processor usage mode (see [method OS.set_low_processor_usage_mode]) when using GraphEdits.
*/
type GraphEdit struct {
	Control
}

func (o *GraphEdit) baseClass() string {
	return "GraphEdit"
}

/*
   Create a connection between 'from_port' slot of 'from' GraphNode and 'to_port' slot of 'to' GraphNode. If the connection already exists, no connection is created.
*/
func (o *GraphEdit) ConnectNode(from string, fromPort int64, to string, toPort int64) int64 {
	log.Println("Calling GraphEdit.ConnectNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(fromPort)
	goArguments[2] = reflect.ValueOf(to)
	goArguments[3] = reflect.ValueOf(toPort)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "connect_node", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Remove the connection between 'from_port' slot of 'from' GraphNode and 'to_port' slot of 'to' GraphNode, if connection exists.
*/
func (o *GraphEdit) DisconnectNode(from string, fromPort int64, to string, toPort int64) {
	log.Println("Calling GraphEdit.DisconnectNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(fromPort)
	goArguments[2] = reflect.ValueOf(to)
	goArguments[3] = reflect.ValueOf(toPort)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "disconnect_node", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return an Array containing the list of connections. A connection consists in a structure of the form {from_slot: 0, from: "GraphNode name 0", to_slot: 1, to: "GraphNode name 1" }
*/
func (o *GraphEdit) GetConnectionList() *Array {
	log.Println("Calling GraphEdit.GetConnectionList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_list", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Return the scroll offset.
*/
func (o *GraphEdit) GetScrollOfs() *Vector2 {
	log.Println("Calling GraphEdit.GetScrollOfs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scroll_ofs", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *GraphEdit) GetSnap() int64 {
	log.Println("Calling GraphEdit.GetSnap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_snap", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the current zoom value.
*/
func (o *GraphEdit) GetZoom() float64 {
	log.Println("Calling GraphEdit.GetZoom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_zoom", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return true if the 'from_port' slot of 'from' GraphNode is connected to the 'to_port' slot of 'to' GraphNode.
*/
func (o *GraphEdit) IsNodeConnected(from string, fromPort int64, to string, toPort int64) *bool {
	log.Println("Calling GraphEdit.IsNodeConnected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(fromPort)
	goArguments[2] = reflect.ValueOf(to)
	goArguments[3] = reflect.ValueOf(toPort)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_node_connected", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true is the disconnection of connections is enable in the visual GraphEdit. False otherwise.
*/
func (o *GraphEdit) IsRightDisconnectsEnabled() *bool {
	log.Println("Calling GraphEdit.IsRightDisconnectsEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_right_disconnects_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *GraphEdit) IsUsingSnap() *bool {
	log.Println("Calling GraphEdit.IsUsingSnap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_using_snap", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Enable the disconnection of existing connections in the visual GraphEdit by left-clicking a connection and releasing into the void.
*/
func (o *GraphEdit) SetRightDisconnects(enable *bool) {
	log.Println("Calling GraphEdit.SetRightDisconnects()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_right_disconnects", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GraphEdit) SetScrollOfs(ofs *Vector2) {
	log.Println("Calling GraphEdit.SetScrollOfs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ofs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_scroll_ofs", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GraphEdit) SetSelected(node *Node) {
	log.Println("Calling GraphEdit.SetSelected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_selected", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GraphEdit) SetSnap(pixels int64) {
	log.Println("Calling GraphEdit.SetSnap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pixels)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_snap", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GraphEdit) SetUseSnap(enable *bool) {
	log.Println("Calling GraphEdit.SetUseSnap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_snap", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the zoom value of the GraphEdit. Zoom value is between [0.01; 1.728].
*/
func (o *GraphEdit) SetZoom(pZoom float64) {
	log.Println("Calling GraphEdit.SetZoom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pZoom)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_zoom", goArguments, "")

	log.Println("Got return value!")

}

/*
        GraphEditImplementer is an interface for GraphEdit objects.
        GraphEdit manages the showing of GraphNodes it contains, as well as connections and disconnections between them. Signals are sent for each of these two events. Disconnection between GraphNodes slots is disabled by default.
		It is greatly advised to enable low processor usage mode (see [method OS.set_low_processor_usage_mode]) when using GraphEdits.
*/
type GraphEditImplementer interface {
	ControlImplementer

	ConnectNode(from string, fromPort int64, to string, toPort int64) int64

	DisconnectNode(from string, fromPort int64, to string, toPort int64)

	GetConnectionList() *Array

	GetScrollOfs() *Vector2

	GetSnap() int64

	GetZoom() float64

	IsNodeConnected(from string, fromPort int64, to string, toPort int64) *bool

	IsRightDisconnectsEnabled() *bool

	IsUsingSnap() *bool

	SetRightDisconnects(enable *bool)

	SetScrollOfs(ofs *Vector2)

	SetSelected(node *Node)

	SetSnap(pixels int64)

	SetUseSnap(enable *bool)

	SetZoom(pZoom float64)
}

/*
   A GraphNode is a container defined by a title. It can have 1 or more input and output slots, which can be enabled (shown) or disabled (not shown) and have different (incompatible) types. Colors can also be assigned to slots. A tuple of input and output slots is defined for each GUI element included in the GraphNode. Input and output connections are left and right slots, but only enabled slots are counted as connections.
*/
type GraphNode struct {
	Container
}

func (o *GraphNode) baseClass() string {
	return "GraphNode"
}

/*
   Disable all input and output slots of the GraphNode.
*/
func (o *GraphNode) ClearAllSlots() {
	log.Println("Calling GraphNode.ClearAllSlots()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_all_slots", goArguments, "")

	log.Println("Got return value!")

}

/*
   Disable input and output slot whose index is 'idx'.
*/
func (o *GraphNode) ClearSlot(idx int64) {
	log.Println("Calling GraphNode.ClearSlot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_slot", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the color of the input connection 'idx'.
*/
func (o *GraphNode) GetConnectionInputColor(idx int64) *Color {
	log.Println("Calling GraphNode.GetConnectionInputColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_input_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   Return the number of enabled input slots (connections) to the GraphNode.
*/
func (o *GraphNode) GetConnectionInputCount() int64 {
	log.Println("Calling GraphNode.GetConnectionInputCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_input_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the position of the input connection 'idx'.
*/
func (o *GraphNode) GetConnectionInputPos(idx int64) *Vector2 {
	log.Println("Calling GraphNode.GetConnectionInputPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_input_pos", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the type of the input connection 'idx'.
*/
func (o *GraphNode) GetConnectionInputType(idx int64) int64 {
	log.Println("Calling GraphNode.GetConnectionInputType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_input_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the color of the output connection 'idx'.
*/
func (o *GraphNode) GetConnectionOutputColor(idx int64) *Color {
	log.Println("Calling GraphNode.GetConnectionOutputColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_output_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   Return the number of enabled output slots (connections) of the GraphNode.
*/
func (o *GraphNode) GetConnectionOutputCount() int64 {
	log.Println("Calling GraphNode.GetConnectionOutputCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_output_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the position of the output connection 'idx'.
*/
func (o *GraphNode) GetConnectionOutputPos(idx int64) *Vector2 {
	log.Println("Calling GraphNode.GetConnectionOutputPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_output_pos", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the type of the output connection 'idx'.
*/
func (o *GraphNode) GetConnectionOutputType(idx int64) int64 {
	log.Println("Calling GraphNode.GetConnectionOutputType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_output_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the offset of the GraphNode.
*/
func (o *GraphNode) GetOffset() *Vector2 {
	log.Println("Calling GraphNode.GetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *GraphNode) GetOverlay() int64 {
	log.Println("Calling GraphNode.GetOverlay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_overlay", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the color set to 'idx' left (input) slot.
*/
func (o *GraphNode) GetSlotColorLeft(idx int64) *Color {
	log.Println("Calling GraphNode.GetSlotColorLeft()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_slot_color_left", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   Return the color set to 'idx' right (output) slot.
*/
func (o *GraphNode) GetSlotColorRight(idx int64) *Color {
	log.Println("Calling GraphNode.GetSlotColorRight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_slot_color_right", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   Return the (integer) type of left (input) 'idx' slot.
*/
func (o *GraphNode) GetSlotTypeLeft(idx int64) int64 {
	log.Println("Calling GraphNode.GetSlotTypeLeft()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_slot_type_left", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the (integer) type of right (output) 'idx' slot.
*/
func (o *GraphNode) GetSlotTypeRight(idx int64) int64 {
	log.Println("Calling GraphNode.GetSlotTypeRight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_slot_type_right", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the title of the GraphNode.
*/
func (o *GraphNode) GetTitle() string {
	log.Println("Calling GraphNode.GetTitle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_title", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Returns true if the close button is shown. False otherwise.
*/
func (o *GraphNode) IsCloseButtonVisible() *bool {
	log.Println("Calling GraphNode.IsCloseButtonVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_close_button_visible", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *GraphNode) IsComment() *bool {
	log.Println("Calling GraphNode.IsComment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_comment", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *GraphNode) IsResizeable() *bool {
	log.Println("Calling GraphNode.IsResizeable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_resizeable", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *GraphNode) IsSelected() *bool {
	log.Println("Calling GraphNode.IsSelected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_selected", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if left (input) slot 'idx' is enabled. False otherwise.
*/
func (o *GraphNode) IsSlotEnabledLeft(idx int64) *bool {
	log.Println("Calling GraphNode.IsSlotEnabledLeft()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_slot_enabled_left", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if right (output) slot 'idx' is enabled. False otherwise.
*/
func (o *GraphNode) IsSlotEnabledRight(idx int64) *bool {
	log.Println("Calling GraphNode.IsSlotEnabledRight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_slot_enabled_right", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *GraphNode) SetComment(comment *bool) {
	log.Println("Calling GraphNode.SetComment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(comment)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_comment", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the offset of the GraphNode.
*/
func (o *GraphNode) SetOffset(offset *Vector2) {
	log.Println("Calling GraphNode.SetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_offset", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GraphNode) SetOverlay(overlay int64) {
	log.Println("Calling GraphNode.SetOverlay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(overlay)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_overlay", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GraphNode) SetResizeable(resizeable *bool) {
	log.Println("Calling GraphNode.SetResizeable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(resizeable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_resizeable", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GraphNode) SetSelected(selected *bool) {
	log.Println("Calling GraphNode.SetSelected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(selected)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_selected", goArguments, "")

	log.Println("Got return value!")

}

/*
   Show the close button on the GraphNode if 'show' is true (disabled by default). If enabled, a connection on the signal close_request is needed for the close button to work.
*/
func (o *GraphNode) SetShowCloseButton(show *bool) {
	log.Println("Calling GraphNode.SetShowCloseButton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(show)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_show_close_button", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GraphNode) SetSlot(idx int64, enableLeft *bool, typeLeft int64, colorLeft *Color, enableRight *bool, typeRight int64, colorRight *Color, customLeft *Texture, customRight *Texture) {
	log.Println("Calling GraphNode.SetSlot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 9, 9)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(enableLeft)
	goArguments[2] = reflect.ValueOf(typeLeft)
	goArguments[3] = reflect.ValueOf(colorLeft)
	goArguments[4] = reflect.ValueOf(enableRight)
	goArguments[5] = reflect.ValueOf(typeRight)
	goArguments[6] = reflect.ValueOf(colorRight)
	goArguments[7] = reflect.ValueOf(customLeft)
	goArguments[8] = reflect.ValueOf(customRight)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_slot", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the title of the GraphNode.
*/
func (o *GraphNode) SetTitle(title string) {
	log.Println("Calling GraphNode.SetTitle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(title)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_title", goArguments, "")

	log.Println("Got return value!")

}

/*
   GraphNodeImplementer is an interface for GraphNode objects.
   A GraphNode is a container defined by a title. It can have 1 or more input and output slots, which can be enabled (shown) or disabled (not shown) and have different (incompatible) types. Colors can also be assigned to slots. A tuple of input and output slots is defined for each GUI element included in the GraphNode. Input and output connections are left and right slots, but only enabled slots are counted as connections.
*/
type GraphNodeImplementer interface {
	ContainerImplementer

	ClearAllSlots()

	ClearSlot(idx int64)

	GetConnectionInputColor(idx int64) *Color

	GetConnectionInputCount() int64

	GetConnectionInputPos(idx int64) *Vector2

	GetConnectionInputType(idx int64) int64

	GetConnectionOutputColor(idx int64) *Color

	GetConnectionOutputCount() int64

	GetConnectionOutputPos(idx int64) *Vector2

	GetConnectionOutputType(idx int64) int64

	GetOffset() *Vector2

	GetOverlay() int64

	GetSlotColorLeft(idx int64) *Color

	GetSlotColorRight(idx int64) *Color

	GetSlotTypeLeft(idx int64) int64

	GetSlotTypeRight(idx int64) int64

	GetTitle() string

	IsCloseButtonVisible() *bool

	IsComment() *bool

	IsResizeable() *bool

	IsSelected() *bool

	IsSlotEnabledLeft(idx int64) *bool

	IsSlotEnabledRight(idx int64) *bool

	SetComment(comment *bool)

	SetOffset(offset *Vector2)

	SetOverlay(overlay int64)

	SetResizeable(resizeable *bool)

	SetSelected(selected *bool)

	SetShowCloseButton(show *bool)

	SetSlot(idx int64, enableLeft *bool, typeLeft int64, colorLeft *Color, enableRight *bool, typeRight int64, colorRight *Color, customLeft *Texture, customRight *Texture)

	SetTitle(title string)
}

/*
   Grid container will arrange its children in a grid like structure, the grid columns are specified using the [method set_columns] method and the number of rows will be equal to the number of children in the container divided by the number of columns, for example: if the container has 5 children, and 2 columns, there will be 3 rows in the container. Notice that grid layout will preserve the columns and rows for every size of the container.
*/
type GridContainer struct {
	Container
}

func (o *GridContainer) baseClass() string {
	return "GridContainer"
}

/*
   Returns the number of columns in this container
*/
func (o *GridContainer) GetColumns() int64 {
	log.Println("Calling GridContainer.GetColumns()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_columns", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Sets the numbers of columns in the container, then reorder its children to accommodate the new layout
*/
func (o *GridContainer) SetColumns(columns int64) {
	log.Println("Calling GridContainer.SetColumns()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(columns)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_columns", goArguments, "")

	log.Println("Got return value!")

}

/*
   GridContainerImplementer is an interface for GridContainer objects.
   Grid container will arrange its children in a grid like structure, the grid columns are specified using the [method set_columns] method and the number of rows will be equal to the number of children in the container divided by the number of columns, for example: if the container has 5 children, and 2 columns, there will be 3 rows in the container. Notice that grid layout will preserve the columns and rows for every size of the container.
*/
type GridContainerImplementer interface {
	ContainerImplementer

	GetColumns() int64

	SetColumns(columns int64)
}

/*

 */
type GridMap struct {
	Spatial
}

func (o *GridMap) baseClass() string {
	return "GridMap"
}

/*

 */
func (o *GridMap) Clear() {
	log.Println("Calling GridMap.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GridMap) GetCellItem(x int64, y int64, z int64) int64 {
	log.Println("Calling GridMap.GetCellItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(x)
	goArguments[1] = reflect.ValueOf(y)
	goArguments[2] = reflect.ValueOf(z)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cell_item", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *GridMap) GetCellItemOrientation(x int64, y int64, z int64) int64 {
	log.Println("Calling GridMap.GetCellItemOrientation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(x)
	goArguments[1] = reflect.ValueOf(y)
	goArguments[2] = reflect.ValueOf(z)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cell_item_orientation", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *GridMap) GetCellSize() *Vector3 {
	log.Println("Calling GridMap.GetCellSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cell_size", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *GridMap) GetCenterX() *bool {
	log.Println("Calling GridMap.GetCenterX()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_center_x", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *GridMap) GetCenterY() *bool {
	log.Println("Calling GridMap.GetCenterY()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_center_y", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *GridMap) GetCenterZ() *bool {
	log.Println("Calling GridMap.GetCenterZ()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_center_z", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *GridMap) GetMeshes() *Array {
	log.Println("Calling GridMap.GetMeshes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_meshes", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *GridMap) GetOctantSize() int64 {
	log.Println("Calling GridMap.GetOctantSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_octant_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *GridMap) GetTheme() *MeshLibrary {
	log.Println("Calling GridMap.GetTheme()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_theme", goArguments, "*MeshLibrary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*MeshLibrary)

	return returnValue

}

/*

 */
func (o *GridMap) ResourceChanged(resource *Resource) {
	log.Println("Calling GridMap.ResourceChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(resource)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "resource_changed", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GridMap) SetCellItem(x int64, y int64, z int64, item int64, orientation int64) {
	log.Println("Calling GridMap.SetCellItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(x)
	goArguments[1] = reflect.ValueOf(y)
	goArguments[2] = reflect.ValueOf(z)
	goArguments[3] = reflect.ValueOf(item)
	goArguments[4] = reflect.ValueOf(orientation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cell_item", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GridMap) SetCellSize(size *Vector3) {
	log.Println("Calling GridMap.SetCellSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cell_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GridMap) SetCenterX(enable *bool) {
	log.Println("Calling GridMap.SetCenterX()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_center_x", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GridMap) SetCenterY(enable *bool) {
	log.Println("Calling GridMap.SetCenterY()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_center_y", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GridMap) SetCenterZ(enable *bool) {
	log.Println("Calling GridMap.SetCenterZ()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_center_z", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GridMap) SetClip(enabled *bool, clipabove *bool, floor int64, axis int64) {
	log.Println("Calling GridMap.SetClip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(enabled)
	goArguments[1] = reflect.ValueOf(clipabove)
	goArguments[2] = reflect.ValueOf(floor)
	goArguments[3] = reflect.ValueOf(axis)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_clip", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GridMap) SetOctantSize(size int64) {
	log.Println("Calling GridMap.SetOctantSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_octant_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *GridMap) SetTheme(theme *MeshLibrary) {
	log.Println("Calling GridMap.SetTheme()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(theme)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_theme", goArguments, "")

	log.Println("Got return value!")

}

/*
   GridMapImplementer is an interface for GridMap objects.

*/
type GridMapImplementer interface {
	SpatialImplementer

	Clear()

	GetCellItem(x int64, y int64, z int64) int64

	GetCellItemOrientation(x int64, y int64, z int64) int64

	GetCellSize() *Vector3

	GetCenterX() *bool

	GetCenterY() *bool

	GetCenterZ() *bool

	GetMeshes() *Array

	GetOctantSize() int64

	GetTheme() *MeshLibrary

	ResourceChanged(resource *Resource)

	SetCellItem(x int64, y int64, z int64, item int64, orientation int64)

	SetCellSize(size *Vector3)

	SetCenterX(enable *bool)

	SetCenterY(enable *bool)

	SetCenterZ(enable *bool)

	SetClip(enabled *bool, clipabove *bool, floor int64, axis int64)

	SetOctantSize(size int64)

	SetTheme(theme *MeshLibrary)
}

/*
   Groove constraint for 2D physics. This is useful for making a body "slide" through a segment placed in another.
*/
type GrooveJoint2D struct {
	Joint2D
}

func (o *GrooveJoint2D) baseClass() string {
	return "GrooveJoint2D"
}

/*
   Set the final offset of the groove on body A.
*/
func (o *GrooveJoint2D) GetInitialOffset() float64 {
	log.Println("Calling GrooveJoint2D.GetInitialOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_initial_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the length of the groove.
*/
func (o *GrooveJoint2D) GetLength() float64 {
	log.Println("Calling GrooveJoint2D.GetLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_length", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the initial offset of the groove on body A.
*/
func (o *GrooveJoint2D) SetInitialOffset(offset float64) {
	log.Println("Calling GrooveJoint2D.SetInitialOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_initial_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the length of the groove.
*/
func (o *GrooveJoint2D) SetLength(length float64) {
	log.Println("Calling GrooveJoint2D.SetLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(length)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_length", goArguments, "")

	log.Println("Got return value!")

}

/*
   GrooveJoint2DImplementer is an interface for GrooveJoint2D objects.
   Groove constraint for 2D physics. This is useful for making a body "slide" through a segment placed in another.
*/
type GrooveJoint2DImplementer interface {
	Joint2DImplementer

	GetInitialOffset() float64

	GetLength() float64

	SetInitialOffset(offset float64)

	SetLength(length float64)
}

/*
   Horizontal box container. See [BoxContainer].
*/
type HBoxContainer struct {
	BoxContainer
}

func (o *HBoxContainer) baseClass() string {
	return "HBoxContainer"
}

/*
   HBoxContainerImplementer is an interface for HBoxContainer objects.
   Horizontal box container. See [BoxContainer].
*/
type HBoxContainerImplementer interface {
	BoxContainerImplementer
}

/*
   Horizontal scroll bar. See [ScrollBar]. This one goes from left (min) to right (max).
*/
type HScrollBar struct {
	ScrollBar
}

func (o *HScrollBar) baseClass() string {
	return "HScrollBar"
}

/*
   HScrollBarImplementer is an interface for HScrollBar objects.
   Horizontal scroll bar. See [ScrollBar]. This one goes from left (min) to right (max).
*/
type HScrollBarImplementer interface {
	ScrollBarImplementer
}

/*
   Horizontal separator. See [Separator]. It is used to separate objects vertically, though (but it looks horizontal!).
*/
type HSeparator struct {
	Separator
}

func (o *HSeparator) baseClass() string {
	return "HSeparator"
}

/*
   HSeparatorImplementer is an interface for HSeparator objects.
   Horizontal separator. See [Separator]. It is used to separate objects vertically, though (but it looks horizontal!).
*/
type HSeparatorImplementer interface {
	SeparatorImplementer
}

/*
   Horizontal slider. See [Slider]. This one goes from left (min) to right (max).
*/
type HSlider struct {
	Slider
}

func (o *HSlider) baseClass() string {
	return "HSlider"
}

/*
   HSliderImplementer is an interface for HSlider objects.
   Horizontal slider. See [Slider]. This one goes from left (min) to right (max).
*/
type HSliderImplementer interface {
	SliderImplementer
}

/*
   Horizontal split container. See [SplitContainer]. This goes from left to right.
*/
type HSplitContainer struct {
	SplitContainer
}

func (o *HSplitContainer) baseClass() string {
	return "HSplitContainer"
}

/*
   HSplitContainerImplementer is an interface for HSplitContainer objects.
   Horizontal split container. See [SplitContainer]. This goes from left to right.
*/
type HSplitContainerImplementer interface {
	SplitContainerImplementer
}

/*
        Hyper-text transfer protocol client. Supports SSL and SSL server certificate verification.
		Can be reused to connect to different hosts and make many requests.
*/
type HTTPClient struct {
	Reference
}

func (o *HTTPClient) baseClass() string {
	return "HTTPClient"
}

/*
   Cloces the current connection, allows for reusal of [HTTPClient].
*/
func (o *HTTPClient) Close() {
	log.Println("Calling HTTPClient.Close()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "close", goArguments, "")

	log.Println("Got return value!")

}

/*
                Connect to a host. This needs to be done before any requests are sent.
				The host should not have http:// prepended but will strip the protocol identifier if provided.
				verify_host will check the SSL identity of the host if set to true.
*/
func (o *HTTPClient) ConnectToHost(host string, port int64, useSsl *bool, verifyHost *bool) int64 {
	log.Println("Calling HTTPClient.ConnectToHost()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(host)
	goArguments[1] = reflect.ValueOf(port)
	goArguments[2] = reflect.ValueOf(useSsl)
	goArguments[3] = reflect.ValueOf(verifyHost)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "connect_to_host", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return current connection.
*/
func (o *HTTPClient) GetConnection() *StreamPeer {
	log.Println("Calling HTTPClient.GetConnection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection", goArguments, "*StreamPeer")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*StreamPeer)

	return returnValue

}

/*
   Return the response's body length.
*/
func (o *HTTPClient) GetResponseBodyLength() int64 {
	log.Println("Calling HTTPClient.GetResponseBodyLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_response_body_length", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the HTTP status code of the response.
*/
func (o *HTTPClient) GetResponseCode() int64 {
	log.Println("Calling HTTPClient.GetResponseCode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_response_code", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the response headers.
*/
func (o *HTTPClient) GetResponseHeaders() *PoolStringArray {
	log.Println("Calling HTTPClient.GetResponseHeaders()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_response_headers", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
                Returns all response headers as dictionary where the case-sensitivity of the keys and values is kept like the server delivers it. A value is a simple String, this string can have more than one value where "; " is used as separator.
				Structure: ("key":"value1; value2")
				Example: (content-length:12), (Content-Type:application/json; charset=UTF-8)
*/
func (o *HTTPClient) GetResponseHeadersAsDictionary() *Dictionary {
	log.Println("Calling HTTPClient.GetResponseHeadersAsDictionary()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_response_headers_as_dictionary", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*
   Returns a STATUS_* enum constant. Need to call [method poll] in order to get status updates.
*/
func (o *HTTPClient) GetStatus() int64 {
	log.Println("Calling HTTPClient.GetStatus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_status", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return whether this [HTTPClient] has a response available.
*/
func (o *HTTPClient) HasResponse() *bool {
	log.Println("Calling HTTPClient.HasResponse()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_response", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether blocking mode is enabled.
*/
func (o *HTTPClient) IsBlockingModeEnabled() *bool {
	log.Println("Calling HTTPClient.IsBlockingModeEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_blocking_mode_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether this [HTTPClient] has a response that is chunked.
*/
func (o *HTTPClient) IsResponseChunked() *bool {
	log.Println("Calling HTTPClient.IsResponseChunked()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_response_chunked", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   This needs to be called in order to have any request processed. Check results with [method get_status]
*/
func (o *HTTPClient) Poll() int64 {
	log.Println("Calling HTTPClient.Poll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "poll", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
                Generates a GET/POST application/x-www-form-urlencoded style query string from a provided dictionary, e.g.:
				[codeblock]
				var fields = {"username": "user", "password": "pass"}
				String queryString = httpClient.query_string_from_dict(fields)
				returns:= "username=user&password=pass"
				[/codeblock]
*/
func (o *HTTPClient) QueryStringFromDict(fields *Dictionary) string {
	log.Println("Calling HTTPClient.QueryStringFromDict()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(fields)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "query_string_from_dict", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Reads one chunk from the response.
*/
func (o *HTTPClient) ReadResponseBodyChunk() *PoolByteArray {
	log.Println("Calling HTTPClient.ReadResponseBodyChunk()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "read_response_body_chunk", goArguments, "*PoolByteArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolByteArray)

	return returnValue

}

/*
                Sends a request to the connected host. The url is what is normally behind the hostname, i.e. in [code]http://somehost.com/index.php[/code], url would be "index.php".
				Headers are HTTP request headers.
				To create a POST request with query strings to push to the server, do:
				[codeblock]
				var fields = {"username" : "user", "password" : "pass"}
				var queryString = httpClient.query_string_from_dict(fields)
				var headers = ["Content-Type: application/x-www-form-urlencoded", "Content-Length: " + str(queryString.length())]
				var result = httpClient.request(httpClient.METHOD_POST, "index.php", headers, queryString)
				[/codeblock]
*/
func (o *HTTPClient) Request(method int64, url string, headers *PoolStringArray, body string) int64 {
	log.Println("Calling HTTPClient.Request()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(method)
	goArguments[1] = reflect.ValueOf(url)
	goArguments[2] = reflect.ValueOf(headers)
	goArguments[3] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "request", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
                Sends a raw request to the connected host. The url is what is normally behind the hostname, i.e. in [code]http://somehost.com/index.php[/code], url would be "index.php".
				Headers are HTTP request headers.
				Sends body raw, as a byte array, does not encode it in any way.
*/
func (o *HTTPClient) RequestRaw(method int64, url string, headers *PoolStringArray, body *PoolByteArray) int64 {
	log.Println("Calling HTTPClient.RequestRaw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(method)
	goArguments[1] = reflect.ValueOf(url)
	goArguments[2] = reflect.ValueOf(headers)
	goArguments[3] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "request_raw", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Stub function
*/
func (o *HTTPClient) SendBodyData(body *PoolByteArray) int64 {
	log.Println("Calling HTTPClient.SendBodyData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "send_body_data", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Stub function
*/
func (o *HTTPClient) SendBodyText(body string) int64 {
	log.Println("Calling HTTPClient.SendBodyText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "send_body_text", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   If set to true, execution will block until all data is read from the response.
*/
func (o *HTTPClient) SetBlockingMode(enabled *bool) {
	log.Println("Calling HTTPClient.SetBlockingMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_blocking_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set connection to use, for this client.
*/
func (o *HTTPClient) SetConnection(connection *StreamPeer) {
	log.Println("Calling HTTPClient.SetConnection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(connection)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_connection", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the size of the buffer used and maximum bytes to read per iteration. see [method read_response_body_chunk]
*/
func (o *HTTPClient) SetReadChunkSize(bytes int64) {
	log.Println("Calling HTTPClient.SetReadChunkSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bytes)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_read_chunk_size", goArguments, "")

	log.Println("Got return value!")

}

/*
        HTTPClientImplementer is an interface for HTTPClient objects.
        Hyper-text transfer protocol client. Supports SSL and SSL server certificate verification.
		Can be reused to connect to different hosts and make many requests.
*/
type HTTPClientImplementer interface {
	ReferenceImplementer

	Close()

	ConnectToHost(host string, port int64, useSsl *bool, verifyHost *bool) int64

	GetConnection() *StreamPeer

	GetResponseBodyLength() int64

	GetResponseCode() int64

	GetResponseHeaders() *PoolStringArray

	GetResponseHeadersAsDictionary() *Dictionary

	GetStatus() int64

	HasResponse() *bool

	IsBlockingModeEnabled() *bool

	IsResponseChunked() *bool

	Poll() int64

	QueryStringFromDict(fields *Dictionary) string

	ReadResponseBodyChunk() *PoolByteArray

	Request(method int64, url string, headers *PoolStringArray, body string) int64

	RequestRaw(method int64, url string, headers *PoolStringArray, body *PoolByteArray) int64

	SendBodyData(body *PoolByteArray) int64

	SendBodyText(body string) int64

	SetBlockingMode(enabled *bool)

	SetConnection(connection *StreamPeer)

	SetReadChunkSize(bytes int64)
}

/*
        A Node with the ability to send HTTP requests. Uses a [HTTPClient] internally, supports HTTPS.
		Can be used to make HTTP requests or download files via HTTP.
*/
type HTTPRequest struct {
	Node
}

func (o *HTTPRequest) baseClass() string {
	return "HTTPRequest"
}

/*
   Cancel the current request.
*/
func (o *HTTPRequest) CancelRequest() {
	log.Println("Calling HTTPRequest.CancelRequest()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "cancel_request", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the response body length.
*/
func (o *HTTPRequest) GetBodySize() int64 {
	log.Println("Calling HTTPRequest.GetBodySize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_body_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return current body size limit.
*/
func (o *HTTPRequest) GetBodySizeLimit() int64 {
	log.Println("Calling HTTPRequest.GetBodySizeLimit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_body_size_limit", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the file this request will download into.
*/
func (o *HTTPRequest) GetDownloadFile() string {
	log.Println("Calling HTTPRequest.GetDownloadFile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_download_file", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the amount of bytes this HTTPRequest downloaded.
*/
func (o *HTTPRequest) GetDownloadedBytes() int64 {
	log.Println("Calling HTTPRequest.GetDownloadedBytes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_downloaded_bytes", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the current status of the underlying [HTTPClient].
*/
func (o *HTTPRequest) GetHttpClientStatus() int64 {
	log.Println("Calling HTTPRequest.GetHttpClientStatus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_http_client_status", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the maximum amount of redirects that will be followed.
*/
func (o *HTTPRequest) GetMaxRedirects() int64 {
	log.Println("Calling HTTPRequest.GetMaxRedirects()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_max_redirects", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Whether this request is using threads.
*/
func (o *HTTPRequest) IsUsingThreads() *bool {
	log.Println("Calling HTTPRequest.IsUsingThreads()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_using_threads", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *HTTPRequest) Request(url string, customHeaders *PoolStringArray, sslValidateDomain *bool, method int64, requestData string) int64 {
	log.Println("Calling HTTPRequest.Request()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(url)
	goArguments[1] = reflect.ValueOf(customHeaders)
	goArguments[2] = reflect.ValueOf(sslValidateDomain)
	goArguments[3] = reflect.ValueOf(method)
	goArguments[4] = reflect.ValueOf(requestData)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "request", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the response body size limit.
*/
func (o *HTTPRequest) SetBodySizeLimit(bytes int64) {
	log.Println("Calling HTTPRequest.SetBodySizeLimit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bytes)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_body_size_limit", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the file to download into. Outputs the response body into the file.
*/
func (o *HTTPRequest) SetDownloadFile(path string) {
	log.Println("Calling HTTPRequest.SetDownloadFile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_download_file", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the maximum amount of redirects the request will follow.
*/
func (o *HTTPRequest) SetMaxRedirects(amount int64) {
	log.Println("Calling HTTPRequest.SetMaxRedirects()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max_redirects", goArguments, "")

	log.Println("Got return value!")

}

/*
   Make this HTTPRequest use threads.
*/
func (o *HTTPRequest) SetUseThreads(enable *bool) {
	log.Println("Calling HTTPRequest.SetUseThreads()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_threads", goArguments, "")

	log.Println("Got return value!")

}

/*
        HTTPRequestImplementer is an interface for HTTPRequest objects.
        A Node with the ability to send HTTP requests. Uses a [HTTPClient] internally, supports HTTPS.
		Can be used to make HTTP requests or download files via HTTP.
*/
type HTTPRequestImplementer interface {
	NodeImplementer

	CancelRequest()

	GetBodySize() int64

	GetBodySizeLimit() int64

	GetDownloadFile() string

	GetDownloadedBytes() int64

	GetHttpClientStatus() int64

	GetMaxRedirects() int64

	IsUsingThreads() *bool

	Request(url string, customHeaders *PoolStringArray, sslValidateDomain *bool, method int64, requestData string) int64

	SetBodySizeLimit(bytes int64)

	SetDownloadFile(path string)

	SetMaxRedirects(amount int64)

	SetUseThreads(enable *bool)
}

/*

 */
type HingeJoint struct {
	Joint
}

func (o *HingeJoint) baseClass() string {
	return "HingeJoint"
}

/*

 */
func (o *HingeJoint) GetFlag(flag int64) *bool {
	log.Println("Calling HingeJoint.GetFlag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flag)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_flag", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *HingeJoint) GetParam(param int64) float64 {
	log.Println("Calling HingeJoint.GetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *HingeJoint) SetFlag(flag int64, enabled *bool) {
	log.Println("Calling HingeJoint.SetFlag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(flag)
	goArguments[1] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flag", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *HingeJoint) SetParam(param int64, value float64) {
	log.Println("Calling HingeJoint.SetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(param)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_param", goArguments, "")

	log.Println("Got return value!")

}

/*
   HingeJointImplementer is an interface for HingeJoint objects.

*/
type HingeJointImplementer interface {
	JointImplementer

	GetFlag(flag int64) *bool

	GetParam(param int64) float64

	SetFlag(flag int64, enabled *bool)

	SetParam(param int64, value float64)
}

/*
   IP contains some support functions for the IPv4 protocol. TCP/IP support is in different classes (see [StreamPeerTCP] and [TCP_Server]). IP provides hostname resolution support, both blocking and threaded.
*/
type IP struct {
	Object
}

func (o *IP) baseClass() string {
	return "IP"
}

/*

 */
func (o *IP) ClearCache(hostname string) {
	log.Println("Calling IP.ClearCache()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(hostname)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_cache", goArguments, "")

	log.Println("Got return value!")

}

/*
   Erase a queue ID, removing it from the queue if needed. This should be used after a queue is completed to free it and enable more queries to happen.
*/
func (o *IP) EraseResolveItem(id int64) {
	log.Println("Calling IP.EraseResolveItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "erase_resolve_item", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *IP) GetLocalAddresses() *Array {
	log.Println("Calling IP.GetLocalAddresses()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_local_addresses", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Return a resolved item address, or an empty string if an error happened or resolution didn't happen yet (see [method get_resolve_item_status]).
*/
func (o *IP) GetResolveItemAddress(id int64) string {
	log.Println("Calling IP.GetResolveItemAddress()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_resolve_item_address", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the status of hostname queued for resolving, given its queue ID. Returned status can be any of the RESOLVER_STATUS_* enumeration.
*/
func (o *IP) GetResolveItemStatus(id int64) int64 {
	log.Println("Calling IP.GetResolveItemStatus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_resolve_item_status", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Resolve a given hostname, blocking. Resolved hostname is returned as an IPv4 or IPv6 depending on "ip_type".
*/
func (o *IP) ResolveHostname(host string, ipType int64) string {
	log.Println("Calling IP.ResolveHostname()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(host)
	goArguments[1] = reflect.ValueOf(ipType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "resolve_hostname", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Create a queue item for resolving a given hostname to an IPv4 or IPv6 depending on "ip_type". The queue ID is returned, or RESOLVER_INVALID_ID on error.
*/
func (o *IP) ResolveHostnameQueueItem(host string, ipType int64) int64 {
	log.Println("Calling IP.ResolveHostnameQueueItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(host)
	goArguments[1] = reflect.ValueOf(ipType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "resolve_hostname_queue_item", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   IPImplementer is an interface for IP objects.
   IP contains some support functions for the IPv4 protocol. TCP/IP support is in different classes (see [StreamPeerTCP] and [TCP_Server]). IP provides hostname resolution support, both blocking and threaded.
*/
type IPImplementer interface {
	ObjectImplementer

	ClearCache(hostname string)

	EraseResolveItem(id int64)

	GetLocalAddresses() *Array

	GetResolveItemAddress(id int64) string

	GetResolveItemStatus(id int64) int64

	ResolveHostname(host string, ipType int64) string

	ResolveHostnameQueueItem(host string, ipType int64) int64
}

/*

 */
type IP_Unix struct {
	IP
}

func (o *IP_Unix) baseClass() string {
	return "IP_Unix"
}

/*
   IP_UnixImplementer is an interface for IP_Unix objects.

*/
type IP_UnixImplementer interface {
	IPImplementer
}

/*
   Native image datatype. Contains image data, which can be converted to a texture, and several functions to interact with it.
*/
type Image struct {
	Resource
}

func (o *Image) baseClass() string {
	return "Image"
}

/*
   Alpha-blends a "src_rect" [Rect2] from "src" [Image] to this [Image] on coordinates "dest".
*/
func (o *Image) BlendRect(src *Image, srcRect *Rect2, dst *Vector2) {
	log.Println("Calling Image.BlendRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(src)
	goArguments[1] = reflect.ValueOf(srcRect)
	goArguments[2] = reflect.ValueOf(dst)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "blend_rect", goArguments, "")

	log.Println("Got return value!")

}

/*
   Alpha-blends a "src_rect" [Rect2] from "src" [Image] to this [Image] using a "mask" [Image] on coordinates "dest". Alpha channels are required for both "src" and "mask", dest pixels and src pixels will blend if the corresponding mask pixel's alpha value is not 0. "src" [Image] and "mask" [Image] *must* have the same size (width and height) but they can have different formats
*/
func (o *Image) BlendRectMask(src *Image, mask *Image, srcRect *Rect2, dst *Vector2) {
	log.Println("Calling Image.BlendRectMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(src)
	goArguments[1] = reflect.ValueOf(mask)
	goArguments[2] = reflect.ValueOf(srcRect)
	goArguments[3] = reflect.ValueOf(dst)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "blend_rect_mask", goArguments, "")

	log.Println("Got return value!")

}

/*
   Copy a "src_rect" [Rect2] from "src" [Image] to this [Image] on coordinates "dest".
*/
func (o *Image) BlitRect(src *Image, srcRect *Rect2, dst *Vector2) {
	log.Println("Calling Image.BlitRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(src)
	goArguments[1] = reflect.ValueOf(srcRect)
	goArguments[2] = reflect.ValueOf(dst)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "blit_rect", goArguments, "")

	log.Println("Got return value!")

}

/*
   Blits a "src_rect" [Rect2] from "src" [Image] to this [Image] using a "mask" [Image] on coordinates "dest". Alpha channel is required for "mask", will copy src pixel onto dest if the corresponding mask pixel's alpha value is not 0. "src" [Image] and "mask" [Image] *must* have the same size (width and height) but they can have different formats
*/
func (o *Image) BlitRectMask(src *Image, mask *Image, srcRect *Rect2, dst *Vector2) {
	log.Println("Calling Image.BlitRectMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(src)
	goArguments[1] = reflect.ValueOf(mask)
	goArguments[2] = reflect.ValueOf(srcRect)
	goArguments[3] = reflect.ValueOf(dst)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "blit_rect_mask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) ClearMipmaps() {
	log.Println("Calling Image.ClearMipmaps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_mipmaps", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) Compress(mode int64, source int64, lossyQuality float64) int64 {
	log.Println("Calling Image.Compress()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(mode)
	goArguments[1] = reflect.ValueOf(source)
	goArguments[2] = reflect.ValueOf(lossyQuality)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "compress", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Image) Convert(format int64) {
	log.Println("Calling Image.Convert()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(format)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "convert", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) CopyFrom(src *Image) {
	log.Println("Calling Image.CopyFrom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(src)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "copy_from", goArguments, "")

	log.Println("Got return value!")

}

/*
   Create an empty image of a specific size and format.
*/
func (o *Image) Create(width int64, height int64, useMipmaps *bool, format int64) {
	log.Println("Calling Image.Create()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(width)
	goArguments[1] = reflect.ValueOf(height)
	goArguments[2] = reflect.ValueOf(useMipmaps)
	goArguments[3] = reflect.ValueOf(format)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "create", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) CreateFromData(width int64, height int64, useMipmaps *bool, format int64, data *PoolByteArray) {
	log.Println("Calling Image.CreateFromData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(width)
	goArguments[1] = reflect.ValueOf(height)
	goArguments[2] = reflect.ValueOf(useMipmaps)
	goArguments[3] = reflect.ValueOf(format)
	goArguments[4] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "create_from_data", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) Crop(width int64, height int64) {
	log.Println("Calling Image.Crop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(width)
	goArguments[1] = reflect.ValueOf(height)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "crop", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) Decompress() int64 {
	log.Println("Calling Image.Decompress()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "decompress", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Image) DetectAlpha() int64 {
	log.Println("Calling Image.DetectAlpha()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "detect_alpha", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Image) ExpandX2Hq2X() {
	log.Println("Calling Image.ExpandX2Hq2X()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "expand_x2_hq2x", goArguments, "")

	log.Println("Got return value!")

}

/*
   Fills an [Image] with a specified [Color]
*/
func (o *Image) Fill(color *Color) {
	log.Println("Calling Image.Fill()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "fill", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) FixAlphaEdges() {
	log.Println("Calling Image.FixAlphaEdges()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "fix_alpha_edges", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) FlipX() {
	log.Println("Calling Image.FlipX()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "flip_x", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) FlipY() {
	log.Println("Calling Image.FlipY()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "flip_y", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) GenerateMipmaps() int64 {
	log.Println("Calling Image.GenerateMipmaps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "generate_mipmaps", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the raw data of the [Image].
*/
func (o *Image) GetData() *PoolByteArray {
	log.Println("Calling Image.GetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_data", goArguments, "*PoolByteArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolByteArray)

	return returnValue

}

/*
   Return the format of the [Image], one of [Image].FORMAT_*.
*/
func (o *Image) GetFormat() int64 {
	log.Println("Calling Image.GetFormat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_format", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the height of the [Image].
*/
func (o *Image) GetHeight() int64 {
	log.Println("Calling Image.GetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_height", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Image) GetMipmapOffset(mipmap int64) int64 {
	log.Println("Calling Image.GetMipmapOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mipmap)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mipmap_offset", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Image) GetPixel(x int64, y int64) *Color {
	log.Println("Calling Image.GetPixel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(x)
	goArguments[1] = reflect.ValueOf(y)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pixel", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   Return a new [Image] that is a copy of "area" in this [Image].
*/
func (o *Image) GetRect(rect *Rect2) *Image {
	log.Println("Calling Image.GetRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rect)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rect", goArguments, "*Image")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Image)

	return returnValue

}

/*

 */
func (o *Image) GetSize() *Vector2 {
	log.Println("Calling Image.GetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the area of this [Image] that is used/visibly colored/opaque.
*/
func (o *Image) GetUsedRect() *Rect2 {
	log.Println("Calling Image.GetUsedRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_used_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   Return the width of the [Image].
*/
func (o *Image) GetWidth() int64 {
	log.Println("Calling Image.GetWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_width", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Image) HasMipmaps() *bool {
	log.Println("Calling Image.HasMipmaps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_mipmaps", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Image) IsCompressed() *bool {
	log.Println("Calling Image.IsCompressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_compressed", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Image) IsEmpty() *bool {
	log.Println("Calling Image.IsEmpty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_empty", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Image) IsInvisible() *bool {
	log.Println("Calling Image.IsInvisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_invisible", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Load an [Image].
*/
func (o *Image) Load(path string) int64 {
	log.Println("Calling Image.Load()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "load", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Image) Lock() {
	log.Println("Calling Image.Lock()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "lock", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) NormalmapToXy() {
	log.Println("Calling Image.NormalmapToXy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "normalmap_to_xy", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) PremultiplyAlpha() {
	log.Println("Calling Image.PremultiplyAlpha()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "premultiply_alpha", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) Resize(width int64, height int64, interpolation int64) {
	log.Println("Calling Image.Resize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(width)
	goArguments[1] = reflect.ValueOf(height)
	goArguments[2] = reflect.ValueOf(interpolation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "resize", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) ResizeToPo2(square *bool) {
	log.Println("Calling Image.ResizeToPo2()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(square)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "resize_to_po2", goArguments, "")

	log.Println("Got return value!")

}

/*
   Save this [Image] as a png.
*/
func (o *Image) SavePng(path string) int64 {
	log.Println("Calling Image.SavePng()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "save_png", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Image) SetPixel(x int64, y int64, color *Color) {
	log.Println("Calling Image.SetPixel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(x)
	goArguments[1] = reflect.ValueOf(y)
	goArguments[2] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pixel", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) ShrinkX2() {
	log.Println("Calling Image.ShrinkX2()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "shrink_x2", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) SrgbToLinear() {
	log.Println("Calling Image.SrgbToLinear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "srgb_to_linear", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Image) Unlock() {
	log.Println("Calling Image.Unlock()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "unlock", goArguments, "")

	log.Println("Got return value!")

}

/*
   ImageImplementer is an interface for Image objects.
   Native image datatype. Contains image data, which can be converted to a texture, and several functions to interact with it.
*/
type ImageImplementer interface {
	ResourceImplementer

	BlendRect(src *Image, srcRect *Rect2, dst *Vector2)

	BlendRectMask(src *Image, mask *Image, srcRect *Rect2, dst *Vector2)

	BlitRect(src *Image, srcRect *Rect2, dst *Vector2)

	BlitRectMask(src *Image, mask *Image, srcRect *Rect2, dst *Vector2)

	ClearMipmaps()

	Compress(mode int64, source int64, lossyQuality float64) int64

	Convert(format int64)

	CopyFrom(src *Image)

	Create(width int64, height int64, useMipmaps *bool, format int64)

	CreateFromData(width int64, height int64, useMipmaps *bool, format int64, data *PoolByteArray)

	Crop(width int64, height int64)

	Decompress() int64

	DetectAlpha() int64

	ExpandX2Hq2X()

	Fill(color *Color)

	FixAlphaEdges()

	FlipX()

	FlipY()

	GenerateMipmaps() int64

	GetData() *PoolByteArray

	GetFormat() int64

	GetHeight() int64

	GetMipmapOffset(mipmap int64) int64

	GetPixel(x int64, y int64) *Color

	GetRect(rect *Rect2) *Image

	GetSize() *Vector2

	GetUsedRect() *Rect2

	GetWidth() int64

	HasMipmaps() *bool

	IsCompressed() *bool

	IsEmpty() *bool

	IsInvisible() *bool

	Load(path string) int64

	Lock()

	NormalmapToXy()

	PremultiplyAlpha()

	Resize(width int64, height int64, interpolation int64)

	ResizeToPo2(square *bool)

	SavePng(path string) int64

	SetPixel(x int64, y int64, color *Color)

	ShrinkX2()

	SrgbToLinear()

	Unlock()
}

/*
   A [Texture] based on an [Image]. Can be created from an [Image].
*/
type ImageTexture struct {
	Texture
}

func (o *ImageTexture) baseClass() string {
	return "ImageTexture"
}

/*
                Create a new [ImageTexture] with "width" and "height".
				"format" one of [Image].FORMAT_*.
				"flags" one or more of [Texture].FLAG_*.
*/
func (o *ImageTexture) Create(width int64, height int64, format int64, flags int64) {
	log.Println("Calling ImageTexture.Create()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(width)
	goArguments[1] = reflect.ValueOf(height)
	goArguments[2] = reflect.ValueOf(format)
	goArguments[3] = reflect.ValueOf(flags)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "create", goArguments, "")

	log.Println("Got return value!")

}

/*
   Create a new [ImageTexture] from an [Image] with "flags" from [Texture].FLAG_*.
*/
func (o *ImageTexture) CreateFromImage(image *Image, flags int64) {
	log.Println("Calling ImageTexture.CreateFromImage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(image)
	goArguments[1] = reflect.ValueOf(flags)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "create_from_image", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the format of the [ImageTexture], one of [Image].FORMAT_*.
*/
func (o *ImageTexture) GetFormat() int64 {
	log.Println("Calling ImageTexture.GetFormat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_format", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the storage quality for [ImageTexture].STORAGE_COMPRESS_LOSSY.
*/
func (o *ImageTexture) GetLossyStorageQuality() float64 {
	log.Println("Calling ImageTexture.GetLossyStorageQuality()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_lossy_storage_quality", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the storage type. One of [ImageTexture].STORAGE_*.
*/
func (o *ImageTexture) GetStorage() int64 {
	log.Println("Calling ImageTexture.GetStorage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_storage", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Load an [ImageTexure].
*/
func (o *ImageTexture) Load(path string) {
	log.Println("Calling ImageTexture.Load()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "load", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the [Image] of this [ImageTexture].
*/
func (o *ImageTexture) SetData(image *Image) {
	log.Println("Calling ImageTexture.SetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(image)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_data", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the storage quality in case of [ImageTexture].STORAGE_COMPRESS_LOSSY.
*/
func (o *ImageTexture) SetLossyStorageQuality(quality float64) {
	log.Println("Calling ImageTexture.SetLossyStorageQuality()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(quality)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_lossy_storage_quality", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ImageTexture) SetSizeOverride(size *Vector2) {
	log.Println("Calling ImageTexture.SetSizeOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_size_override", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the storage type. One of [ImageTexture].STORAGE_*.
*/
func (o *ImageTexture) SetStorage(mode int64) {
	log.Println("Calling ImageTexture.SetStorage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_storage", goArguments, "")

	log.Println("Got return value!")

}

/*
   ImageTextureImplementer is an interface for ImageTexture objects.
   A [Texture] based on an [Image]. Can be created from an [Image].
*/
type ImageTextureImplementer interface {
	TextureImplementer

	Create(width int64, height int64, format int64, flags int64)

	CreateFromImage(image *Image, flags int64)

	GetFormat() int64

	GetLossyStorageQuality() float64

	GetStorage() int64

	Load(path string)

	SetData(image *Image)

	SetLossyStorageQuality(quality float64)

	SetSizeOverride(size *Vector2)

	SetStorage(mode int64)
}

/*

 */
type ImmediateGeometry struct {
	GeometryInstance
}

func (o *ImmediateGeometry) baseClass() string {
	return "ImmediateGeometry"
}

/*
   Simple helper to draw a uvsphere, with given latitudes, longitude and radius.
*/
func (o *ImmediateGeometry) AddSphere(lats int64, lons int64, radius float64, addUv *bool) {
	log.Println("Calling ImmediateGeometry.AddSphere()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(lats)
	goArguments[1] = reflect.ValueOf(lons)
	goArguments[2] = reflect.ValueOf(radius)
	goArguments[3] = reflect.ValueOf(addUv)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_sphere", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a vertex with the currently set color/uv/etc.
*/
func (o *ImmediateGeometry) AddVertex(pos *Vector3) {
	log.Println("Calling ImmediateGeometry.AddVertex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_vertex", goArguments, "")

	log.Println("Got return value!")

}

/*
                Begin drawing (And optionally pass a texture override). When done call end(). For more information on how this works, search for glBegin() glEnd() references.
			For the type of primitive, use the [Mesh].PRIMITIVE_* enumerations.
*/
func (o *ImmediateGeometry) Begin(primitive int64, texture *Texture) {
	log.Println("Calling ImmediateGeometry.Begin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(primitive)
	goArguments[1] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "begin", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear everything that was drawn using begin/end.
*/
func (o *ImmediateGeometry) Clear() {
	log.Println("Calling ImmediateGeometry.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Call this when done adding a batch of geometry, otherwise it can't be displayed.
*/
func (o *ImmediateGeometry) End() {
	log.Println("Calling ImmediateGeometry.End()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "end", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the color that the next vertex will use to be drawn.
*/
func (o *ImmediateGeometry) SetColor(color *Color) {
	log.Println("Calling ImmediateGeometry.SetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_color", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the normal that the next vertex will use to be drawn.
*/
func (o *ImmediateGeometry) SetNormal(normal *Vector3) {
	log.Println("Calling ImmediateGeometry.SetNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(normal)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_normal", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the tangent (and binormal facing) that the next vertex will use to be drawn.
*/
func (o *ImmediateGeometry) SetTangent(tangent *Plane) {
	log.Println("Calling ImmediateGeometry.SetTangent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tangent)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tangent", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the UV that the next vertex will use to be drawn.
*/
func (o *ImmediateGeometry) SetUv(uv *Vector2) {
	log.Println("Calling ImmediateGeometry.SetUv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(uv)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_uv", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the second layer of UV that the next vertex will use to be drawn.
*/
func (o *ImmediateGeometry) SetUv2(uv *Vector2) {
	log.Println("Calling ImmediateGeometry.SetUv2()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(uv)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_uv2", goArguments, "")

	log.Println("Got return value!")

}

/*
   ImmediateGeometryImplementer is an interface for ImmediateGeometry objects.

*/
type ImmediateGeometryImplementer interface {
	GeometryInstanceImplementer

	AddSphere(lats int64, lons int64, radius float64, addUv *bool)

	AddVertex(pos *Vector3)

	Begin(primitive int64, texture *Texture)

	Clear()

	End()

	SetColor(color *Color)

	SetNormal(normal *Vector3)

	SetTangent(tangent *Plane)

	SetUv(uv *Vector2)

	SetUv2(uv *Vector2)
}

/*
   A Singleton that deals with inputs. This includes key presses, mouse buttons and movement, joypads, and input actions.
*/
type Input struct {
	Object
}

func (o *Input) baseClass() string {
	return "Input"
}

/*
   This will simulate pressing the specificed action.
*/
func (o *Input) ActionPress(action string) {
	log.Println("Calling Input.ActionPress()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "action_press", goArguments, "")

	log.Println("Got return value!")

}

/*
   If the specified action is already pressed, this will release it.
*/
func (o *Input) ActionRelease(action string) {
	log.Println("Calling Input.ActionRelease()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "action_release", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a new mapping entry (in SDL2 format) to the mapping database. Optionally update already connected devices.
*/
func (o *Input) AddJoyMapping(mapping string, updateExisting *bool) {
	log.Println("Calling Input.AddJoyMapping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(mapping)
	goArguments[1] = reflect.ValueOf(updateExisting)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_joy_mapping", goArguments, "")

	log.Println("Got return value!")

}

/*
   If the device has an accelerometer, this will return the movement.
*/
func (o *Input) GetAccelerometer() *Vector3 {
	log.Println("Calling Input.GetAccelerometer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_accelerometer", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Returns an [Array] containing the device IDs of all currently connected joypads.
*/
func (o *Input) GetConnectedJoypads() *Array {
	log.Println("Calling Input.GetConnectedJoypads()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connected_joypads", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *Input) GetGravity() *Vector3 {
	log.Println("Calling Input.GetGravity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gravity", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   If the device has a gyroscope, this will return the rate of rotation in rad/s around a device's x, y, and z axis.
*/
func (o *Input) GetGyroscope() *Vector3 {
	log.Println("Calling Input.GetGyroscope()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gyroscope", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Returns the current value of the joypad axis at given index (see JOY_* constants in [@Global Scope])
*/
func (o *Input) GetJoyAxis(device int64, axis int64) float64 {
	log.Println("Calling Input.GetJoyAxis()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(device)
	goArguments[1] = reflect.ValueOf(axis)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_joy_axis", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Input) GetJoyAxisIndexFromString(axis string) int64 {
	log.Println("Calling Input.GetJoyAxisIndexFromString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(axis)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_joy_axis_index_from_string", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Input) GetJoyAxisString(axisIndex int64) string {
	log.Println("Calling Input.GetJoyAxisString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(axisIndex)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_joy_axis_string", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *Input) GetJoyButtonIndexFromString(button string) int64 {
	log.Println("Calling Input.GetJoyButtonIndexFromString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(button)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_joy_button_index_from_string", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Input) GetJoyButtonString(buttonIndex int64) string {
	log.Println("Calling Input.GetJoyButtonString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(buttonIndex)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_joy_button_string", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Returns a SDL2 compatible device guid on platforms that use gamepad remapping. Returns "Default Gamepad" otherwise.
*/
func (o *Input) GetJoyGuid(device int64) string {
	log.Println("Calling Input.GetJoyGuid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(device)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_joy_guid", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Returns the name of the joypad at the specified device index
*/
func (o *Input) GetJoyName(device int64) string {
	log.Println("Calling Input.GetJoyName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(device)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_joy_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Returns the duration of the current vibration effect in seconds.
*/
func (o *Input) GetJoyVibrationDuration(device int64) float64 {
	log.Println("Calling Input.GetJoyVibrationDuration()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(device)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_joy_vibration_duration", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns the strength of the joypad vibration: x is the strength of the weak motor, and y is the strength of the strong motor.
*/
func (o *Input) GetJoyVibrationStrength(device int64) *Vector2 {
	log.Println("Calling Input.GetJoyVibrationStrength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(device)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_joy_vibration_strength", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Returns the mouse speed for the last time the cursor was moved, and this until the next frame where the mouse moves. This means that even if the mouse is not moving, this function will still return the value of the last motion.
*/
func (o *Input) GetLastMouseSpeed() *Vector2 {
	log.Println("Calling Input.GetLastMouseSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_last_mouse_speed", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   If the device has a magnetometer, this will return the magnetic field strength in micro-Tesla for all axes.
*/
func (o *Input) GetMagnetometer() *Vector3 {
	log.Println("Calling Input.GetMagnetometer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_magnetometer", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Returns mouse buttons as a bitmask. If multiple mouse buttons are pressed at the same time the bits are added together.
*/
func (o *Input) GetMouseButtonMask() int64 {
	log.Println("Calling Input.GetMouseButtonMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mouse_button_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the mouse mode. See the constants for more information.
*/
func (o *Input) GetMouseMode() int64 {
	log.Println("Calling Input.GetMouseMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mouse_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Input) IsActionJustPressed(action string) *bool {
	log.Println("Calling Input.IsActionJustPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_action_just_pressed", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Input) IsActionJustReleased(action string) *bool {
	log.Println("Calling Input.IsActionJustReleased()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_action_just_released", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns true or false depending on whether the action event is pressed. Actions and their events can be set in the Project Settings / Input Map tab. Or be set with [InputMap].
*/
func (o *Input) IsActionPressed(action string) *bool {
	log.Println("Calling Input.IsActionPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_action_pressed", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns if the joypad button at the given index is currently pressed. (see JOY_* constants in [@Global Scope])
*/
func (o *Input) IsJoyButtonPressed(device int64, button int64) *bool {
	log.Println("Calling Input.IsJoyButtonPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(device)
	goArguments[1] = reflect.ValueOf(button)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_joy_button_pressed", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns if the specified device is known by the system. This means that it sets all button and axis indices exactly as defined in the JOY_* constants (see [@Global Scope]). Unknown joypads are not expected to match these constants, but you can still retrieve events from them.
*/
func (o *Input) IsJoyKnown(device int64) *bool {
	log.Println("Calling Input.IsJoyKnown()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(device)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_joy_known", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns true or false depending on whether the key is pressed or not. You can pass KEY_*, which are pre-defined constants listed in [@Global Scope].
*/
func (o *Input) IsKeyPressed(scancode int64) *bool {
	log.Println("Calling Input.IsKeyPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scancode)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_key_pressed", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns true or false depending on whether mouse button is pressed or not. You can pass BUTTON_*, which are pre-defined constants listed in [@Global Scope].
*/
func (o *Input) IsMouseButtonPressed(button int64) *bool {
	log.Println("Calling Input.IsMouseButtonPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(button)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_mouse_button_pressed", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Input) ParseInputEvent(event *InputEvent) {
	log.Println("Calling Input.ParseInputEvent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(event)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "parse_input_event", goArguments, "")

	log.Println("Got return value!")

}

/*
   Removes all mappings from the internal db that match the given uid.
*/
func (o *Input) RemoveJoyMapping(guid string) {
	log.Println("Calling Input.RemoveJoyMapping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(guid)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_joy_mapping", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Input) SetCustomMouseCursor(image *Resource, hotspot *Vector2) {
	log.Println("Calling Input.SetCustomMouseCursor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(image)
	goArguments[1] = reflect.ValueOf(hotspot)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_custom_mouse_cursor", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the mouse mode. See the constants for more information.
*/
func (o *Input) SetMouseMode(mode int64) {
	log.Println("Calling Input.SetMouseMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mouse_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
                Starts to vibrate the joypad. Joypads usually come with two rumble motors, a strong and a weak one. weak_magnitude is the strength of the weak motor (between 0 and 1) and strong_magnitude is the strength of the strong motor (between 0 and 1). duration is the duration of the effect in seconds (a duration of 0 will try to play the vibration indefinitely).
				Note that not every hardware is compatible with long effect durations, it is recommended to restart an effect if in need to play it for more than a few seconds.
*/
func (o *Input) StartJoyVibration(device int64, weakMagnitude float64, strongMagnitude float64, duration float64) {
	log.Println("Calling Input.StartJoyVibration()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(device)
	goArguments[1] = reflect.ValueOf(weakMagnitude)
	goArguments[2] = reflect.ValueOf(strongMagnitude)
	goArguments[3] = reflect.ValueOf(duration)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "start_joy_vibration", goArguments, "")

	log.Println("Got return value!")

}

/*
   Stops the vibration of the joypad.
*/
func (o *Input) StopJoyVibration(device int64) {
	log.Println("Calling Input.StopJoyVibration()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(device)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "stop_joy_vibration", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the mouse position to the specified vector.
*/
func (o *Input) WarpMousePos(to *Vector2) {
	log.Println("Calling Input.WarpMousePos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(to)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "warp_mouse_pos", goArguments, "")

	log.Println("Got return value!")

}

/*
   InputImplementer is an interface for Input objects.
   A Singleton that deals with inputs. This includes key presses, mouse buttons and movement, joypads, and input actions.
*/
type InputImplementer interface {
	ObjectImplementer

	ActionPress(action string)

	ActionRelease(action string)

	AddJoyMapping(mapping string, updateExisting *bool)

	GetAccelerometer() *Vector3

	GetConnectedJoypads() *Array

	GetGravity() *Vector3

	GetGyroscope() *Vector3

	GetJoyAxis(device int64, axis int64) float64

	GetJoyAxisIndexFromString(axis string) int64

	GetJoyAxisString(axisIndex int64) string

	GetJoyButtonIndexFromString(button string) int64

	GetJoyButtonString(buttonIndex int64) string

	GetJoyGuid(device int64) string

	GetJoyName(device int64) string

	GetJoyVibrationDuration(device int64) float64

	GetJoyVibrationStrength(device int64) *Vector2

	GetLastMouseSpeed() *Vector2

	GetMagnetometer() *Vector3

	GetMouseButtonMask() int64

	GetMouseMode() int64

	IsActionJustPressed(action string) *bool

	IsActionJustReleased(action string) *bool

	IsActionPressed(action string) *bool

	IsJoyButtonPressed(device int64, button int64) *bool

	IsJoyKnown(device int64) *bool

	IsKeyPressed(scancode int64) *bool

	IsMouseButtonPressed(button int64) *bool

	ParseInputEvent(event *InputEvent)

	RemoveJoyMapping(guid string)

	SetCustomMouseCursor(image *Resource, hotspot *Vector2)

	SetMouseMode(mode int64)

	StartJoyVibration(device int64, weakMagnitude float64, strongMagnitude float64, duration float64)

	StopJoyVibration(device int64)

	WarpMousePos(to *Vector2)
}

/*
   Default implementation of the [Input] class, used internally by the editor and games for default input management.
*/
type InputDefault struct {
	Input
}

func (o *InputDefault) baseClass() string {
	return "InputDefault"
}

/*
   InputDefaultImplementer is an interface for InputDefault objects.
   Default implementation of the [Input] class, used internally by the editor and games for default input management.
*/
type InputDefaultImplementer interface {
	InputImplementer
}

/*

 */
type InputEvent struct {
	Resource
}

func (o *InputEvent) baseClass() string {
	return "InputEvent"
}

/*

 */
func (o *InputEvent) ActionMatch(event *InputEvent) *bool {
	log.Println("Calling InputEvent.ActionMatch()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(event)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "action_match", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *InputEvent) AsText() string {
	log.Println("Calling InputEvent.AsText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "as_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *InputEvent) GetDevice() int64 {
	log.Println("Calling InputEvent.GetDevice()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_device", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *InputEvent) GetId() int64 {
	log.Println("Calling InputEvent.GetId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return if this input event matches a pre-defined action, no matter the type.
*/
func (o *InputEvent) IsAction(action string) *bool {
	log.Println("Calling InputEvent.IsAction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_action", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether the given action is being pressed (and is not an echo event for KEY events). Not relevant for the event types MOUSE_MOTION, SCREEN_DRAG and NONE.
*/
func (o *InputEvent) IsActionPressed(action string) *bool {
	log.Println("Calling InputEvent.IsActionPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_action_pressed", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether the given action is released (i.e. not pressed). Not relevant for the event types MOUSE_MOTION, SCREEN_DRAG and NONE.
*/
func (o *InputEvent) IsActionReleased(action string) *bool {
	log.Println("Calling InputEvent.IsActionReleased()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_action_released", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *InputEvent) IsActionType() *bool {
	log.Println("Calling InputEvent.IsActionType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_action_type", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return if this input event is an echo event (only for events of type KEY, it will return false for other types).
*/
func (o *InputEvent) IsEcho() *bool {
	log.Println("Calling InputEvent.IsEcho()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_echo", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return if this input event is pressed. Not relevant for the event types MOUSE_MOTION, SCREEN_DRAG and NONE.
*/
func (o *InputEvent) IsPressed() *bool {
	log.Println("Calling InputEvent.IsPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_pressed", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *InputEvent) SetDevice(device int64) {
	log.Println("Calling InputEvent.SetDevice()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(device)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_device", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEvent) SetId(id int64) {
	log.Println("Calling InputEvent.SetId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_id", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEvent) ShortcutMatch(event *InputEvent) *bool {
	log.Println("Calling InputEvent.ShortcutMatch()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(event)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shortcut_match", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *InputEvent) XformedBy(xform *Transform2D, localOfs *Vector2) *InputEvent {
	log.Println("Calling InputEvent.XformedBy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(xform)
	goArguments[1] = reflect.ValueOf(localOfs)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "xformed_by", goArguments, "*InputEvent")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*InputEvent)

	return returnValue

}

/*
   InputEventImplementer is an interface for InputEvent objects.

*/
type InputEventImplementer interface {
	ResourceImplementer

	ActionMatch(event *InputEvent) *bool

	AsText() string

	GetDevice() int64

	GetId() int64

	IsAction(action string) *bool

	IsActionPressed(action string) *bool

	IsActionReleased(action string) *bool

	IsActionType() *bool

	IsEcho() *bool

	IsPressed() *bool

	SetDevice(device int64)

	SetId(id int64)

	ShortcutMatch(event *InputEvent) *bool

	XformedBy(xform *Transform2D, localOfs *Vector2) *InputEvent
}

/*

 */
type InputEventAction struct {
	InputEvent
}

func (o *InputEventAction) baseClass() string {
	return "InputEventAction"
}

/*

 */
func (o *InputEventAction) GetAction() string {
	log.Println("Calling InputEventAction.GetAction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_action", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *InputEventAction) SetAction(action string) {
	log.Println("Calling InputEventAction.SetAction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_action", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventAction) SetPressed(pressed *bool) {
	log.Println("Calling InputEventAction.SetPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pressed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pressed", goArguments, "")

	log.Println("Got return value!")

}

/*
   InputEventActionImplementer is an interface for InputEventAction objects.

*/
type InputEventActionImplementer interface {
	InputEventImplementer

	GetAction() string

	SetAction(action string)

	SetPressed(pressed *bool)
}

/*

 */
type InputEventJoypadButton struct {
	InputEvent
}

func (o *InputEventJoypadButton) baseClass() string {
	return "InputEventJoypadButton"
}

/*

 */
func (o *InputEventJoypadButton) GetButtonIndex() int64 {
	log.Println("Calling InputEventJoypadButton.GetButtonIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_button_index", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *InputEventJoypadButton) GetPressure() float64 {
	log.Println("Calling InputEventJoypadButton.GetPressure()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pressure", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *InputEventJoypadButton) SetButtonIndex(buttonIndex int64) {
	log.Println("Calling InputEventJoypadButton.SetButtonIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(buttonIndex)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_button_index", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventJoypadButton) SetPressed(pressed *bool) {
	log.Println("Calling InputEventJoypadButton.SetPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pressed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pressed", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventJoypadButton) SetPressure(pressure float64) {
	log.Println("Calling InputEventJoypadButton.SetPressure()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pressure)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pressure", goArguments, "")

	log.Println("Got return value!")

}

/*
   InputEventJoypadButtonImplementer is an interface for InputEventJoypadButton objects.

*/
type InputEventJoypadButtonImplementer interface {
	InputEventImplementer

	GetButtonIndex() int64

	GetPressure() float64

	SetButtonIndex(buttonIndex int64)

	SetPressed(pressed *bool)

	SetPressure(pressure float64)
}

/*

 */
type InputEventJoypadMotion struct {
	InputEvent
}

func (o *InputEventJoypadMotion) baseClass() string {
	return "InputEventJoypadMotion"
}

/*

 */
func (o *InputEventJoypadMotion) GetAxis() int64 {
	log.Println("Calling InputEventJoypadMotion.GetAxis()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_axis", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *InputEventJoypadMotion) GetAxisValue() float64 {
	log.Println("Calling InputEventJoypadMotion.GetAxisValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_axis_value", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *InputEventJoypadMotion) SetAxis(axis int64) {
	log.Println("Calling InputEventJoypadMotion.SetAxis()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(axis)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_axis", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventJoypadMotion) SetAxisValue(axisValue float64) {
	log.Println("Calling InputEventJoypadMotion.SetAxisValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(axisValue)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_axis_value", goArguments, "")

	log.Println("Got return value!")

}

/*
   InputEventJoypadMotionImplementer is an interface for InputEventJoypadMotion objects.

*/
type InputEventJoypadMotionImplementer interface {
	InputEventImplementer

	GetAxis() int64

	GetAxisValue() float64

	SetAxis(axis int64)

	SetAxisValue(axisValue float64)
}

/*

 */
type InputEventKey struct {
	InputEventWithModifiers
}

func (o *InputEventKey) baseClass() string {
	return "InputEventKey"
}

/*

 */
func (o *InputEventKey) GetScancode() int64 {
	log.Println("Calling InputEventKey.GetScancode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scancode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *InputEventKey) GetScancodeWithModifiers() int64 {
	log.Println("Calling InputEventKey.GetScancodeWithModifiers()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scancode_with_modifiers", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *InputEventKey) GetUnicode() int64 {
	log.Println("Calling InputEventKey.GetUnicode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_unicode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *InputEventKey) SetEcho(echo *bool) {
	log.Println("Calling InputEventKey.SetEcho()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(echo)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_echo", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventKey) SetPressed(pressed *bool) {
	log.Println("Calling InputEventKey.SetPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pressed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pressed", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventKey) SetScancode(scancode int64) {
	log.Println("Calling InputEventKey.SetScancode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scancode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_scancode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventKey) SetUnicode(unicode int64) {
	log.Println("Calling InputEventKey.SetUnicode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(unicode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_unicode", goArguments, "")

	log.Println("Got return value!")

}

/*
   InputEventKeyImplementer is an interface for InputEventKey objects.

*/
type InputEventKeyImplementer interface {
	InputEventWithModifiersImplementer

	GetScancode() int64

	GetScancodeWithModifiers() int64

	GetUnicode() int64

	SetEcho(echo *bool)

	SetPressed(pressed *bool)

	SetScancode(scancode int64)

	SetUnicode(unicode int64)
}

/*

 */
type InputEventMouse struct {
	InputEventWithModifiers
}

func (o *InputEventMouse) baseClass() string {
	return "InputEventMouse"
}

/*

 */
func (o *InputEventMouse) GetButtonMask() int64 {
	log.Println("Calling InputEventMouse.GetButtonMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_button_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *InputEventMouse) GetGlobalPosition() *Vector2 {
	log.Println("Calling InputEventMouse.GetGlobalPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_global_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *InputEventMouse) GetPosition() *Vector2 {
	log.Println("Calling InputEventMouse.GetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *InputEventMouse) SetButtonMask(buttonMask int64) {
	log.Println("Calling InputEventMouse.SetButtonMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(buttonMask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_button_mask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventMouse) SetGlobalPosition(globalPosition *Vector2) {
	log.Println("Calling InputEventMouse.SetGlobalPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(globalPosition)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_global_position", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventMouse) SetPosition(position *Vector2) {
	log.Println("Calling InputEventMouse.SetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_position", goArguments, "")

	log.Println("Got return value!")

}

/*
   InputEventMouseImplementer is an interface for InputEventMouse objects.

*/
type InputEventMouseImplementer interface {
	InputEventWithModifiersImplementer

	GetButtonMask() int64

	GetGlobalPosition() *Vector2

	GetPosition() *Vector2

	SetButtonMask(buttonMask int64)

	SetGlobalPosition(globalPosition *Vector2)

	SetPosition(position *Vector2)
}

/*

 */
type InputEventMouseButton struct {
	InputEventMouse
}

func (o *InputEventMouseButton) baseClass() string {
	return "InputEventMouseButton"
}

/*

 */
func (o *InputEventMouseButton) GetButtonIndex() int64 {
	log.Println("Calling InputEventMouseButton.GetButtonIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_button_index", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *InputEventMouseButton) GetFactor() float64 {
	log.Println("Calling InputEventMouseButton.GetFactor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_factor", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *InputEventMouseButton) IsDoubleclick() *bool {
	log.Println("Calling InputEventMouseButton.IsDoubleclick()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_doubleclick", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *InputEventMouseButton) SetButtonIndex(buttonIndex int64) {
	log.Println("Calling InputEventMouseButton.SetButtonIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(buttonIndex)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_button_index", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventMouseButton) SetDoubleclick(doubleclick *bool) {
	log.Println("Calling InputEventMouseButton.SetDoubleclick()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(doubleclick)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_doubleclick", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventMouseButton) SetFactor(factor float64) {
	log.Println("Calling InputEventMouseButton.SetFactor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(factor)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_factor", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventMouseButton) SetPressed(pressed *bool) {
	log.Println("Calling InputEventMouseButton.SetPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pressed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pressed", goArguments, "")

	log.Println("Got return value!")

}

/*
   InputEventMouseButtonImplementer is an interface for InputEventMouseButton objects.

*/
type InputEventMouseButtonImplementer interface {
	InputEventMouseImplementer

	GetButtonIndex() int64

	GetFactor() float64

	IsDoubleclick() *bool

	SetButtonIndex(buttonIndex int64)

	SetDoubleclick(doubleclick *bool)

	SetFactor(factor float64)

	SetPressed(pressed *bool)
}

/*

 */
type InputEventMouseMotion struct {
	InputEventMouse
}

func (o *InputEventMouseMotion) baseClass() string {
	return "InputEventMouseMotion"
}

/*

 */
func (o *InputEventMouseMotion) GetRelative() *Vector2 {
	log.Println("Calling InputEventMouseMotion.GetRelative()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_relative", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *InputEventMouseMotion) GetSpeed() *Vector2 {
	log.Println("Calling InputEventMouseMotion.GetSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_speed", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *InputEventMouseMotion) SetRelative(relative *Vector2) {
	log.Println("Calling InputEventMouseMotion.SetRelative()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(relative)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_relative", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventMouseMotion) SetSpeed(speed *Vector2) {
	log.Println("Calling InputEventMouseMotion.SetSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(speed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_speed", goArguments, "")

	log.Println("Got return value!")

}

/*
   InputEventMouseMotionImplementer is an interface for InputEventMouseMotion objects.

*/
type InputEventMouseMotionImplementer interface {
	InputEventMouseImplementer

	GetRelative() *Vector2

	GetSpeed() *Vector2

	SetRelative(relative *Vector2)

	SetSpeed(speed *Vector2)
}

/*

 */
type InputEventScreenDrag struct {
	InputEvent
}

func (o *InputEventScreenDrag) baseClass() string {
	return "InputEventScreenDrag"
}

/*

 */
func (o *InputEventScreenDrag) GetIndex() int64 {
	log.Println("Calling InputEventScreenDrag.GetIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_index", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *InputEventScreenDrag) GetPosition() *Vector2 {
	log.Println("Calling InputEventScreenDrag.GetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *InputEventScreenDrag) GetRelative() *Vector2 {
	log.Println("Calling InputEventScreenDrag.GetRelative()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_relative", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *InputEventScreenDrag) GetSpeed() *Vector2 {
	log.Println("Calling InputEventScreenDrag.GetSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_speed", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *InputEventScreenDrag) SetIndex(index int64) {
	log.Println("Calling InputEventScreenDrag.SetIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_index", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventScreenDrag) SetPosition(position *Vector2) {
	log.Println("Calling InputEventScreenDrag.SetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_position", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventScreenDrag) SetRelative(relative *Vector2) {
	log.Println("Calling InputEventScreenDrag.SetRelative()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(relative)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_relative", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventScreenDrag) SetSpeed(speed *Vector2) {
	log.Println("Calling InputEventScreenDrag.SetSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(speed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_speed", goArguments, "")

	log.Println("Got return value!")

}

/*
   InputEventScreenDragImplementer is an interface for InputEventScreenDrag objects.

*/
type InputEventScreenDragImplementer interface {
	InputEventImplementer

	GetIndex() int64

	GetPosition() *Vector2

	GetRelative() *Vector2

	GetSpeed() *Vector2

	SetIndex(index int64)

	SetPosition(position *Vector2)

	SetRelative(relative *Vector2)

	SetSpeed(speed *Vector2)
}

/*

 */
type InputEventScreenTouch struct {
	InputEvent
}

func (o *InputEventScreenTouch) baseClass() string {
	return "InputEventScreenTouch"
}

/*

 */
func (o *InputEventScreenTouch) GetIndex() int64 {
	log.Println("Calling InputEventScreenTouch.GetIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_index", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *InputEventScreenTouch) GetPosition() *Vector2 {
	log.Println("Calling InputEventScreenTouch.GetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *InputEventScreenTouch) SetIndex(index int64) {
	log.Println("Calling InputEventScreenTouch.SetIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_index", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventScreenTouch) SetPosition(pos *Vector2) {
	log.Println("Calling InputEventScreenTouch.SetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_position", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventScreenTouch) SetPressed(pressed *bool) {
	log.Println("Calling InputEventScreenTouch.SetPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pressed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pressed", goArguments, "")

	log.Println("Got return value!")

}

/*
   InputEventScreenTouchImplementer is an interface for InputEventScreenTouch objects.

*/
type InputEventScreenTouchImplementer interface {
	InputEventImplementer

	GetIndex() int64

	GetPosition() *Vector2

	SetIndex(index int64)

	SetPosition(pos *Vector2)

	SetPressed(pressed *bool)
}

/*

 */
type InputEventWithModifiers struct {
	InputEvent
}

func (o *InputEventWithModifiers) baseClass() string {
	return "InputEventWithModifiers"
}

/*

 */
func (o *InputEventWithModifiers) GetAlt() *bool {
	log.Println("Calling InputEventWithModifiers.GetAlt()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_alt", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *InputEventWithModifiers) GetCommand() *bool {
	log.Println("Calling InputEventWithModifiers.GetCommand()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_command", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *InputEventWithModifiers) GetControl() *bool {
	log.Println("Calling InputEventWithModifiers.GetControl()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_control", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *InputEventWithModifiers) GetMetakey() *bool {
	log.Println("Calling InputEventWithModifiers.GetMetakey()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_metakey", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *InputEventWithModifiers) GetShift() *bool {
	log.Println("Calling InputEventWithModifiers.GetShift()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shift", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *InputEventWithModifiers) SetAlt(enable *bool) {
	log.Println("Calling InputEventWithModifiers.SetAlt()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_alt", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventWithModifiers) SetCommand(enable *bool) {
	log.Println("Calling InputEventWithModifiers.SetCommand()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_command", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventWithModifiers) SetControl(enable *bool) {
	log.Println("Calling InputEventWithModifiers.SetControl()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_control", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventWithModifiers) SetMetakey(enable *bool) {
	log.Println("Calling InputEventWithModifiers.SetMetakey()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_metakey", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InputEventWithModifiers) SetShift(enable *bool) {
	log.Println("Calling InputEventWithModifiers.SetShift()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shift", goArguments, "")

	log.Println("Got return value!")

}

/*
   InputEventWithModifiersImplementer is an interface for InputEventWithModifiers objects.

*/
type InputEventWithModifiersImplementer interface {
	InputEventImplementer

	GetAlt() *bool

	GetCommand() *bool

	GetControl() *bool

	GetMetakey() *bool

	GetShift() *bool

	SetAlt(enable *bool)

	SetCommand(enable *bool)

	SetControl(enable *bool)

	SetMetakey(enable *bool)

	SetShift(enable *bool)
}

/*

 */
type InputMap struct {
	Object
}

func (o *InputMap) baseClass() string {
	return "InputMap"
}

/*
   Add an [InputEvent] to an action. This [InputEvent] will trigger the action.
*/
func (o *InputMap) ActionAddEvent(action string, event *InputEvent) {
	log.Println("Calling InputMap.ActionAddEvent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(action)
	goArguments[1] = reflect.ValueOf(event)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "action_add_event", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove an [InputEvent] from an action.
*/
func (o *InputMap) ActionEraseEvent(action string, event *InputEvent) {
	log.Println("Calling InputMap.ActionEraseEvent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(action)
	goArguments[1] = reflect.ValueOf(event)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "action_erase_event", goArguments, "")

	log.Println("Got return value!")

}

/*
   Whether an action has an [InputEvent] associated with it.
*/
func (o *InputMap) ActionHasEvent(action string, event *InputEvent) *bool {
	log.Println("Calling InputMap.ActionHasEvent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(action)
	goArguments[1] = reflect.ValueOf(event)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "action_has_event", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Add an (empty) action to the [InputMap]. An [InputEvent] can then be added to this action with [method action_add_event].
*/
func (o *InputMap) AddAction(action string) {
	log.Println("Calling InputMap.AddAction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_action", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove an action from the [InputMap].
*/
func (o *InputMap) EraseAction(action string) {
	log.Println("Calling InputMap.EraseAction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "erase_action", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether the given event is part of an existing action. This method ignores keyboard modifiers if the given [InputEvent] is not pressed (for proper release detection). See [method action_has_event] if you don't want this behavior.
*/
func (o *InputMap) EventIsAction(event *InputEvent, action string) *bool {
	log.Println("Calling InputMap.EventIsAction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(event)
	goArguments[1] = reflect.ValueOf(action)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "event_is_action", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return an array of InputEvents associated with a given action.
*/
func (o *InputMap) GetActionList(action string) *Array {
	log.Println("Calling InputMap.GetActionList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_action_list", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Return an array of all actions in the [InputMap].
*/
func (o *InputMap) GetActions() *Array {
	log.Println("Calling InputMap.GetActions()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_actions", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Whether this InputMap has a registered action with the given name.
*/
func (o *InputMap) HasAction(action string) *bool {
	log.Println("Calling InputMap.HasAction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_action", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Clear the [InputMap] and load it anew from [ProjectSettings].
*/
func (o *InputMap) LoadFromGlobals() {
	log.Println("Calling InputMap.LoadFromGlobals()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "load_from_globals", goArguments, "")

	log.Println("Got return value!")

}

/*
   InputMapImplementer is an interface for InputMap objects.

*/
type InputMapImplementer interface {
	ObjectImplementer

	ActionAddEvent(action string, event *InputEvent)

	ActionEraseEvent(action string, event *InputEvent)

	ActionHasEvent(action string, event *InputEvent) *bool

	AddAction(action string)

	EraseAction(action string)

	EventIsAction(event *InputEvent, action string) *bool

	GetActionList(action string) *Array

	GetActions() *Array

	HasAction(action string) *bool

	LoadFromGlobals()
}

/*
        Turning on the option [b]Load As Placeholder[/b] for an instanced scene in the editor causes it to be replaced by an InstacePlaceholder when running the game. This makes it possible to delay actually loading the scene until calling [method replace_by_instance]. This is useful to avoid loading large scenes all at once by loading parts of it selectively.
		The InstancePlaceholder does not have a transform. This causes any child nodes to be positioned relatively to the Viewport from point (0,0), rather than their parent as displayed in the editor. Replacing the placeholder with a scene with a transform will transform children relatively to their parent again.
*/
type InstancePlaceholder struct {
	Node
}

func (o *InstancePlaceholder) baseClass() string {
	return "InstancePlaceholder"
}

/*
   Retrieve the path to the [PackedScene] resource file that is loaded by default when calling [method replace_by_instance].
*/
func (o *InstancePlaceholder) GetInstancePath() string {
	log.Println("Calling InstancePlaceholder.GetInstancePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_instance_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *InstancePlaceholder) GetStoredValues(withOrder *bool) *Dictionary {
	log.Println("Calling InstancePlaceholder.GetStoredValues()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(withOrder)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stored_values", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*
   Replace this placeholder by the scene handed as an argument, or the original scene if no argument is given. As for all resources, the scene is loaded only if it's not loaded already. By manually loading the scene beforehand, delays caused by this function can be avoided.
*/
func (o *InstancePlaceholder) ReplaceByInstance(customScene *PackedScene) {
	log.Println("Calling InstancePlaceholder.ReplaceByInstance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(customScene)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "replace_by_instance", goArguments, "")

	log.Println("Got return value!")

}

/*
        InstancePlaceholderImplementer is an interface for InstancePlaceholder objects.
        Turning on the option [b]Load As Placeholder[/b] for an instanced scene in the editor causes it to be replaced by an InstacePlaceholder when running the game. This makes it possible to delay actually loading the scene until calling [method replace_by_instance]. This is useful to avoid loading large scenes all at once by loading parts of it selectively.
		The InstancePlaceholder does not have a transform. This causes any child nodes to be positioned relatively to the Viewport from point (0,0), rather than their parent as displayed in the editor. Replacing the placeholder with a scene with a transform will transform children relatively to their parent again.
*/
type InstancePlaceholderImplementer interface {
	NodeImplementer

	GetInstancePath() string

	GetStoredValues(withOrder *bool) *Dictionary

	ReplaceByInstance(customScene *PackedScene)
}

/*

 */
type InterpolatedCamera struct {
	Camera
}

func (o *InterpolatedCamera) baseClass() string {
	return "InterpolatedCamera"
}

/*

 */
func (o *InterpolatedCamera) GetSpeed() float64 {
	log.Println("Calling InterpolatedCamera.GetSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_speed", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *InterpolatedCamera) GetTargetPath() *NodePath {
	log.Println("Calling InterpolatedCamera.GetTargetPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_target_path", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *InterpolatedCamera) IsInterpolationEnabled() *bool {
	log.Println("Calling InterpolatedCamera.IsInterpolationEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_interpolation_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *InterpolatedCamera) SetInterpolationEnabled(targetPath *bool) {
	log.Println("Calling InterpolatedCamera.SetInterpolationEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(targetPath)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_interpolation_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InterpolatedCamera) SetSpeed(speed float64) {
	log.Println("Calling InterpolatedCamera.SetSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(speed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_speed", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InterpolatedCamera) SetTarget(target *Object) {
	log.Println("Calling InterpolatedCamera.SetTarget()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(target)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_target", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *InterpolatedCamera) SetTargetPath(targetPath *NodePath) {
	log.Println("Calling InterpolatedCamera.SetTargetPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(targetPath)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_target_path", goArguments, "")

	log.Println("Got return value!")

}

/*
   InterpolatedCameraImplementer is an interface for InterpolatedCamera objects.

*/
type InterpolatedCameraImplementer interface {
	CameraImplementer

	GetSpeed() float64

	GetTargetPath() *NodePath

	IsInterpolationEnabled() *bool

	SetInterpolationEnabled(targetPath *bool)

	SetSpeed(speed float64)

	SetTarget(target *Object)

	SetTargetPath(targetPath *NodePath)
}

/*
        This control provides a selectable list of items that may be in a single (or multiple columns) with option of text, icons,
		or both text and icon.  Tooltips are supported and may be different for every item in the list.  Selectable items in the list
		may be selected or deselected and multiple selection may be enabled.  Selection with right mouse button may also be enabled
		to allow use of popup context menus.  Items may also be 'activated' with a double click (or Enter key).
*/
type ItemList struct {
	Control
}

func (o *ItemList) baseClass() string {
	return "ItemList"
}

/*
   Adds an item to the item list with no text, only an icon.
*/
func (o *ItemList) AddIconItem(icon *Texture, selectable *bool) {
	log.Println("Calling ItemList.AddIconItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(icon)
	goArguments[1] = reflect.ValueOf(selectable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_icon_item", goArguments, "")

	log.Println("Got return value!")

}

/*
                Adds an item to the item list with specified text.  Specify an icon of null for a list item with no icon.
				If selectable is true the list item will be selectable.
*/
func (o *ItemList) AddItem(text string, icon *Texture, selectable *bool) {
	log.Println("Calling ItemList.AddItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(text)
	goArguments[1] = reflect.ValueOf(icon)
	goArguments[2] = reflect.ValueOf(selectable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_item", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove all items from the list.
*/
func (o *ItemList) Clear() {
	log.Println("Calling ItemList.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Ensure selection is visible, adjusting the scroll position as necessary.
*/
func (o *ItemList) EnsureCurrentIsVisible() {
	log.Println("Calling ItemList.EnsureCurrentIsVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "ensure_current_is_visible", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether or not items may be selected via right mouse clicking.
*/
func (o *ItemList) GetAllowRmbSelect() *bool {
	log.Println("Calling ItemList.GetAllowRmbSelect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_allow_rmb_select", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   If column size has been fixed to a value, return that value.
*/
func (o *ItemList) GetFixedColumnWidth() int64 {
	log.Println("Calling ItemList.GetFixedColumnWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fixed_column_width", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ItemList) GetFixedIconSize() *Vector2 {
	log.Println("Calling ItemList.GetFixedIconSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fixed_icon_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *ItemList) GetIconMode() int64 {
	log.Println("Calling ItemList.GetIconMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_icon_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ItemList) GetIconScale() float64 {
	log.Println("Calling ItemList.GetIconScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_icon_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Given a position within the control return the item (if any) at that point.
*/
func (o *ItemList) GetItemAtPos(pos *Vector2, exact *bool) int64 {
	log.Println("Calling ItemList.GetItemAtPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(pos)
	goArguments[1] = reflect.ValueOf(exact)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_at_pos", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return count of items currently in the item list.
*/
func (o *ItemList) GetItemCount() int64 {
	log.Println("Calling ItemList.GetItemCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ItemList) GetItemCustomBgColor(idx int64) *Color {
	log.Println("Calling ItemList.GetItemCustomBgColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_custom_bg_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *ItemList) GetItemIcon(idx int64) *Texture {
	log.Println("Calling ItemList.GetItemIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_icon", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *ItemList) GetItemIconRegion(idx int64) *Rect2 {
	log.Println("Calling ItemList.GetItemIconRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_icon_region", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*

 */
func (o *ItemList) GetItemMetadata(idx int64) *Variant {
	log.Println("Calling ItemList.GetItemMetadata()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_metadata", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Return the text for specified item index.
*/
func (o *ItemList) GetItemText(idx int64) string {
	log.Println("Calling ItemList.GetItemText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return tooltip hint for specified item index.
*/
func (o *ItemList) GetItemTooltip(idx int64) string {
	log.Println("Calling ItemList.GetItemTooltip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_tooltip", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return total number of columns in use by the list.
*/
func (o *ItemList) GetMaxColumns() int64 {
	log.Println("Calling ItemList.GetMaxColumns()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_max_columns", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return total number of lines currently in use by the list.
*/
func (o *ItemList) GetMaxTextLines() int64 {
	log.Println("Calling ItemList.GetMaxTextLines()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_max_text_lines", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ItemList) GetSelectMode() int64 {
	log.Println("Calling ItemList.GetSelectMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_select_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the list of selected indexes.
*/
func (o *ItemList) GetSelectedItems() *PoolIntArray {
	log.Println("Calling ItemList.GetSelectedItems()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_selected_items", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*
   Returns the current vertical scroll bar for the List.
*/
func (o *ItemList) GetVScroll() *VScrollBar {
	log.Println("Calling ItemList.GetVScroll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_v_scroll", goArguments, "*VScrollBar")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*VScrollBar)

	return returnValue

}

/*

 */
func (o *ItemList) HasAutoHeight() *bool {
	log.Println("Calling ItemList.HasAutoHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_auto_height", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns whether or not the item at the specified index is disabled
*/
func (o *ItemList) IsItemDisabled(idx int64) *bool {
	log.Println("Calling ItemList.IsItemDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_item_disabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns whether or not the item at the specified index is selectable.
*/
func (o *ItemList) IsItemSelectable(idx int64) *bool {
	log.Println("Calling ItemList.IsItemSelectable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_item_selectable", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns whether the tooptip is enabled for specified item index.
*/
func (o *ItemList) IsItemTooltipEnabled(idx int64) *bool {
	log.Println("Calling ItemList.IsItemTooltipEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_item_tooltip_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns whether or not all columns of the list are of the same size.
*/
func (o *ItemList) IsSameColumnWidth() *bool {
	log.Println("Calling ItemList.IsSameColumnWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_same_column_width", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns whether or not item at the specified index is currently selected.
*/
func (o *ItemList) IsSelected(idx int64) *bool {
	log.Println("Calling ItemList.IsSelected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_selected", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Remove item at specified index from the list.
*/
func (o *ItemList) RemoveItem(idx int64) {
	log.Println("Calling ItemList.RemoveItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_item", goArguments, "")

	log.Println("Got return value!")

}

/*
                Select the item at the specified index.
				Note:  This method does not trigger the item selection signal.
*/
func (o *ItemList) Select(idx int64, single *bool) {
	log.Println("Calling ItemList.Select()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(single)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "select", goArguments, "")

	log.Println("Got return value!")

}

/*
   Allow (or disallow) selection of (selectable) items in the list using right mouse button.
*/
func (o *ItemList) SetAllowRmbSelect(allow *bool) {
	log.Println("Calling ItemList.SetAllowRmbSelect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(allow)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_allow_rmb_select", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ItemList) SetAutoHeight(enable *bool) {
	log.Println("Calling ItemList.SetAutoHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_auto_height", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the size (width) all columns in the list are to use.
*/
func (o *ItemList) SetFixedColumnWidth(width int64) {
	log.Println("Calling ItemList.SetFixedColumnWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(width)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fixed_column_width", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ItemList) SetFixedIconSize(size *Vector2) {
	log.Println("Calling ItemList.SetFixedIconSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fixed_icon_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ItemList) SetIconMode(mode int64) {
	log.Println("Calling ItemList.SetIconMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_icon_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ItemList) SetIconScale(scale float64) {
	log.Println("Calling ItemList.SetIconScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_icon_scale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ItemList) SetItemCustomBgColor(idx int64, customBgColor *Color) {
	log.Println("Calling ItemList.SetItemCustomBgColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(customBgColor)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_custom_bg_color", goArguments, "")

	log.Println("Got return value!")

}

/*
                Disable (or enable) item at specified index.
				Disabled items are not be selectable and do not fire activation (Enter or double-click) signals.
*/
func (o *ItemList) SetItemDisabled(idx int64, disabled *bool) {
	log.Println("Calling ItemList.SetItemDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(disabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_disabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set (or replace) icon of the item at the specified index.
*/
func (o *ItemList) SetItemIcon(idx int64, icon *Texture) {
	log.Println("Calling ItemList.SetItemIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(icon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_icon", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ItemList) SetItemIconRegion(idx int64, rect *Rect2) {
	log.Println("Calling ItemList.SetItemIconRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(rect)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_icon_region", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets a value (of any type) to be stored with the item at the specified index.
*/
func (o *ItemList) SetItemMetadata(idx int64, metadata *Variant) {
	log.Println("Calling ItemList.SetItemMetadata()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(metadata)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_metadata", goArguments, "")

	log.Println("Got return value!")

}

/*
   Allow or disallow selection of the item at the specified index.
*/
func (o *ItemList) SetItemSelectable(idx int64, selectable *bool) {
	log.Println("Calling ItemList.SetItemSelectable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(selectable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_selectable", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets text of item at specified index.
*/
func (o *ItemList) SetItemText(idx int64, text string) {
	log.Println("Calling ItemList.SetItemText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_text", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets tooltip hint for item at specified index.
*/
func (o *ItemList) SetItemTooltip(idx int64, tooltip string) {
	log.Println("Calling ItemList.SetItemTooltip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(tooltip)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_tooltip", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets whether the tooltip is enabled for specified item index.
*/
func (o *ItemList) SetItemTooltipEnabled(idx int64, enable *bool) {
	log.Println("Calling ItemList.SetItemTooltipEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_tooltip_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set maximum number of columns to use for the list.
*/
func (o *ItemList) SetMaxColumns(amount int64) {
	log.Println("Calling ItemList.SetMaxColumns()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max_columns", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set maximum number of lines to use for the list.
*/
func (o *ItemList) SetMaxTextLines(lines int64) {
	log.Println("Calling ItemList.SetMaxTextLines()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(lines)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max_text_lines", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets a fixed size (width) to use for all columns of the list.
*/
func (o *ItemList) SetSameColumnWidth(enable *bool) {
	log.Println("Calling ItemList.SetSameColumnWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_same_column_width", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ItemList) SetSelectMode(mode int64) {
	log.Println("Calling ItemList.SetSelectMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_select_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sorts items in the list by their text.
*/
func (o *ItemList) SortItemsByText() {
	log.Println("Calling ItemList.SortItemsByText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "sort_items_by_text", goArguments, "")

	log.Println("Got return value!")

}

/*
   Ensure item at specified index is not selected.
*/
func (o *ItemList) Unselect(idx int64) {
	log.Println("Calling ItemList.Unselect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "unselect", goArguments, "")

	log.Println("Got return value!")

}

/*
        ItemListImplementer is an interface for ItemList objects.
        This control provides a selectable list of items that may be in a single (or multiple columns) with option of text, icons,
		or both text and icon.  Tooltips are supported and may be different for every item in the list.  Selectable items in the list
		may be selected or deselected and multiple selection may be enabled.  Selection with right mouse button may also be enabled
		to allow use of popup context menus.  Items may also be 'activated' with a double click (or Enter key).
*/
type ItemListImplementer interface {
	ControlImplementer

	AddIconItem(icon *Texture, selectable *bool)

	AddItem(text string, icon *Texture, selectable *bool)

	Clear()

	EnsureCurrentIsVisible()

	GetAllowRmbSelect() *bool

	GetFixedColumnWidth() int64

	GetFixedIconSize() *Vector2

	GetIconMode() int64

	GetIconScale() float64

	GetItemAtPos(pos *Vector2, exact *bool) int64

	GetItemCount() int64

	GetItemCustomBgColor(idx int64) *Color

	GetItemIcon(idx int64) *Texture

	GetItemIconRegion(idx int64) *Rect2

	GetItemMetadata(idx int64) *Variant

	GetItemText(idx int64) string

	GetItemTooltip(idx int64) string

	GetMaxColumns() int64

	GetMaxTextLines() int64

	GetSelectMode() int64

	GetSelectedItems() *PoolIntArray

	GetVScroll() *VScrollBar

	HasAutoHeight() *bool

	IsItemDisabled(idx int64) *bool

	IsItemSelectable(idx int64) *bool

	IsItemTooltipEnabled(idx int64) *bool

	IsSameColumnWidth() *bool

	IsSelected(idx int64) *bool

	RemoveItem(idx int64)

	Select(idx int64, single *bool)

	SetAllowRmbSelect(allow *bool)

	SetAutoHeight(enable *bool)

	SetFixedColumnWidth(width int64)

	SetFixedIconSize(size *Vector2)

	SetIconMode(mode int64)

	SetIconScale(scale float64)

	SetItemCustomBgColor(idx int64, customBgColor *Color)

	SetItemDisabled(idx int64, disabled *bool)

	SetItemIcon(idx int64, icon *Texture)

	SetItemIconRegion(idx int64, rect *Rect2)

	SetItemMetadata(idx int64, metadata *Variant)

	SetItemSelectable(idx int64, selectable *bool)

	SetItemText(idx int64, text string)

	SetItemTooltip(idx int64, tooltip string)

	SetItemTooltipEnabled(idx int64, enable *bool)

	SetMaxColumns(amount int64)

	SetMaxTextLines(lines int64)

	SetSameColumnWidth(enable *bool)

	SetSelectMode(mode int64)

	SortItemsByText()

	Unselect(idx int64)
}

/*

 */
type Joint struct {
	Spatial
}

func (o *Joint) baseClass() string {
	return "Joint"
}

/*

 */
func (o *Joint) GetExcludeNodesFromCollision() *bool {
	log.Println("Calling Joint.GetExcludeNodesFromCollision()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_exclude_nodes_from_collision", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Joint) GetNodeA() *NodePath {
	log.Println("Calling Joint.GetNodeA()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_a", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *Joint) GetNodeB() *NodePath {
	log.Println("Calling Joint.GetNodeB()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_b", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *Joint) GetSolverPriority() int64 {
	log.Println("Calling Joint.GetSolverPriority()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_solver_priority", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Joint) SetExcludeNodesFromCollision(enable *bool) {
	log.Println("Calling Joint.SetExcludeNodesFromCollision()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_exclude_nodes_from_collision", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Joint) SetNodeA(node *NodePath) {
	log.Println("Calling Joint.SetNodeA()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_node_a", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Joint) SetNodeB(node *NodePath) {
	log.Println("Calling Joint.SetNodeB()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_node_b", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Joint) SetSolverPriority(priority int64) {
	log.Println("Calling Joint.SetSolverPriority()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(priority)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_solver_priority", goArguments, "")

	log.Println("Got return value!")

}

/*
   JointImplementer is an interface for Joint objects.

*/
type JointImplementer interface {
	SpatialImplementer

	GetExcludeNodesFromCollision() *bool

	GetNodeA() *NodePath

	GetNodeB() *NodePath

	GetSolverPriority() int64

	SetExcludeNodesFromCollision(enable *bool)

	SetNodeA(node *NodePath)

	SetNodeB(node *NodePath)

	SetSolverPriority(priority int64)
}

/*
   Base node for all joint constraints in 2D physics. Joints take 2 bodies and apply a custom constraint.
*/
type Joint2D struct {
	Node2D
}

func (o *Joint2D) baseClass() string {
	return "Joint2D"
}

/*

 */
func (o *Joint2D) GetBias() float64 {
	log.Println("Calling Joint2D.GetBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bias", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Joint2D) GetExcludeNodesFromCollision() *bool {
	log.Println("Calling Joint2D.GetExcludeNodesFromCollision()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_exclude_nodes_from_collision", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return the path to the A node for the joint.
*/
func (o *Joint2D) GetNodeA() *NodePath {
	log.Println("Calling Joint2D.GetNodeA()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_a", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*
   Return the path to the B node for the joint.
*/
func (o *Joint2D) GetNodeB() *NodePath {
	log.Println("Calling Joint2D.GetNodeB()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_b", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *Joint2D) SetBias(bias float64) {
	log.Println("Calling Joint2D.SetBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bias)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bias", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Joint2D) SetExcludeNodesFromCollision(enable *bool) {
	log.Println("Calling Joint2D.SetExcludeNodesFromCollision()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_exclude_nodes_from_collision", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the path to the A node for the joint. Must be of type [PhysicsBody2D].
*/
func (o *Joint2D) SetNodeA(node *NodePath) {
	log.Println("Calling Joint2D.SetNodeA()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_node_a", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the path to the B node for the joint. Must be of type [PhysicsBody2D].
*/
func (o *Joint2D) SetNodeB(node *NodePath) {
	log.Println("Calling Joint2D.SetNodeB()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_node_b", goArguments, "")

	log.Println("Got return value!")

}

/*
   Joint2DImplementer is an interface for Joint2D objects.
   Base node for all joint constraints in 2D physics. Joints take 2 bodies and apply a custom constraint.
*/
type Joint2DImplementer interface {
	Node2DImplementer

	GetBias() float64

	GetExcludeNodesFromCollision() *bool

	GetNodeA() *NodePath

	GetNodeB() *NodePath

	SetBias(bias float64)

	SetExcludeNodesFromCollision(enable *bool)

	SetNodeA(node *NodePath)

	SetNodeB(node *NodePath)
}

/*
        Kinematic bodies are special types of bodies that are meant to be user-controlled. They are not affected by physics at all (to other types of bodies, such a character or a rigid body, these are the same as a static body). They have however, two main uses:
		Simulated Motion: When these bodies are moved manually, either from code or from an AnimationPlayer (with process mode set to fixed), the physics will automatically compute an estimate of their linear and angular velocity. This makes them very useful for moving platforms or other AnimationPlayer-controlled objects (like a door, a bridge that opens, etc).
		Kinematic Characters: KinematicBody also has an api for moving objects (the [method move] method) while performing collision tests. This makes them really useful to implement characters that collide against a world, but that don't require advanced physics.
*/
type KinematicBody struct {
	PhysicsBody
}

func (o *KinematicBody) baseClass() string {
	return "KinematicBody"
}

/*

 */
func (o *KinematicBody) GetCollisionCollider(collision int64) *Object {
	log.Println("Calling KinematicBody.GetCollisionCollider()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collision)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_collider", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*

 */
func (o *KinematicBody) GetCollisionColliderId(collision int64) int64 {
	log.Println("Calling KinematicBody.GetCollisionColliderId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collision)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_collider_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *KinematicBody) GetCollisionColliderMetadata(collision int64) *Variant {
	log.Println("Calling KinematicBody.GetCollisionColliderMetadata()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collision)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_collider_metadata", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *KinematicBody) GetCollisionColliderShape(collision int64) *Object {
	log.Println("Calling KinematicBody.GetCollisionColliderShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collision)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_collider_shape", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*

 */
func (o *KinematicBody) GetCollisionColliderShapeIndex(collision int64) int64 {
	log.Println("Calling KinematicBody.GetCollisionColliderShapeIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collision)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_collider_shape_index", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *KinematicBody) GetCollisionColliderVelocity(collision int64) *Vector3 {
	log.Println("Calling KinematicBody.GetCollisionColliderVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collision)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_collider_velocity", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *KinematicBody) GetCollisionCount() int64 {
	log.Println("Calling KinematicBody.GetCollisionCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *KinematicBody) GetCollisionLocalShape(collision int64) *Object {
	log.Println("Calling KinematicBody.GetCollisionLocalShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collision)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_local_shape", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*

 */
func (o *KinematicBody) GetCollisionNormal(collision int64) *Vector3 {
	log.Println("Calling KinematicBody.GetCollisionNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collision)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_normal", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *KinematicBody) GetCollisionPosition(collision int64) *Vector3 {
	log.Println("Calling KinematicBody.GetCollisionPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collision)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_position", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *KinematicBody) GetCollisionRemainder(collision int64) *Vector3 {
	log.Println("Calling KinematicBody.GetCollisionRemainder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collision)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_remainder", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *KinematicBody) GetCollisionTravel(collision int64) *Vector3 {
	log.Println("Calling KinematicBody.GetCollisionTravel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collision)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_travel", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *KinematicBody) GetFloorVelocity() *Vector3 {
	log.Println("Calling KinematicBody.GetFloorVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_floor_velocity", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *KinematicBody) GetSafeMargin() float64 {
	log.Println("Calling KinematicBody.GetSafeMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_safe_margin", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *KinematicBody) IsOnCeiling() *bool {
	log.Println("Calling KinematicBody.IsOnCeiling()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_on_ceiling", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *KinematicBody) IsOnFloor() *bool {
	log.Println("Calling KinematicBody.IsOnFloor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_on_floor", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *KinematicBody) IsOnWall() *bool {
	log.Println("Calling KinematicBody.IsOnWall()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_on_wall", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
                Move the body in the given direction, stopping if there is an obstacle. If as a result of a movement there will be any collision then informations about this collision will be in returned dictionary. Dictionary will contains those keys:
				- "position" - collision position
				- "normal" - collision normal
				- "local_shape" - id of this kinematic body shape that took part in a collision
				- "travel" -  traveled movement before being stopped
				- "remainder" - remaining movement before being stopped
				- "collider_id" - id of the collider, it can be used when dealing with [PhysicsServer]
				- "collider" - colliding body
				- "collider_shape_index" - index of the colliding shape, inside collider body "collider_metadata"
				If the body did not intersect anything, then an empty dictionary (dir.empty()==true) is returned instead. Please note that this method is less user friendly than [method move_and_slide]. If you don't want to program each edge case manually, then it's recommended to use [method move_and_slide] instead.
*/
func (o *KinematicBody) Move(relVec *Vector3) *Dictionary {
	log.Println("Calling KinematicBody.Move()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(relVec)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "move", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*

 */
func (o *KinematicBody) MoveAndSlide(linearVelocity *Vector3, floorNormal *Vector3, slopeStopMinVelocity float64, maxBounces int64, floorMaxAngle float64) *Vector3 {
	log.Println("Calling KinematicBody.MoveAndSlide()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(linearVelocity)
	goArguments[1] = reflect.ValueOf(floorNormal)
	goArguments[2] = reflect.ValueOf(slopeStopMinVelocity)
	goArguments[3] = reflect.ValueOf(maxBounces)
	goArguments[4] = reflect.ValueOf(floorMaxAngle)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "move_and_slide", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *KinematicBody) SetSafeMargin(pixels float64) {
	log.Println("Calling KinematicBody.SetSafeMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pixels)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_safe_margin", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *KinematicBody) TestMove(from *Transform, relVec *Vector3) *bool {
	log.Println("Calling KinematicBody.TestMove()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(relVec)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "test_move", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
        KinematicBodyImplementer is an interface for KinematicBody objects.
        Kinematic bodies are special types of bodies that are meant to be user-controlled. They are not affected by physics at all (to other types of bodies, such a character or a rigid body, these are the same as a static body). They have however, two main uses:
		Simulated Motion: When these bodies are moved manually, either from code or from an AnimationPlayer (with process mode set to fixed), the physics will automatically compute an estimate of their linear and angular velocity. This makes them very useful for moving platforms or other AnimationPlayer-controlled objects (like a door, a bridge that opens, etc).
		Kinematic Characters: KinematicBody also has an api for moving objects (the [method move] method) while performing collision tests. This makes them really useful to implement characters that collide against a world, but that don't require advanced physics.
*/
type KinematicBodyImplementer interface {
	PhysicsBodyImplementer

	GetCollisionCollider(collision int64) *Object

	GetCollisionColliderId(collision int64) int64

	GetCollisionColliderMetadata(collision int64) *Variant

	GetCollisionColliderShape(collision int64) *Object

	GetCollisionColliderShapeIndex(collision int64) int64

	GetCollisionColliderVelocity(collision int64) *Vector3

	GetCollisionCount() int64

	GetCollisionLocalShape(collision int64) *Object

	GetCollisionNormal(collision int64) *Vector3

	GetCollisionPosition(collision int64) *Vector3

	GetCollisionRemainder(collision int64) *Vector3

	GetCollisionTravel(collision int64) *Vector3

	GetFloorVelocity() *Vector3

	GetSafeMargin() float64

	IsOnCeiling() *bool

	IsOnFloor() *bool

	IsOnWall() *bool

	Move(relVec *Vector3) *Dictionary

	MoveAndSlide(linearVelocity *Vector3, floorNormal *Vector3, slopeStopMinVelocity float64, maxBounces int64, floorMaxAngle float64) *Vector3

	SetSafeMargin(pixels float64)

	TestMove(from *Transform, relVec *Vector3) *bool
}

/*
        Kinematic bodies are special types of bodies that are meant to be user-controlled. They are not affected by physics at all (to other types of bodies, such a character or a rigid body, these are the same as a static body). They have however, two main uses:
		Simulated Motion: When these bodies are moved manually, either from code or from an AnimationPlayer (with process mode set to fixed), the physics will automatically compute an estimate of their linear and angular velocity. This makes them very useful for moving platforms or other AnimationPlayer-controlled objects (like a door, a bridge that opens, etc).
		Kinematic Characters: KinematicBody2D also has an api for moving objects (the [method move] method) while performing collision tests. This makes them really useful to implement characters that collide against a world, but that don't require advanced physics.
*/
type KinematicBody2D struct {
	PhysicsBody2D
}

func (o *KinematicBody2D) baseClass() string {
	return "KinematicBody2D"
}

/*

 */
func (o *KinematicBody2D) GetCollisionCollider(collision int64) *Object {
	log.Println("Calling KinematicBody2D.GetCollisionCollider()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collision)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_collider", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*

 */
func (o *KinematicBody2D) GetCollisionColliderId(collision int64) int64 {
	log.Println("Calling KinematicBody2D.GetCollisionColliderId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collision)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_collider_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *KinematicBody2D) GetCollisionColliderMetadata(collision int64) *Variant {
	log.Println("Calling KinematicBody2D.GetCollisionColliderMetadata()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collision)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_collider_metadata", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *KinematicBody2D) GetCollisionColliderShape(collision int64) *Object {
	log.Println("Calling KinematicBody2D.GetCollisionColliderShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collision)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_collider_shape", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*

 */
func (o *KinematicBody2D) GetCollisionColliderShapeIndex(collision int64) int64 {
	log.Println("Calling KinematicBody2D.GetCollisionColliderShapeIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collision)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_collider_shape_index", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the velocity of the body that collided with this one.
*/
func (o *KinematicBody2D) GetCollisionColliderVelocity(collision int64) *Vector2 {
	log.Println("Calling KinematicBody2D.GetCollisionColliderVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collision)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_collider_velocity", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *KinematicBody2D) GetCollisionCount() int64 {
	log.Println("Calling KinematicBody2D.GetCollisionCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *KinematicBody2D) GetCollisionLocalShape(collision int64) *Object {
	log.Println("Calling KinematicBody2D.GetCollisionLocalShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collision)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_local_shape", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*

 */
func (o *KinematicBody2D) GetCollisionNormal(collision int64) *Vector2 {
	log.Println("Calling KinematicBody2D.GetCollisionNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collision)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_normal", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *KinematicBody2D) GetCollisionPosition(collision int64) *Vector2 {
	log.Println("Calling KinematicBody2D.GetCollisionPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collision)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *KinematicBody2D) GetCollisionRemainder(collision int64) *Vector2 {
	log.Println("Calling KinematicBody2D.GetCollisionRemainder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collision)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_remainder", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *KinematicBody2D) GetCollisionTravel(collision int64) *Vector2 {
	log.Println("Calling KinematicBody2D.GetCollisionTravel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collision)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_travel", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *KinematicBody2D) GetFloorVelocity() *Vector2 {
	log.Println("Calling KinematicBody2D.GetFloorVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_floor_velocity", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *KinematicBody2D) GetSafeMargin() float64 {
	log.Println("Calling KinematicBody2D.GetSafeMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_safe_margin", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *KinematicBody2D) IsOnCeiling() *bool {
	log.Println("Calling KinematicBody2D.IsOnCeiling()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_on_ceiling", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *KinematicBody2D) IsOnFloor() *bool {
	log.Println("Calling KinematicBody2D.IsOnFloor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_on_floor", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *KinematicBody2D) IsOnWall() *bool {
	log.Println("Calling KinematicBody2D.IsOnWall()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_on_wall", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
                Move the body in the given direction, stopping if there is an obstacle. If as a result of a movement there will be any collision then informations about this collision will be in returned dictionary.	Dictionary will contains those keys:
				- "position" - collision position
				- "normal" - collision normal
				- "local_shape" - id of this kinematic body shape that took part in a collision
				- "travel" -  traveled movement before being stopped
				- "remainder" - remaining movement before being stopped
				- "collider_id" - id of the collider, it can be used when dealing with [Physics2DServer]
				- "collider" - colliding body
				- "collider_shape_index" - index of the colliding shape, inside collider body "collider_metadata"
				If the body did not intersect anything, then an empty dictionary (dir.empty()==true) is returned instead. Please note that this method is less user friendly than [method move_and_slide]. If you don't want to program each edge case manually, then it's recommended to use [method move_and_slide] instead.
*/
func (o *KinematicBody2D) Move(relVec *Vector2) *Dictionary {
	log.Println("Calling KinematicBody2D.Move()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(relVec)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "move", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*

 */
func (o *KinematicBody2D) MoveAndSlide(linearVelocity *Vector2, floorNormal *Vector2, slopeStopMinVelocity float64, maxBounces int64, floorMaxAngle float64) *Vector2 {
	log.Println("Calling KinematicBody2D.MoveAndSlide()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(linearVelocity)
	goArguments[1] = reflect.ValueOf(floorNormal)
	goArguments[2] = reflect.ValueOf(slopeStopMinVelocity)
	goArguments[3] = reflect.ValueOf(maxBounces)
	goArguments[4] = reflect.ValueOf(floorMaxAngle)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "move_and_slide", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *KinematicBody2D) SetSafeMargin(pixels float64) {
	log.Println("Calling KinematicBody2D.SetSafeMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pixels)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_safe_margin", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if there would be a collision if the body moved from the given point in the given direction.
*/
func (o *KinematicBody2D) TestMove(from *Transform2D, relVec *Vector2) *bool {
	log.Println("Calling KinematicBody2D.TestMove()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(relVec)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "test_move", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
        KinematicBody2DImplementer is an interface for KinematicBody2D objects.
        Kinematic bodies are special types of bodies that are meant to be user-controlled. They are not affected by physics at all (to other types of bodies, such a character or a rigid body, these are the same as a static body). They have however, two main uses:
		Simulated Motion: When these bodies are moved manually, either from code or from an AnimationPlayer (with process mode set to fixed), the physics will automatically compute an estimate of their linear and angular velocity. This makes them very useful for moving platforms or other AnimationPlayer-controlled objects (like a door, a bridge that opens, etc).
		Kinematic Characters: KinematicBody2D also has an api for moving objects (the [method move] method) while performing collision tests. This makes them really useful to implement characters that collide against a world, but that don't require advanced physics.
*/
type KinematicBody2DImplementer interface {
	PhysicsBody2DImplementer

	GetCollisionCollider(collision int64) *Object

	GetCollisionColliderId(collision int64) int64

	GetCollisionColliderMetadata(collision int64) *Variant

	GetCollisionColliderShape(collision int64) *Object

	GetCollisionColliderShapeIndex(collision int64) int64

	GetCollisionColliderVelocity(collision int64) *Vector2

	GetCollisionCount() int64

	GetCollisionLocalShape(collision int64) *Object

	GetCollisionNormal(collision int64) *Vector2

	GetCollisionPosition(collision int64) *Vector2

	GetCollisionRemainder(collision int64) *Vector2

	GetCollisionTravel(collision int64) *Vector2

	GetFloorVelocity() *Vector2

	GetSafeMargin() float64

	IsOnCeiling() *bool

	IsOnFloor() *bool

	IsOnWall() *bool

	Move(relVec *Vector2) *Dictionary

	MoveAndSlide(linearVelocity *Vector2, floorNormal *Vector2, slopeStopMinVelocity float64, maxBounces int64, floorMaxAngle float64) *Vector2

	SetSafeMargin(pixels float64)

	TestMove(from *Transform2D, relVec *Vector2) *bool
}

/*
   Label is a control that displays formatted text, optionally autowrapping it to the [Control] area. It inherits from range to be able to scroll wrapped text vertically.
*/
type Label struct {
	Control
}

func (o *Label) baseClass() string {
	return "Label"
}

/*
   Return the alignment mode (any of the ALIGN_* enumeration values).
*/
func (o *Label) GetAlign() int64 {
	log.Println("Calling Label.GetAlign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_align", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the amount of lines.
*/
func (o *Label) GetLineCount() int64 {
	log.Println("Calling Label.GetLineCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_line_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the height of a line.
*/
func (o *Label) GetLineHeight() int64 {
	log.Println("Calling Label.GetLineHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_line_height", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the the number of lines to skipped before displaying.
*/
func (o *Label) GetLinesSkipped() int64 {
	log.Println("Calling Label.GetLinesSkipped()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_lines_skipped", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the restricted number of lines to display. Returns -1 if unrestricted.
*/
func (o *Label) GetMaxLinesVisible() int64 {
	log.Println("Calling Label.GetMaxLinesVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_max_lines_visible", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the restricted number of characters to display (as a percentage of the total text).
*/
func (o *Label) GetPercentVisible() float64 {
	log.Println("Calling Label.GetPercentVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_percent_visible", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the label text. Text can contain newlines.
*/
func (o *Label) GetText() string {
	log.Println("Calling Label.GetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the total length of the text.
*/
func (o *Label) GetTotalCharacterCount() int64 {
	log.Println("Calling Label.GetTotalCharacterCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_total_character_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the vertical alignment mode (any of the VALIGN_* enumeration values).
*/
func (o *Label) GetValign() int64 {
	log.Println("Calling Label.GetValign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_valign", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the restricted number of characters to display. Returns -1 if unrestricted.
*/
func (o *Label) GetVisibleCharacters() int64 {
	log.Println("Calling Label.GetVisibleCharacters()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_visible_characters", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Label) GetVisibleLineCount() int64 {
	log.Println("Calling Label.GetVisibleLineCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_visible_line_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the state of the [i]autowrap[/i] mode (see [method set_autowrap]).
*/
func (o *Label) HasAutowrap() *bool {
	log.Println("Calling Label.HasAutowrap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_autowrap", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if text would be cut off if it is too wide.
*/
func (o *Label) IsClippingText() *bool {
	log.Println("Calling Label.IsClippingText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_clipping_text", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if text is displayed in all capitals.
*/
func (o *Label) IsUppercase() *bool {
	log.Println("Calling Label.IsUppercase()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_uppercase", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Sets the alignment mode to any of the ALIGN_* enumeration values.
*/
func (o *Label) SetAlign(align int64) {
	log.Println("Calling Label.SetAlign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(align)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_align", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set [i]autowrap[/i] mode. When enabled, autowrap will fit text to the control width, breaking sentences when they exceed the available horizontal space. When disabled, the label minimum width becomes the width of the longest row, and the minimum height large enough to fit all rows.
*/
func (o *Label) SetAutowrap(enable *bool) {
	log.Println("Calling Label.SetAutowrap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_autowrap", goArguments, "")

	log.Println("Got return value!")

}

/*
   Cuts off the rest of the text if it is too wide.
*/
func (o *Label) SetClipText(enable *bool) {
	log.Println("Calling Label.SetClipText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_clip_text", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the number of lines to skip before displaying. Useful for scrolling text.
*/
func (o *Label) SetLinesSkipped(linesSkipped int64) {
	log.Println("Calling Label.SetLinesSkipped()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(linesSkipped)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_lines_skipped", goArguments, "")

	log.Println("Got return value!")

}

/*
   Restricts the number of lines to display. Set to -1 to disable.
*/
func (o *Label) SetMaxLinesVisible(linesVisible int64) {
	log.Println("Calling Label.SetMaxLinesVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(linesVisible)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max_lines_visible", goArguments, "")

	log.Println("Got return value!")

}

/*
   Restricts the number of characters to display (as a percentage of the total text).
*/
func (o *Label) SetPercentVisible(percentVisible float64) {
	log.Println("Calling Label.SetPercentVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(percentVisible)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_percent_visible", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the label text. Text can contain newlines.
*/
func (o *Label) SetText(text string) {
	log.Println("Calling Label.SetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_text", goArguments, "")

	log.Println("Got return value!")

}

/*
   Display text in all capitals.
*/
func (o *Label) SetUppercase(enable *bool) {
	log.Println("Calling Label.SetUppercase()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_uppercase", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the vertical alignment mode to any of the VALIGN_* enumeration values.
*/
func (o *Label) SetValign(valign int64) {
	log.Println("Calling Label.SetValign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(valign)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_valign", goArguments, "")

	log.Println("Got return value!")

}

/*
   Restricts the number of characters to display. Set to -1 to disable.
*/
func (o *Label) SetVisibleCharacters(amount int64) {
	log.Println("Calling Label.SetVisibleCharacters()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_visible_characters", goArguments, "")

	log.Println("Got return value!")

}

/*
   LabelImplementer is an interface for Label objects.
   Label is a control that displays formatted text, optionally autowrapping it to the [Control] area. It inherits from range to be able to scroll wrapped text vertically.
*/
type LabelImplementer interface {
	ControlImplementer

	GetAlign() int64

	GetLineCount() int64

	GetLineHeight() int64

	GetLinesSkipped() int64

	GetMaxLinesVisible() int64

	GetPercentVisible() float64

	GetText() string

	GetTotalCharacterCount() int64

	GetValign() int64

	GetVisibleCharacters() int64

	GetVisibleLineCount() int64

	HasAutowrap() *bool

	IsClippingText() *bool

	IsUppercase() *bool

	SetAlign(align int64)

	SetAutowrap(enable *bool)

	SetClipText(enable *bool)

	SetLinesSkipped(linesSkipped int64)

	SetMaxLinesVisible(linesVisible int64)

	SetPercentVisible(percentVisible float64)

	SetText(text string)

	SetUppercase(enable *bool)

	SetValign(valign int64)

	SetVisibleCharacters(amount int64)
}

/*
        A Texture capable of storing many smaller Textures with offsets.
		You can dynamically add pieces(Textures) to this fLargeTexture] using different offsets.
*/
type LargeTexture struct {
	Texture
}

func (o *LargeTexture) baseClass() string {
	return "LargeTexture"
}

/*
   Add another [Texture] to this [LargeTexture], starting on offset "ofs".
*/
func (o *LargeTexture) AddPiece(ofs *Vector2, texture *Texture) int64 {
	log.Println("Calling LargeTexture.AddPiece()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(ofs)
	goArguments[1] = reflect.ValueOf(texture)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "add_piece", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Clear the [LargeTexture].
*/
func (o *LargeTexture) Clear() {
	log.Println("Calling LargeTexture.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the number of pieces currently in this [LargeTexture].
*/
func (o *LargeTexture) GetPieceCount() int64 {
	log.Println("Calling LargeTexture.GetPieceCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_piece_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the offset of the piece with index "idx".
*/
func (o *LargeTexture) GetPieceOffset(idx int64) *Vector2 {
	log.Println("Calling LargeTexture.GetPieceOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_piece_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the [Texture] of the piece with index "idx".
*/
func (o *LargeTexture) GetPieceTexture(idx int64) *Texture {
	log.Println("Calling LargeTexture.GetPieceTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_piece_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   Set the offset of the piece with index "idx" to "ofs".
*/
func (o *LargeTexture) SetPieceOffset(idx int64, ofs *Vector2) {
	log.Println("Calling LargeTexture.SetPieceOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(ofs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_piece_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the [Texture] of the piece with index "idx" to  "ofs".
*/
func (o *LargeTexture) SetPieceTexture(idx int64, texture *Texture) {
	log.Println("Calling LargeTexture.SetPieceTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_piece_texture", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the size of this [LargeTexture].
*/
func (o *LargeTexture) SetSize(size *Vector2) {
	log.Println("Calling LargeTexture.SetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_size", goArguments, "")

	log.Println("Got return value!")

}

/*
        LargeTextureImplementer is an interface for LargeTexture objects.
        A Texture capable of storing many smaller Textures with offsets.
		You can dynamically add pieces(Textures) to this fLargeTexture] using different offsets.
*/
type LargeTextureImplementer interface {
	TextureImplementer

	AddPiece(ofs *Vector2, texture *Texture) int64

	Clear()

	GetPieceCount() int64

	GetPieceOffset(idx int64) *Vector2

	GetPieceTexture(idx int64) *Texture

	SetPieceOffset(idx int64, ofs *Vector2)

	SetPieceTexture(idx int64, texture *Texture)

	SetSize(size *Vector2)
}

/*
   Light is the abstract base class for light nodes, so it shouldn't be used directly (It can't be instanced). Other types of light nodes inherit from it. Light contains the common variables and parameters used for lighting.
*/
type Light struct {
	VisualInstance
}

func (o *Light) baseClass() string {
	return "Light"
}

/*

 */
func (o *Light) GetColor() *Color {
	log.Println("Calling Light.GetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *Light) GetCullMask() int64 {
	log.Println("Calling Light.GetCullMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cull_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Light) GetParam(param int64) float64 {
	log.Println("Calling Light.GetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Light) GetShadowColor() *Color {
	log.Println("Calling Light.GetShadowColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shadow_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *Light) GetShadowReverseCullFace() *bool {
	log.Println("Calling Light.GetShadowReverseCullFace()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shadow_reverse_cull_face", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Light) HasShadow() *bool {
	log.Println("Calling Light.HasShadow()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_shadow", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Light) IsEditorOnly() *bool {
	log.Println("Calling Light.IsEditorOnly()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_editor_only", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Light) IsNegative() *bool {
	log.Println("Calling Light.IsNegative()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_negative", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Light) SetColor(color *Color) {
	log.Println("Calling Light.SetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Light) SetCullMask(cullMask int64) {
	log.Println("Calling Light.SetCullMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(cullMask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cull_mask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Light) SetEditorOnly(editorOnly *bool) {
	log.Println("Calling Light.SetEditorOnly()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(editorOnly)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_editor_only", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Light) SetNegative(enabled *bool) {
	log.Println("Calling Light.SetNegative()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_negative", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Light) SetParam(param int64, value float64) {
	log.Println("Calling Light.SetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(param)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_param", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Light) SetShadow(enabled *bool) {
	log.Println("Calling Light.SetShadow()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Light) SetShadowColor(shadowColor *Color) {
	log.Println("Calling Light.SetShadowColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shadowColor)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Light) SetShadowReverseCullFace(enable *bool) {
	log.Println("Calling Light.SetShadowReverseCullFace()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_reverse_cull_face", goArguments, "")

	log.Println("Got return value!")

}

/*
   LightImplementer is an interface for Light objects.
   Light is the abstract base class for light nodes, so it shouldn't be used directly (It can't be instanced). Other types of light nodes inherit from it. Light contains the common variables and parameters used for lighting.
*/
type LightImplementer interface {
	VisualInstanceImplementer

	GetColor() *Color

	GetCullMask() int64

	GetParam(param int64) float64

	GetShadowColor() *Color

	GetShadowReverseCullFace() *bool

	HasShadow() *bool

	IsEditorOnly() *bool

	IsNegative() *bool

	SetColor(color *Color)

	SetCullMask(cullMask int64)

	SetEditorOnly(editorOnly *bool)

	SetNegative(enabled *bool)

	SetParam(param int64, value float64)

	SetShadow(enabled *bool)

	SetShadowColor(shadowColor *Color)

	SetShadowReverseCullFace(enable *bool)
}

/*
   Node that casts light in a 2D environment. Light is defined by a (usually grayscale) texture, a color, an energy value, a mode (see constants), and various other parameters (range and shadows-related). Note that Light2D can be used as a mask.
*/
type Light2D struct {
	Node2D
}

func (o *Light2D) baseClass() string {
	return "Light2D"
}

/*
   Return the color of the Light2D.
*/
func (o *Light2D) GetColor() *Color {
	log.Println("Calling Light2D.GetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   Return the energy value of the Light2D.
*/
func (o *Light2D) GetEnergy() float64 {
	log.Println("Calling Light2D.GetEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_energy", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the height of the Light2D. Used with 2D normalmapping.
*/
func (o *Light2D) GetHeight() float64 {
	log.Println("Calling Light2D.GetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_height", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Light2D) GetItemCullMask() int64 {
	log.Println("Calling Light2D.GetItemCullMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_cull_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Light2D) GetItemShadowCullMask() int64 {
	log.Println("Calling Light2D.GetItemShadowCullMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_shadow_cull_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the maximum layer value of objects of the scene that are affected by the Light2D.
*/
func (o *Light2D) GetLayerRangeMax() int64 {
	log.Println("Calling Light2D.GetLayerRangeMax()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_layer_range_max", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the minimum layer value of objects of the scene that are affected by the Light2D.
*/
func (o *Light2D) GetLayerRangeMin() int64 {
	log.Println("Calling Light2D.GetLayerRangeMin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_layer_range_min", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the current mode set to the Light2D.
*/
func (o *Light2D) GetMode() int64 {
	log.Println("Calling Light2D.GetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the shadow buffer size.
*/
func (o *Light2D) GetShadowBufferSize() int64 {
	log.Println("Calling Light2D.GetShadowBufferSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shadow_buffer_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the color of casted shadows for this Light2D.
*/
func (o *Light2D) GetShadowColor() *Color {
	log.Println("Calling Light2D.GetShadowColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shadow_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *Light2D) GetShadowFilter() int64 {
	log.Println("Calling Light2D.GetShadowFilter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shadow_filter", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Light2D) GetShadowGradientLength() float64 {
	log.Println("Calling Light2D.GetShadowGradientLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shadow_gradient_length", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Light2D) GetShadowSmooth() float64 {
	log.Println("Calling Light2D.GetShadowSmooth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shadow_smooth", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the texture of the Light2D.
*/
func (o *Light2D) GetTexture() *Texture {
	log.Println("Calling Light2D.GetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   Return the offset of the light texture.
*/
func (o *Light2D) GetTextureOffset() *Vector2 {
	log.Println("Calling Light2D.GetTextureOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the scale value of the light texture.
*/
func (o *Light2D) GetTextureScale() float64 {
	log.Println("Calling Light2D.GetTextureScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Get the maximum Z value that objects of the scene can be in order to be affected by the Light2D.
*/
func (o *Light2D) GetZRangeMax() int64 {
	log.Println("Calling Light2D.GetZRangeMax()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_z_range_max", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the minimum Z value that objects of the scene have to be in order to be affected by the Light2D.
*/
func (o *Light2D) GetZRangeMin() int64 {
	log.Println("Calling Light2D.GetZRangeMin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_z_range_min", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Light2D) IsEditorOnly() *bool {
	log.Println("Calling Light2D.IsEditorOnly()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_editor_only", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if the Light2D is enabled, false if it is not.
*/
func (o *Light2D) IsEnabled() *bool {
	log.Println("Calling Light2D.IsEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if shadow casting is enabled for this Light2D, else return false.
*/
func (o *Light2D) IsShadowEnabled() *bool {
	log.Println("Calling Light2D.IsShadowEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_shadow_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Set the color of the Light2D.
*/
func (o *Light2D) SetColor(color *Color) {
	log.Println("Calling Light2D.SetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Light2D) SetEditorOnly(editorOnly *bool) {
	log.Println("Calling Light2D.SetEditorOnly()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(editorOnly)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_editor_only", goArguments, "")

	log.Println("Got return value!")

}

/*
   Switches the Light2D on or off, depending on the 'enabled' parameter.
*/
func (o *Light2D) SetEnabled(enabled *bool) {
	log.Println("Calling Light2D.SetEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the energy value of the Light2D. The bigger the value, the stronger the light.
*/
func (o *Light2D) SetEnergy(energy float64) {
	log.Println("Calling Light2D.SetEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(energy)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_energy", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the height of the Light2D. Used with 2D normalmapping.
*/
func (o *Light2D) SetHeight(height float64) {
	log.Println("Calling Light2D.SetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(height)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_height", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the item mask of the Light2D to 'item_mask' value.
*/
func (o *Light2D) SetItemCullMask(itemCullMask int64) {
	log.Println("Calling Light2D.SetItemCullMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(itemCullMask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_cull_mask", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the item shadow mask to 'item_shadow_mask' value.
*/
func (o *Light2D) SetItemShadowCullMask(itemShadowCullMask int64) {
	log.Println("Calling Light2D.SetItemShadowCullMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(itemShadowCullMask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_shadow_cull_mask", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the maximum layer value of objects of the scene that are affected by the Light2D.
*/
func (o *Light2D) SetLayerRangeMax(layer int64) {
	log.Println("Calling Light2D.SetLayerRangeMax()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_layer_range_max", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the minimum layer value of objects of the scene that are affected by the Light2D.
*/
func (o *Light2D) SetLayerRangeMin(layer int64) {
	log.Println("Calling Light2D.SetLayerRangeMin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_layer_range_min", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the behaviour mode of the Light2D. Use constants defined in the constants section.
*/
func (o *Light2D) SetMode(mode int64) {
	log.Println("Calling Light2D.SetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the shadow buffer size.
*/
func (o *Light2D) SetShadowBufferSize(size int64) {
	log.Println("Calling Light2D.SetShadowBufferSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_buffer_size", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the color of casted shadows for this Light2D.
*/
func (o *Light2D) SetShadowColor(shadowColor *Color) {
	log.Println("Calling Light2D.SetShadowColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shadowColor)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_color", goArguments, "")

	log.Println("Got return value!")

}

/*
   Enable or disable shadows casting from this Light2D according to the 'enabled' parameter.
*/
func (o *Light2D) SetShadowEnabled(enabled *bool) {
	log.Println("Calling Light2D.SetShadowEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Light2D) SetShadowFilter(filter int64) {
	log.Println("Calling Light2D.SetShadowFilter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(filter)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_filter", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Light2D) SetShadowGradientLength(multiplier float64) {
	log.Println("Calling Light2D.SetShadowGradientLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(multiplier)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_gradient_length", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Light2D) SetShadowSmooth(smooth float64) {
	log.Println("Calling Light2D.SetShadowSmooth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(smooth)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_smooth", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the texture of the Light2D.
*/
func (o *Light2D) SetTexture(texture *Texture) {
	log.Println("Calling Light2D.SetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the offset of the light texture.
*/
func (o *Light2D) SetTextureOffset(textureOffset *Vector2) {
	log.Println("Calling Light2D.SetTextureOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(textureOffset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the scale value of the light texture.
*/
func (o *Light2D) SetTextureScale(textureScale float64) {
	log.Println("Calling Light2D.SetTextureScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(textureScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the maximum Z value that objects of the scene can be in order to be affected by the Light2D.
*/
func (o *Light2D) SetZRangeMax(z int64) {
	log.Println("Calling Light2D.SetZRangeMax()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(z)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_z_range_max", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the minimum Z value that objects of the scene have to be in order to be affected by the Light2D.
*/
func (o *Light2D) SetZRangeMin(z int64) {
	log.Println("Calling Light2D.SetZRangeMin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(z)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_z_range_min", goArguments, "")

	log.Println("Got return value!")

}

/*
   Light2DImplementer is an interface for Light2D objects.
   Node that casts light in a 2D environment. Light is defined by a (usually grayscale) texture, a color, an energy value, a mode (see constants), and various other parameters (range and shadows-related). Note that Light2D can be used as a mask.
*/
type Light2DImplementer interface {
	Node2DImplementer

	GetColor() *Color

	GetEnergy() float64

	GetHeight() float64

	GetItemCullMask() int64

	GetItemShadowCullMask() int64

	GetLayerRangeMax() int64

	GetLayerRangeMin() int64

	GetMode() int64

	GetShadowBufferSize() int64

	GetShadowColor() *Color

	GetShadowFilter() int64

	GetShadowGradientLength() float64

	GetShadowSmooth() float64

	GetTexture() *Texture

	GetTextureOffset() *Vector2

	GetTextureScale() float64

	GetZRangeMax() int64

	GetZRangeMin() int64

	IsEditorOnly() *bool

	IsEnabled() *bool

	IsShadowEnabled() *bool

	SetColor(color *Color)

	SetEditorOnly(editorOnly *bool)

	SetEnabled(enabled *bool)

	SetEnergy(energy float64)

	SetHeight(height float64)

	SetItemCullMask(itemCullMask int64)

	SetItemShadowCullMask(itemShadowCullMask int64)

	SetLayerRangeMax(layer int64)

	SetLayerRangeMin(layer int64)

	SetMode(mode int64)

	SetShadowBufferSize(size int64)

	SetShadowColor(shadowColor *Color)

	SetShadowEnabled(enabled *bool)

	SetShadowFilter(filter int64)

	SetShadowGradientLength(multiplier float64)

	SetShadowSmooth(smooth float64)

	SetTexture(texture *Texture)

	SetTextureOffset(textureOffset *Vector2)

	SetTextureScale(textureScale float64)

	SetZRangeMax(z int64)

	SetZRangeMin(z int64)
}

/*
   Occludes light cast by a Light2D, thus casting shadows. The LightOccluder2D must be provided with a shape (see OccluderPolygon2D) that allows the shadow to be computed. This shape affects the resulting shadow, while the shape of the representating asset shadowed does not actually affect shadows.
*/
type LightOccluder2D struct {
	Node2D
}

func (o *LightOccluder2D) baseClass() string {
	return "LightOccluder2D"
}

/*
   Return the light mask of the LightOccluder2D.
*/
func (o *LightOccluder2D) GetOccluderLightMask() int64 {
	log.Println("Calling LightOccluder2D.GetOccluderLightMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_occluder_light_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the OccluderPolygon2D that defines the LightOccluder2D.
*/
func (o *LightOccluder2D) GetOccluderPolygon() *OccluderPolygon2D {
	log.Println("Calling LightOccluder2D.GetOccluderPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_occluder_polygon", goArguments, "*OccluderPolygon2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*OccluderPolygon2D)

	return returnValue

}

/*
   Set the LightOccluder2D light mask. The LightOccluder2D will cast shadows only from Light2Ds that belong to the same light mask(s).
*/
func (o *LightOccluder2D) SetOccluderLightMask(mask int64) {
	log.Println("Calling LightOccluder2D.SetOccluderLightMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_occluder_light_mask", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the OccluderPolygon2D that defines the LightOccluder2D.
*/
func (o *LightOccluder2D) SetOccluderPolygon(polygon *OccluderPolygon2D) {
	log.Println("Calling LightOccluder2D.SetOccluderPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(polygon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_occluder_polygon", goArguments, "")

	log.Println("Got return value!")

}

/*
   LightOccluder2DImplementer is an interface for LightOccluder2D objects.
   Occludes light cast by a Light2D, thus casting shadows. The LightOccluder2D must be provided with a shape (see OccluderPolygon2D) that allows the shadow to be computed. This shape affects the resulting shadow, while the shape of the representating asset shadowed does not actually affect shadows.
*/
type LightOccluder2DImplementer interface {
	Node2DImplementer

	GetOccluderLightMask() int64

	GetOccluderPolygon() *OccluderPolygon2D

	SetOccluderLightMask(mask int64)

	SetOccluderPolygon(polygon *OccluderPolygon2D)
}

/*

 */
type Line2D struct {
	Node2D
}

func (o *Line2D) baseClass() string {
	return "Line2D"
}

/*

 */
func (o *Line2D) AddPoint(pos *Vector2) {
	log.Println("Calling Line2D.AddPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_point", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Line2D) GetBeginCapMode() int64 {
	log.Println("Calling Line2D.GetBeginCapMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_begin_cap_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Line2D) GetDefaultColor() *Color {
	log.Println("Calling Line2D.GetDefaultColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_default_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *Line2D) GetEndCapMode() int64 {
	log.Println("Calling Line2D.GetEndCapMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_end_cap_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Line2D) GetGradient() *Gradient {
	log.Println("Calling Line2D.GetGradient()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gradient", goArguments, "*Gradient")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Gradient)

	return returnValue

}

/*

 */
func (o *Line2D) GetJointMode() int64 {
	log.Println("Calling Line2D.GetJointMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_joint_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Line2D) GetPointCount() int64 {
	log.Println("Calling Line2D.GetPointCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Line2D) GetPointPos(i int64) *Vector2 {
	log.Println("Calling Line2D.GetPointPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(i)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_pos", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Line2D) GetPoints() *PoolVector2Array {
	log.Println("Calling Line2D.GetPoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_points", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*

 */
func (o *Line2D) GetRoundPrecision() int64 {
	log.Println("Calling Line2D.GetRoundPrecision()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_round_precision", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Line2D) GetSharpLimit() float64 {
	log.Println("Calling Line2D.GetSharpLimit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sharp_limit", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Line2D) GetTexture() *Texture {
	log.Println("Calling Line2D.GetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *Line2D) GetTextureMode() int64 {
	log.Println("Calling Line2D.GetTextureMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Line2D) GetWidth() float64 {
	log.Println("Calling Line2D.GetWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_width", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Line2D) RemovePoint(i int64) {
	log.Println("Calling Line2D.RemovePoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(i)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_point", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Line2D) SetBeginCapMode(mode int64) {
	log.Println("Calling Line2D.SetBeginCapMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_begin_cap_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Line2D) SetDefaultColor(color *Color) {
	log.Println("Calling Line2D.SetDefaultColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_default_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Line2D) SetEndCapMode(mode int64) {
	log.Println("Calling Line2D.SetEndCapMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_end_cap_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Line2D) SetGradient(color *Gradient) {
	log.Println("Calling Line2D.SetGradient()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gradient", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Line2D) SetJointMode(mode int64) {
	log.Println("Calling Line2D.SetJointMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_joint_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Line2D) SetPointPos(i int64, pos *Vector2) {
	log.Println("Calling Line2D.SetPointPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(i)
	goArguments[1] = reflect.ValueOf(pos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_pos", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Line2D) SetPoints(points *PoolVector2Array) {
	log.Println("Calling Line2D.SetPoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(points)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_points", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Line2D) SetRoundPrecision(precision int64) {
	log.Println("Calling Line2D.SetRoundPrecision()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(precision)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_round_precision", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Line2D) SetSharpLimit(limit float64) {
	log.Println("Calling Line2D.SetSharpLimit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(limit)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sharp_limit", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Line2D) SetTexture(texture *Texture) {
	log.Println("Calling Line2D.SetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Line2D) SetTextureMode(mode int64) {
	log.Println("Calling Line2D.SetTextureMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Line2D) SetWidth(width float64) {
	log.Println("Calling Line2D.SetWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(width)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_width", goArguments, "")

	log.Println("Got return value!")

}

/*
   Line2DImplementer is an interface for Line2D objects.

*/
type Line2DImplementer interface {
	Node2DImplementer

	AddPoint(pos *Vector2)

	GetBeginCapMode() int64

	GetDefaultColor() *Color

	GetEndCapMode() int64

	GetGradient() *Gradient

	GetJointMode() int64

	GetPointCount() int64

	GetPointPos(i int64) *Vector2

	GetPoints() *PoolVector2Array

	GetRoundPrecision() int64

	GetSharpLimit() float64

	GetTexture() *Texture

	GetTextureMode() int64

	GetWidth() float64

	RemovePoint(i int64)

	SetBeginCapMode(mode int64)

	SetDefaultColor(color *Color)

	SetEndCapMode(mode int64)

	SetGradient(color *Gradient)

	SetJointMode(mode int64)

	SetPointPos(i int64, pos *Vector2)

	SetPoints(points *PoolVector2Array)

	SetRoundPrecision(precision int64)

	SetSharpLimit(limit float64)

	SetTexture(texture *Texture)

	SetTextureMode(mode int64)

	SetWidth(width float64)
}

/*
   LineEdit provides a single line string editor, used for text fields.
*/
type LineEdit struct {
	Control
}

func (o *LineEdit) baseClass() string {
	return "LineEdit"
}

/*
   Append text at cursor, scrolling the [LineEdit] when needed.
*/
func (o *LineEdit) AppendAtCursor(text string) {
	log.Println("Calling LineEdit.AppendAtCursor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "append_at_cursor", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear the [LineEdit] text.
*/
func (o *LineEdit) Clear() {
	log.Println("Calling LineEdit.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Gets whether the line edit caret is blinking.
*/
func (o *LineEdit) CursorGetBlinkEnabled() *bool {
	log.Println("Calling LineEdit.CursorGetBlinkEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "cursor_get_blink_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Gets the line edit caret blink speed.
*/
func (o *LineEdit) CursorGetBlinkSpeed() float64 {
	log.Println("Calling LineEdit.CursorGetBlinkSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "cursor_get_blink_speed", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the line edit caret to blink.
*/
func (o *LineEdit) CursorSetBlinkEnabled(enabled *bool) {
	log.Println("Calling LineEdit.CursorSetBlinkEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "cursor_set_blink_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the line edit caret blink speed. Cannot be less then or equal to 0.
*/
func (o *LineEdit) CursorSetBlinkSpeed(blinkSpeed float64) {
	log.Println("Calling LineEdit.CursorSetBlinkSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(blinkSpeed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "cursor_set_blink_speed", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *LineEdit) GetAlign() int64 {
	log.Println("Calling LineEdit.GetAlign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_align", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the cursor position inside the [LineEdit].
*/
func (o *LineEdit) GetCursorPos() int64 {
	log.Println("Calling LineEdit.GetCursorPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cursor_pos", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *LineEdit) GetExpandToTextLength() *bool {
	log.Println("Calling LineEdit.GetExpandToTextLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_expand_to_text_length", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return the maximum amount of characters the [LineEdit] can edit. If 0 is returned, no limit exists.
*/
func (o *LineEdit) GetMaxLength() int64 {
	log.Println("Calling LineEdit.GetMaxLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_max_length", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *LineEdit) GetMenu() *PopupMenu {
	log.Println("Calling LineEdit.GetMenu()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_menu", goArguments, "*PopupMenu")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PopupMenu)

	return returnValue

}

/*

 */
func (o *LineEdit) GetPlaceholder() string {
	log.Println("Calling LineEdit.GetPlaceholder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_placeholder", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *LineEdit) GetPlaceholderAlpha() float64 {
	log.Println("Calling LineEdit.GetPlaceholderAlpha()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_placeholder_alpha", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the text in the [LineEdit].
*/
func (o *LineEdit) GetText() string {
	log.Println("Calling LineEdit.GetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the [i]editable[/i] status of the [LineEdit] (see [method set_editable]).
*/
func (o *LineEdit) IsEditable() *bool {
	log.Println("Calling LineEdit.IsEditable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_editable", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return the [i]secret[/i] status of the [LineEdit] (see [method set_secret]).
*/
func (o *LineEdit) IsSecret() *bool {
	log.Println("Calling LineEdit.IsSecret()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_secret", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *LineEdit) MenuOption(option int64) {
	log.Println("Calling LineEdit.MenuOption()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(option)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "menu_option", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *LineEdit) Select(from int64, to int64) {
	log.Println("Calling LineEdit.Select()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(to)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "select", goArguments, "")

	log.Println("Got return value!")

}

/*
   Select the whole string.
*/
func (o *LineEdit) SelectAll() {
	log.Println("Calling LineEdit.SelectAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "select_all", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *LineEdit) SetAlign(align int64) {
	log.Println("Calling LineEdit.SetAlign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(align)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_align", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the cursor position inside the [LineEdit], causing it to scroll if needed.
*/
func (o *LineEdit) SetCursorPos(pos int64) {
	log.Println("Calling LineEdit.SetCursorPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cursor_pos", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the [i]editable[/i] status of the [LineEdit]. When disabled, existing text can't be modified and new text can't be added.
*/
func (o *LineEdit) SetEditable(enabled *bool) {
	log.Println("Calling LineEdit.SetEditable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_editable", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *LineEdit) SetExpandToTextLength(enabled *bool) {
	log.Println("Calling LineEdit.SetExpandToTextLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_expand_to_text_length", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the maximum amount of characters the [LineEdit] can edit, and cropping existing text in case it exceeds that limit. Setting 0 removes the limit.
*/
func (o *LineEdit) SetMaxLength(chars int64) {
	log.Println("Calling LineEdit.SetMaxLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(chars)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max_length", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *LineEdit) SetPlaceholder(text string) {
	log.Println("Calling LineEdit.SetPlaceholder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_placeholder", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *LineEdit) SetPlaceholderAlpha(alpha float64) {
	log.Println("Calling LineEdit.SetPlaceholderAlpha()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(alpha)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_placeholder_alpha", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the [i]secret[/i] status of the [LineEdit]. When enabled, every character is displayed as "*".
*/
func (o *LineEdit) SetSecret(enabled *bool) {
	log.Println("Calling LineEdit.SetSecret()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_secret", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the text in the [LineEdit], clearing the existing one and the selection.
*/
func (o *LineEdit) SetText(text string) {
	log.Println("Calling LineEdit.SetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_text", goArguments, "")

	log.Println("Got return value!")

}

/*
   LineEditImplementer is an interface for LineEdit objects.
   LineEdit provides a single line string editor, used for text fields.
*/
type LineEditImplementer interface {
	ControlImplementer

	AppendAtCursor(text string)

	Clear()

	CursorGetBlinkEnabled() *bool

	CursorGetBlinkSpeed() float64

	CursorSetBlinkEnabled(enabled *bool)

	CursorSetBlinkSpeed(blinkSpeed float64)

	GetAlign() int64

	GetCursorPos() int64

	GetExpandToTextLength() *bool

	GetMaxLength() int64

	GetMenu() *PopupMenu

	GetPlaceholder() string

	GetPlaceholderAlpha() float64

	GetText() string

	IsEditable() *bool

	IsSecret() *bool

	MenuOption(option int64)

	Select(from int64, to int64)

	SelectAll()

	SetAlign(align int64)

	SetCursorPos(pos int64)

	SetEditable(enabled *bool)

	SetExpandToTextLength(enabled *bool)

	SetMaxLength(chars int64)

	SetPlaceholder(text string)

	SetPlaceholderAlpha(alpha float64)

	SetSecret(enabled *bool)

	SetText(text string)
}

/*
   Line shape for 2D collision objects. It works like a 2D plane and will not allow any body to go to the negative side. Not recommended for rigid bodies, and usually not recommended for static bodies either because it forces checks against it on every frame.
*/
type LineShape2D struct {
	Shape2D
}

func (o *LineShape2D) baseClass() string {
	return "LineShape2D"
}

/*
   Return the line distance from the origin.
*/
func (o *LineShape2D) GetD() float64 {
	log.Println("Calling LineShape2D.GetD()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_d", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the line normal.
*/
func (o *LineShape2D) GetNormal() *Vector2 {
	log.Println("Calling LineShape2D.GetNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_normal", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Set the line distance from the origin.
*/
func (o *LineShape2D) SetD(d float64) {
	log.Println("Calling LineShape2D.SetD()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(d)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_d", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the line normal.
*/
func (o *LineShape2D) SetNormal(normal *Vector2) {
	log.Println("Calling LineShape2D.SetNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(normal)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_normal", goArguments, "")

	log.Println("Got return value!")

}

/*
   LineShape2DImplementer is an interface for LineShape2D objects.
   Line shape for 2D collision objects. It works like a 2D plane and will not allow any body to go to the negative side. Not recommended for rigid bodies, and usually not recommended for static bodies either because it forces checks against it on every frame.
*/
type LineShape2DImplementer interface {
	Shape2DImplementer

	GetD() float64

	GetNormal() *Vector2

	SetD(d float64)

	SetNormal(normal *Vector2)
}

/*
   This kind of buttons are primarily used when the interaction with the button causes a context change (like linking to a web page).
*/
type LinkButton struct {
	BaseButton
}

func (o *LinkButton) baseClass() string {
	return "LinkButton"
}

/*
   Returns the text of the button.
*/
func (o *LinkButton) GetText() string {
	log.Println("Calling LinkButton.GetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Returns the underline mode for this button.
*/
func (o *LinkButton) GetUnderlineMode() int64 {
	log.Println("Calling LinkButton.GetUnderlineMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_underline_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Sets the text of the button.
*/
func (o *LinkButton) SetText(text string) {
	log.Println("Calling LinkButton.SetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_text", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the underline mode for this button, the argument must be one of the [LinkButton] constants (see constants section).
*/
func (o *LinkButton) SetUnderlineMode(underlineMode int64) {
	log.Println("Calling LinkButton.SetUnderlineMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(underlineMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_underline_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   LinkButtonImplementer is an interface for LinkButton objects.
   This kind of buttons are primarily used when the interaction with the button causes a context change (like linking to a web page).
*/
type LinkButtonImplementer interface {
	BaseButtonImplementer

	GetText() string

	GetUnderlineMode() int64

	SetText(text string)

	SetUnderlineMode(underlineMode int64)
}

/*

 */
type Listener struct {
	Spatial
}

func (o *Listener) baseClass() string {
	return "Listener"
}

/*

 */
func (o *Listener) ClearCurrent() {
	log.Println("Calling Listener.ClearCurrent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_current", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Listener) GetListenerTransform() *Transform {
	log.Println("Calling Listener.GetListenerTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_listener_transform", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*

 */
func (o *Listener) IsCurrent() *bool {
	log.Println("Calling Listener.IsCurrent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_current", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Listener) MakeCurrent() {
	log.Println("Calling Listener.MakeCurrent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "make_current", goArguments, "")

	log.Println("Got return value!")

}

/*
   ListenerImplementer is an interface for Listener objects.

*/
type ListenerImplementer interface {
	SpatialImplementer

	ClearCurrent()

	GetListenerTransform() *Transform

	IsCurrent() *bool

	MakeCurrent()
}

/*
   Main loop is the abstract main loop base class. All other main loop classes are derived from it. Upon application start, a [MainLoop] has to be provided to OS, else the application will exit. This happens automatically (and a [SceneTree] is created), unless a main [Script] is supplied, which may or not create and return a [MainLoop].
*/
type MainLoop struct {
	Object
}

func (o *MainLoop) baseClass() string {
	return "MainLoop"
}

/*

 */
func (o *MainLoop) X_DropFiles(files *PoolStringArray, screen int64) {
	log.Println("Calling MainLoop.X_DropFiles()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(files)
	goArguments[1] = reflect.ValueOf(screen)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_drop_files", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MainLoop) X_Finalize() {
	log.Println("Calling MainLoop.X_Finalize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_finalize", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MainLoop) X_Idle(delta float64) {
	log.Println("Calling MainLoop.X_Idle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(delta)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_idle", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MainLoop) X_Initialize() {
	log.Println("Calling MainLoop.X_Initialize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_initialize", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MainLoop) X_InputEvent(ev *InputEvent) {
	log.Println("Calling MainLoop.X_InputEvent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ev)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_input_event", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MainLoop) X_InputText(text string) {
	log.Println("Calling MainLoop.X_InputText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_input_text", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MainLoop) X_Iteration(delta float64) {
	log.Println("Calling MainLoop.X_Iteration()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(delta)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_iteration", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MainLoop) Finish() {
	log.Println("Calling MainLoop.Finish()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "finish", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MainLoop) Idle(delta float64) *bool {
	log.Println("Calling MainLoop.Idle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(delta)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "idle", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *MainLoop) Init() {
	log.Println("Calling MainLoop.Init()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "init", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MainLoop) InputEvent(ev *InputEvent) {
	log.Println("Calling MainLoop.InputEvent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ev)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "input_event", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MainLoop) InputText(text string) {
	log.Println("Calling MainLoop.InputText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "input_text", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MainLoop) Iteration(delta float64) *bool {
	log.Println("Calling MainLoop.Iteration()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(delta)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "iteration", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   MainLoopImplementer is an interface for MainLoop objects.
   Main loop is the abstract main loop base class. All other main loop classes are derived from it. Upon application start, a [MainLoop] has to be provided to OS, else the application will exit. This happens automatically (and a [SceneTree] is created), unless a main [Script] is supplied, which may or not create and return a [MainLoop].
*/
type MainLoopImplementer interface {
	ObjectImplementer

	X_DropFiles(files *PoolStringArray, screen int64)

	X_Finalize()

	X_Idle(delta float64)

	X_Initialize()

	X_InputEvent(ev *InputEvent)

	X_InputText(text string)

	X_Iteration(delta float64)

	Finish()

	Idle(delta float64) *bool

	Init()

	InputEvent(ev *InputEvent)

	InputText(text string)

	Iteration(delta float64) *bool
}

/*
   Simple margin container. Adds a left margin to anything contained.
*/
type MarginContainer struct {
	Container
}

func (o *MarginContainer) baseClass() string {
	return "MarginContainer"
}

/*
   MarginContainerImplementer is an interface for MarginContainer objects.
   Simple margin container. Adds a left margin to anything contained.
*/
type MarginContainerImplementer interface {
	ContainerImplementer
}

/*

 */
type Marshalls struct {
	Reference
}

func (o *Marshalls) baseClass() string {
	return "Marshalls"
}

/*

 */
func (o *Marshalls) Base64ToRaw(base64Str string) *PoolByteArray {
	log.Println("Calling Marshalls.Base64ToRaw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(base64Str)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "base64_to_raw", goArguments, "*PoolByteArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolByteArray)

	return returnValue

}

/*

 */
func (o *Marshalls) Base64ToUtf8(base64Str string) string {
	log.Println("Calling Marshalls.Base64ToUtf8()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(base64Str)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "base64_to_utf8", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *Marshalls) Base64ToVariant(base64Str string) *Variant {
	log.Println("Calling Marshalls.Base64ToVariant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(base64Str)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "base64_to_variant", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *Marshalls) RawToBase64(array *PoolByteArray) string {
	log.Println("Calling Marshalls.RawToBase64()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(array)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "raw_to_base64", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *Marshalls) Utf8ToBase64(utf8Str string) string {
	log.Println("Calling Marshalls.Utf8ToBase64()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(utf8Str)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "utf8_to_base64", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *Marshalls) VariantToBase64(variant *Variant) string {
	log.Println("Calling Marshalls.VariantToBase64()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(variant)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "variant_to_base64", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   MarshallsImplementer is an interface for Marshalls objects.

*/
type MarshallsImplementer interface {
	ReferenceImplementer

	Base64ToRaw(base64Str string) *PoolByteArray

	Base64ToUtf8(base64Str string) string

	Base64ToVariant(base64Str string) *Variant

	RawToBase64(array *PoolByteArray) string

	Utf8ToBase64(utf8Str string) string

	VariantToBase64(variant *Variant) string
}

/*
   Material is a base [Resource] used for coloring and shading geometry. All materials inherit from it and almost all [VisualInstance] derived nodes carry a Material. A few flags and parameters are shared between all material types and are configured here.
*/
type Material struct {
	Resource
}

func (o *Material) baseClass() string {
	return "Material"
}

/*

 */
func (o *Material) GetNextPass() *Material {
	log.Println("Calling Material.GetNextPass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_next_pass", goArguments, "*Material")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Material)

	return returnValue

}

/*

 */
func (o *Material) GetRenderPriority() int64 {
	log.Println("Calling Material.GetRenderPriority()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_render_priority", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Material) SetNextPass(nextPass *Material) {
	log.Println("Calling Material.SetNextPass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(nextPass)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_next_pass", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Material) SetRenderPriority(priority int64) {
	log.Println("Calling Material.SetRenderPriority()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(priority)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_render_priority", goArguments, "")

	log.Println("Got return value!")

}

/*
   MaterialImplementer is an interface for Material objects.
   Material is a base [Resource] used for coloring and shading geometry. All materials inherit from it and almost all [VisualInstance] derived nodes carry a Material. A few flags and parameters are shared between all material types and are configured here.
*/
type MaterialImplementer interface {
	ResourceImplementer

	GetNextPass() *Material

	GetRenderPriority() int64

	SetNextPass(nextPass *Material)

	SetRenderPriority(priority int64)
}

/*
   Special button that brings up a [PopupMenu] when clicked. That's pretty much all it does, as it's just a helper class when building GUIs.
*/
type MenuButton struct {
	Button
}

func (o *MenuButton) baseClass() string {
	return "MenuButton"
}

/*
   Return the [PopupMenu] contained in this button.
*/
func (o *MenuButton) GetPopup() *PopupMenu {
	log.Println("Calling MenuButton.GetPopup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_popup", goArguments, "*PopupMenu")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PopupMenu)

	return returnValue

}

/*
   MenuButtonImplementer is an interface for MenuButton objects.
   Special button that brings up a [PopupMenu] when clicked. That's pretty much all it does, as it's just a helper class when building GUIs.
*/
type MenuButtonImplementer interface {
	ButtonImplementer

	GetPopup() *PopupMenu
}

/*
   Mesh is a type of [Resource] that contains vertex-array based geometry, divided in [i]surfaces[/i]. Each surface contains a completely separate array and a material used to draw it. Design wise, a mesh with multiple surfaces is preferred to a single surface, because objects created in 3D editing software commonly contain multiple materials.
*/
type Mesh struct {
	Resource
}

func (o *Mesh) baseClass() string {
	return "Mesh"
}

/*

 */
func (o *Mesh) CreateConvexShape() *Shape {
	log.Println("Calling Mesh.CreateConvexShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "create_convex_shape", goArguments, "*Shape")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Shape)

	return returnValue

}

/*

 */
func (o *Mesh) CreateOutline(margin float64) *Mesh {
	log.Println("Calling Mesh.CreateOutline()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "create_outline", goArguments, "*Mesh")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Mesh)

	return returnValue

}

/*

 */
func (o *Mesh) CreateTrimeshShape() *Shape {
	log.Println("Calling Mesh.CreateTrimeshShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "create_trimesh_shape", goArguments, "*Shape")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Shape)

	return returnValue

}

/*

 */
func (o *Mesh) GenerateTriangleMesh() *TriangleMesh {
	log.Println("Calling Mesh.GenerateTriangleMesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "generate_triangle_mesh", goArguments, "*TriangleMesh")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*TriangleMesh)

	return returnValue

}

/*

 */
func (o *Mesh) GetFaces() *PoolVector3Array {
	log.Println("Calling Mesh.GetFaces()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_faces", goArguments, "*PoolVector3Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector3Array)

	return returnValue

}

/*
   MeshImplementer is an interface for Mesh objects.
   Mesh is a type of [Resource] that contains vertex-array based geometry, divided in [i]surfaces[/i]. Each surface contains a completely separate array and a material used to draw it. Design wise, a mesh with multiple surfaces is preferred to a single surface, because objects created in 3D editing software commonly contain multiple materials.
*/
type MeshImplementer interface {
	ResourceImplementer

	CreateConvexShape() *Shape

	CreateOutline(margin float64) *Mesh

	CreateTrimeshShape() *Shape

	GenerateTriangleMesh() *TriangleMesh

	GetFaces() *PoolVector3Array
}

/*

 */
type MeshDataTool struct {
	Reference
}

func (o *MeshDataTool) baseClass() string {
	return "MeshDataTool"
}

/*

 */
func (o *MeshDataTool) Clear() {
	log.Println("Calling MeshDataTool.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshDataTool) CommitToSurface(mesh *ArrayMesh) int64 {
	log.Println("Calling MeshDataTool.CommitToSurface()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mesh)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "commit_to_surface", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *MeshDataTool) CreateFromSurface(mesh *ArrayMesh, surface int64) int64 {
	log.Println("Calling MeshDataTool.CreateFromSurface()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(mesh)
	goArguments[1] = reflect.ValueOf(surface)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "create_from_surface", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetEdgeCount() int64 {
	log.Println("Calling MeshDataTool.GetEdgeCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_edge_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetEdgeFaces(idx int64) *PoolIntArray {
	log.Println("Calling MeshDataTool.GetEdgeFaces()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_edge_faces", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetEdgeMeta(idx int64) *Variant {
	log.Println("Calling MeshDataTool.GetEdgeMeta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_edge_meta", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetEdgeVertex(idx int64, vertex int64) int64 {
	log.Println("Calling MeshDataTool.GetEdgeVertex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(vertex)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_edge_vertex", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetFaceCount() int64 {
	log.Println("Calling MeshDataTool.GetFaceCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_face_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetFaceEdge(idx int64, edge int64) int64 {
	log.Println("Calling MeshDataTool.GetFaceEdge()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(edge)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_face_edge", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetFaceMeta(idx int64) *Variant {
	log.Println("Calling MeshDataTool.GetFaceMeta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_face_meta", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetFaceNormal(idx int64) *Vector3 {
	log.Println("Calling MeshDataTool.GetFaceNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_face_normal", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetFaceVertex(idx int64, vertex int64) int64 {
	log.Println("Calling MeshDataTool.GetFaceVertex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(vertex)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_face_vertex", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetFormat() int64 {
	log.Println("Calling MeshDataTool.GetFormat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_format", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetMaterial() *Material {
	log.Println("Calling MeshDataTool.GetMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_material", goArguments, "*Material")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Material)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetVertex(idx int64) *Vector3 {
	log.Println("Calling MeshDataTool.GetVertex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertex", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetVertexBones(idx int64) *PoolIntArray {
	log.Println("Calling MeshDataTool.GetVertexBones()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertex_bones", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetVertexColor(idx int64) *Color {
	log.Println("Calling MeshDataTool.GetVertexColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertex_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetVertexCount() int64 {
	log.Println("Calling MeshDataTool.GetVertexCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertex_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetVertexEdges(idx int64) *PoolIntArray {
	log.Println("Calling MeshDataTool.GetVertexEdges()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertex_edges", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetVertexFaces(idx int64) *PoolIntArray {
	log.Println("Calling MeshDataTool.GetVertexFaces()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertex_faces", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetVertexMeta(idx int64) *Variant {
	log.Println("Calling MeshDataTool.GetVertexMeta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertex_meta", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetVertexNormal(idx int64) *Vector3 {
	log.Println("Calling MeshDataTool.GetVertexNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertex_normal", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetVertexTangent(idx int64) *Plane {
	log.Println("Calling MeshDataTool.GetVertexTangent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertex_tangent", goArguments, "*Plane")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Plane)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetVertexUv(idx int64) *Vector2 {
	log.Println("Calling MeshDataTool.GetVertexUv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertex_uv", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetVertexUv2(idx int64) *Vector2 {
	log.Println("Calling MeshDataTool.GetVertexUv2()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertex_uv2", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *MeshDataTool) GetVertexWeights(idx int64) *PoolRealArray {
	log.Println("Calling MeshDataTool.GetVertexWeights()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertex_weights", goArguments, "*PoolRealArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolRealArray)

	return returnValue

}

/*

 */
func (o *MeshDataTool) SetEdgeMeta(idx int64, meta *Variant) {
	log.Println("Calling MeshDataTool.SetEdgeMeta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(meta)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_edge_meta", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshDataTool) SetFaceMeta(idx int64, meta *Variant) {
	log.Println("Calling MeshDataTool.SetFaceMeta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(meta)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_face_meta", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshDataTool) SetMaterial(material *Material) {
	log.Println("Calling MeshDataTool.SetMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(material)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_material", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshDataTool) SetVertex(idx int64, vertex *Vector3) {
	log.Println("Calling MeshDataTool.SetVertex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(vertex)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vertex", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshDataTool) SetVertexBones(idx int64, bones *PoolIntArray) {
	log.Println("Calling MeshDataTool.SetVertexBones()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(bones)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vertex_bones", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshDataTool) SetVertexColor(idx int64, color *Color) {
	log.Println("Calling MeshDataTool.SetVertexColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vertex_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshDataTool) SetVertexMeta(idx int64, meta *Variant) {
	log.Println("Calling MeshDataTool.SetVertexMeta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(meta)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vertex_meta", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshDataTool) SetVertexNormal(idx int64, normal *Vector3) {
	log.Println("Calling MeshDataTool.SetVertexNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(normal)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vertex_normal", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshDataTool) SetVertexTangent(idx int64, tangent *Plane) {
	log.Println("Calling MeshDataTool.SetVertexTangent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(tangent)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vertex_tangent", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshDataTool) SetVertexUv(idx int64, uv *Vector2) {
	log.Println("Calling MeshDataTool.SetVertexUv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(uv)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vertex_uv", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshDataTool) SetVertexUv2(idx int64, uv2 *Vector2) {
	log.Println("Calling MeshDataTool.SetVertexUv2()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(uv2)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vertex_uv2", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshDataTool) SetVertexWeights(idx int64, weights *PoolRealArray) {
	log.Println("Calling MeshDataTool.SetVertexWeights()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(weights)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vertex_weights", goArguments, "")

	log.Println("Got return value!")

}

/*
   MeshDataToolImplementer is an interface for MeshDataTool objects.

*/
type MeshDataToolImplementer interface {
	ReferenceImplementer

	Clear()

	CommitToSurface(mesh *ArrayMesh) int64

	CreateFromSurface(mesh *ArrayMesh, surface int64) int64

	GetEdgeCount() int64

	GetEdgeFaces(idx int64) *PoolIntArray

	GetEdgeMeta(idx int64) *Variant

	GetEdgeVertex(idx int64, vertex int64) int64

	GetFaceCount() int64

	GetFaceEdge(idx int64, edge int64) int64

	GetFaceMeta(idx int64) *Variant

	GetFaceNormal(idx int64) *Vector3

	GetFaceVertex(idx int64, vertex int64) int64

	GetFormat() int64

	GetMaterial() *Material

	GetVertex(idx int64) *Vector3

	GetVertexBones(idx int64) *PoolIntArray

	GetVertexColor(idx int64) *Color

	GetVertexCount() int64

	GetVertexEdges(idx int64) *PoolIntArray

	GetVertexFaces(idx int64) *PoolIntArray

	GetVertexMeta(idx int64) *Variant

	GetVertexNormal(idx int64) *Vector3

	GetVertexTangent(idx int64) *Plane

	GetVertexUv(idx int64) *Vector2

	GetVertexUv2(idx int64) *Vector2

	GetVertexWeights(idx int64) *PoolRealArray

	SetEdgeMeta(idx int64, meta *Variant)

	SetFaceMeta(idx int64, meta *Variant)

	SetMaterial(material *Material)

	SetVertex(idx int64, vertex *Vector3)

	SetVertexBones(idx int64, bones *PoolIntArray)

	SetVertexColor(idx int64, color *Color)

	SetVertexMeta(idx int64, meta *Variant)

	SetVertexNormal(idx int64, normal *Vector3)

	SetVertexTangent(idx int64, tangent *Plane)

	SetVertexUv(idx int64, uv *Vector2)

	SetVertexUv2(idx int64, uv2 *Vector2)

	SetVertexWeights(idx int64, weights *PoolRealArray)
}

/*
   MeshInstance is a [Node] that takes a [Mesh] resource and adds it to the current scenario by creating an instance of it. This is the class most often used to get 3D geometry rendered and can be used to instance a single [Mesh] in many places. This allows to reuse geometry and save on resources. When a [Mesh] has to be instanced more than thousands of times at close proximity, consider using a [MultiMesh] in a [MultiMeshInstance] instead.
*/
type MeshInstance struct {
	GeometryInstance
}

func (o *MeshInstance) baseClass() string {
	return "MeshInstance"
}

/*

 */
func (o *MeshInstance) CreateConvexCollision() {
	log.Println("Calling MeshInstance.CreateConvexCollision()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "create_convex_collision", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshInstance) CreateDebugTangents() {
	log.Println("Calling MeshInstance.CreateDebugTangents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "create_debug_tangents", goArguments, "")

	log.Println("Got return value!")

}

/*
   This helper creates a [StaticBody] child [Node] using the mesh geometry as collision. It's mainly used for testing.
*/
func (o *MeshInstance) CreateTrimeshCollision() {
	log.Println("Calling MeshInstance.CreateTrimeshCollision()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "create_trimesh_collision", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the current [Mesh] resource for the instance.
*/
func (o *MeshInstance) GetMesh() *Mesh {
	log.Println("Calling MeshInstance.GetMesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mesh", goArguments, "*Mesh")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Mesh)

	return returnValue

}

/*

 */
func (o *MeshInstance) GetSkeletonPath() *NodePath {
	log.Println("Calling MeshInstance.GetSkeletonPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_skeleton_path", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *MeshInstance) GetSurfaceMaterial(surface int64) *Material {
	log.Println("Calling MeshInstance.GetSurfaceMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(surface)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_surface_material", goArguments, "*Material")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Material)

	return returnValue

}

/*
   Set the [Mesh] resource for the instance.
*/
func (o *MeshInstance) SetMesh(mesh *Mesh) {
	log.Println("Calling MeshInstance.SetMesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mesh)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mesh", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshInstance) SetSkeletonPath(skeletonPath *NodePath) {
	log.Println("Calling MeshInstance.SetSkeletonPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(skeletonPath)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_skeleton_path", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshInstance) SetSurfaceMaterial(surface int64, material *Material) {
	log.Println("Calling MeshInstance.SetSurfaceMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(surface)
	goArguments[1] = reflect.ValueOf(material)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_surface_material", goArguments, "")

	log.Println("Got return value!")

}

/*
   MeshInstanceImplementer is an interface for MeshInstance objects.
   MeshInstance is a [Node] that takes a [Mesh] resource and adds it to the current scenario by creating an instance of it. This is the class most often used to get 3D geometry rendered and can be used to instance a single [Mesh] in many places. This allows to reuse geometry and save on resources. When a [Mesh] has to be instanced more than thousands of times at close proximity, consider using a [MultiMesh] in a [MultiMeshInstance] instead.
*/
type MeshInstanceImplementer interface {
	GeometryInstanceImplementer

	CreateConvexCollision()

	CreateDebugTangents()

	CreateTrimeshCollision()

	GetMesh() *Mesh

	GetSkeletonPath() *NodePath

	GetSurfaceMaterial(surface int64) *Material

	SetMesh(mesh *Mesh)

	SetSkeletonPath(skeletonPath *NodePath)

	SetSurfaceMaterial(surface int64, material *Material)
}

/*
   Library of meshes. Contains a list of [Mesh] resources, each with name and ID. Useful for GridMap or painting Terrain.
*/
type MeshLibrary struct {
	Resource
}

func (o *MeshLibrary) baseClass() string {
	return "MeshLibrary"
}

/*
   Clear the library.
*/
func (o *MeshLibrary) Clear() {
	log.Println("Calling MeshLibrary.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Create a new item in the library, supplied an id.
*/
func (o *MeshLibrary) CreateItem(id int64) {
	log.Println("Calling MeshLibrary.CreateItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "create_item", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the list of items.
*/
func (o *MeshLibrary) GetItemList() *PoolIntArray {
	log.Println("Calling MeshLibrary.GetItemList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_list", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*
   Return the mesh of the item.
*/
func (o *MeshLibrary) GetItemMesh(id int64) *Mesh {
	log.Println("Calling MeshLibrary.GetItemMesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_mesh", goArguments, "*Mesh")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Mesh)

	return returnValue

}

/*
   Return the name of the item.
*/
func (o *MeshLibrary) GetItemName(id int64) string {
	log.Println("Calling MeshLibrary.GetItemName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *MeshLibrary) GetItemNavmesh(id int64) *NavigationMesh {
	log.Println("Calling MeshLibrary.GetItemNavmesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_navmesh", goArguments, "*NavigationMesh")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NavigationMesh)

	return returnValue

}

/*

 */
func (o *MeshLibrary) GetItemPreview(id int64) *Texture {
	log.Println("Calling MeshLibrary.GetItemPreview()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_preview", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *MeshLibrary) GetItemShapes(id int64) *Array {
	log.Println("Calling MeshLibrary.GetItemShapes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_shapes", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Get an unused id for a new item.
*/
func (o *MeshLibrary) GetLastUnusedItemId() int64 {
	log.Println("Calling MeshLibrary.GetLastUnusedItemId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_last_unused_item_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Remove the item.
*/
func (o *MeshLibrary) RemoveItem(id int64) {
	log.Println("Calling MeshLibrary.RemoveItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_item", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the mesh of the item.
*/
func (o *MeshLibrary) SetItemMesh(id int64, mesh *Mesh) {
	log.Println("Calling MeshLibrary.SetItemMesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(mesh)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_mesh", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the name of the item.
*/
func (o *MeshLibrary) SetItemName(id int64, name string) {
	log.Println("Calling MeshLibrary.SetItemName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_name", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshLibrary) SetItemNavmesh(id int64, navmesh *NavigationMesh) {
	log.Println("Calling MeshLibrary.SetItemNavmesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(navmesh)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_navmesh", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshLibrary) SetItemPreview(id int64, texture *Texture) {
	log.Println("Calling MeshLibrary.SetItemPreview()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_preview", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MeshLibrary) SetItemShapes(id int64, shapes *Array) {
	log.Println("Calling MeshLibrary.SetItemShapes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(shapes)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_shapes", goArguments, "")

	log.Println("Got return value!")

}

/*
   MeshLibraryImplementer is an interface for MeshLibrary objects.
   Library of meshes. Contains a list of [Mesh] resources, each with name and ID. Useful for GridMap or painting Terrain.
*/
type MeshLibraryImplementer interface {
	ResourceImplementer

	Clear()

	CreateItem(id int64)

	GetItemList() *PoolIntArray

	GetItemMesh(id int64) *Mesh

	GetItemName(id int64) string

	GetItemNavmesh(id int64) *NavigationMesh

	GetItemPreview(id int64) *Texture

	GetItemShapes(id int64) *Array

	GetLastUnusedItemId() int64

	RemoveItem(id int64)

	SetItemMesh(id int64, mesh *Mesh)

	SetItemName(id int64, name string)

	SetItemNavmesh(id int64, navmesh *NavigationMesh)

	SetItemPreview(id int64, texture *Texture)

	SetItemShapes(id int64, shapes *Array)
}

/*
        MultiMesh provides low level mesh instancing. If the amount of [Mesh] instances needed goes from hundreds to thousands (and most need to be visible at close proximity) creating such a large amount of [MeshInstance] nodes may affect performance by using too much CPU or video memory.
		For this case a MultiMesh becomes very useful, as it can draw thousands of instances with little API overhead.
		As a drawback, if the instances are too far away of each other, performance may be reduced as every single instance will always rendered (they are spatially indexed as one, for the whole object).
		Since instances may have any behavior, the Rect3 used for visibility must be provided by the user.
*/
type MultiMesh struct {
	Resource
}

func (o *MultiMesh) baseClass() string {
	return "MultiMesh"
}

/*
   Return the visibility Rect3.
*/
func (o *MultiMesh) GetAabb() *Rect3 {
	log.Println("Calling MultiMesh.GetAabb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_aabb", goArguments, "*Rect3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect3)

	return returnValue

}

/*

 */
func (o *MultiMesh) GetColorFormat() int64 {
	log.Println("Calling MultiMesh.GetColorFormat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_color_format", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the color of a specific instance.
*/
func (o *MultiMesh) GetInstanceColor(instance int64) *Color {
	log.Println("Calling MultiMesh.GetInstanceColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(instance)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_instance_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   Return the amount of instances that is going to be drawn.
*/
func (o *MultiMesh) GetInstanceCount() int64 {
	log.Println("Calling MultiMesh.GetInstanceCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_instance_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the transform of a specific instance.
*/
func (o *MultiMesh) GetInstanceTransform(instance int64) *Transform {
	log.Println("Calling MultiMesh.GetInstanceTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(instance)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_instance_transform", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*
   Return the [Mesh] resource drawn as multiple instances.
*/
func (o *MultiMesh) GetMesh() *Mesh {
	log.Println("Calling MultiMesh.GetMesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mesh", goArguments, "*Mesh")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Mesh)

	return returnValue

}

/*

 */
func (o *MultiMesh) GetTransformFormat() int64 {
	log.Println("Calling MultiMesh.GetTransformFormat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_transform_format", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *MultiMesh) SetColorFormat(format int64) {
	log.Println("Calling MultiMesh.SetColorFormat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(format)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_color_format", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the color of a specific instance.
*/
func (o *MultiMesh) SetInstanceColor(instance int64, color *Color) {
	log.Println("Calling MultiMesh.SetInstanceColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(instance)
	goArguments[1] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_instance_color", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the amount of instances that is going to be drawn. Changing this number will erase all the existing instance transform and color data.
*/
func (o *MultiMesh) SetInstanceCount(count int64) {
	log.Println("Calling MultiMesh.SetInstanceCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(count)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_instance_count", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the transform for a specific instance.
*/
func (o *MultiMesh) SetInstanceTransform(instance int64, transform *Transform) {
	log.Println("Calling MultiMesh.SetInstanceTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(instance)
	goArguments[1] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_instance_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the [Mesh] resource to be drawn in multiple instances.
*/
func (o *MultiMesh) SetMesh(mesh *Mesh) {
	log.Println("Calling MultiMesh.SetMesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mesh)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mesh", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *MultiMesh) SetTransformFormat(format int64) {
	log.Println("Calling MultiMesh.SetTransformFormat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(format)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_transform_format", goArguments, "")

	log.Println("Got return value!")

}

/*
        MultiMeshImplementer is an interface for MultiMesh objects.
        MultiMesh provides low level mesh instancing. If the amount of [Mesh] instances needed goes from hundreds to thousands (and most need to be visible at close proximity) creating such a large amount of [MeshInstance] nodes may affect performance by using too much CPU or video memory.
		For this case a MultiMesh becomes very useful, as it can draw thousands of instances with little API overhead.
		As a drawback, if the instances are too far away of each other, performance may be reduced as every single instance will always rendered (they are spatially indexed as one, for the whole object).
		Since instances may have any behavior, the Rect3 used for visibility must be provided by the user.
*/
type MultiMeshImplementer interface {
	ResourceImplementer

	GetAabb() *Rect3

	GetColorFormat() int64

	GetInstanceColor(instance int64) *Color

	GetInstanceCount() int64

	GetInstanceTransform(instance int64) *Transform

	GetMesh() *Mesh

	GetTransformFormat() int64

	SetColorFormat(format int64)

	SetInstanceColor(instance int64, color *Color)

	SetInstanceCount(count int64)

	SetInstanceTransform(instance int64, transform *Transform)

	SetMesh(mesh *Mesh)

	SetTransformFormat(format int64)
}

/*
   MultiMeshInstance is a [Node] that takes a [MultiMesh] resource and adds it to the current scenario by creating an instance of it (yes, this is an instance of instances).
*/
type MultiMeshInstance struct {
	GeometryInstance
}

func (o *MultiMeshInstance) baseClass() string {
	return "MultiMeshInstance"
}

/*
   Return the [MultiMesh] that is used for instancing.
*/
func (o *MultiMeshInstance) GetMultimesh() *MultiMesh {
	log.Println("Calling MultiMeshInstance.GetMultimesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_multimesh", goArguments, "*MultiMesh")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*MultiMesh)

	return returnValue

}

/*
   Set the [MultiMesh] to be instanced.
*/
func (o *MultiMeshInstance) SetMultimesh(multimesh *MultiMesh) {
	log.Println("Calling MultiMeshInstance.SetMultimesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(multimesh)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_multimesh", goArguments, "")

	log.Println("Got return value!")

}

/*
   MultiMeshInstanceImplementer is an interface for MultiMeshInstance objects.
   MultiMeshInstance is a [Node] that takes a [MultiMesh] resource and adds it to the current scenario by creating an instance of it (yes, this is an instance of instances).
*/
type MultiMeshInstanceImplementer interface {
	GeometryInstanceImplementer

	GetMultimesh() *MultiMesh

	SetMultimesh(multimesh *MultiMesh)
}

/*
   A synchronization Mutex. Element used in multi-threadding. Basically a binary [Semaphore]. Guarantees that only one thread has this lock, can be used to protect a critical section.
*/
type Mutex struct {
	Reference
}

func (o *Mutex) baseClass() string {
	return "Mutex"
}

/*
   Lock this [Mutex], blocks until it is unlocked by the current owner.
*/
func (o *Mutex) Lock() {
	log.Println("Calling Mutex.Lock()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "lock", goArguments, "")

	log.Println("Got return value!")

}

/*
   Try locking this [Mutex], does not block. Returns [OK] on success else [ERR_BUSY].
*/
func (o *Mutex) TryLock() int64 {
	log.Println("Calling Mutex.TryLock()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "try_lock", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Unlock this [Mutex], leaving it to others threads.
*/
func (o *Mutex) Unlock() {
	log.Println("Calling Mutex.Unlock()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "unlock", goArguments, "")

	log.Println("Got return value!")

}

/*
   MutexImplementer is an interface for Mutex objects.
   A synchronization Mutex. Element used in multi-threadding. Basically a binary [Semaphore]. Guarantees that only one thread has this lock, can be used to protect a critical section.
*/
type MutexImplementer interface {
	ReferenceImplementer

	Lock()

	TryLock() int64

	Unlock()
}

/*

 */
type NativeScript struct {
	Script
}

func (o *NativeScript) baseClass() string {
	return "NativeScript"
}

/*

 */
func (o *NativeScript) GetClassName() string {
	log.Println("Calling NativeScript.GetClassName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_class_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *NativeScript) GetLibrary() *GDNativeLibrary {
	log.Println("Calling NativeScript.GetLibrary()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_library", goArguments, "*GDNativeLibrary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*GDNativeLibrary)

	return returnValue

}

/*

 */
func (o *NativeScript) New() *Object {
	log.Println("Calling NativeScript.New()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "new", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*

 */
func (o *NativeScript) SetClassName(className string) {
	log.Println("Calling NativeScript.SetClassName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(className)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_class_name", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NativeScript) SetLibrary(library *GDNativeLibrary) {
	log.Println("Calling NativeScript.SetLibrary()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(library)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_library", goArguments, "")

	log.Println("Got return value!")

}

/*
   NativeScriptImplementer is an interface for NativeScript objects.

*/
type NativeScriptImplementer interface {
	ScriptImplementer

	GetClassName() string

	GetLibrary() *GDNativeLibrary

	New() *Object

	SetClassName(className string)

	SetLibrary(library *GDNativeLibrary)
}

/*

 */
type Navigation struct {
	Spatial
}

func (o *Navigation) baseClass() string {
	return "Navigation"
}

/*

 */
func (o *Navigation) GetClosestPoint(toPoint *Vector3) *Vector3 {
	log.Println("Calling Navigation.GetClosestPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(toPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_point", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *Navigation) GetClosestPointNormal(toPoint *Vector3) *Vector3 {
	log.Println("Calling Navigation.GetClosestPointNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(toPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_point_normal", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *Navigation) GetClosestPointOwner(toPoint *Vector3) *Object {
	log.Println("Calling Navigation.GetClosestPointOwner()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(toPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_point_owner", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*

 */
func (o *Navigation) GetClosestPointToSegment(start *Vector3, end *Vector3, useCollision *bool) *Vector3 {
	log.Println("Calling Navigation.GetClosestPointToSegment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(start)
	goArguments[1] = reflect.ValueOf(end)
	goArguments[2] = reflect.ValueOf(useCollision)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_point_to_segment", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *Navigation) GetSimplePath(start *Vector3, end *Vector3, optimize *bool) *PoolVector3Array {
	log.Println("Calling Navigation.GetSimplePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(start)
	goArguments[1] = reflect.ValueOf(end)
	goArguments[2] = reflect.ValueOf(optimize)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_simple_path", goArguments, "*PoolVector3Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector3Array)

	return returnValue

}

/*

 */
func (o *Navigation) GetUpVector() *Vector3 {
	log.Println("Calling Navigation.GetUpVector()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_up_vector", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *Navigation) NavmeshCreate(mesh *NavigationMesh, xform *Transform, owner *Object) int64 {
	log.Println("Calling Navigation.NavmeshCreate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(mesh)
	goArguments[1] = reflect.ValueOf(xform)
	goArguments[2] = reflect.ValueOf(owner)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "navmesh_create", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Navigation) NavmeshRemove(id int64) {
	log.Println("Calling Navigation.NavmeshRemove()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "navmesh_remove", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Navigation) NavmeshSetTransform(id int64, xform *Transform) {
	log.Println("Calling Navigation.NavmeshSetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(xform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "navmesh_set_transform", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Navigation) SetUpVector(up *Vector3) {
	log.Println("Calling Navigation.SetUpVector()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(up)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_up_vector", goArguments, "")

	log.Println("Got return value!")

}

/*
   NavigationImplementer is an interface for Navigation objects.

*/
type NavigationImplementer interface {
	SpatialImplementer

	GetClosestPoint(toPoint *Vector3) *Vector3

	GetClosestPointNormal(toPoint *Vector3) *Vector3

	GetClosestPointOwner(toPoint *Vector3) *Object

	GetClosestPointToSegment(start *Vector3, end *Vector3, useCollision *bool) *Vector3

	GetSimplePath(start *Vector3, end *Vector3, optimize *bool) *PoolVector3Array

	GetUpVector() *Vector3

	NavmeshCreate(mesh *NavigationMesh, xform *Transform, owner *Object) int64

	NavmeshRemove(id int64)

	NavmeshSetTransform(id int64, xform *Transform)

	SetUpVector(up *Vector3)
}

/*

 */
type Navigation2D struct {
	Node2D
}

func (o *Navigation2D) baseClass() string {
	return "Navigation2D"
}

/*

 */
func (o *Navigation2D) GetClosestPoint(toPoint *Vector2) *Vector2 {
	log.Println("Calling Navigation2D.GetClosestPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(toPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_point", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Navigation2D) GetClosestPointOwner(toPoint *Vector2) *Object {
	log.Println("Calling Navigation2D.GetClosestPointOwner()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(toPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_point_owner", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*

 */
func (o *Navigation2D) GetSimplePath(start *Vector2, end *Vector2, optimize *bool) *PoolVector2Array {
	log.Println("Calling Navigation2D.GetSimplePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(start)
	goArguments[1] = reflect.ValueOf(end)
	goArguments[2] = reflect.ValueOf(optimize)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_simple_path", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*

 */
func (o *Navigation2D) NavpolyCreate(mesh *NavigationPolygon, xform *Transform2D, owner *Object) int64 {
	log.Println("Calling Navigation2D.NavpolyCreate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(mesh)
	goArguments[1] = reflect.ValueOf(xform)
	goArguments[2] = reflect.ValueOf(owner)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "navpoly_create", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Navigation2D) NavpolyRemove(id int64) {
	log.Println("Calling Navigation2D.NavpolyRemove()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "navpoly_remove", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Navigation2D) NavpolySetTransform(id int64, xform *Transform2D) {
	log.Println("Calling Navigation2D.NavpolySetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(xform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "navpoly_set_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   Navigation2DImplementer is an interface for Navigation2D objects.

*/
type Navigation2DImplementer interface {
	Node2DImplementer

	GetClosestPoint(toPoint *Vector2) *Vector2

	GetClosestPointOwner(toPoint *Vector2) *Object

	GetSimplePath(start *Vector2, end *Vector2, optimize *bool) *PoolVector2Array

	NavpolyCreate(mesh *NavigationPolygon, xform *Transform2D, owner *Object) int64

	NavpolyRemove(id int64)

	NavpolySetTransform(id int64, xform *Transform2D)
}

/*

 */
type NavigationMesh struct {
	Resource
}

func (o *NavigationMesh) baseClass() string {
	return "NavigationMesh"
}

/*

 */
func (o *NavigationMesh) AddPolygon(polygon *PoolIntArray) {
	log.Println("Calling NavigationMesh.AddPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(polygon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_polygon", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationMesh) ClearPolygons() {
	log.Println("Calling NavigationMesh.ClearPolygons()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_polygons", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationMesh) CreateFromMesh(mesh *Mesh) {
	log.Println("Calling NavigationMesh.CreateFromMesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mesh)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "create_from_mesh", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationMesh) GetPolygon(idx int64) *PoolIntArray {
	log.Println("Calling NavigationMesh.GetPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_polygon", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*

 */
func (o *NavigationMesh) GetPolygonCount() int64 {
	log.Println("Calling NavigationMesh.GetPolygonCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_polygon_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *NavigationMesh) GetVertices() *PoolVector3Array {
	log.Println("Calling NavigationMesh.GetVertices()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertices", goArguments, "*PoolVector3Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector3Array)

	return returnValue

}

/*

 */
func (o *NavigationMesh) SetVertices(vertices *PoolVector3Array) {
	log.Println("Calling NavigationMesh.SetVertices()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vertices)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vertices", goArguments, "")

	log.Println("Got return value!")

}

/*
   NavigationMeshImplementer is an interface for NavigationMesh objects.

*/
type NavigationMeshImplementer interface {
	ResourceImplementer

	AddPolygon(polygon *PoolIntArray)

	ClearPolygons()

	CreateFromMesh(mesh *Mesh)

	GetPolygon(idx int64) *PoolIntArray

	GetPolygonCount() int64

	GetVertices() *PoolVector3Array

	SetVertices(vertices *PoolVector3Array)
}

/*

 */
type NavigationMeshInstance struct {
	Spatial
}

func (o *NavigationMeshInstance) baseClass() string {
	return "NavigationMeshInstance"
}

/*

 */
func (o *NavigationMeshInstance) GetNavigationMesh() *NavigationMesh {
	log.Println("Calling NavigationMeshInstance.GetNavigationMesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_navigation_mesh", goArguments, "*NavigationMesh")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NavigationMesh)

	return returnValue

}

/*

 */
func (o *NavigationMeshInstance) IsEnabled() *bool {
	log.Println("Calling NavigationMeshInstance.IsEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *NavigationMeshInstance) SetEnabled(enabled *bool) {
	log.Println("Calling NavigationMeshInstance.SetEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationMeshInstance) SetNavigationMesh(navmesh *NavigationMesh) {
	log.Println("Calling NavigationMeshInstance.SetNavigationMesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(navmesh)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_navigation_mesh", goArguments, "")

	log.Println("Got return value!")

}

/*
   NavigationMeshInstanceImplementer is an interface for NavigationMeshInstance objects.

*/
type NavigationMeshInstanceImplementer interface {
	SpatialImplementer

	GetNavigationMesh() *NavigationMesh

	IsEnabled() *bool

	SetEnabled(enabled *bool)

	SetNavigationMesh(navmesh *NavigationMesh)
}

/*

 */
type NavigationPolygon struct {
	Resource
}

func (o *NavigationPolygon) baseClass() string {
	return "NavigationPolygon"
}

/*

 */
func (o *NavigationPolygon) AddOutline(outline *PoolVector2Array) {
	log.Println("Calling NavigationPolygon.AddOutline()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(outline)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_outline", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationPolygon) AddOutlineAtIndex(outline *PoolVector2Array, index int64) {
	log.Println("Calling NavigationPolygon.AddOutlineAtIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(outline)
	goArguments[1] = reflect.ValueOf(index)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_outline_at_index", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationPolygon) AddPolygon(polygon *PoolIntArray) {
	log.Println("Calling NavigationPolygon.AddPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(polygon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_polygon", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationPolygon) ClearOutlines() {
	log.Println("Calling NavigationPolygon.ClearOutlines()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_outlines", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationPolygon) ClearPolygons() {
	log.Println("Calling NavigationPolygon.ClearPolygons()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_polygons", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationPolygon) GetOutline(idx int64) *PoolVector2Array {
	log.Println("Calling NavigationPolygon.GetOutline()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_outline", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*

 */
func (o *NavigationPolygon) GetOutlineCount() int64 {
	log.Println("Calling NavigationPolygon.GetOutlineCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_outline_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *NavigationPolygon) GetPolygon(idx int64) *PoolIntArray {
	log.Println("Calling NavigationPolygon.GetPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_polygon", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*

 */
func (o *NavigationPolygon) GetPolygonCount() int64 {
	log.Println("Calling NavigationPolygon.GetPolygonCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_polygon_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *NavigationPolygon) GetVertices() *PoolVector2Array {
	log.Println("Calling NavigationPolygon.GetVertices()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertices", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*

 */
func (o *NavigationPolygon) MakePolygonsFromOutlines() {
	log.Println("Calling NavigationPolygon.MakePolygonsFromOutlines()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "make_polygons_from_outlines", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationPolygon) RemoveOutline(idx int64) {
	log.Println("Calling NavigationPolygon.RemoveOutline()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_outline", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationPolygon) SetOutline(idx int64, outline *PoolVector2Array) {
	log.Println("Calling NavigationPolygon.SetOutline()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(outline)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_outline", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationPolygon) SetVertices(vertices *PoolVector2Array) {
	log.Println("Calling NavigationPolygon.SetVertices()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vertices)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vertices", goArguments, "")

	log.Println("Got return value!")

}

/*
   NavigationPolygonImplementer is an interface for NavigationPolygon objects.

*/
type NavigationPolygonImplementer interface {
	ResourceImplementer

	AddOutline(outline *PoolVector2Array)

	AddOutlineAtIndex(outline *PoolVector2Array, index int64)

	AddPolygon(polygon *PoolIntArray)

	ClearOutlines()

	ClearPolygons()

	GetOutline(idx int64) *PoolVector2Array

	GetOutlineCount() int64

	GetPolygon(idx int64) *PoolIntArray

	GetPolygonCount() int64

	GetVertices() *PoolVector2Array

	MakePolygonsFromOutlines()

	RemoveOutline(idx int64)

	SetOutline(idx int64, outline *PoolVector2Array)

	SetVertices(vertices *PoolVector2Array)
}

/*

 */
type NavigationPolygonInstance struct {
	Node2D
}

func (o *NavigationPolygonInstance) baseClass() string {
	return "NavigationPolygonInstance"
}

/*

 */
func (o *NavigationPolygonInstance) GetNavigationPolygon() *NavigationPolygon {
	log.Println("Calling NavigationPolygonInstance.GetNavigationPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_navigation_polygon", goArguments, "*NavigationPolygon")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NavigationPolygon)

	return returnValue

}

/*

 */
func (o *NavigationPolygonInstance) IsEnabled() *bool {
	log.Println("Calling NavigationPolygonInstance.IsEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *NavigationPolygonInstance) SetEnabled(enabled *bool) {
	log.Println("Calling NavigationPolygonInstance.SetEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NavigationPolygonInstance) SetNavigationPolygon(navpoly *NavigationPolygon) {
	log.Println("Calling NavigationPolygonInstance.SetNavigationPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(navpoly)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_navigation_polygon", goArguments, "")

	log.Println("Got return value!")

}

/*
   NavigationPolygonInstanceImplementer is an interface for NavigationPolygonInstance objects.

*/
type NavigationPolygonInstanceImplementer interface {
	Node2DImplementer

	GetNavigationPolygon() *NavigationPolygon

	IsEnabled() *bool

	SetEnabled(enabled *bool)

	SetNavigationPolygon(navpoly *NavigationPolygon)
}

/*
   A connection (or a listening server) that should be passed to [method SceneTree.set_network_peer]. Socket events can be handled by connecting to [SceneTree] signals.
*/
type NetworkedMultiplayerENet struct {
	NetworkedMultiplayerPeer
}

func (o *NetworkedMultiplayerENet) baseClass() string {
	return "NetworkedMultiplayerENet"
}

/*

 */
func (o *NetworkedMultiplayerENet) CloseConnection() {
	log.Println("Calling NetworkedMultiplayerENet.CloseConnection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "close_connection", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NetworkedMultiplayerENet) CreateClient(ip string, port int64, inBandwidth int64, outBandwidth int64) int64 {
	log.Println("Calling NetworkedMultiplayerENet.CreateClient()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(ip)
	goArguments[1] = reflect.ValueOf(port)
	goArguments[2] = reflect.ValueOf(inBandwidth)
	goArguments[3] = reflect.ValueOf(outBandwidth)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "create_client", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *NetworkedMultiplayerENet) CreateServer(port int64, maxClients int64, inBandwidth int64, outBandwidth int64) int64 {
	log.Println("Calling NetworkedMultiplayerENet.CreateServer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(port)
	goArguments[1] = reflect.ValueOf(maxClients)
	goArguments[2] = reflect.ValueOf(inBandwidth)
	goArguments[3] = reflect.ValueOf(outBandwidth)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "create_server", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *NetworkedMultiplayerENet) GetCompressionMode() int64 {
	log.Println("Calling NetworkedMultiplayerENet.GetCompressionMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_compression_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *NetworkedMultiplayerENet) SetBindIp(ip string) {
	log.Println("Calling NetworkedMultiplayerENet.SetBindIp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ip)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bind_ip", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NetworkedMultiplayerENet) SetCompressionMode(mode int64) {
	log.Println("Calling NetworkedMultiplayerENet.SetCompressionMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_compression_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   NetworkedMultiplayerENetImplementer is an interface for NetworkedMultiplayerENet objects.
   A connection (or a listening server) that should be passed to [method SceneTree.set_network_peer]. Socket events can be handled by connecting to [SceneTree] signals.
*/
type NetworkedMultiplayerENetImplementer interface {
	NetworkedMultiplayerPeerImplementer

	CloseConnection()

	CreateClient(ip string, port int64, inBandwidth int64, outBandwidth int64) int64

	CreateServer(port int64, maxClients int64, inBandwidth int64, outBandwidth int64) int64

	GetCompressionMode() int64

	SetBindIp(ip string)

	SetCompressionMode(mode int64)
}

/*

 */
type NetworkedMultiplayerPeer struct {
	PacketPeer
}

func (o *NetworkedMultiplayerPeer) baseClass() string {
	return "NetworkedMultiplayerPeer"
}

/*

 */
func (o *NetworkedMultiplayerPeer) GetConnectionStatus() int64 {
	log.Println("Calling NetworkedMultiplayerPeer.GetConnectionStatus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_status", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *NetworkedMultiplayerPeer) GetPacketPeer() int64 {
	log.Println("Calling NetworkedMultiplayerPeer.GetPacketPeer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_packet_peer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *NetworkedMultiplayerPeer) GetUniqueId() int64 {
	log.Println("Calling NetworkedMultiplayerPeer.GetUniqueId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_unique_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *NetworkedMultiplayerPeer) IsRefusingNewConnections() *bool {
	log.Println("Calling NetworkedMultiplayerPeer.IsRefusingNewConnections()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_refusing_new_connections", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *NetworkedMultiplayerPeer) Poll() {
	log.Println("Calling NetworkedMultiplayerPeer.Poll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "poll", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NetworkedMultiplayerPeer) SetRefuseNewConnections(enable *bool) {
	log.Println("Calling NetworkedMultiplayerPeer.SetRefuseNewConnections()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_refuse_new_connections", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NetworkedMultiplayerPeer) SetTargetPeer(id int64) {
	log.Println("Calling NetworkedMultiplayerPeer.SetTargetPeer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_target_peer", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NetworkedMultiplayerPeer) SetTransferMode(mode int64) {
	log.Println("Calling NetworkedMultiplayerPeer.SetTransferMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_transfer_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   NetworkedMultiplayerPeerImplementer is an interface for NetworkedMultiplayerPeer objects.

*/
type NetworkedMultiplayerPeerImplementer interface {
	PacketPeerImplementer

	GetConnectionStatus() int64

	GetPacketPeer() int64

	GetUniqueId() int64

	IsRefusingNewConnections() *bool

	Poll()

	SetRefuseNewConnections(enable *bool)

	SetTargetPeer(id int64)

	SetTransferMode(mode int64)
}

/*

 */
type NinePatchRect struct {
	Control
}

func (o *NinePatchRect) baseClass() string {
	return "NinePatchRect"
}

/*

 */
func (o *NinePatchRect) GetHAxisStretchMode() int64 {
	log.Println("Calling NinePatchRect.GetHAxisStretchMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_h_axis_stretch_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *NinePatchRect) GetPatchMargin(margin int64) int64 {
	log.Println("Calling NinePatchRect.GetPatchMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_patch_margin", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *NinePatchRect) GetRegionRect() *Rect2 {
	log.Println("Calling NinePatchRect.GetRegionRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_region_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*

 */
func (o *NinePatchRect) GetTexture() *Texture {
	log.Println("Calling NinePatchRect.GetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *NinePatchRect) GetVAxisStretchMode() int64 {
	log.Println("Calling NinePatchRect.GetVAxisStretchMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_v_axis_stretch_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *NinePatchRect) IsDrawCenterEnabled() *bool {
	log.Println("Calling NinePatchRect.IsDrawCenterEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_draw_center_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *NinePatchRect) SetDrawCenter(drawCenter *bool) {
	log.Println("Calling NinePatchRect.SetDrawCenter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(drawCenter)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_draw_center", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NinePatchRect) SetHAxisStretchMode(mode int64) {
	log.Println("Calling NinePatchRect.SetHAxisStretchMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_h_axis_stretch_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NinePatchRect) SetPatchMargin(margin int64, value int64) {
	log.Println("Calling NinePatchRect.SetPatchMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_patch_margin", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NinePatchRect) SetRegionRect(rect *Rect2) {
	log.Println("Calling NinePatchRect.SetRegionRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rect)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_region_rect", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NinePatchRect) SetTexture(texture *Texture) {
	log.Println("Calling NinePatchRect.SetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *NinePatchRect) SetVAxisStretchMode(mode int64) {
	log.Println("Calling NinePatchRect.SetVAxisStretchMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_v_axis_stretch_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   NinePatchRectImplementer is an interface for NinePatchRect objects.

*/
type NinePatchRectImplementer interface {
	ControlImplementer

	GetHAxisStretchMode() int64

	GetPatchMargin(margin int64) int64

	GetRegionRect() *Rect2

	GetTexture() *Texture

	GetVAxisStretchMode() int64

	IsDrawCenterEnabled() *bool

	SetDrawCenter(drawCenter *bool)

	SetHAxisStretchMode(mode int64)

	SetPatchMargin(margin int64, value int64)

	SetRegionRect(rect *Rect2)

	SetTexture(texture *Texture)

	SetVAxisStretchMode(mode int64)
}

/*
        Nodes are the base bricks with which Godot games are developed. They can be set as children of other nodes, resulting in a tree arrangement. A given node can contain any number of nodes as children (but there is only one scene tree root node) with the requirement that all siblings (direct children of a node) should have unique names.
		Any tree of nodes is called a [i]scene[/i]. Scenes can be saved to the disk and then instanced into other scenes. This allows for very high flexibility in the architecture and data model of the projects. Nodes can optionally be added to groups. This makes it easy to reach a number of nodes from the code (for example an "enemies" group) to perform grouped actions.
		[b]Scene tree:[/b] The [SceneTree] contains the active tree of nodes. When a node is added to the scene tree, it receives the NOTIFICATION_ENTER_TREE notification and its [method _enter_tree] callback is triggered. Children nodes are always added [i]after[/i] their parent node, i.e. the [method _enter_tree] callback of a parent node will be triggered before its child's.
		Once all nodes have been added in the scene tree, they receive the NOTIFICATION_READY notification and their respective [method _ready] callbacks are triggered. For groups of nodes, the [method _ready] callback is called in reverse order, from the children up to the parent nodes.
		It means that when adding a scene to the scene tree, the following order will be used for the callbacks: [method _enter_tree] of the parent, [method _enter_tree] of the children, [method _ready] of the children and finally [method _ready] of the parent (and that recursively for the whole scene).
		[b]Processing:[/b] Nodes can be set to the "process" state, so that they receive a callback on each frame requesting them to process (do something). Normal processing (callback [method _process], toggled with [method set_process]) happens as fast as possible and is dependent on the frame rate, so the processing time [i]delta[/i] is variable. Fixed processing (callback [method _fixed_process], toggled with [method set_fixed_process]) happens a fixed amount of times per second (by default 60) and is useful to link itself to the physics.
		Nodes can also process input events. When set, the [method _input] function will be called for each input that the program receives. In many cases, this can be overkill (unless used for simple projects), and the [method _unhandled_input] function might be preferred; it is called when the input event was not handled by anyone else (typically, GUI [Control] nodes), ensuring that the node only receives the events that were meant for it.
		To keep track of the scene hierarchy (especially when instancing scenes into other scenes), an "owner" can be set for the node with [method set_owner]. This keeps track of who instanced what. This is mostly useful when writing editors and tools, though.
		Finally, when a node is freed with [method free] or [method queue_free], it will also free all its children.
		[b]Networking with nodes:[/b] After connecting to a server (or making one, see [NetworkedMultiplayerENet]) it is possible to use the built-in RPC (remote procedure call) system to easily communicate over the network. By calling [method rpc] with a method name, it will be called locally, and in all connected peers (peers = clients and the server that accepts connections), with behaviour varying depending on the network mode ([method set_network_mode]) on the receiving peer. To identify which [Node] receives the RPC call Godot will use its [NodePath] (make sure node names are the same on all peers).
*/
type Node struct {
	Object
}

func (o *Node) baseClass() string {
	return "Node"
}

/*
                Called when the node enters the [SceneTree] (e.g. upon instancing, scene changing or after calling [method add_child] in a script). If the node has children, its [method _enter_tree] callback will be called first, and then that of the children.
				Corresponds to the NOTIFICATION_ENTER_TREE notification in [method Object._notification].
*/
func (o *Node) X_EnterTree() {
	log.Println("Calling Node.X_EnterTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_enter_tree", goArguments, "")

	log.Println("Got return value!")

}

/*
                Called when the node leaves the [SceneTree] (e.g. upon freeing, scene changing or after calling [method remove_child] in a script). If the node has children, its [method _exit_tree] callback will be called last, after all its children have left the tree.
				Corresponds to the NOTIFICATION_EXIT_TREE notification in [method Object._notification].
*/
func (o *Node) X_ExitTree() {
	log.Println("Calling Node.X_ExitTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_exit_tree", goArguments, "")

	log.Println("Got return value!")

}

/*
                Called during the fixed processing step of the main loop. Fixed processing means that the frame rate is synced to the physics, i.e. the [code]delta[/code] variable should be constant.
				It is only called if fixed processing has been enabled with [method set_fixed_process].
				Corresponds to the NOTIFICATION_FIXED_PROCESS notification in [method Object._notification].
*/
func (o *Node) X_FixedProcess(delta float64) {
	log.Println("Calling Node.X_FixedProcess()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(delta)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_fixed_process", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Node) X_Input(event *InputEvent) {
	log.Println("Calling Node.X_Input()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(event)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_input", goArguments, "")

	log.Println("Got return value!")

}

/*
                Called during the processing step of the main loop. Processing happens at every frame and as fast as possible, so the [code]delta[/code] time since the previous frame is not constant.
				It is only called if processing has been enabled with [method set_process].
				Corresponds to the NOTIFICATION_PROCESS notification in [method Object._notification].
*/
func (o *Node) X_Process(delta float64) {
	log.Println("Calling Node.X_Process()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(delta)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_process", goArguments, "")

	log.Println("Got return value!")

}

/*
                Called when the node is "ready", i.e. when both the node and its children have entered the scene tree. If the node has children, their [method _ready] callback gets triggered first, and the node will receive the ready notification only afterwards.
				Corresponds to the NOTIFICATION_READY notification in [method Object._notification].
*/
func (o *Node) X_Ready() {
	log.Println("Calling Node.X_Ready()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_ready", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Node) X_UnhandledInput(event *InputEvent) {
	log.Println("Calling Node.X_UnhandledInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(event)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_unhandled_input", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Node) X_UnhandledKeyInput(event *InputEventKey) {
	log.Println("Calling Node.X_UnhandledKeyInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(event)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_unhandled_key_input", goArguments, "")

	log.Println("Got return value!")

}

/*
                Add a child [Node]. Nodes can have as many children as they want, but every child must have a unique name. Children nodes are automatically deleted when the parent node is deleted, so deleting a whole scene is performed by deleting its topmost node.
				The optional boolean argument enforces creating child nodes with human-readable names, based on the name of the node being instanced instead of its type only.
*/
func (o *Node) AddChild(node *Node, legibleUniqueName *bool) {
	log.Println("Calling Node.AddChild()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(node)
	goArguments[1] = reflect.ValueOf(legibleUniqueName)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_child", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a node to a group. Groups are helpers to name and organize a subset of nodes, like for example "enemies" or "collectables". A [Node] can be in any number of groups. Nodes can be assigned a group at any time, but will not be added to it until they are inside the scene tree (see [method is_inside_tree]).
*/
func (o *Node) AddToGroup(group string, persistent *bool) {
	log.Println("Calling Node.AddToGroup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(group)
	goArguments[1] = reflect.ValueOf(persistent)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_to_group", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if the node can process, i.e. whether its pause mode allows processing while the scene tree is paused (see [method set_pause_mode]). Always returns true if the scene tree is not paused, and false if the node is not in the tree. FIXME: Why FAIL_COND?
*/
func (o *Node) CanProcess() *bool {
	log.Println("Calling Node.CanProcess()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "can_process", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
                Duplicate the node, returning a new [Node].
				You can fine-tune the behavior using the [code]flags[/code], which are based on the DUPLICATE_* constants.
*/
func (o *Node) Duplicate(flags int64) *Node {
	log.Println("Calling Node.Duplicate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flags)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "duplicate", goArguments, "*Node")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Node)

	return returnValue

}

/*
   Find a descendant of this node whose name matches [code]mask[/code] as in [method String.match] (i.e. case sensitive, but '*' matches zero or more characters and '?' matches any single character except '.'). Note that it does not match against the full path, just against individual node names.
*/
func (o *Node) FindNode(mask string, recursive *bool, owned *bool) *Node {
	log.Println("Calling Node.FindNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(mask)
	goArguments[1] = reflect.ValueOf(recursive)
	goArguments[2] = reflect.ValueOf(owned)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "find_node", goArguments, "*Node")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Node)

	return returnValue

}

/*
   Return a child node by its index (see [method get_child_count]). This method is often used for iterating all children of a node.
*/
func (o *Node) GetChild(idx int64) *Node {
	log.Println("Calling Node.GetChild()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_child", goArguments, "*Node")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Node)

	return returnValue

}

/*
   Return the amount of child nodes.
*/
func (o *Node) GetChildCount() int64 {
	log.Println("Calling Node.GetChildCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_child_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return an array of references ([Node]) to the child nodes.
*/
func (o *Node) GetChildren() *Array {
	log.Println("Calling Node.GetChildren()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_children", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Return a filename that may be contained by the node. When a scene is instanced from a file, it topmost node contains the filename from where it was loaded (see [method set_filename]).
*/
func (o *Node) GetFilename() string {
	log.Println("Calling Node.GetFilename()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_filename", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the time elapsed since the last fixed frame (see [method _fixed_process]). This is always the same in fixed processing unless the frames per second is changed in [OS].
*/
func (o *Node) GetFixedProcessDeltaTime() float64 {
	log.Println("Calling Node.GetFixedProcessDeltaTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fixed_process_delta_time", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return an array listing the groups that the node is part of.
*/
func (o *Node) GetGroups() *Array {
	log.Println("Calling Node.GetGroups()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_groups", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Get the node index, i.e. its position among the siblings of its parent.
*/
func (o *Node) GetIndex() int64 {
	log.Println("Calling Node.GetIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_index", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the name of the node. This name is unique among the siblings (other child nodes from the same parent).
*/
func (o *Node) GetName() string {
	log.Println("Calling Node.GetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *Node) GetNetworkMaster() int64 {
	log.Println("Calling Node.GetNetworkMaster()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_network_master", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
                Fetch a node. The [NodePath] must be valid (or else an error will be raised) and can be either the path to child node, a relative path (from the current node to another node), or an absolute path to a node.
				Note: fetching absolute paths only works when the node is inside the scene tree (see [method is_inside_tree]).
				[i]Example:[/i] Assume your current node is Character and the following tree:
				[codeblock]
				/root
				/root/Character
				/root/Character/Sword
				/root/Character/Backpack/Dagger
				/root/MyGame
				/root/Swamp/Alligator
				/root/Swamp/Mosquito
				/root/Swamp/Goblin
				[/codeblock]
				Possible paths are:
				[codeblock]
				get_node("Sword")
				get_node("Backpack/Dagger")
				get_node("../Swamp/Alligator")
				get_node("/root/MyGame")
				[/codeblock]
*/
func (o *Node) GetNode(path *NodePath) *Node {
	log.Println("Calling Node.GetNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node", goArguments, "*Node")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Node)

	return returnValue

}

/*

 */
func (o *Node) GetNodeAndResource(path *NodePath) *Array {
	log.Println("Calling Node.GetNodeAndResource()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_and_resource", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Get the node owner (see [method set_owner]).
*/
func (o *Node) GetOwner() *Node {
	log.Println("Calling Node.GetOwner()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_owner", goArguments, "*Node")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Node)

	return returnValue

}

/*
   Return the parent node of the current node, or an empty [Node] if the node lacks a parent.
*/
func (o *Node) GetParent() *Node {
	log.Println("Calling Node.GetParent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_parent", goArguments, "*Node")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Node)

	return returnValue

}

/*
   Return the absolute path of the current node. This only works if the current node is inside the scene tree (see [method is_inside_tree]).
*/
func (o *Node) GetPath() *NodePath {
	log.Println("Calling Node.GetPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_path", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*
   Return the relative path from the current node to the specified node in "node" argument. Both nodes must be in the same scene, or else the function will fail.
*/
func (o *Node) GetPathTo(node *Node) *NodePath {
	log.Println("Calling Node.GetPathTo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_path_to", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *Node) GetPauseMode() int64 {
	log.Println("Calling Node.GetPauseMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pause_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Node) GetPositionInParent() int64 {
	log.Println("Calling Node.GetPositionInParent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_position_in_parent", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the time elapsed (in seconds) since the last process callback. This is almost always different each time.
*/
func (o *Node) GetProcessDeltaTime() float64 {
	log.Println("Calling Node.GetProcessDeltaTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_process_delta_time", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Node) GetSceneInstanceLoadPlaceholder() *bool {
	log.Println("Calling Node.GetSceneInstanceLoadPlaceholder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scene_instance_load_placeholder", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Node) GetTree() *SceneTree {
	log.Println("Calling Node.GetTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tree", goArguments, "*SceneTree")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*SceneTree)

	return returnValue

}

/*

 */
func (o *Node) GetViewport() *Viewport {
	log.Println("Calling Node.GetViewport()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_viewport", goArguments, "*Viewport")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Viewport)

	return returnValue

}

/*

 */
func (o *Node) HasNode(path *NodePath) *bool {
	log.Println("Calling Node.HasNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_node", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Node) HasNodeAndResource(path *NodePath) *bool {
	log.Println("Calling Node.HasNodeAndResource()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_node_and_resource", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return [i]true[/i] if the "node" argument is a direct or indirect child of the current node, otherwise return [i]false[/i].
*/
func (o *Node) IsAParentOf(node *Node) *bool {
	log.Println("Calling Node.IsAParentOf()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_a_parent_of", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Node) IsDisplayedFolded() *bool {
	log.Println("Calling Node.IsDisplayedFolded()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_displayed_folded", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if fixed processing is enabled (see [method set_fixed_process]).
*/
func (o *Node) IsFixedProcessing() *bool {
	log.Println("Calling Node.IsFixedProcessing()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_fixed_processing", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Node) IsFixedProcessingInternal() *bool {
	log.Println("Calling Node.IsFixedProcessingInternal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_fixed_processing_internal", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return [i]true[/i] if "node" occurs later in the scene hierarchy than the current node, otherwise return [i]false[/i].
*/
func (o *Node) IsGreaterThan(node *Node) *bool {
	log.Println("Calling Node.IsGreaterThan()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_greater_than", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Node) IsInGroup(group string) *bool {
	log.Println("Calling Node.IsInGroup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(group)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_in_group", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Node) IsInsideTree() *bool {
	log.Println("Calling Node.IsInsideTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_inside_tree", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Node) IsNetworkMaster() *bool {
	log.Println("Calling Node.IsNetworkMaster()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_network_master", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether processing is enabled in the current node (see [method set_process]).
*/
func (o *Node) IsProcessing() *bool {
	log.Println("Calling Node.IsProcessing()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_processing", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if the node is processing input (see [method set_process_input]).
*/
func (o *Node) IsProcessingInput() *bool {
	log.Println("Calling Node.IsProcessingInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_processing_input", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Node) IsProcessingInternal() *bool {
	log.Println("Calling Node.IsProcessingInternal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_processing_internal", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if the node is processing unhandled input (see [method set_process_unhandled_input]).
*/
func (o *Node) IsProcessingUnhandledInput() *bool {
	log.Println("Calling Node.IsProcessingUnhandledInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_processing_unhandled_input", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Node) IsProcessingUnhandledKeyInput() *bool {
	log.Println("Calling Node.IsProcessingUnhandledKeyInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_processing_unhandled_key_input", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Move a child node to a different position (order) amongst the other children. Since calls, signals, etc are performed by tree order, changing the order of children nodes may be useful.
*/
func (o *Node) MoveChild(childNode *Node, toPos int64) {
	log.Println("Calling Node.MoveChild()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(childNode)
	goArguments[1] = reflect.ValueOf(toPos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "move_child", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Node) PrintStrayNodes() {
	log.Println("Calling Node.PrintStrayNodes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "print_stray_nodes", goArguments, "")

	log.Println("Got return value!")

}

/*
   Print the scene to stdout. Used mainly for debugging purposes.
*/
func (o *Node) PrintTree() {
	log.Println("Calling Node.PrintTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "print_tree", goArguments, "")

	log.Println("Got return value!")

}

/*
   Calls the method (if present) with the arguments given in "args" on this Node and recursively on all children. If the parent_first argument is true then the method will be called on the current [Node] first, then on all children. If it is false then the children will get called first.
*/
func (o *Node) PropagateCall(method string, args *Array, parentFirst *bool) {
	log.Println("Calling Node.PropagateCall()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(method)
	goArguments[1] = reflect.ValueOf(args)
	goArguments[2] = reflect.ValueOf(parentFirst)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "propagate_call", goArguments, "")

	log.Println("Got return value!")

}

/*
   Notify the current node and all its children recursively by calling notification() in all of them.
*/
func (o *Node) PropagateNotification(what int64) {
	log.Println("Calling Node.PropagateNotification()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(what)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "propagate_notification", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Node) QueueFree() {
	log.Println("Calling Node.QueueFree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "queue_free", goArguments, "")

	log.Println("Got return value!")

}

/*
   Move this node to the top of the array of nodes of the parent node. This is often useful on GUIs ([Control]), because their order of drawing fully depends on their order in the tree.
*/
func (o *Node) Raise() {
	log.Println("Calling Node.Raise()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "raise", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove a node and set all its children as children of the parent node (if exists). All even subscriptions that pass by the removed node will be unsubscribed.
*/
func (o *Node) RemoveAndSkip() {
	log.Println("Calling Node.RemoveAndSkip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_and_skip", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove a child [Node]. Node is NOT deleted and will have to be deleted manually.
*/
func (o *Node) RemoveChild(node *Node) {
	log.Println("Calling Node.RemoveChild()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_child", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove a node from a group.
*/
func (o *Node) RemoveFromGroup(group string) {
	log.Println("Calling Node.RemoveFromGroup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(group)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_from_group", goArguments, "")

	log.Println("Got return value!")

}

/*
   Replace a node in a scene by a given one. Subscriptions that pass through this node will be lost.
*/
func (o *Node) ReplaceBy(node *Node, keepData *bool) {
	log.Println("Calling Node.ReplaceBy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(node)
	goArguments[1] = reflect.ValueOf(keepData)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "replace_by", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Node) RequestReady() {
	log.Println("Calling Node.RequestReady()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "request_ready", goArguments, "")

	log.Println("Got return value!")

}

/*
   Send a remote procedure call request to all peers on the network (and locally), optionally sending additional data as arguments. Call request will be received by nodes with the same [NodePath].
*/
func (o *Node) Rpc(method string) *Variant {
	log.Println("Calling Node.Rpc()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "rpc", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Change the method's RPC mode (one of RPC_MODE_* constants).
*/
func (o *Node) RpcConfig(method string, mode int64) {
	log.Println("Calling Node.RpcConfig()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(method)
	goArguments[1] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rpc_config", goArguments, "")

	log.Println("Got return value!")

}

/*
   Send a [method rpc] to a specific peer identified by [i]peer_id[/i].
*/
func (o *Node) RpcId(peerId int64, method string) *Variant {
	log.Println("Calling Node.RpcId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(peerId)
	goArguments[1] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "rpc_id", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Send a [method rpc] using an unreliable protocol.
*/
func (o *Node) RpcUnreliable(method string) *Variant {
	log.Println("Calling Node.RpcUnreliable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "rpc_unreliable", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Send a [method rpc] to a specific peer identified by [i]peer_id[/i] using an unreliable protocol.
*/
func (o *Node) RpcUnreliableId(peerId int64, method string) *Variant {
	log.Println("Calling Node.RpcUnreliableId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(peerId)
	goArguments[1] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "rpc_unreliable_id", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Remotely change property's value on other peers (and locally).
*/
func (o *Node) Rset(property string, value *Variant) {
	log.Println("Calling Node.Rset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(property)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Change the property's RPC mode (one of RPC_MODE_* constants).
*/
func (o *Node) RsetConfig(property string, mode int64) {
	log.Println("Calling Node.RsetConfig()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(property)
	goArguments[1] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rset_config", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remotely change property's value on a specific peer identified by [i]peer_id[/i].
*/
func (o *Node) RsetId(peerId int64, property string, value *Variant) {
	log.Println("Calling Node.RsetId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(peerId)
	goArguments[1] = reflect.ValueOf(property)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rset_id", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remotely change property's value on other peers (and locally) using an unreliable protocol.
*/
func (o *Node) RsetUnreliable(property string, value *Variant) {
	log.Println("Calling Node.RsetUnreliable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(property)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rset_unreliable", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remotely change property's value on a specific peer identified by [i]peer_id[/i] using an unreliable protocol.
*/
func (o *Node) RsetUnreliableId(peerId int64, property string, value *Variant) {
	log.Println("Calling Node.RsetUnreliableId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(peerId)
	goArguments[1] = reflect.ValueOf(property)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rset_unreliable_id", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Node) SetDisplayFolded(fold *bool) {
	log.Println("Calling Node.SetDisplayFolded()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(fold)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_display_folded", goArguments, "")

	log.Println("Got return value!")

}

/*
   A node can contain a filename. This filename should not be changed by the user, unless writing editors and tools. When a scene is instanced from a file, it topmost node contains the filename from where it was loaded.
*/
func (o *Node) SetFilename(filename string) {
	log.Println("Calling Node.SetFilename()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(filename)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_filename", goArguments, "")

	log.Println("Got return value!")

}

/*
   Enables or disables node fixed framerate processing. When a node is being processed, it will receive a NOTIFICATION_PROCESS at a fixed (usually 60 fps, check [OS] to change that) interval (and the [method _fixed_process] callback will be called if exists). It is common to check how much time was elapsed since the previous frame by calling [method get_fixed_process_delta_time].
*/
func (o *Node) SetFixedProcess(enable *bool) {
	log.Println("Calling Node.SetFixedProcess()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fixed_process", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Node) SetFixedProcessInternal(enable *bool) {
	log.Println("Calling Node.SetFixedProcessInternal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fixed_process_internal", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the name of the [Node]. Name must be unique within parent, and setting an already existing name will cause for the node to be automatically renamed.
*/
func (o *Node) SetName(name string) {
	log.Println("Calling Node.SetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_name", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Node) SetNetworkMaster(id int64, recursive *bool) {
	log.Println("Calling Node.SetNetworkMaster()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(recursive)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_network_master", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the node owner. A node can have any other node as owner (as long as a valid parent, grandparent, etc ascending in the tree). When saving a node (using SceneSaver) all the nodes it owns will be saved with it. This allows to create complex SceneTrees, with instancing and subinstancing.
*/
func (o *Node) SetOwner(owner *Node) {
	log.Println("Calling Node.SetOwner()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(owner)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_owner", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Node) SetPauseMode(mode int64) {
	log.Println("Calling Node.SetPauseMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pause_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Enables or disables node processing. When a node is being processed, it will receive a NOTIFICATION_PROCESS on every drawn frame (and the [method _process] callback will be called if exists). It is common to check how much time was elapsed since the previous frame by calling [method get_process_delta_time].
*/
func (o *Node) SetProcess(enable *bool) {
	log.Println("Calling Node.SetProcess()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_process", goArguments, "")

	log.Println("Got return value!")

}

/*
   Enable input processing for node. This is not required for GUI controls! It hooks up the node to receive all input (see [method _input]).
*/
func (o *Node) SetProcessInput(enable *bool) {
	log.Println("Calling Node.SetProcessInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_process_input", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Node) SetProcessInternal(enable *bool) {
	log.Println("Calling Node.SetProcessInternal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_process_internal", goArguments, "")

	log.Println("Got return value!")

}

/*
   Enable unhandled input processing for node. This is not required for GUI controls! It hooks up the node to receive all input that was not previously handled before (usually by a [Control]). (see [method _unhandled_input]).
*/
func (o *Node) SetProcessUnhandledInput(enable *bool) {
	log.Println("Calling Node.SetProcessUnhandledInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_process_unhandled_input", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Node) SetProcessUnhandledKeyInput(enable *bool) {
	log.Println("Calling Node.SetProcessUnhandledKeyInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_process_unhandled_key_input", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Node) SetSceneInstanceLoadPlaceholder(loadPlaceholder *bool) {
	log.Println("Calling Node.SetSceneInstanceLoadPlaceholder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(loadPlaceholder)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_scene_instance_load_placeholder", goArguments, "")

	log.Println("Got return value!")

}

/*
        NodeImplementer is an interface for Node objects.
        Nodes are the base bricks with which Godot games are developed. They can be set as children of other nodes, resulting in a tree arrangement. A given node can contain any number of nodes as children (but there is only one scene tree root node) with the requirement that all siblings (direct children of a node) should have unique names.
		Any tree of nodes is called a [i]scene[/i]. Scenes can be saved to the disk and then instanced into other scenes. This allows for very high flexibility in the architecture and data model of the projects. Nodes can optionally be added to groups. This makes it easy to reach a number of nodes from the code (for example an "enemies" group) to perform grouped actions.
		[b]Scene tree:[/b] The [SceneTree] contains the active tree of nodes. When a node is added to the scene tree, it receives the NOTIFICATION_ENTER_TREE notification and its [method _enter_tree] callback is triggered. Children nodes are always added [i]after[/i] their parent node, i.e. the [method _enter_tree] callback of a parent node will be triggered before its child's.
		Once all nodes have been added in the scene tree, they receive the NOTIFICATION_READY notification and their respective [method _ready] callbacks are triggered. For groups of nodes, the [method _ready] callback is called in reverse order, from the children up to the parent nodes.
		It means that when adding a scene to the scene tree, the following order will be used for the callbacks: [method _enter_tree] of the parent, [method _enter_tree] of the children, [method _ready] of the children and finally [method _ready] of the parent (and that recursively for the whole scene).
		[b]Processing:[/b] Nodes can be set to the "process" state, so that they receive a callback on each frame requesting them to process (do something). Normal processing (callback [method _process], toggled with [method set_process]) happens as fast as possible and is dependent on the frame rate, so the processing time [i]delta[/i] is variable. Fixed processing (callback [method _fixed_process], toggled with [method set_fixed_process]) happens a fixed amount of times per second (by default 60) and is useful to link itself to the physics.
		Nodes can also process input events. When set, the [method _input] function will be called for each input that the program receives. In many cases, this can be overkill (unless used for simple projects), and the [method _unhandled_input] function might be preferred; it is called when the input event was not handled by anyone else (typically, GUI [Control] nodes), ensuring that the node only receives the events that were meant for it.
		To keep track of the scene hierarchy (especially when instancing scenes into other scenes), an "owner" can be set for the node with [method set_owner]. This keeps track of who instanced what. This is mostly useful when writing editors and tools, though.
		Finally, when a node is freed with [method free] or [method queue_free], it will also free all its children.
		[b]Networking with nodes:[/b] After connecting to a server (or making one, see [NetworkedMultiplayerENet]) it is possible to use the built-in RPC (remote procedure call) system to easily communicate over the network. By calling [method rpc] with a method name, it will be called locally, and in all connected peers (peers = clients and the server that accepts connections), with behaviour varying depending on the network mode ([method set_network_mode]) on the receiving peer. To identify which [Node] receives the RPC call Godot will use its [NodePath] (make sure node names are the same on all peers).
*/
type NodeImplementer interface {
	ObjectImplementer

	X_EnterTree()

	X_ExitTree()

	X_FixedProcess(delta float64)

	X_Input(event *InputEvent)

	X_Process(delta float64)

	X_Ready()

	X_UnhandledInput(event *InputEvent)

	X_UnhandledKeyInput(event *InputEventKey)

	AddChild(node *Node, legibleUniqueName *bool)

	AddToGroup(group string, persistent *bool)

	CanProcess() *bool

	Duplicate(flags int64) *Node

	FindNode(mask string, recursive *bool, owned *bool) *Node

	GetChild(idx int64) *Node

	GetChildCount() int64

	GetChildren() *Array

	GetFilename() string

	GetFixedProcessDeltaTime() float64

	GetGroups() *Array

	GetIndex() int64

	GetName() string

	GetNetworkMaster() int64

	GetNode(path *NodePath) *Node

	GetNodeAndResource(path *NodePath) *Array

	GetOwner() *Node

	GetParent() *Node

	GetPath() *NodePath

	GetPathTo(node *Node) *NodePath

	GetPauseMode() int64

	GetPositionInParent() int64

	GetProcessDeltaTime() float64

	GetSceneInstanceLoadPlaceholder() *bool

	GetTree() *SceneTree

	GetViewport() *Viewport

	HasNode(path *NodePath) *bool

	HasNodeAndResource(path *NodePath) *bool

	IsAParentOf(node *Node) *bool

	IsDisplayedFolded() *bool

	IsFixedProcessing() *bool

	IsFixedProcessingInternal() *bool

	IsGreaterThan(node *Node) *bool

	IsInGroup(group string) *bool

	IsInsideTree() *bool

	IsNetworkMaster() *bool

	IsProcessing() *bool

	IsProcessingInput() *bool

	IsProcessingInternal() *bool

	IsProcessingUnhandledInput() *bool

	IsProcessingUnhandledKeyInput() *bool

	MoveChild(childNode *Node, toPos int64)

	PrintStrayNodes()

	PrintTree()

	PropagateCall(method string, args *Array, parentFirst *bool)

	PropagateNotification(what int64)

	QueueFree()

	Raise()

	RemoveAndSkip()

	RemoveChild(node *Node)

	RemoveFromGroup(group string)

	ReplaceBy(node *Node, keepData *bool)

	RequestReady()

	Rpc(method string) *Variant

	RpcConfig(method string, mode int64)

	RpcId(peerId int64, method string) *Variant

	RpcUnreliable(method string) *Variant

	RpcUnreliableId(peerId int64, method string) *Variant

	Rset(property string, value *Variant)

	RsetConfig(property string, mode int64)

	RsetId(peerId int64, property string, value *Variant)

	RsetUnreliable(property string, value *Variant)

	RsetUnreliableId(peerId int64, property string, value *Variant)

	SetDisplayFolded(fold *bool)

	SetFilename(filename string)

	SetFixedProcess(enable *bool)

	SetFixedProcessInternal(enable *bool)

	SetName(name string)

	SetNetworkMaster(id int64, recursive *bool)

	SetOwner(owner *Node)

	SetPauseMode(mode int64)

	SetProcess(enable *bool)

	SetProcessInput(enable *bool)

	SetProcessInternal(enable *bool)

	SetProcessUnhandledInput(enable *bool)

	SetProcessUnhandledKeyInput(enable *bool)

	SetSceneInstanceLoadPlaceholder(loadPlaceholder *bool)
}

/*
   Base node for 2D system. Node2D contains a position, rotation and scale, which is used to position and animate. It can alternatively be used with a custom 2D transform ([Transform2D]). A tree of Node2Ds allows complex hierarchies for animation and positioning.
*/
type Node2D struct {
	CanvasItem
}

func (o *Node2D) baseClass() string {
	return "Node2D"
}

/*
   Apply the 'ratio' scale to the 2D node, according to its current scale value.
*/
func (o *Node2D) ApplyScale(ratio *Vector2) {
	log.Println("Calling Node2D.ApplyScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ratio)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "apply_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the pivot position of the 2D node to 'pivot' value. This method is implemented only in some nodes that inherit Node2D.
*/
func (o *Node2D) EditSetPivot(pivot *Vector2) {
	log.Println("Calling Node2D.EditSetPivot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pivot)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "edit_set_pivot", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the rotation angle in radians needed for the 2d node to point at 'point' position.
*/
func (o *Node2D) GetAngleTo(point *Vector2) float64 {
	log.Println("Calling Node2D.GetAngleTo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(point)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_angle_to", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the global position of the 2D node.
*/
func (o *Node2D) GetGlobalPosition() *Vector2 {
	log.Println("Calling Node2D.GetGlobalPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_global_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the global rotation in radians of the 2D node.
*/
func (o *Node2D) GetGlobalRotation() float64 {
	log.Println("Calling Node2D.GetGlobalRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_global_rotation", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the global rotation in degrees of the 2D node.
*/
func (o *Node2D) GetGlobalRotationInDegrees() float64 {
	log.Println("Calling Node2D.GetGlobalRotationInDegrees()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_global_rotation_in_degrees", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the global scale of the 2D node.
*/
func (o *Node2D) GetGlobalScale() *Vector2 {
	log.Println("Calling Node2D.GetGlobalScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_global_scale", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the position of the 2D node.
*/
func (o *Node2D) GetPosition() *Vector2 {
	log.Println("Calling Node2D.GetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the transform [Transform2D] calculated relatively to the parent of this 2D node.
*/
func (o *Node2D) GetRelativeTransformToParent(parent *Node) *Transform2D {
	log.Println("Calling Node2D.GetRelativeTransformToParent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(parent)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_relative_transform_to_parent", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Return the rotation in radians of the 2D node.
*/
func (o *Node2D) GetRotation() float64 {
	log.Println("Calling Node2D.GetRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rotation", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the rotation in degrees of the 2D node.
*/
func (o *Node2D) GetRotationInDegrees() float64 {
	log.Println("Calling Node2D.GetRotationInDegrees()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rotation_in_degrees", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the scale of the 2D node.
*/
func (o *Node2D) GetScale() *Vector2 {
	log.Println("Calling Node2D.GetScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scale", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the Z-index of the 2D node.
*/
func (o *Node2D) GetZ() int64 {
	log.Println("Calling Node2D.GetZ()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_z", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Apply a global translation of 'offset' to the 2D node, starting from its current global position.
*/
func (o *Node2D) GlobalTranslate(offset *Vector2) {
	log.Println("Calling Node2D.GlobalTranslate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "global_translate", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if the Z-index value of this 2D node is relative to its parent's. Else, return false.
*/
func (o *Node2D) IsZRelative() *bool {
	log.Println("Calling Node2D.IsZRelative()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_z_relative", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Rotate the 2d node so it points at 'point' position.
*/
func (o *Node2D) LookAt(point *Vector2) {
	log.Println("Calling Node2D.LookAt()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(point)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "look_at", goArguments, "")

	log.Println("Got return value!")

}

/*
   Apply a local translation on X axis to the 2D node according to the 'delta' of the process. If 'scaled' is false, the movement is normalized.
*/
func (o *Node2D) MoveLocalX(delta float64, scaled *bool) {
	log.Println("Calling Node2D.MoveLocalX()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(delta)
	goArguments[1] = reflect.ValueOf(scaled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "move_local_x", goArguments, "")

	log.Println("Got return value!")

}

/*
   Apply a local translation on Y axis to the 2D node according to the 'delta' of the process. If 'scaled' is false, the movement is normalized.
*/
func (o *Node2D) MoveLocalY(delta float64, scaled *bool) {
	log.Println("Calling Node2D.MoveLocalY()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(delta)
	goArguments[1] = reflect.ValueOf(scaled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "move_local_y", goArguments, "")

	log.Println("Got return value!")

}

/*
   Apply a rotation (in radians) to the 2D node, starting from its current rotation.
*/
func (o *Node2D) Rotate(radians float64) {
	log.Println("Calling Node2D.Rotate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radians)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rotate", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the global position of the 2D node.
*/
func (o *Node2D) SetGlobalPosition(pos *Vector2) {
	log.Println("Calling Node2D.SetGlobalPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_global_position", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the global rotation in radians of the 2D node
*/
func (o *Node2D) SetGlobalRotation(radians float64) {
	log.Println("Calling Node2D.SetGlobalRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radians)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_global_rotation", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the global rotation in degrees of the 2D node
*/
func (o *Node2D) SetGlobalRotationInDegrees(degrees float64) {
	log.Println("Calling Node2D.SetGlobalRotationInDegrees()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_global_rotation_in_degrees", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the global scale of the 2D node.
*/
func (o *Node2D) SetGlobalScale(scale *Vector2) {
	log.Println("Calling Node2D.SetGlobalScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_global_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the global transform [Transform2D] of the 2D node.
*/
func (o *Node2D) SetGlobalTransform(xform *Transform2D) {
	log.Println("Calling Node2D.SetGlobalTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(xform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_global_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the position of the 2D node.
*/
func (o *Node2D) SetPosition(pos *Vector2) {
	log.Println("Calling Node2D.SetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_position", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the rotation in radians of the 2D node.
*/
func (o *Node2D) SetRotation(radians float64) {
	log.Println("Calling Node2D.SetRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radians)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rotation", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the rotation in degrees of the 2D node.
*/
func (o *Node2D) SetRotationInDegrees(degrees float64) {
	log.Println("Calling Node2D.SetRotationInDegrees()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rotation_in_degrees", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the scale of the 2D node.
*/
func (o *Node2D) SetScale(scale *Vector2) {
	log.Println("Calling Node2D.SetScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the local transform [Transform2D] of the 2D node.
*/
func (o *Node2D) SetTransform(xform *Transform2D) {
	log.Println("Calling Node2D.SetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(xform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the Z-index value of the 2D node.
*/
func (o *Node2D) SetZ(z int64) {
	log.Println("Calling Node2D.SetZ()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(z)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_z", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the Z-index value as relative to the parent node of this 2D node. Thus, if this 2D node's Z-index value is 2 and its parent's effective Z-index is 3, then the effective Z-index value of this 2D node would be 3 + 2 = 5.
*/
func (o *Node2D) SetZAsRelative(enable *bool) {
	log.Println("Calling Node2D.SetZAsRelative()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_z_as_relative", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Node2D) ToGlobal(localPoint *Vector2) *Vector2 {
	log.Println("Calling Node2D.ToGlobal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(localPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "to_global", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Node2D) ToLocal(globalPoint *Vector2) *Vector2 {
	log.Println("Calling Node2D.ToLocal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(globalPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "to_local", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Apply a local translation of 'offset' to the 2D node, starting from its current local position.
*/
func (o *Node2D) Translate(offset *Vector2) {
	log.Println("Calling Node2D.Translate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "translate", goArguments, "")

	log.Println("Got return value!")

}

/*
   Node2DImplementer is an interface for Node2D objects.
   Base node for 2D system. Node2D contains a position, rotation and scale, which is used to position and animate. It can alternatively be used with a custom 2D transform ([Transform2D]). A tree of Node2Ds allows complex hierarchies for animation and positioning.
*/
type Node2DImplementer interface {
	CanvasItemImplementer

	ApplyScale(ratio *Vector2)

	EditSetPivot(pivot *Vector2)

	GetAngleTo(point *Vector2) float64

	GetGlobalPosition() *Vector2

	GetGlobalRotation() float64

	GetGlobalRotationInDegrees() float64

	GetGlobalScale() *Vector2

	GetPosition() *Vector2

	GetRelativeTransformToParent(parent *Node) *Transform2D

	GetRotation() float64

	GetRotationInDegrees() float64

	GetScale() *Vector2

	GetZ() int64

	GlobalTranslate(offset *Vector2)

	IsZRelative() *bool

	LookAt(point *Vector2)

	MoveLocalX(delta float64, scaled *bool)

	MoveLocalY(delta float64, scaled *bool)

	Rotate(radians float64)

	SetGlobalPosition(pos *Vector2)

	SetGlobalRotation(radians float64)

	SetGlobalRotationInDegrees(degrees float64)

	SetGlobalScale(scale *Vector2)

	SetGlobalTransform(xform *Transform2D)

	SetPosition(pos *Vector2)

	SetRotation(radians float64)

	SetRotationInDegrees(degrees float64)

	SetScale(scale *Vector2)

	SetTransform(xform *Transform2D)

	SetZ(z int64)

	SetZAsRelative(enable *bool)

	ToGlobal(localPoint *Vector2) *Vector2

	ToLocal(globalPoint *Vector2) *Vector2

	Translate(offset *Vector2)
}

/*
   Operating System functions. OS Wraps the most common functionality to communicate with the host Operating System, such as: mouse grabbing, mouse cursors, clipboard, video mode, date and time, timers, environment variables, execution of binaries, command line, etc.
*/
type OS struct {
	Object
}

func (o *OS) baseClass() string {
	return "OS"
}

/*
   Displays a modal dialog box utilizing the host OS.
*/
func (o *OS) Alert(text string, title string) {
	log.Println("Calling OS.Alert()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(text)
	goArguments[1] = reflect.ValueOf(title)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "alert", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if the host OS allows drawing.
*/
func (o *OS) CanDraw() *bool {
	log.Println("Calling OS.CanDraw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "can_draw", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns if the current host platform is using multiple threads.
*/
func (o *OS) CanUseThreads() *bool {
	log.Println("Calling OS.CanUseThreads()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "can_use_threads", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Delay executing of the current thread by given milliseconds.
*/
func (o *OS) DelayMsec(msec int64) {
	log.Println("Calling OS.DelayMsec()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(msec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "delay_msec", goArguments, "")

	log.Println("Got return value!")

}

/*
   Delay executing of the current thread by given microseconds.
*/
func (o *OS) DelayUsec(usec int64) {
	log.Println("Calling OS.DelayUsec()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(usec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "delay_usec", goArguments, "")

	log.Println("Got return value!")

}

/*
                Dumps the memory allocation ringlist to a file (only works in debug).
				Entry format per line: "Address - Size - Description"
*/
func (o *OS) DumpMemoryToFile(file string) {
	log.Println("Calling OS.DumpMemoryToFile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(file)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "dump_memory_to_file", goArguments, "")

	log.Println("Got return value!")

}

/*
                Dumps all used resources to file (only works in debug).
				Entry format per line: "Resource Type : Resource Location"
				At the end of the file is a statistic of all used Resource Types.
*/
func (o *OS) DumpResourcesToFile(file string) {
	log.Println("Calling OS.DumpResourcesToFile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(file)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "dump_resources_to_file", goArguments, "")

	log.Println("Got return value!")

}

/*
   Execute the binary file in given path, optionally blocking until it returns. A process ID is returned.
*/
func (o *OS) Execute(path string, arguments *PoolStringArray, blocking *bool, output *Array) int64 {
	log.Println("Calling OS.Execute()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(path)
	goArguments[1] = reflect.ValueOf(arguments)
	goArguments[2] = reflect.ValueOf(blocking)
	goArguments[3] = reflect.ValueOf(output)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "execute", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the scancode of the given string (e.g. "Escape")
*/
func (o *OS) FindScancodeFromString(string string) int64 {
	log.Println("Calling OS.FindScancodeFromString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(string)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "find_scancode_from_string", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns true if the current window is borderless.
*/
func (o *OS) GetBorderlessWindow() *bool {
	log.Println("Calling OS.GetBorderlessWindow()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_borderless_window", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Get clipboard from the host OS.
*/
func (o *OS) GetClipboard() string {
	log.Println("Calling OS.GetClipboard()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_clipboard", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the commandline passed to the engine.
*/
func (o *OS) GetCmdlineArgs() *PoolStringArray {
	log.Println("Calling OS.GetCmdlineArgs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cmdline_args", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   Returns the current screen index (0 padded).
*/
func (o *OS) GetCurrentScreen() int64 {
	log.Println("Calling OS.GetCurrentScreen()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_screen", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the absolute directory path of user data path([user://]).
*/
func (o *OS) GetDataDir() string {
	log.Println("Calling OS.GetDataDir()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_data_dir", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Returns current date as a dictionary of keys: year, month, day, weekday, dst (daylight savings time).
*/
func (o *OS) GetDate(utc *bool) *Dictionary {
	log.Println("Calling OS.GetDate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(utc)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_date", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*
   Returns current datetime as a dictionary of keys: year, month, day, weekday, dst (daylight savings time), hour, minute, second.
*/
func (o *OS) GetDatetime(utc *bool) *Dictionary {
	log.Println("Calling OS.GetDatetime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(utc)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_datetime", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*
                Get a dictionary of time values when given epoch time.
				Dictionary Time values will be a union of values from [method get_time] and [method get_date] dictionaries (with the exception of dst = day light standard time, as it cannot be determined from epoch).
*/
func (o *OS) GetDatetimeFromUnixTime(unixTimeVal int64) *Dictionary {
	log.Println("Calling OS.GetDatetimeFromUnixTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(unixTimeVal)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_datetime_from_unix_time", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*
   Return the total amount of dynamic memory used (only works in debug).
*/
func (o *OS) GetDynamicMemoryUsage() int64 {
	log.Println("Calling OS.GetDynamicMemoryUsage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dynamic_memory_usage", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return an environment variable.
*/
func (o *OS) GetEnvironment(environment string) string {
	log.Println("Calling OS.GetEnvironment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(environment)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_environment", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the path to the current engine executable.
*/
func (o *OS) GetExecutablePath() string {
	log.Println("Calling OS.GetExecutablePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_executable_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *OS) GetExitCode() int64 {
	log.Println("Calling OS.GetExitCode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_exit_code", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
                Returns the current latin keyboard variant as a String.
				Possible return values are: "QWERTY", "AZERTY", "QZERTY", "DVORAK", "NEO" or "ERROR"
*/
func (o *OS) GetLatinKeyboardVariant() string {
	log.Println("Calling OS.GetLatinKeyboardVariant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_latin_keyboard_variant", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the host OS locale.
*/
func (o *OS) GetLocale() string {
	log.Println("Calling OS.GetLocale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_locale", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Returns the model name of the current device.
*/
func (o *OS) GetModelName() string {
	log.Println("Calling OS.GetModelName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_model_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the name of the host OS. Possible values are: "Android", "Haiku", "iOS", "HTML5", "OSX", "Server", "Windows", "UWP", "X11".
*/
func (o *OS) GetName() string {
	log.Println("Calling OS.GetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *OS) GetPowerPercentLeft() int64 {
	log.Println("Calling OS.GetPowerPercentLeft()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_power_percent_left", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *OS) GetPowerSecondsLeft() int64 {
	log.Println("Calling OS.GetPowerSecondsLeft()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_power_seconds_left", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *OS) GetPowerState() int64 {
	log.Println("Calling OS.GetPowerState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_power_state", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the game process ID
*/
func (o *OS) GetProcessId() int64 {
	log.Println("Calling OS.GetProcessId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_process_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the number of cores available in the host machine.
*/
func (o *OS) GetProcessorCount() int64 {
	log.Println("Calling OS.GetProcessorCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_processor_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the given scancode as a string (e.g. Return values: "Escape", "Shift+Escape").
*/
func (o *OS) GetScancodeString(code int64) string {
	log.Println("Calling OS.GetScancodeString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(code)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scancode_string", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Returns the number of displays attached to the host machine
*/
func (o *OS) GetScreenCount() int64 {
	log.Println("Calling OS.GetScreenCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_screen_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
                Returns the dots per inch density of the specified screen.

				On Android Devices, the actual screen densities are grouped into six generalized densities:
					ldpi    - 120 dpi
					mdpi    - 160 dpi
					hdpi    - 240 dpi
					xhdpi   - 320 dpi
					xxhdpi  - 480 dpi
					xxxhdpi - 640 dpi
*/
func (o *OS) GetScreenDpi(screen int64) int64 {
	log.Println("Calling OS.GetScreenDpi()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(screen)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_screen_dpi", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the current screen orientation, the return value will be one of the SCREEN_ORIENTATION constants in this class.
*/
func (o *OS) GetScreenOrientation() int64 {
	log.Println("Calling OS.GetScreenOrientation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_screen_orientation", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *OS) GetScreenPosition(screen int64) *Vector2 {
	log.Println("Calling OS.GetScreenPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(screen)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_screen_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Returns the dimensions in pixels of the specified screen.
*/
func (o *OS) GetScreenSize(screen int64) *Vector2 {
	log.Println("Calling OS.GetScreenSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(screen)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_screen_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *OS) GetSplashTickMsec() int64 {
	log.Println("Calling OS.GetSplashTickMsec()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_splash_tick_msec", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the max amount of static memory used (only works in debug).
*/
func (o *OS) GetStaticMemoryPeakUsage() int64 {
	log.Println("Calling OS.GetStaticMemoryPeakUsage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_static_memory_peak_usage", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *OS) GetStaticMemoryUsage() int64 {
	log.Println("Calling OS.GetStaticMemoryUsage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_static_memory_usage", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *OS) GetSystemDir(dir int64) string {
	log.Println("Calling OS.GetSystemDir()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(dir)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_system_dir", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *OS) GetSystemTimeSecs() int64 {
	log.Println("Calling OS.GetSystemTimeSecs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_system_time_secs", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the amount of time passed in milliseconds since the engine started.
*/
func (o *OS) GetTicksMsec() int64 {
	log.Println("Calling OS.GetTicksMsec()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ticks_msec", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns current time as a dictionary of keys: hour, minute, second
*/
func (o *OS) GetTime(utc *bool) *Dictionary {
	log.Println("Calling OS.GetTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(utc)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_time", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*

 */
func (o *OS) GetTimeZoneInfo() *Dictionary {
	log.Println("Calling OS.GetTimeZoneInfo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_time_zone_info", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*

 */
func (o *OS) GetUniqueId() string {
	log.Println("Calling OS.GetUniqueId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_unique_id", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return	the current unix timestamp.
*/
func (o *OS) GetUnixTime() int64 {
	log.Println("Calling OS.GetUnixTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_unix_time", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
                Get an epoch time value from a dictionary of time values.
				[code]datetime[/code] must be populated with the following keys: year, month, day, hour, minute, second.
				You can pass the output from [method get_datetime_from_unix_time] directly into this function. Daylight savings time (dst), if present, is ignored.
*/
func (o *OS) GetUnixTimeFromDatetime(datetime *Dictionary) int64 {
	log.Println("Calling OS.GetUnixTimeFromDatetime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(datetime)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_unix_time_from_datetime", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the window position relative to the screen, the origin is the top left corner, +Y axis goes to the bottom and +X axis goes to the right.
*/
func (o *OS) GetWindowPosition() *Vector2 {
	log.Println("Calling OS.GetWindowPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_window_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Returns the size of the window (without counting window manager decorations).
*/
func (o *OS) GetWindowSize() *Vector2 {
	log.Println("Calling OS.GetWindowSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_window_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return true if an environment variable exists.
*/
func (o *OS) HasEnvironment(environment string) *bool {
	log.Println("Calling OS.HasEnvironment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(environment)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_environment", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *OS) HasTouchscreenUiHint() *bool {
	log.Println("Calling OS.HasTouchscreenUiHint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_touchscreen_ui_hint", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns true if the platform has a virtual keyboard, false otherwise.
*/
func (o *OS) HasVirtualKeyboard() *bool {
	log.Println("Calling OS.HasVirtualKeyboard()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_virtual_keyboard", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Hides the virtual keyboard if it is shown, does nothing otherwise.
*/
func (o *OS) HideVirtualKeyboard() {
	log.Println("Calling OS.HideVirtualKeyboard()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "hide_virtual_keyboard", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *OS) IsDebugBuild() *bool {
	log.Println("Calling OS.IsDebugBuild()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_debug_build", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if low cpu usage mode is enabled.
*/
func (o *OS) IsInLowProcessorUsageMode() *bool {
	log.Println("Calling OS.IsInLowProcessorUsageMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_in_low_processor_usage_mode", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns whether the screen is being kept on or not.
*/
func (o *OS) IsKeepScreenOn() *bool {
	log.Println("Calling OS.IsKeepScreenOn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_keep_screen_on", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *OS) IsOkLeftAndCancelRight() *bool {
	log.Println("Calling OS.IsOkLeftAndCancelRight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_ok_left_and_cancel_right", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *OS) IsScancodeUnicode(code int64) *bool {
	log.Println("Calling OS.IsScancodeUnicode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(code)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_scancode_unicode", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if the engine was executed with -v (verbose stdout).
*/
func (o *OS) IsStdoutVerbose() *bool {
	log.Println("Calling OS.IsStdoutVerbose()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_stdout_verbose", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *OS) IsVsyncEnabled() *bool {
	log.Println("Calling OS.IsVsyncEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_vsync_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns whether the window is in fullscreen mode or not.
*/
func (o *OS) IsWindowFullscreen() *bool {
	log.Println("Calling OS.IsWindowFullscreen()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_window_fullscreen", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if the window is maximized.
*/
func (o *OS) IsWindowMaximized() *bool {
	log.Println("Calling OS.IsWindowMaximized()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_window_maximized", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if the window is minimized.
*/
func (o *OS) IsWindowMinimized() *bool {
	log.Println("Calling OS.IsWindowMinimized()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_window_minimized", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns whether the window is resizable or not.
*/
func (o *OS) IsWindowResizable() *bool {
	log.Println("Calling OS.IsWindowResizable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_window_resizable", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Kill a process ID (this method can be used to kill processes that were not spawned by the game).
*/
func (o *OS) Kill(pid int64) int64 {
	log.Println("Calling OS.Kill()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pid)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "kill", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *OS) NativeVideoIsPlaying() *bool {
	log.Println("Calling OS.NativeVideoIsPlaying()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "native_video_is_playing", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *OS) NativeVideoPause() {
	log.Println("Calling OS.NativeVideoPause()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "native_video_pause", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *OS) NativeVideoPlay(path string, volume float64, audioTrack string, subtitleTrack string) int64 {
	log.Println("Calling OS.NativeVideoPlay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(path)
	goArguments[1] = reflect.ValueOf(volume)
	goArguments[2] = reflect.ValueOf(audioTrack)
	goArguments[3] = reflect.ValueOf(subtitleTrack)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "native_video_play", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *OS) NativeVideoStop() {
	log.Println("Calling OS.NativeVideoStop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "native_video_stop", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *OS) NativeVideoUnpause() {
	log.Println("Calling OS.NativeVideoUnpause()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "native_video_unpause", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *OS) PrintAllResources(tofile string) {
	log.Println("Calling OS.PrintAllResources()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tofile)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "print_all_resources", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *OS) PrintAllTexturesBySize() {
	log.Println("Calling OS.PrintAllTexturesBySize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "print_all_textures_by_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *OS) PrintResourcesByType(types *PoolStringArray) {
	log.Println("Calling OS.PrintResourcesByType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(types)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "print_resources_by_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *OS) PrintResourcesInUse(short *bool) {
	log.Println("Calling OS.PrintResourcesInUse()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(short)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "print_resources_in_use", goArguments, "")

	log.Println("Got return value!")

}

/*
   Request the user attention to the window. It'll flash the taskbar button on Windows or bounce the dock icon on OSX.
*/
func (o *OS) RequestAttention() {
	log.Println("Calling OS.RequestAttention()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "request_attention", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *OS) SetBorderlessWindow(borderless *bool) {
	log.Println("Calling OS.SetBorderlessWindow()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(borderless)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_borderless_window", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set clipboard to the OS.
*/
func (o *OS) SetClipboard(clipboard string) {
	log.Println("Calling OS.SetClipboard()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(clipboard)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_clipboard", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *OS) SetCurrentScreen(screen int64) {
	log.Println("Calling OS.SetCurrentScreen()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(screen)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_current_screen", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *OS) SetExitCode(code int64) {
	log.Println("Calling OS.SetExitCode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(code)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_exit_code", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *OS) SetIcon(icon *Image) {
	log.Println("Calling OS.SetIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(icon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_icon", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *OS) SetImePosition(position *Vector2) {
	log.Println("Calling OS.SetImePosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ime_position", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set keep screen on if true, or goes to sleep by device setting if false. (for Android/iOS)
*/
func (o *OS) SetKeepScreenOn(enabled *bool) {
	log.Println("Calling OS.SetKeepScreenOn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_keep_screen_on", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set to true to enable the low cpu usage mode. In this mode, the screen only redraws when there are changes, and a considerable sleep time is inserted between frames. This way, editors using the engine UI only use very little cpu.
*/
func (o *OS) SetLowProcessorUsageMode(enable *bool) {
	log.Println("Calling OS.SetLowProcessorUsageMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_low_processor_usage_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the current screen orientation, the argument value must be one of the SCREEN_ORIENTATION constants in this class.
*/
func (o *OS) SetScreenOrientation(orientation int64) {
	log.Println("Calling OS.SetScreenOrientation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(orientation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_screen_orientation", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *OS) SetThreadName(name string) int64 {
	log.Println("Calling OS.SetThreadName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "set_thread_name", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *OS) SetUseFileAccessSaveAndSwap(enabled *bool) {
	log.Println("Calling OS.SetUseFileAccessSaveAndSwap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_file_access_save_and_swap", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *OS) SetUseVsync(enable *bool) {
	log.Println("Calling OS.SetUseVsync()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_vsync", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets window fullscreen mode to the [i]enabled[/i] argument, [i]enabled[/i] is a toggle for the fullscreen mode, calling the function with [i]enabled[/i] true when the screen is not on fullscreen mode will cause the screen to go to fullscreen mode, calling the function with [i]enabled[/i] false when the screen is in fullscreen mode will cause the window to exit the fullscreen mode.
*/
func (o *OS) SetWindowFullscreen(enabled *bool) {
	log.Println("Calling OS.SetWindowFullscreen()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_window_fullscreen", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the window size to maximized.
*/
func (o *OS) SetWindowMaximized(enabled *bool) {
	log.Println("Calling OS.SetWindowMaximized()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_window_maximized", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether the window is minimized.
*/
func (o *OS) SetWindowMinimized(enabled *bool) {
	log.Println("Calling OS.SetWindowMinimized()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_window_minimized", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the position of the window to the specified position (this function could be restricted by the window manager, meaning that there could be some unreachable areas of the screen).
*/
func (o *OS) SetWindowPosition(position *Vector2) {
	log.Println("Calling OS.SetWindowPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_window_position", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the window resizable state, if the window is not resizable it will preserve the dimensions specified in the project settings.
*/
func (o *OS) SetWindowResizable(enabled *bool) {
	log.Println("Calling OS.SetWindowResizable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_window_resizable", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the window size to the specified size.
*/
func (o *OS) SetWindowSize(size *Vector2) {
	log.Println("Calling OS.SetWindowSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_window_size", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the window title to the specified string.
*/
func (o *OS) SetWindowTitle(title string) {
	log.Println("Calling OS.SetWindowTitle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(title)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_window_title", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *OS) ShellOpen(uri string) int64 {
	log.Println("Calling OS.ShellOpen()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(uri)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shell_open", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Shows the virtual keyboard if the platform has one. The [i]existing_text[/i] parameter is useful for implementing your own LineEdit, as it tells the virtual keyboard what text has already been typed (the virtual keyboard uses it for auto-correct and predictions).
*/
func (o *OS) ShowVirtualKeyboard(existingText string) {
	log.Println("Calling OS.ShowVirtualKeyboard()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(existingText)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "show_virtual_keyboard", goArguments, "")

	log.Println("Got return value!")

}

/*
   OSImplementer is an interface for OS objects.
   Operating System functions. OS Wraps the most common functionality to communicate with the host Operating System, such as: mouse grabbing, mouse cursors, clipboard, video mode, date and time, timers, environment variables, execution of binaries, command line, etc.
*/
type OSImplementer interface {
	ObjectImplementer

	Alert(text string, title string)

	CanDraw() *bool

	CanUseThreads() *bool

	DelayMsec(msec int64)

	DelayUsec(usec int64)

	DumpMemoryToFile(file string)

	DumpResourcesToFile(file string)

	Execute(path string, arguments *PoolStringArray, blocking *bool, output *Array) int64

	FindScancodeFromString(string string) int64

	GetBorderlessWindow() *bool

	GetClipboard() string

	GetCmdlineArgs() *PoolStringArray

	GetCurrentScreen() int64

	GetDataDir() string

	GetDate(utc *bool) *Dictionary

	GetDatetime(utc *bool) *Dictionary

	GetDatetimeFromUnixTime(unixTimeVal int64) *Dictionary

	GetDynamicMemoryUsage() int64

	GetEnvironment(environment string) string

	GetExecutablePath() string

	GetExitCode() int64

	GetLatinKeyboardVariant() string

	GetLocale() string

	GetModelName() string

	GetName() string

	GetPowerPercentLeft() int64

	GetPowerSecondsLeft() int64

	GetPowerState() int64

	GetProcessId() int64

	GetProcessorCount() int64

	GetScancodeString(code int64) string

	GetScreenCount() int64

	GetScreenDpi(screen int64) int64

	GetScreenOrientation() int64

	GetScreenPosition(screen int64) *Vector2

	GetScreenSize(screen int64) *Vector2

	GetSplashTickMsec() int64

	GetStaticMemoryPeakUsage() int64

	GetStaticMemoryUsage() int64

	GetSystemDir(dir int64) string

	GetSystemTimeSecs() int64

	GetTicksMsec() int64

	GetTime(utc *bool) *Dictionary

	GetTimeZoneInfo() *Dictionary

	GetUniqueId() string

	GetUnixTime() int64

	GetUnixTimeFromDatetime(datetime *Dictionary) int64

	GetWindowPosition() *Vector2

	GetWindowSize() *Vector2

	HasEnvironment(environment string) *bool

	HasTouchscreenUiHint() *bool

	HasVirtualKeyboard() *bool

	HideVirtualKeyboard()

	IsDebugBuild() *bool

	IsInLowProcessorUsageMode() *bool

	IsKeepScreenOn() *bool

	IsOkLeftAndCancelRight() *bool

	IsScancodeUnicode(code int64) *bool

	IsStdoutVerbose() *bool

	IsVsyncEnabled() *bool

	IsWindowFullscreen() *bool

	IsWindowMaximized() *bool

	IsWindowMinimized() *bool

	IsWindowResizable() *bool

	Kill(pid int64) int64

	NativeVideoIsPlaying() *bool

	NativeVideoPause()

	NativeVideoPlay(path string, volume float64, audioTrack string, subtitleTrack string) int64

	NativeVideoStop()

	NativeVideoUnpause()

	PrintAllResources(tofile string)

	PrintAllTexturesBySize()

	PrintResourcesByType(types *PoolStringArray)

	PrintResourcesInUse(short *bool)

	RequestAttention()

	SetBorderlessWindow(borderless *bool)

	SetClipboard(clipboard string)

	SetCurrentScreen(screen int64)

	SetExitCode(code int64)

	SetIcon(icon *Image)

	SetImePosition(position *Vector2)

	SetKeepScreenOn(enabled *bool)

	SetLowProcessorUsageMode(enable *bool)

	SetScreenOrientation(orientation int64)

	SetThreadName(name string) int64

	SetUseFileAccessSaveAndSwap(enabled *bool)

	SetUseVsync(enable *bool)

	SetWindowFullscreen(enabled *bool)

	SetWindowMaximized(enabled *bool)

	SetWindowMinimized(enabled *bool)

	SetWindowPosition(position *Vector2)

	SetWindowResizable(enabled *bool)

	SetWindowSize(size *Vector2)

	SetWindowTitle(title string)

	ShellOpen(uri string) int64

	ShowVirtualKeyboard(existingText string)
}

/*
        Base class for all non built-in types. Everything not a built-in type starts the inheritance chain from this class.
		Objects do not manage memory, if inheriting from one the object will most likely have to be deleted manually (call the [method free] function from the script or delete from C++).
		Some derivates add memory management, such as [Reference] (which keeps a reference count and deletes itself automatically when no longer referenced) and [Node], which deletes the children tree when deleted.
		Objects export properties, which are mainly useful for storage and editing, but not really so much in programming. Properties are exported in [method _get_property_list] and handled in [method _get] and [method _set]. However, scripting languages and C++ have simpler means to export them.
		Objects also receive notifications ([method _notification]). Notifications are a simple way to notify the object about simple events, so they can all be handled together.
*/
type Object struct {
	owner *C.godot_object
}

func (o *Object) baseClass() string {
	return "Object"
}

/*
   Return a property, return null if the property does not exist.
*/
func (o *Object) X_Get(property string) {
	log.Println("Calling Object.X_Get()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(property)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_get", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the property list, array of dictionaries, dictionaries must contain: name:String, type:int (see TYPE_* enum in [@Global Scope]) and optionally: hint:int (see PROPERTY_HINT_* in [@Global Scope]), hint_string:String, usage:int (see PROPERTY_USAGE_* in [@Global Scope]).
*/
func (o *Object) X_GetPropertyList() *Array {
	log.Println("Calling Object.X_GetPropertyList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_property_list", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *Object) X_Init() {
	log.Println("Calling Object.X_Init()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_init", goArguments, "")

	log.Println("Got return value!")

}

/*
   Notification request, the notification id is received.
*/
func (o *Object) X_Notification(what int64) {
	log.Println("Calling Object.X_Notification()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(what)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_notification", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set a property. Return true if the property was found.
*/
func (o *Object) X_Set(property string, value *Variant) *bool {
	log.Println("Calling Object.X_Set()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(property)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_set", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Add a user signal (can be added anytime). Arguments are optional, but can be added as an array of dictionaries, each containing "name" and "type" (from [@Global Scope] TYPE_*).
*/
func (o *Object) AddUserSignal(signal string, arguments *Array) {
	log.Println("Calling Object.AddUserSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(signal)
	goArguments[1] = reflect.ValueOf(arguments)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_user_signal", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Object) Call(method string) *Variant {
	log.Println("Calling Object.Call()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "call", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *Object) CallDeferred(method string) *Variant {
	log.Println("Calling Object.CallDeferred()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "call_deferred", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *Object) Callv(method string, argArray *Array) *Variant {
	log.Println("Calling Object.Callv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(method)
	goArguments[1] = reflect.ValueOf(argArray)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "callv", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Return true if this object can translate strings.
*/
func (o *Object) CanTranslateMessages() *bool {
	log.Println("Calling Object.CanTranslateMessages()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "can_translate_messages", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Connect a signal to a method at a target (member function). Binds are optional and are passed as extra arguments to the call. Flags specify optional deferred or one shot connections, see enum CONNECT_*. A signal can only be connected once to a method, and it will throw an error if already connected. If you want to avoid this, use [method is_connected] to check.
*/
func (o *Object) Connect(signal string, target *Object, method string, binds *Array, flags int64) int64 {
	log.Println("Calling Object.Connect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(signal)
	goArguments[1] = reflect.ValueOf(target)
	goArguments[2] = reflect.ValueOf(method)
	goArguments[3] = reflect.ValueOf(binds)
	goArguments[4] = reflect.ValueOf(flags)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "connect", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Disconnect a signal from a method.
*/
func (o *Object) Disconnect(signal string, target *Object, method string) {
	log.Println("Calling Object.Disconnect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(signal)
	goArguments[1] = reflect.ValueOf(target)
	goArguments[2] = reflect.ValueOf(method)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "disconnect", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Object) EmitSignal(signal string) *Variant {
	log.Println("Calling Object.EmitSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(signal)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "emit_signal", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *Object) Free() {
	log.Println("Calling Object.Free()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "free", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get a property from the object.
*/
func (o *Object) Get(property string) *Variant {
	log.Println("Calling Object.Get()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(property)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Return the class of the object as a string.
*/
func (o *Object) GetClass() string {
	log.Println("Calling Object.GetClass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_class", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
                Returns an [Array] of dictionaries with informations about signals that are connected to this object.
				Inside each [Dictionary] there are 3 fields:
				- "source" is a reference to signal emitter.
				- "signal_name" is name of connected signal.
				- "method_name" is a name of method to which signal is connected.
*/
func (o *Object) GetIncomingConnections() *Array {
	log.Println("Calling Object.GetIncomingConnections()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_incoming_connections", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Return the instance ID. All objects have a unique instance ID.
*/
func (o *Object) GetInstanceId() int64 {
	log.Println("Calling Object.GetInstanceId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_instance_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return a metadata from the object.
*/
func (o *Object) GetMeta(name string) *Variant {
	log.Println("Calling Object.GetMeta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_meta", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Return the list of metadata in the object.
*/
func (o *Object) GetMetaList() *PoolStringArray {
	log.Println("Calling Object.GetMetaList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_meta_list", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*

 */
func (o *Object) GetMethodList() *Array {
	log.Println("Calling Object.GetMethodList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_method_list", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Return the list of properties as an array of dictionaries, dictionaries contain: name:String, type:int (see TYPE_* enum in [@Global Scope]) and optionally: hint:int (see PROPERTY_HINT_* in [@Global Scope]), hint_string:String, usage:int (see PROPERTY_USAGE_* in [@Global Scope]).
*/
func (o *Object) GetPropertyList() *Array {
	log.Println("Calling Object.GetPropertyList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_property_list", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Return the object script (or null if it doesn't have one).
*/
func (o *Object) GetScript() *Reference {
	log.Println("Calling Object.GetScript()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_script", goArguments, "*Reference")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Reference)

	return returnValue

}

/*

 */
func (o *Object) GetSignalConnectionList(signal string) *Array {
	log.Println("Calling Object.GetSignalConnectionList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(signal)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_signal_connection_list", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Return the list of signals as an array of dictionaries.
*/
func (o *Object) GetSignalList() *Array {
	log.Println("Calling Object.GetSignalList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_signal_list", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Return true if a metadata is found with the requested name.
*/
func (o *Object) HasMeta(name string) *bool {
	log.Println("Calling Object.HasMeta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_meta", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Object) HasMethod(method string) *bool {
	log.Println("Calling Object.HasMethod()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_method", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Object) HasUserSignal(signal string) *bool {
	log.Println("Calling Object.HasUserSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(signal)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_user_signal", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if signal emission blocking is enabled.
*/
func (o *Object) IsBlockingSignals() *bool {
	log.Println("Calling Object.IsBlockingSignals()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_blocking_signals", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Check the class of the object against a string (including inheritance).
*/
func (o *Object) IsClass(aType string) *bool {
	log.Println("Calling Object.IsClass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_class", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if a connection exists for a given signal and target/method.
*/
func (o *Object) IsConnected(signal string, target *Object, method string) *bool {
	log.Println("Calling Object.IsConnected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(signal)
	goArguments[1] = reflect.ValueOf(target)
	goArguments[2] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_connected", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Object) IsQueuedForDeletion() *bool {
	log.Println("Calling Object.IsQueuedForDeletion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_queued_for_deletion", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Notify the object of something.
*/
func (o *Object) Notification(what int64, reversed *bool) {
	log.Println("Calling Object.Notification()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(what)
	goArguments[1] = reflect.ValueOf(reversed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "notification", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Object) PropertyListChangedNotify() {
	log.Println("Calling Object.PropertyListChangedNotify()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "property_list_changed_notify", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set property into the object.
*/
func (o *Object) Set(property string, value *Variant) {
	log.Println("Calling Object.Set()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(property)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set", goArguments, "")

	log.Println("Got return value!")

}

/*
   If set to true, signal emission is blocked.
*/
func (o *Object) SetBlockSignals(enable *bool) {
	log.Println("Calling Object.SetBlockSignals()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_block_signals", goArguments, "")

	log.Println("Got return value!")

}

/*
   Define whether this object can translate strings (with calls to [method tr]). Default is true.
*/
func (o *Object) SetMessageTranslation(enable *bool) {
	log.Println("Calling Object.SetMessageTranslation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_message_translation", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set a metadata into the object. Metadata is serialized. Metadata can be [i]anything[/i].
*/
func (o *Object) SetMeta(name string, value *Variant) {
	log.Println("Calling Object.SetMeta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_meta", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set a script into the object, scripts extend the object functionality.
*/
func (o *Object) SetScript(script *Reference) {
	log.Println("Calling Object.SetScript()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(script)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_script", goArguments, "")

	log.Println("Got return value!")

}

/*
   Translate a message. Only works if message translation is enabled (which it is by default). See [method set_message_translation].
*/
func (o *Object) Tr(message string) string {
	log.Println("Calling Object.Tr()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(message)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tr", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

// SetOwner will internally set the Godot object inside the struct.
// This is used to call parent methods.
func (o *Object) setOwner(object *C.godot_object) {
	o.owner = object
}

func (o *Object) getOwner() *C.godot_object {
	return o.owner
}

// callParentMethod will call this object's method with the given method name.
func (o *Object) callParentMethod(baseClass, methodName string, args []reflect.Value, returns string) reflect.Value {
	log.Println("Calling parent method!")

	// Convert the base class and method names to C strings.
	log.Println("  Using base class: ", baseClass)
	classCString := C.CString(baseClass)
	log.Println("  Using method name: ", methodName)
	methodCString := C.CString(methodName)

	// Get the Godot method bind pointer so we can pass it to godot_method_bind_ptrcall.
	log.Println("  Using godot object:", o.owner)
	var methodBind *C.godot_method_bind
	methodBind = C.godot_method_bind_get_method(classCString, methodCString)
	log.Println("  Using method bind pointer: ", methodBind)

	// Loop through the given arguments and see what type they are. When we know what
	// type it is, we need to convert them to the correct godot objects.
	// TODO: Probably pull this out into its own function?
	variantArgs := []unsafe.Pointer{}
	for _, arg := range args {
		log.Println("  Argument type: ", arg.Type().String())

		// Look up our conversion function in our map of conversion functions
		// based on the Go type. This is essentially a more optimal case/switch
		// statement on the type of Go object, so we can know how to convert it
		// to a Godot object.
		if convert, ok := goToGodotConversionMap[arg.Type().String()]; ok {
			argValue := convert(arg.Interface())
			variantArgs = append(variantArgs, argValue)
		} else {
			log.Fatal("Unknown type of argument value")
		}
	}
	log.Println("  Built variant arguments: ", variantArgs)

	// Construct a C array that will contain pointers to our arguments.
	log.Println("  Allocating argument array in C.")
	cArgsArray := C.build_array(C.int(len(variantArgs)))
	log.Println("    C Array: ", cArgsArray)

	// Loop through and add each argument to our C args array.
	for i, arg := range variantArgs {
		C.add_element(cArgsArray, arg, C.int(i))
	}
	log.Println("  Built argument array from variant arguments: ", cArgsArray)

	// Construct our return object that will be populated by the method call.
	// TODO: We need to have the return type passed to us so we know how to convert
	// the return value to its correct type.
	log.Println("  Building return value.")
	var ret unsafe.Pointer
	switch returns {
	case "string":
		ret = unsafe.Pointer(C.CString(""))
	case "Node":
		// Create a pointer to a pointer to a godot_object
		var gdObject *C.godot_object
		ret = unsafe.Pointer(gdObject)
	default:
		log.Fatal("Unknown return type specified.")
	}

	// Call the parent method. "ret" will be populated with the return value.
	log.Println("  Calling bind_ptrcall...")
	C.godot_method_bind_ptrcall(
		methodBind,
		unsafe.Pointer(o.owner),
		cArgsArray, // void**
		ret,        // void*
	)
	log.Println("  Finished calling method")

	// Convert the return value based on the type.
	var retValue reflect.Value
	switch returns {
	case "string":
		gdString := (*C.godot_string)(ret)
		retValue = reflect.ValueOf(C.GoString(C.godot_string_c_str(gdString)))
		//case "Node":
		//	// TODO: We might be able to optimize this better.
		//	gdObject := (*C.godot_object)(ret)
		//	nodeObject := &Node{
		//		Object: Object{
		//			owner: gdObject,
		//		},
		//	}

		//	// Find out exactly what type of Node object this is. It's possible
		//	// that it is actually a child class of Node that we need to downcast to.
		//	typeValue := nodeObject.callParentMethod("Object", "get_type", []reflect.Value{}, "string")
		//	objectType := typeValue.Interface().(string)

		//	switch objectType {
		//	case "Node":
		//		retValue = reflect.ValueOf(nodeObject)
		//	default:
		//		log.Fatal("Unhandled type of object found when trying to downcast Node into its child type: ", objectType)
		//	}

		//	// TODO: We need to look up and see if this instance already exists in our instance registry.
	}

	// Return the converted variant.
	return retValue
}

/*
        ObjectImplementer is an interface for Object objects.
        Base class for all non built-in types. Everything not a built-in type starts the inheritance chain from this class.
		Objects do not manage memory, if inheriting from one the object will most likely have to be deleted manually (call the [method free] function from the script or delete from C++).
		Some derivates add memory management, such as [Reference] (which keeps a reference count and deletes itself automatically when no longer referenced) and [Node], which deletes the children tree when deleted.
		Objects export properties, which are mainly useful for storage and editing, but not really so much in programming. Properties are exported in [method _get_property_list] and handled in [method _get] and [method _set]. However, scripting languages and C++ have simpler means to export them.
		Objects also receive notifications ([method _notification]). Notifications are a simple way to notify the object about simple events, so they can all be handled together.
*/
type ObjectImplementer interface {
	Class

	X_Get(property string)

	X_GetPropertyList() *Array

	X_Init()

	X_Notification(what int64)

	X_Set(property string, value *Variant) *bool

	AddUserSignal(signal string, arguments *Array)

	Call(method string) *Variant

	CallDeferred(method string) *Variant

	Callv(method string, argArray *Array) *Variant

	CanTranslateMessages() *bool

	Connect(signal string, target *Object, method string, binds *Array, flags int64) int64

	Disconnect(signal string, target *Object, method string)

	EmitSignal(signal string) *Variant

	Free()

	Get(property string) *Variant

	GetClass() string

	GetIncomingConnections() *Array

	GetInstanceId() int64

	GetMeta(name string) *Variant

	GetMetaList() *PoolStringArray

	GetMethodList() *Array

	GetPropertyList() *Array

	GetScript() *Reference

	GetSignalConnectionList(signal string) *Array

	GetSignalList() *Array

	HasMeta(name string) *bool

	HasMethod(method string) *bool

	HasUserSignal(signal string) *bool

	IsBlockingSignals() *bool

	IsClass(aType string) *bool

	IsConnected(signal string, target *Object, method string) *bool

	IsQueuedForDeletion() *bool

	Notification(what int64, reversed *bool)

	PropertyListChangedNotify()

	Set(property string, value *Variant)

	SetBlockSignals(enable *bool)

	SetMessageTranslation(enable *bool)

	SetMeta(name string, value *Variant)

	SetScript(script *Reference)

	Tr(message string) string
}

/*

 */
type OccluderPolygon2D struct {
	Resource
}

func (o *OccluderPolygon2D) baseClass() string {
	return "OccluderPolygon2D"
}

/*

 */
func (o *OccluderPolygon2D) GetCullMode() int64 {
	log.Println("Calling OccluderPolygon2D.GetCullMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cull_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *OccluderPolygon2D) GetPolygon() *PoolVector2Array {
	log.Println("Calling OccluderPolygon2D.GetPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_polygon", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*

 */
func (o *OccluderPolygon2D) IsClosed() *bool {
	log.Println("Calling OccluderPolygon2D.IsClosed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_closed", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *OccluderPolygon2D) SetClosed(closed *bool) {
	log.Println("Calling OccluderPolygon2D.SetClosed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(closed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_closed", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *OccluderPolygon2D) SetCullMode(cullMode int64) {
	log.Println("Calling OccluderPolygon2D.SetCullMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(cullMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cull_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *OccluderPolygon2D) SetPolygon(polygon *PoolVector2Array) {
	log.Println("Calling OccluderPolygon2D.SetPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(polygon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_polygon", goArguments, "")

	log.Println("Got return value!")

}

/*
   OccluderPolygon2DImplementer is an interface for OccluderPolygon2D objects.

*/
type OccluderPolygon2DImplementer interface {
	ResourceImplementer

	GetCullMode() int64

	GetPolygon() *PoolVector2Array

	IsClosed() *bool

	SetClosed(closed *bool)

	SetCullMode(cullMode int64)

	SetPolygon(polygon *PoolVector2Array)
}

/*
   An OmniDirectional light is a type of [Light] node that emits lights in all directions. The light is attenuated through the distance and this attenuation can be configured by changing the energy, radius and attenuation parameters of [Light].
*/
type OmniLight struct {
	Light
}

func (o *OmniLight) baseClass() string {
	return "OmniLight"
}

/*

 */
func (o *OmniLight) GetShadowDetail() int64 {
	log.Println("Calling OmniLight.GetShadowDetail()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shadow_detail", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *OmniLight) GetShadowMode() int64 {
	log.Println("Calling OmniLight.GetShadowMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shadow_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *OmniLight) SetShadowDetail(detail int64) {
	log.Println("Calling OmniLight.SetShadowDetail()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(detail)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_detail", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *OmniLight) SetShadowMode(mode int64) {
	log.Println("Calling OmniLight.SetShadowMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   OmniLightImplementer is an interface for OmniLight objects.
   An OmniDirectional light is a type of [Light] node that emits lights in all directions. The light is attenuated through the distance and this attenuation can be configured by changing the energy, radius and attenuation parameters of [Light].
*/
type OmniLightImplementer interface {
	LightImplementer

	GetShadowDetail() int64

	GetShadowMode() int64

	SetShadowDetail(detail int64)

	SetShadowMode(mode int64)
}

/*
   OptionButton is a type button that provides a selectable list of items when pressed. The item selected becomes the "current" item and is displayed as the button text.
*/
type OptionButton struct {
	Button
}

func (o *OptionButton) baseClass() string {
	return "OptionButton"
}

/*
   Add an item, with a "texture" icon, text "label" and (optionally) id. If no "id" is passed, "id" becomes the item index. New items are appended at the end.
*/
func (o *OptionButton) AddIconItem(texture *Texture, label string, id int64) {
	log.Println("Calling OptionButton.AddIconItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(texture)
	goArguments[1] = reflect.ValueOf(label)
	goArguments[2] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_icon_item", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add an item, with text "label" and (optionally) id. If no "id" is passed, "id" becomes the item index. New items are appended at the end.
*/
func (o *OptionButton) AddItem(label string, id int64) {
	log.Println("Calling OptionButton.AddItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(label)
	goArguments[1] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_item", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a separator to the list of items. Separators help to group items. Separator also takes up an index and is appended at the end.
*/
func (o *OptionButton) AddSeparator() {
	log.Println("Calling OptionButton.AddSeparator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_separator", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear all the items in the [OptionButton].
*/
func (o *OptionButton) Clear() {
	log.Println("Calling OptionButton.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the amount of items in the OptionButton.
*/
func (o *OptionButton) GetItemCount() int64 {
	log.Println("Calling OptionButton.GetItemCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the icon of the item at index "idx".
*/
func (o *OptionButton) GetItemIcon(idx int64) *Texture {
	log.Println("Calling OptionButton.GetItemIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_icon", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   Return the ID of the item at index "idx".
*/
func (o *OptionButton) GetItemId(idx int64) int64 {
	log.Println("Calling OptionButton.GetItemId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *OptionButton) GetItemMetadata(idx int64) *Variant {
	log.Println("Calling OptionButton.GetItemMetadata()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_metadata", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Return the text of the item at index "idx".
*/
func (o *OptionButton) GetItemText(idx int64) string {
	log.Println("Calling OptionButton.GetItemText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the current item index
*/
func (o *OptionButton) GetSelected() int64 {
	log.Println("Calling OptionButton.GetSelected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_selected", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *OptionButton) GetSelectedId() int64 {
	log.Println("Calling OptionButton.GetSelectedId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_selected_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *OptionButton) GetSelectedMetadata() *Variant {
	log.Println("Calling OptionButton.GetSelectedMetadata()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_selected_metadata", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *OptionButton) IsItemDisabled(idx int64) *bool {
	log.Println("Calling OptionButton.IsItemDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_item_disabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *OptionButton) RemoveItem(idx int64) {
	log.Println("Calling OptionButton.RemoveItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_item", goArguments, "")

	log.Println("Got return value!")

}

/*
   Select an item by index and make it the current item.
*/
func (o *OptionButton) Select(idx int64) {
	log.Println("Calling OptionButton.Select()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "select", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *OptionButton) SetItemDisabled(idx int64, disabled *bool) {
	log.Println("Calling OptionButton.SetItemDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(disabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_disabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the icon of an item at index "idx".
*/
func (o *OptionButton) SetItemIcon(idx int64, texture *Texture) {
	log.Println("Calling OptionButton.SetItemIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_icon", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the ID of an item at index "idx".
*/
func (o *OptionButton) SetItemId(idx int64, id int64) {
	log.Println("Calling OptionButton.SetItemId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_id", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *OptionButton) SetItemMetadata(idx int64, metadata *Variant) {
	log.Println("Calling OptionButton.SetItemMetadata()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(metadata)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_metadata", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the text of an item at index "idx".
*/
func (o *OptionButton) SetItemText(idx int64, text string) {
	log.Println("Calling OptionButton.SetItemText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_text", goArguments, "")

	log.Println("Got return value!")

}

/*
   OptionButtonImplementer is an interface for OptionButton objects.
   OptionButton is a type button that provides a selectable list of items when pressed. The item selected becomes the "current" item and is displayed as the button text.
*/
type OptionButtonImplementer interface {
	ButtonImplementer

	AddIconItem(texture *Texture, label string, id int64)

	AddItem(label string, id int64)

	AddSeparator()

	Clear()

	GetItemCount() int64

	GetItemIcon(idx int64) *Texture

	GetItemId(idx int64) int64

	GetItemMetadata(idx int64) *Variant

	GetItemText(idx int64) string

	GetSelected() int64

	GetSelectedId() int64

	GetSelectedMetadata() *Variant

	IsItemDisabled(idx int64) *bool

	RemoveItem(idx int64)

	Select(idx int64)

	SetItemDisabled(idx int64, disabled *bool)

	SetItemIcon(idx int64, texture *Texture)

	SetItemId(idx int64, id int64)

	SetItemMetadata(idx int64, metadata *Variant)

	SetItemText(idx int64, text string)
}

/*

 */
type PCKPacker struct {
	Reference
}

func (o *PCKPacker) baseClass() string {
	return "PCKPacker"
}

/*

 */
func (o *PCKPacker) AddFile(pckPath string, sourcePath string) int64 {
	log.Println("Calling PCKPacker.AddFile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(pckPath)
	goArguments[1] = reflect.ValueOf(sourcePath)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "add_file", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PCKPacker) Flush(verbose *bool) int64 {
	log.Println("Calling PCKPacker.Flush()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(verbose)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "flush", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PCKPacker) PckStart(pckName string, alignment int64) int64 {
	log.Println("Calling PCKPacker.PckStart()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(pckName)
	goArguments[1] = reflect.ValueOf(alignment)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "pck_start", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   PCKPackerImplementer is an interface for PCKPacker objects.

*/
type PCKPackerImplementer interface {
	ReferenceImplementer

	AddFile(pckPath string, sourcePath string) int64

	Flush(verbose *bool) int64

	PckStart(pckName string, alignment int64) int64
}

/*
   Optimized translation. Uses real-time compressed translations, which results in very small dictionaries.
*/
type PHashTranslation struct {
	Translation
}

func (o *PHashTranslation) baseClass() string {
	return "PHashTranslation"
}

/*

 */
func (o *PHashTranslation) Generate(from *Translation) {
	log.Println("Calling PHashTranslation.Generate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(from)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "generate", goArguments, "")

	log.Println("Got return value!")

}

/*
   PHashTranslationImplementer is an interface for PHashTranslation objects.
   Optimized translation. Uses real-time compressed translations, which results in very small dictionaries.
*/
type PHashTranslationImplementer interface {
	TranslationImplementer

	Generate(from *Translation)
}

/*

 */
type PackedDataContainer struct {
	Resource
}

func (o *PackedDataContainer) baseClass() string {
	return "PackedDataContainer"
}

/*

 */
func (o *PackedDataContainer) Pack(value *Variant) int64 {
	log.Println("Calling PackedDataContainer.Pack()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(value)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "pack", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PackedDataContainer) Size() int64 {
	log.Println("Calling PackedDataContainer.Size()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   PackedDataContainerImplementer is an interface for PackedDataContainer objects.

*/
type PackedDataContainerImplementer interface {
	ResourceImplementer

	Pack(value *Variant) int64

	Size() int64
}

/*

 */
type PackedDataContainerRef struct {
	Reference
}

func (o *PackedDataContainerRef) baseClass() string {
	return "PackedDataContainerRef"
}

/*

 */
func (o *PackedDataContainerRef) Size() int64 {
	log.Println("Calling PackedDataContainerRef.Size()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   PackedDataContainerRefImplementer is an interface for PackedDataContainerRef objects.

*/
type PackedDataContainerRefImplementer interface {
	ReferenceImplementer

	Size() int64
}

/*
   TODO: explain ownership, and that node does not need to own itself
*/
type PackedScene struct {
	Resource
}

func (o *PackedScene) baseClass() string {
	return "PackedScene"
}

/*

 */
func (o *PackedScene) CanInstance() *bool {
	log.Println("Calling PackedScene.CanInstance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "can_instance", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *PackedScene) GetState() *SceneState {
	log.Println("Calling PackedScene.GetState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_state", goArguments, "*SceneState")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*SceneState)

	return returnValue

}

/*

 */
func (o *PackedScene) Instance(editState int64) *Node {
	log.Println("Calling PackedScene.Instance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(editState)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "instance", goArguments, "*Node")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Node)

	return returnValue

}

/*
   Pack will ignore any sub-nodes not owned by given node. See [method Node.set_owner].
*/
func (o *PackedScene) Pack(path *Node) int64 {
	log.Println("Calling PackedScene.Pack()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "pack", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   PackedSceneImplementer is an interface for PackedScene objects.
   TODO: explain ownership, and that node does not need to own itself
*/
type PackedSceneImplementer interface {
	ResourceImplementer

	CanInstance() *bool

	GetState() *SceneState

	Instance(editState int64) *Node

	Pack(path *Node) int64
}

/*
   PacketPeer is an abstraction and base class for packet-based protocols (such as UDP). It provides an API for sending and receiving packets both as raw data or variables. This makes it easy to transfer data over a protocol, without having to encode data as low level bytes or having to worry about network ordering.
*/
type PacketPeer struct {
	Reference
}

func (o *PacketPeer) baseClass() string {
	return "PacketPeer"
}

/*
   Return the number of packets currently available in the ring-buffer.
*/
func (o *PacketPeer) GetAvailablePacketCount() int64 {
	log.Println("Calling PacketPeer.GetAvailablePacketCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_available_packet_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get a raw packet.
*/
func (o *PacketPeer) GetPacket() *PoolByteArray {
	log.Println("Calling PacketPeer.GetPacket()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_packet", goArguments, "*PoolByteArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolByteArray)

	return returnValue

}

/*
   Return the error state of the last packet received (via [method get_packet] and [method get_var]).
*/
func (o *PacketPeer) GetPacketError() int64 {
	log.Println("Calling PacketPeer.GetPacketError()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_packet_error", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get a Variant.
*/
func (o *PacketPeer) GetVar() *Variant {
	log.Println("Calling PacketPeer.GetVar()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_var", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *PacketPeer) IsObjectDecodingAllowed() *bool {
	log.Println("Calling PacketPeer.IsObjectDecodingAllowed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_object_decoding_allowed", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Send a raw packet.
*/
func (o *PacketPeer) PutPacket(buffer *PoolByteArray) int64 {
	log.Println("Calling PacketPeer.PutPacket()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(buffer)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "put_packet", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Send a Variant as a packet.
*/
func (o *PacketPeer) PutVar(variable *Variant) int64 {
	log.Println("Calling PacketPeer.PutVar()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(variable)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "put_var", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PacketPeer) SetAllowObjectDecoding(enable *bool) {
	log.Println("Calling PacketPeer.SetAllowObjectDecoding()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_allow_object_decoding", goArguments, "")

	log.Println("Got return value!")

}

/*
   PacketPeerImplementer is an interface for PacketPeer objects.
   PacketPeer is an abstraction and base class for packet-based protocols (such as UDP). It provides an API for sending and receiving packets both as raw data or variables. This makes it easy to transfer data over a protocol, without having to encode data as low level bytes or having to worry about network ordering.
*/
type PacketPeerImplementer interface {
	ReferenceImplementer

	GetAvailablePacketCount() int64

	GetPacket() *PoolByteArray

	GetPacketError() int64

	GetVar() *Variant

	IsObjectDecodingAllowed() *bool

	PutPacket(buffer *PoolByteArray) int64

	PutVar(variable *Variant) int64

	SetAllowObjectDecoding(enable *bool)
}

/*
   PacketStreamPeer provides a wrapper for working using packets over a stream. This allows for using packet based code with StreamPeers. PacketPeerStream implements a custom protocol over the StreamPeer, so the user should not read or write to the wrapped StreamPeer directly.
*/
type PacketPeerStream struct {
	PacketPeer
}

func (o *PacketPeerStream) baseClass() string {
	return "PacketPeerStream"
}

/*

 */
func (o *PacketPeerStream) GetInputBufferMaxSize() int64 {
	log.Println("Calling PacketPeerStream.GetInputBufferMaxSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_input_buffer_max_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PacketPeerStream) GetOutputBufferMaxSize() int64 {
	log.Println("Calling PacketPeerStream.GetOutputBufferMaxSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_output_buffer_max_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PacketPeerStream) SetInputBufferMaxSize(maxSizeBytes int64) {
	log.Println("Calling PacketPeerStream.SetInputBufferMaxSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(maxSizeBytes)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_input_buffer_max_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PacketPeerStream) SetOutputBufferMaxSize(maxSizeBytes int64) {
	log.Println("Calling PacketPeerStream.SetOutputBufferMaxSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(maxSizeBytes)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_output_buffer_max_size", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the [StreamPeer] object to be wrapped.
*/
func (o *PacketPeerStream) SetStreamPeer(peer *Reference) {
	log.Println("Calling PacketPeerStream.SetStreamPeer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(peer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_stream_peer", goArguments, "")

	log.Println("Got return value!")

}

/*
   PacketPeerStreamImplementer is an interface for PacketPeerStream objects.
   PacketStreamPeer provides a wrapper for working using packets over a stream. This allows for using packet based code with StreamPeers. PacketPeerStream implements a custom protocol over the StreamPeer, so the user should not read or write to the wrapped StreamPeer directly.
*/
type PacketPeerStreamImplementer interface {
	PacketPeerImplementer

	GetInputBufferMaxSize() int64

	GetOutputBufferMaxSize() int64

	SetInputBufferMaxSize(maxSizeBytes int64)

	SetOutputBufferMaxSize(maxSizeBytes int64)

	SetStreamPeer(peer *Reference)
}

/*
   UDP packet peer. Can be used to send raw UDP packets as well as [Variant]\ s.
*/
type PacketPeerUDP struct {
	PacketPeer
}

func (o *PacketPeerUDP) baseClass() string {
	return "PacketPeerUDP"
}

/*
   Close the UDP socket the [PacketPeerUDP] is currently listening on.
*/
func (o *PacketPeerUDP) Close() {
	log.Println("Calling PacketPeerUDP.Close()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "close", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the IP of the remote peer that sent the last packet(that was received with [method get_packet] or [method get_var]).
*/
func (o *PacketPeerUDP) GetPacketIp() string {
	log.Println("Calling PacketPeerUDP.GetPacketIp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_packet_ip", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the port of the remote peer that sent the last packet(that was received with [method get_packet] or [method get_var]).
*/
func (o *PacketPeerUDP) GetPacketPort() int64 {
	log.Println("Calling PacketPeerUDP.GetPacketPort()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_packet_port", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return whether this [PacketPeerUDP] is listening.
*/
func (o *PacketPeerUDP) IsListening() *bool {
	log.Println("Calling PacketPeerUDP.IsListening()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_listening", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
                Make this [PacketPeerUDP] listen on the "port" binding to "bind_address" with a buffer size "recv_buf_size".
				If "bind_address" is set as "*" (default), the peer will listen on all available addresses (both IPv4 and IPv6).
				If "bind_address" is set as "0.0.0.0" (for IPv4) or "::" (for IPv6), the peer will listen on all available addresses matching that IP type.
				If "bind_address" is set to any valid address (e.g. "192.168.1.101", "::1", etc), the peer will only listen on the interface with that addresses (or fail if no interface with the given address exists).
*/
func (o *PacketPeerUDP) Listen(port int64, bindAddress string, recvBufSize int64) int64 {
	log.Println("Calling PacketPeerUDP.Listen()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(port)
	goArguments[1] = reflect.ValueOf(bindAddress)
	goArguments[2] = reflect.ValueOf(recvBufSize)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "listen", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the destination address and port for sending packets and variables, a hostname will be resolved using if valid.
*/
func (o *PacketPeerUDP) SetDestAddress(host string, port int64) int64 {
	log.Println("Calling PacketPeerUDP.SetDestAddress()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(host)
	goArguments[1] = reflect.ValueOf(port)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "set_dest_address", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Wait for a packet to arrive on the listening port, see [method listen].
*/
func (o *PacketPeerUDP) Wait() int64 {
	log.Println("Calling PacketPeerUDP.Wait()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "wait", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   PacketPeerUDPImplementer is an interface for PacketPeerUDP objects.
   UDP packet peer. Can be used to send raw UDP packets as well as [Variant]\ s.
*/
type PacketPeerUDPImplementer interface {
	PacketPeerImplementer

	Close()

	GetPacketIp() string

	GetPacketPort() int64

	IsListening() *bool

	Listen(port int64, bindAddress string, recvBufSize int64) int64

	SetDestAddress(host string, port int64) int64

	Wait() int64
}

/*
   Panel is a [Control] that displays an opaque background. It's commonly used as a parent and container for other types of [Control] nodes.
*/
type Panel struct {
	Control
}

func (o *Panel) baseClass() string {
	return "Panel"
}

/*
   PanelImplementer is an interface for Panel objects.
   Panel is a [Control] that displays an opaque background. It's commonly used as a parent and container for other types of [Control] nodes.
*/
type PanelImplementer interface {
	ControlImplementer
}

/*
   Panel container type. This container fits controls inside of the delimited area of a stylebox. It's useful for giving controls an outline.
*/
type PanelContainer struct {
	Container
}

func (o *PanelContainer) baseClass() string {
	return "PanelContainer"
}

/*
   PanelContainerImplementer is an interface for PanelContainer objects.
   Panel container type. This container fits controls inside of the delimited area of a stylebox. It's useful for giving controls an outline.
*/
type PanelContainerImplementer interface {
	ContainerImplementer
}

/*

 */
type PanoramaSky struct {
	Sky
}

func (o *PanoramaSky) baseClass() string {
	return "PanoramaSky"
}

/*

 */
func (o *PanoramaSky) GetPanorama() *Texture {
	log.Println("Calling PanoramaSky.GetPanorama()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_panorama", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *PanoramaSky) SetPanorama(texture *Texture) {
	log.Println("Calling PanoramaSky.SetPanorama()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_panorama", goArguments, "")

	log.Println("Got return value!")

}

/*
   PanoramaSkyImplementer is an interface for PanoramaSky objects.

*/
type PanoramaSkyImplementer interface {
	SkyImplementer

	GetPanorama() *Texture

	SetPanorama(texture *Texture)
}

/*
   A ParallaxBackground will use one or more [ParallaxLayer] nodes to create a parallax scrolling background. Each [ParallaxLayer] can be set to move at different speeds relative to the camera movement, this can be used to create an illusion of depth in a 2D game.
*/
type ParallaxBackground struct {
	CanvasLayer
}

func (o *ParallaxBackground) baseClass() string {
	return "ParallaxBackground"
}

/*
   Return the beginning limit.
*/
func (o *ParallaxBackground) GetLimitBegin() *Vector2 {
	log.Println("Calling ParallaxBackground.GetLimitBegin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_limit_begin", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the ending limit.
*/
func (o *ParallaxBackground) GetLimitEnd() *Vector2 {
	log.Println("Calling ParallaxBackground.GetLimitEnd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_limit_end", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the base offset.
*/
func (o *ParallaxBackground) GetScrollBaseOffset() *Vector2 {
	log.Println("Calling ParallaxBackground.GetScrollBaseOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scroll_base_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the base motion scale.
*/
func (o *ParallaxBackground) GetScrollBaseScale() *Vector2 {
	log.Println("Calling ParallaxBackground.GetScrollBaseScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scroll_base_scale", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *ParallaxBackground) GetScrollOffset() *Vector2 {
	log.Println("Calling ParallaxBackground.GetScrollOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scroll_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return ignoring camera zoom.
*/
func (o *ParallaxBackground) IsIgnoreCameraZoom() *bool {
	log.Println("Calling ParallaxBackground.IsIgnoreCameraZoom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_ignore_camera_zoom", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Set to true for all child [ParallaxLayer] nodes to not be affected by the zoom level of the camera.
*/
func (o *ParallaxBackground) SetIgnoreCameraZoom(ignore *bool) {
	log.Println("Calling ParallaxBackground.SetIgnoreCameraZoom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ignore)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ignore_camera_zoom", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the left and top limits in pixels for scrolling to begin. If the camera is outside of this limit the background will not continue to scroll. If an axis is greater than or equal to the corresponding axis of limit_end, then it will not limit scrolling for that axis.
*/
func (o *ParallaxBackground) SetLimitBegin(ofs *Vector2) {
	log.Println("Calling ParallaxBackground.SetLimitBegin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ofs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_limit_begin", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the right and bottom limits in pixels for scrolling to end. If the camera is outside of this limit the background will not continue to scroll. If an axis is less than or equal to the corresponding axis of limit_begin, then it will not limit scrolling for that axis.
*/
func (o *ParallaxBackground) SetLimitEnd(ofs *Vector2) {
	log.Println("Calling ParallaxBackground.SetLimitEnd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ofs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_limit_end", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the base offset in pixels of all children [ParallaxLayer] nodes.
*/
func (o *ParallaxBackground) SetScrollBaseOffset(ofs *Vector2) {
	log.Println("Calling ParallaxBackground.SetScrollBaseOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ofs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_scroll_base_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the base motion scale of all children [ParallaxLayer] nodes.
*/
func (o *ParallaxBackground) SetScrollBaseScale(scale *Vector2) {
	log.Println("Calling ParallaxBackground.SetScrollBaseScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_scroll_base_scale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParallaxBackground) SetScrollOffset(ofs *Vector2) {
	log.Println("Calling ParallaxBackground.SetScrollOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ofs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_scroll_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   ParallaxBackgroundImplementer is an interface for ParallaxBackground objects.
   A ParallaxBackground will use one or more [ParallaxLayer] nodes to create a parallax scrolling background. Each [ParallaxLayer] can be set to move at different speeds relative to the camera movement, this can be used to create an illusion of depth in a 2D game.
*/
type ParallaxBackgroundImplementer interface {
	CanvasLayerImplementer

	GetLimitBegin() *Vector2

	GetLimitEnd() *Vector2

	GetScrollBaseOffset() *Vector2

	GetScrollBaseScale() *Vector2

	GetScrollOffset() *Vector2

	IsIgnoreCameraZoom() *bool

	SetIgnoreCameraZoom(ignore *bool)

	SetLimitBegin(ofs *Vector2)

	SetLimitEnd(ofs *Vector2)

	SetScrollBaseOffset(ofs *Vector2)

	SetScrollBaseScale(scale *Vector2)

	SetScrollOffset(ofs *Vector2)
}

/*
   A ParallaxLayer must be the child of a [ParallaxBackground] node. All child nodes will be affected by the parallax scrolling of this layer.
*/
type ParallaxLayer struct {
	Node2D
}

func (o *ParallaxLayer) baseClass() string {
	return "ParallaxLayer"
}

/*
   Return the mirroring of the ParallaxLayer.
*/
func (o *ParallaxLayer) GetMirroring() *Vector2 {
	log.Println("Calling ParallaxLayer.GetMirroring()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mirroring", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *ParallaxLayer) GetMotionOffset() *Vector2 {
	log.Println("Calling ParallaxLayer.GetMotionOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_motion_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the motion scale of the ParallaxLayer.
*/
func (o *ParallaxLayer) GetMotionScale() *Vector2 {
	log.Println("Calling ParallaxLayer.GetMotionScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_motion_scale", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Set the mirroring of the ParallaxLayer. If an axis is set to 0 then that axis will have no mirroring.
*/
func (o *ParallaxLayer) SetMirroring(mirror *Vector2) {
	log.Println("Calling ParallaxLayer.SetMirroring()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mirror)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mirroring", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParallaxLayer) SetMotionOffset(offset *Vector2) {
	log.Println("Calling ParallaxLayer.SetMotionOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_motion_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the motion scale of the ParallaxLayer. If an axis is set to 0 then it will not move at all, it will stick with the camera.
*/
func (o *ParallaxLayer) SetMotionScale(scale *Vector2) {
	log.Println("Calling ParallaxLayer.SetMotionScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_motion_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   ParallaxLayerImplementer is an interface for ParallaxLayer objects.
   A ParallaxLayer must be the child of a [ParallaxBackground] node. All child nodes will be affected by the parallax scrolling of this layer.
*/
type ParallaxLayerImplementer interface {
	Node2DImplementer

	GetMirroring() *Vector2

	GetMotionOffset() *Vector2

	GetMotionScale() *Vector2

	SetMirroring(mirror *Vector2)

	SetMotionOffset(offset *Vector2)

	SetMotionScale(scale *Vector2)
}

/*

 */
type Particles struct {
	GeometryInstance
}

func (o *Particles) baseClass() string {
	return "Particles"
}

/*

 */
func (o *Particles) CaptureAabb() *Rect3 {
	log.Println("Calling Particles.CaptureAabb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "capture_aabb", goArguments, "*Rect3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect3)

	return returnValue

}

/*

 */
func (o *Particles) GetAmount() int64 {
	log.Println("Calling Particles.GetAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_amount", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Particles) GetDrawOrder() int64 {
	log.Println("Calling Particles.GetDrawOrder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_draw_order", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Particles) GetDrawPassMesh(pass int64) *Mesh {
	log.Println("Calling Particles.GetDrawPassMesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pass)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_draw_pass_mesh", goArguments, "*Mesh")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Mesh)

	return returnValue

}

/*

 */
func (o *Particles) GetDrawPasses() int64 {
	log.Println("Calling Particles.GetDrawPasses()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_draw_passes", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Particles) GetExplosivenessRatio() float64 {
	log.Println("Calling Particles.GetExplosivenessRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_explosiveness_ratio", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Particles) GetFixedFps() int64 {
	log.Println("Calling Particles.GetFixedFps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fixed_fps", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Particles) GetFractionalDelta() *bool {
	log.Println("Calling Particles.GetFractionalDelta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fractional_delta", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Particles) GetLifetime() float64 {
	log.Println("Calling Particles.GetLifetime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_lifetime", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Particles) GetOneShot() *bool {
	log.Println("Calling Particles.GetOneShot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_one_shot", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Particles) GetPreProcessTime() float64 {
	log.Println("Calling Particles.GetPreProcessTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pre_process_time", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Particles) GetProcessMaterial() *Material {
	log.Println("Calling Particles.GetProcessMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_process_material", goArguments, "*Material")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Material)

	return returnValue

}

/*

 */
func (o *Particles) GetRandomnessRatio() float64 {
	log.Println("Calling Particles.GetRandomnessRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_randomness_ratio", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Particles) GetSpeedScale() float64 {
	log.Println("Calling Particles.GetSpeedScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_speed_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Particles) GetUseLocalCoordinates() *bool {
	log.Println("Calling Particles.GetUseLocalCoordinates()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_use_local_coordinates", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Particles) GetVisibilityAabb() *Rect3 {
	log.Println("Calling Particles.GetVisibilityAabb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_visibility_aabb", goArguments, "*Rect3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect3)

	return returnValue

}

/*

 */
func (o *Particles) IsEmitting() *bool {
	log.Println("Calling Particles.IsEmitting()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_emitting", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Particles) Restart() {
	log.Println("Calling Particles.Restart()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "restart", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) SetAmount(amount int64) {
	log.Println("Calling Particles.SetAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_amount", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) SetDrawOrder(order int64) {
	log.Println("Calling Particles.SetDrawOrder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(order)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_draw_order", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) SetDrawPassMesh(pass int64, mesh *Mesh) {
	log.Println("Calling Particles.SetDrawPassMesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(pass)
	goArguments[1] = reflect.ValueOf(mesh)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_draw_pass_mesh", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) SetDrawPasses(passes int64) {
	log.Println("Calling Particles.SetDrawPasses()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(passes)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_draw_passes", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) SetEmitting(emitting *bool) {
	log.Println("Calling Particles.SetEmitting()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(emitting)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_emitting", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) SetExplosivenessRatio(ratio float64) {
	log.Println("Calling Particles.SetExplosivenessRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ratio)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_explosiveness_ratio", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) SetFixedFps(fps int64) {
	log.Println("Calling Particles.SetFixedFps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(fps)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fixed_fps", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) SetFractionalDelta(enable *bool) {
	log.Println("Calling Particles.SetFractionalDelta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fractional_delta", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) SetLifetime(secs float64) {
	log.Println("Calling Particles.SetLifetime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(secs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_lifetime", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) SetOneShot(enable *bool) {
	log.Println("Calling Particles.SetOneShot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_one_shot", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) SetPreProcessTime(secs float64) {
	log.Println("Calling Particles.SetPreProcessTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(secs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pre_process_time", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) SetProcessMaterial(material *Material) {
	log.Println("Calling Particles.SetProcessMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(material)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_process_material", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) SetRandomnessRatio(ratio float64) {
	log.Println("Calling Particles.SetRandomnessRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ratio)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_randomness_ratio", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) SetSpeedScale(scale float64) {
	log.Println("Calling Particles.SetSpeedScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_speed_scale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) SetUseLocalCoordinates(enable *bool) {
	log.Println("Calling Particles.SetUseLocalCoordinates()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_local_coordinates", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles) SetVisibilityAabb(aabb *Rect3) {
	log.Println("Calling Particles.SetVisibilityAabb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aabb)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_visibility_aabb", goArguments, "")

	log.Println("Got return value!")

}

/*
   ParticlesImplementer is an interface for Particles objects.

*/
type ParticlesImplementer interface {
	GeometryInstanceImplementer

	CaptureAabb() *Rect3

	GetAmount() int64

	GetDrawOrder() int64

	GetDrawPassMesh(pass int64) *Mesh

	GetDrawPasses() int64

	GetExplosivenessRatio() float64

	GetFixedFps() int64

	GetFractionalDelta() *bool

	GetLifetime() float64

	GetOneShot() *bool

	GetPreProcessTime() float64

	GetProcessMaterial() *Material

	GetRandomnessRatio() float64

	GetSpeedScale() float64

	GetUseLocalCoordinates() *bool

	GetVisibilityAabb() *Rect3

	IsEmitting() *bool

	Restart()

	SetAmount(amount int64)

	SetDrawOrder(order int64)

	SetDrawPassMesh(pass int64, mesh *Mesh)

	SetDrawPasses(passes int64)

	SetEmitting(emitting *bool)

	SetExplosivenessRatio(ratio float64)

	SetFixedFps(fps int64)

	SetFractionalDelta(enable *bool)

	SetLifetime(secs float64)

	SetOneShot(enable *bool)

	SetPreProcessTime(secs float64)

	SetProcessMaterial(material *Material)

	SetRandomnessRatio(ratio float64)

	SetSpeedScale(scale float64)

	SetUseLocalCoordinates(enable *bool)

	SetVisibilityAabb(aabb *Rect3)
}

/*
   Particles2D is a particle system 2D [Node] that is used to simulate several types of particle effects, such as explosions, rain, snow, fireflies, or other magical-like shinny sparkles. Particles are drawn using impostors, and given their dynamic behavior, the user must provide a visibility bounding box (although helpers to create one automatically exist).
*/
type Particles2D struct {
	Node2D
}

func (o *Particles2D) baseClass() string {
	return "Particles2D"
}

/*

 */
func (o *Particles2D) CaptureRect() *Rect2 {
	log.Println("Calling Particles2D.CaptureRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "capture_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   Returns the amount of particles spawned at each emission
*/
func (o *Particles2D) GetAmount() int64 {
	log.Println("Calling Particles2D.GetAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_amount", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Particles2D) GetDrawOrder() int64 {
	log.Println("Calling Particles2D.GetDrawOrder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_draw_order", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Particles2D) GetExplosivenessRatio() float64 {
	log.Println("Calling Particles2D.GetExplosivenessRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_explosiveness_ratio", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Particles2D) GetFixedFps() int64 {
	log.Println("Calling Particles2D.GetFixedFps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fixed_fps", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Particles2D) GetFractionalDelta() *bool {
	log.Println("Calling Particles2D.GetFractionalDelta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fractional_delta", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Particles2D) GetHFrames() int64 {
	log.Println("Calling Particles2D.GetHFrames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_h_frames", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Gets the amount of seconds that each particle will be visible.
*/
func (o *Particles2D) GetLifetime() float64 {
	log.Println("Calling Particles2D.GetLifetime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_lifetime", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Particles2D) GetNormalMap() *Texture {
	log.Println("Calling Particles2D.GetNormalMap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_normal_map", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *Particles2D) GetOneShot() *bool {
	log.Println("Calling Particles2D.GetOneShot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_one_shot", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Particles2D) GetPreProcessTime() float64 {
	log.Println("Calling Particles2D.GetPreProcessTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pre_process_time", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Particles2D) GetProcessMaterial() *Material {
	log.Println("Calling Particles2D.GetProcessMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_process_material", goArguments, "*Material")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Material)

	return returnValue

}

/*

 */
func (o *Particles2D) GetRandomnessRatio() float64 {
	log.Println("Calling Particles2D.GetRandomnessRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_randomness_ratio", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Particles2D) GetSpeedScale() float64 {
	log.Println("Calling Particles2D.GetSpeedScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_speed_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns the texture for emitted particles
*/
func (o *Particles2D) GetTexture() *Texture {
	log.Println("Calling Particles2D.GetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *Particles2D) GetUseLocalCoordinates() *bool {
	log.Println("Calling Particles2D.GetUseLocalCoordinates()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_use_local_coordinates", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Particles2D) GetVFrames() int64 {
	log.Println("Calling Particles2D.GetVFrames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_v_frames", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Particles2D) GetVisibilityRect() *Rect2 {
	log.Println("Calling Particles2D.GetVisibilityRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_visibility_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   Returns whether this emitter is currently emitting or not
*/
func (o *Particles2D) IsEmitting() *bool {
	log.Println("Calling Particles2D.IsEmitting()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_emitting", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Particles2D) Restart() {
	log.Println("Calling Particles2D.Restart()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "restart", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the amount of particles spawned at each emission
*/
func (o *Particles2D) SetAmount(amount int64) {
	log.Println("Calling Particles2D.SetAmount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_amount", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles2D) SetDrawOrder(order int64) {
	log.Println("Calling Particles2D.SetDrawOrder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(order)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_draw_order", goArguments, "")

	log.Println("Got return value!")

}

/*
   If this is set to true then the particle emitter will emit particles, if its false it will not.
*/
func (o *Particles2D) SetEmitting(emitting *bool) {
	log.Println("Calling Particles2D.SetEmitting()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(emitting)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_emitting", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles2D) SetExplosivenessRatio(ratio float64) {
	log.Println("Calling Particles2D.SetExplosivenessRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ratio)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_explosiveness_ratio", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles2D) SetFixedFps(fps int64) {
	log.Println("Calling Particles2D.SetFixedFps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(fps)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fixed_fps", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles2D) SetFractionalDelta(enable *bool) {
	log.Println("Calling Particles2D.SetFractionalDelta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fractional_delta", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles2D) SetHFrames(frames int64) {
	log.Println("Calling Particles2D.SetHFrames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(frames)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_h_frames", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the amount of seconds that each particle will be visible.
*/
func (o *Particles2D) SetLifetime(secs float64) {
	log.Println("Calling Particles2D.SetLifetime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(secs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_lifetime", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles2D) SetNormalMap(texture *Texture) {
	log.Println("Calling Particles2D.SetNormalMap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_normal_map", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles2D) SetOneShot(secs *bool) {
	log.Println("Calling Particles2D.SetOneShot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(secs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_one_shot", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles2D) SetPreProcessTime(secs float64) {
	log.Println("Calling Particles2D.SetPreProcessTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(secs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pre_process_time", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles2D) SetProcessMaterial(material *Material) {
	log.Println("Calling Particles2D.SetProcessMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(material)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_process_material", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles2D) SetRandomnessRatio(ratio float64) {
	log.Println("Calling Particles2D.SetRandomnessRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ratio)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_randomness_ratio", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles2D) SetSpeedScale(scale float64) {
	log.Println("Calling Particles2D.SetSpeedScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_speed_scale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles2D) SetTexture(texture *Texture) {
	log.Println("Calling Particles2D.SetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles2D) SetUseLocalCoordinates(enable *bool) {
	log.Println("Calling Particles2D.SetUseLocalCoordinates()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_local_coordinates", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles2D) SetVFrames(frames int64) {
	log.Println("Calling Particles2D.SetVFrames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(frames)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_v_frames", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Particles2D) SetVisibilityRect(aabb *Rect2) {
	log.Println("Calling Particles2D.SetVisibilityRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aabb)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_visibility_rect", goArguments, "")

	log.Println("Got return value!")

}

/*
   Particles2DImplementer is an interface for Particles2D objects.
   Particles2D is a particle system 2D [Node] that is used to simulate several types of particle effects, such as explosions, rain, snow, fireflies, or other magical-like shinny sparkles. Particles are drawn using impostors, and given their dynamic behavior, the user must provide a visibility bounding box (although helpers to create one automatically exist).
*/
type Particles2DImplementer interface {
	Node2DImplementer

	CaptureRect() *Rect2

	GetAmount() int64

	GetDrawOrder() int64

	GetExplosivenessRatio() float64

	GetFixedFps() int64

	GetFractionalDelta() *bool

	GetHFrames() int64

	GetLifetime() float64

	GetNormalMap() *Texture

	GetOneShot() *bool

	GetPreProcessTime() float64

	GetProcessMaterial() *Material

	GetRandomnessRatio() float64

	GetSpeedScale() float64

	GetTexture() *Texture

	GetUseLocalCoordinates() *bool

	GetVFrames() int64

	GetVisibilityRect() *Rect2

	IsEmitting() *bool

	Restart()

	SetAmount(amount int64)

	SetDrawOrder(order int64)

	SetEmitting(emitting *bool)

	SetExplosivenessRatio(ratio float64)

	SetFixedFps(fps int64)

	SetFractionalDelta(enable *bool)

	SetHFrames(frames int64)

	SetLifetime(secs float64)

	SetNormalMap(texture *Texture)

	SetOneShot(secs *bool)

	SetPreProcessTime(secs float64)

	SetProcessMaterial(material *Material)

	SetRandomnessRatio(ratio float64)

	SetSpeedScale(scale float64)

	SetTexture(texture *Texture)

	SetUseLocalCoordinates(enable *bool)

	SetVFrames(frames int64)

	SetVisibilityRect(aabb *Rect2)
}

/*

 */
type ParticlesMaterial struct {
	Material
}

func (o *ParticlesMaterial) baseClass() string {
	return "ParticlesMaterial"
}

/*

 */
func (o *ParticlesMaterial) GetColor() *Color {
	log.Println("Calling ParticlesMaterial.GetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) GetColorRamp() *Texture {
	log.Println("Calling ParticlesMaterial.GetColorRamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_color_ramp", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) GetEmissionBoxExtents() *Vector3 {
	log.Println("Calling ParticlesMaterial.GetEmissionBoxExtents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_emission_box_extents", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) GetEmissionColorTexture() *Texture {
	log.Println("Calling ParticlesMaterial.GetEmissionColorTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_emission_color_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) GetEmissionNormalTexture() *Texture {
	log.Println("Calling ParticlesMaterial.GetEmissionNormalTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_emission_normal_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) GetEmissionPointCount() int64 {
	log.Println("Calling ParticlesMaterial.GetEmissionPointCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_emission_point_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) GetEmissionPointTexture() *Texture {
	log.Println("Calling ParticlesMaterial.GetEmissionPointTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_emission_point_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) GetEmissionShape() int64 {
	log.Println("Calling ParticlesMaterial.GetEmissionShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_emission_shape", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) GetEmissionSphereRadius() float64 {
	log.Println("Calling ParticlesMaterial.GetEmissionSphereRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_emission_sphere_radius", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) GetFlag(flag int64) *bool {
	log.Println("Calling ParticlesMaterial.GetFlag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flag)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_flag", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) GetFlatness() float64 {
	log.Println("Calling ParticlesMaterial.GetFlatness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_flatness", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) GetGravity() *Vector3 {
	log.Println("Calling ParticlesMaterial.GetGravity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gravity", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) GetParam(param int64) float64 {
	log.Println("Calling ParticlesMaterial.GetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) GetParamRandomness(param int64) float64 {
	log.Println("Calling ParticlesMaterial.GetParamRandomness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_param_randomness", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) GetParamTexture(param int64) *Texture {
	log.Println("Calling ParticlesMaterial.GetParamTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_param_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) GetSpread() float64 {
	log.Println("Calling ParticlesMaterial.GetSpread()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_spread", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) GetTrailColorModifier() *GradientTexture {
	log.Println("Calling ParticlesMaterial.GetTrailColorModifier()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_trail_color_modifier", goArguments, "*GradientTexture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*GradientTexture)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) GetTrailDivisor() int64 {
	log.Println("Calling ParticlesMaterial.GetTrailDivisor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_trail_divisor", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) GetTrailSizeModifier() *CurveTexture {
	log.Println("Calling ParticlesMaterial.GetTrailSizeModifier()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_trail_size_modifier", goArguments, "*CurveTexture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*CurveTexture)

	return returnValue

}

/*

 */
func (o *ParticlesMaterial) SetColor(color *Color) {
	log.Println("Calling ParticlesMaterial.SetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) SetColorRamp(ramp *Texture) {
	log.Println("Calling ParticlesMaterial.SetColorRamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ramp)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_color_ramp", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) SetEmissionBoxExtents(extents *Vector3) {
	log.Println("Calling ParticlesMaterial.SetEmissionBoxExtents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(extents)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_emission_box_extents", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) SetEmissionColorTexture(texture *Texture) {
	log.Println("Calling ParticlesMaterial.SetEmissionColorTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_emission_color_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) SetEmissionNormalTexture(texture *Texture) {
	log.Println("Calling ParticlesMaterial.SetEmissionNormalTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_emission_normal_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) SetEmissionPointCount(pointCount int64) {
	log.Println("Calling ParticlesMaterial.SetEmissionPointCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pointCount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_emission_point_count", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) SetEmissionPointTexture(texture *Texture) {
	log.Println("Calling ParticlesMaterial.SetEmissionPointTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_emission_point_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) SetEmissionShape(shape int64) {
	log.Println("Calling ParticlesMaterial.SetEmissionShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_emission_shape", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) SetEmissionSphereRadius(radius float64) {
	log.Println("Calling ParticlesMaterial.SetEmissionSphereRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radius)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_emission_sphere_radius", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) SetFlag(flag int64, enable *bool) {
	log.Println("Calling ParticlesMaterial.SetFlag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(flag)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flag", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) SetFlatness(amount float64) {
	log.Println("Calling ParticlesMaterial.SetFlatness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flatness", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) SetGravity(accelVec *Vector3) {
	log.Println("Calling ParticlesMaterial.SetGravity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(accelVec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) SetParam(param int64, value float64) {
	log.Println("Calling ParticlesMaterial.SetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(param)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_param", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) SetParamRandomness(param int64, randomness float64) {
	log.Println("Calling ParticlesMaterial.SetParamRandomness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(param)
	goArguments[1] = reflect.ValueOf(randomness)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_param_randomness", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) SetParamTexture(param int64, texture *Texture) {
	log.Println("Calling ParticlesMaterial.SetParamTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(param)
	goArguments[1] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_param_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) SetSpread(degrees float64) {
	log.Println("Calling ParticlesMaterial.SetSpread()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_spread", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) SetTrailColorModifier(texture *GradientTexture) {
	log.Println("Calling ParticlesMaterial.SetTrailColorModifier()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_trail_color_modifier", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) SetTrailDivisor(divisor int64) {
	log.Println("Calling ParticlesMaterial.SetTrailDivisor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(divisor)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_trail_divisor", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ParticlesMaterial) SetTrailSizeModifier(texture *CurveTexture) {
	log.Println("Calling ParticlesMaterial.SetTrailSizeModifier()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_trail_size_modifier", goArguments, "")

	log.Println("Got return value!")

}

/*
   ParticlesMaterialImplementer is an interface for ParticlesMaterial objects.

*/
type ParticlesMaterialImplementer interface {
	MaterialImplementer

	GetColor() *Color

	GetColorRamp() *Texture

	GetEmissionBoxExtents() *Vector3

	GetEmissionColorTexture() *Texture

	GetEmissionNormalTexture() *Texture

	GetEmissionPointCount() int64

	GetEmissionPointTexture() *Texture

	GetEmissionShape() int64

	GetEmissionSphereRadius() float64

	GetFlag(flag int64) *bool

	GetFlatness() float64

	GetGravity() *Vector3

	GetParam(param int64) float64

	GetParamRandomness(param int64) float64

	GetParamTexture(param int64) *Texture

	GetSpread() float64

	GetTrailColorModifier() *GradientTexture

	GetTrailDivisor() int64

	GetTrailSizeModifier() *CurveTexture

	SetColor(color *Color)

	SetColorRamp(ramp *Texture)

	SetEmissionBoxExtents(extents *Vector3)

	SetEmissionColorTexture(texture *Texture)

	SetEmissionNormalTexture(texture *Texture)

	SetEmissionPointCount(pointCount int64)

	SetEmissionPointTexture(texture *Texture)

	SetEmissionShape(shape int64)

	SetEmissionSphereRadius(radius float64)

	SetFlag(flag int64, enable *bool)

	SetFlatness(amount float64)

	SetGravity(accelVec *Vector3)

	SetParam(param int64, value float64)

	SetParamRandomness(param int64, randomness float64)

	SetParamTexture(param int64, texture *Texture)

	SetSpread(degrees float64)

	SetTrailColorModifier(texture *GradientTexture)

	SetTrailDivisor(divisor int64)

	SetTrailSizeModifier(texture *CurveTexture)
}

/*
   This class is a container/Node-ification of a [Curve3D], so it can have [Spatial] properties and [Node] info.
*/
type Path struct {
	Spatial
}

func (o *Path) baseClass() string {
	return "Path"
}

/*
   Returns the [Curve3D] contained.
*/
func (o *Path) GetCurve() *Curve3D {
	log.Println("Calling Path.GetCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_curve", goArguments, "*Curve3D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Curve3D)

	return returnValue

}

/*
   Sets the [Curve3D].
*/
func (o *Path) SetCurve(curve *Curve3D) {
	log.Println("Calling Path.SetCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(curve)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_curve", goArguments, "")

	log.Println("Got return value!")

}

/*
   PathImplementer is an interface for Path objects.
   This class is a container/Node-ification of a [Curve3D], so it can have [Spatial] properties and [Node] info.
*/
type PathImplementer interface {
	SpatialImplementer

	GetCurve() *Curve3D

	SetCurve(curve *Curve3D)
}

/*
   This class is a container/Node-ification of a [Curve2D], so it can have [Node2D] properties and [Node] info.
*/
type Path2D struct {
	Node2D
}

func (o *Path2D) baseClass() string {
	return "Path2D"
}

/*
   Returns the [Curve2D] contained.
*/
func (o *Path2D) GetCurve() *Curve2D {
	log.Println("Calling Path2D.GetCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_curve", goArguments, "*Curve2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Curve2D)

	return returnValue

}

/*
   Sets the [Curve2D].
*/
func (o *Path2D) SetCurve(curve *Curve2D) {
	log.Println("Calling Path2D.SetCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(curve)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_curve", goArguments, "")

	log.Println("Got return value!")

}

/*
   Path2DImplementer is an interface for Path2D objects.
   This class is a container/Node-ification of a [Curve2D], so it can have [Node2D] properties and [Node] info.
*/
type Path2DImplementer interface {
	Node2DImplementer

	GetCurve() *Curve2D

	SetCurve(curve *Curve2D)
}

/*
        This node takes its parent [Path], and returns the coordinates of a point within it, given a distance from the first vertex.
		It is useful for making other nodes follow a path, without coding the movement pattern. For that, the nodes must be descendants of this node. Then, when setting an offset in this node, the descendant nodes will move accordingly.
*/
type PathFollow struct {
	Spatial
}

func (o *PathFollow) baseClass() string {
	return "PathFollow"
}

/*
   This method returns whether the position between two cached points (see [method set_cubic_interpolation]) is interpolated linearly, or cubicly.
*/
func (o *PathFollow) GetCubicInterpolation() *bool {
	log.Println("Calling PathFollow.GetCubicInterpolation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cubic_interpolation", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns the X displacement this node has from its parent [Path].
*/
func (o *PathFollow) GetHOffset() float64 {
	log.Println("Calling PathFollow.GetHOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_h_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns the distance along the path in 3D units.
*/
func (o *PathFollow) GetOffset() float64 {
	log.Println("Calling PathFollow.GetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns the rotation mode. The constants below list which axes are allowed to rotate for each mode.
*/
func (o *PathFollow) GetRotationMode() int64 {
	log.Println("Calling PathFollow.GetRotationMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rotation_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the distance along the path as a number in the range 0.0 (for the first vertex) to 1.0 (for the last).
*/
func (o *PathFollow) GetUnitOffset() float64 {
	log.Println("Calling PathFollow.GetUnitOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_unit_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns the Y displacement this node has from its parent [Path].
*/
func (o *PathFollow) GetVOffset() float64 {
	log.Println("Calling PathFollow.GetVOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_v_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns whether this node wraps its offsets around, or truncates them to the path ends.
*/
func (o *PathFollow) HasLoop() *bool {
	log.Println("Calling PathFollow.HasLoop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_loop", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
                The points along the [Curve3D] of the [Path] are precomputed before use, for faster calculations. The point at the requested offset is then calculated interpolating between two adjacent cached points. This may present a problem if the curve makes sharp turns, as the cached points may not follow the curve closely enough.
				There are two answers to this problem: Either increase the number of cached points and increase memory consumption, or make a cubic interpolation between two points at the cost of (slightly) slower calculations.
				This method controls whether the position between two cached points is interpolated linearly, or cubicly.
*/
func (o *PathFollow) SetCubicInterpolation(enable *bool) {
	log.Println("Calling PathFollow.SetCubicInterpolation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cubic_interpolation", goArguments, "")

	log.Println("Got return value!")

}

/*
                Moves this node in the X axis. As this node's position will be set every time its offset is set, this allows many PathFollow to share the same curve (and thus the same movement pattern), yet not return the same position for a given path offset.
				A similar effect may be achieved moving the this node's descendants.
*/
func (o *PathFollow) SetHOffset(hOffset float64) {
	log.Println("Calling PathFollow.SetHOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(hOffset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_h_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   If set, any offset outside the path's length (whether set by [method set_offset] or [method set_unit_offset] will wrap around, instead of stopping at the ends. Set it for cyclic paths.
*/
func (o *PathFollow) SetLoop(loop *bool) {
	log.Println("Calling PathFollow.SetLoop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(loop)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_loop", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the distance from the first vertex, measured in 3D units along the path. This sets this node's position to a point within the path.
*/
func (o *PathFollow) SetOffset(offset float64) {
	log.Println("Calling PathFollow.SetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Allows or forbids rotation on one or more axes, per the constants below.
*/
func (o *PathFollow) SetRotationMode(rotationMode int64) {
	log.Println("Calling PathFollow.SetRotationMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rotationMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rotation_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the distance from the first vertex, considering 0.0 as the first vertex and 1.0 as the last. This is just another way of expressing the offset within the path, as the offset supplied is multiplied internally by the path's length.
*/
func (o *PathFollow) SetUnitOffset(unitOffset float64) {
	log.Println("Calling PathFollow.SetUnitOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(unitOffset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_unit_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Moves this node in the Y axis, for the same reasons of [method set_h_offset].
*/
func (o *PathFollow) SetVOffset(vOffset float64) {
	log.Println("Calling PathFollow.SetVOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vOffset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_v_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
        PathFollowImplementer is an interface for PathFollow objects.
        This node takes its parent [Path], and returns the coordinates of a point within it, given a distance from the first vertex.
		It is useful for making other nodes follow a path, without coding the movement pattern. For that, the nodes must be descendants of this node. Then, when setting an offset in this node, the descendant nodes will move accordingly.
*/
type PathFollowImplementer interface {
	SpatialImplementer

	GetCubicInterpolation() *bool

	GetHOffset() float64

	GetOffset() float64

	GetRotationMode() int64

	GetUnitOffset() float64

	GetVOffset() float64

	HasLoop() *bool

	SetCubicInterpolation(enable *bool)

	SetHOffset(hOffset float64)

	SetLoop(loop *bool)

	SetOffset(offset float64)

	SetRotationMode(rotationMode int64)

	SetUnitOffset(unitOffset float64)

	SetVOffset(vOffset float64)
}

/*
        This node takes its parent [Path2D], and returns the coordinates of a point within it, given a distance from the first vertex.
		It is useful for making other nodes follow a path, without coding the movement pattern. For that, the nodes must be descendants of this node. Then, when setting an offset in this node, the descendant nodes will move accordingly.
*/
type PathFollow2D struct {
	Node2D
}

func (o *PathFollow2D) baseClass() string {
	return "PathFollow2D"
}

/*
   This method returns whether the position between two cached points (see [method set_cubic_interpolation]) is interpolated linearly, or cubicly.
*/
func (o *PathFollow2D) GetCubicInterpolation() *bool {
	log.Println("Calling PathFollow2D.GetCubicInterpolation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cubic_interpolation", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns the horizontal displacement this node has from its parent [Path2D].
*/
func (o *PathFollow2D) GetHOffset() float64 {
	log.Println("Calling PathFollow2D.GetHOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_h_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns the distance along the path in pixels.
*/
func (o *PathFollow2D) GetOffset() float64 {
	log.Println("Calling PathFollow2D.GetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns the distance along the path as a number in the range 0.0 (for the first vertex) to 1.0 (for the last).
*/
func (o *PathFollow2D) GetUnitOffset() float64 {
	log.Println("Calling PathFollow2D.GetUnitOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_unit_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns the vertical displacement this node has from its parent [Path2D].
*/
func (o *PathFollow2D) GetVOffset() float64 {
	log.Println("Calling PathFollow2D.GetVOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_v_offset", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns whether this node wraps its offsets around, or truncates them to the path ends.
*/
func (o *PathFollow2D) HasLoop() *bool {
	log.Println("Calling PathFollow2D.HasLoop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_loop", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns whether this node rotates to follow the path.
*/
func (o *PathFollow2D) IsRotating() *bool {
	log.Println("Calling PathFollow2D.IsRotating()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_rotating", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
                The points along the [Curve2D] of the [Path2D] are precomputed before use, for faster calculations. The point at the requested offset is then calculated interpolating between two adjacent cached points. This may present a problem if the curve makes sharp turns, as the cached points may not follow the curve closely enough.
				There are two answers to this problem: Either increase the number of cached points and increase memory consumption, or make a cubic interpolation between two points at the cost of (slightly) slower calculations.
				This method controls whether the position between two cached points is interpolated linearly, or cubicly.
*/
func (o *PathFollow2D) SetCubicInterpolation(enable *bool) {
	log.Println("Calling PathFollow2D.SetCubicInterpolation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cubic_interpolation", goArguments, "")

	log.Println("Got return value!")

}

/*
                Moves this node horizontally. As this node's position will be set every time its offset is set, this allows many PathFollow2D to share the same curve (and thus the same movement pattern), yet not return the same position for a given path offset.
				A similar effect may be achieved moving this node's descendants.
*/
func (o *PathFollow2D) SetHOffset(hOffset float64) {
	log.Println("Calling PathFollow2D.SetHOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(hOffset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_h_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   If set, any offset outside the path's length (whether set by [method set_offset] or [method set_unit_offset] will wrap around, instead of stopping at the ends. Set it for cyclic paths.
*/
func (o *PathFollow2D) SetLoop(loop *bool) {
	log.Println("Calling PathFollow2D.SetLoop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(loop)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_loop", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the distance from the first vertex, measured in pixels along the path. This sets this node's position to a point within the path.
*/
func (o *PathFollow2D) SetOffset(offset float64) {
	log.Println("Calling PathFollow2D.SetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   If set, this node rotates to follow the path, making its descendants rotate.
*/
func (o *PathFollow2D) SetRotate(enable *bool) {
	log.Println("Calling PathFollow2D.SetRotate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rotate", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the distance from the first vertex, considering 0.0 as the first vertex and 1.0 as the last. This is just another way of expressing the offset within the path, as the offset supplied is multiplied internally by the path's length.
*/
func (o *PathFollow2D) SetUnitOffset(unitOffset float64) {
	log.Println("Calling PathFollow2D.SetUnitOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(unitOffset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_unit_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Moves the PathFollow2D vertically, for the same reasons of [method set_h_offset].
*/
func (o *PathFollow2D) SetVOffset(vOffset float64) {
	log.Println("Calling PathFollow2D.SetVOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vOffset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_v_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
        PathFollow2DImplementer is an interface for PathFollow2D objects.
        This node takes its parent [Path2D], and returns the coordinates of a point within it, given a distance from the first vertex.
		It is useful for making other nodes follow a path, without coding the movement pattern. For that, the nodes must be descendants of this node. Then, when setting an offset in this node, the descendant nodes will move accordingly.
*/
type PathFollow2DImplementer interface {
	Node2DImplementer

	GetCubicInterpolation() *bool

	GetHOffset() float64

	GetOffset() float64

	GetUnitOffset() float64

	GetVOffset() float64

	HasLoop() *bool

	IsRotating() *bool

	SetCubicInterpolation(enable *bool)

	SetHOffset(hOffset float64)

	SetLoop(loop *bool)

	SetOffset(offset float64)

	SetRotate(enable *bool)

	SetUnitOffset(unitOffset float64)

	SetVOffset(vOffset float64)
}

/*

 */
type Performance struct {
	Object
}

func (o *Performance) baseClass() string {
	return "Performance"
}

/*

 */
func (o *Performance) GetMonitor(monitor int64) float64 {
	log.Println("Calling Performance.GetMonitor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(monitor)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_monitor", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   PerformanceImplementer is an interface for Performance objects.

*/
type PerformanceImplementer interface {
	ObjectImplementer

	GetMonitor(monitor int64) float64
}

/*
   Direct access object to a physics body in the [Physics2DServer]. This object is passed via the direct state callback of rigid/character bodies, and is intended for changing the direct state of that body.
*/
type Physics2DDirectBodyState struct {
	Object
}

func (o *Physics2DDirectBodyState) baseClass() string {
	return "Physics2DDirectBodyState"
}

/*
   Return the angular velocity of the body.
*/
func (o *Physics2DDirectBodyState) GetAngularVelocity() float64 {
	log.Println("Calling Physics2DDirectBodyState.GetAngularVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_angular_velocity", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the [RID] of the collider.
*/
func (o *Physics2DDirectBodyState) GetContactCollider(contactIdx int64) *RID {
	log.Println("Calling Physics2DDirectBodyState.GetContactCollider()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_collider", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Return the object id of the collider.
*/
func (o *Physics2DDirectBodyState) GetContactColliderId(contactIdx int64) int64 {
	log.Println("Calling Physics2DDirectBodyState.GetContactColliderId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_collider_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the collider object, this depends on how it was created (will return a scene node if such was used to create it).
*/
func (o *Physics2DDirectBodyState) GetContactColliderObject(contactIdx int64) *Object {
	log.Println("Calling Physics2DDirectBodyState.GetContactColliderObject()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_collider_object", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*
   Return the contact position in the collider.
*/
func (o *Physics2DDirectBodyState) GetContactColliderPos(contactIdx int64) *Vector2 {
	log.Println("Calling Physics2DDirectBodyState.GetContactColliderPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_collider_pos", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the collider shape index.
*/
func (o *Physics2DDirectBodyState) GetContactColliderShape(contactIdx int64) int64 {
	log.Println("Calling Physics2DDirectBodyState.GetContactColliderShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_collider_shape", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the metadata of the collided shape. This metadata is different from [method Object.get_meta], and is set with [method Physics2DServer.shape_set_data].
*/
func (o *Physics2DDirectBodyState) GetContactColliderShapeMetadata(contactIdx int64) *Variant {
	log.Println("Calling Physics2DDirectBodyState.GetContactColliderShapeMetadata()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_collider_shape_metadata", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Return the linear velocity vector at contact point of the collider.
*/
func (o *Physics2DDirectBodyState) GetContactColliderVelocityAtPos(contactIdx int64) *Vector2 {
	log.Println("Calling Physics2DDirectBodyState.GetContactColliderVelocityAtPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_collider_velocity_at_pos", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the amount of contacts this body has with other bodies. Note that by default this returns 0 unless bodies are configured to log contacts.
*/
func (o *Physics2DDirectBodyState) GetContactCount() int64 {
	log.Println("Calling Physics2DDirectBodyState.GetContactCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the local normal (of this body) of the contact point.
*/
func (o *Physics2DDirectBodyState) GetContactLocalNormal(contactIdx int64) *Vector2 {
	log.Println("Calling Physics2DDirectBodyState.GetContactLocalNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_local_normal", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the local position (of this body) of the contact point.
*/
func (o *Physics2DDirectBodyState) GetContactLocalPos(contactIdx int64) *Vector2 {
	log.Println("Calling Physics2DDirectBodyState.GetContactLocalPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_local_pos", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the local shape index of the collision.
*/
func (o *Physics2DDirectBodyState) GetContactLocalShape(contactIdx int64) int64 {
	log.Println("Calling Physics2DDirectBodyState.GetContactLocalShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_local_shape", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the inverse of the inertia of the body.
*/
func (o *Physics2DDirectBodyState) GetInverseInertia() float64 {
	log.Println("Calling Physics2DDirectBodyState.GetInverseInertia()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_inverse_inertia", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the inverse of the mass of the body.
*/
func (o *Physics2DDirectBodyState) GetInverseMass() float64 {
	log.Println("Calling Physics2DDirectBodyState.GetInverseMass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_inverse_mass", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the current linear velocity of the body.
*/
func (o *Physics2DDirectBodyState) GetLinearVelocity() *Vector2 {
	log.Println("Calling Physics2DDirectBodyState.GetLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_linear_velocity", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the current state of space, useful for queries.
*/
func (o *Physics2DDirectBodyState) GetSpaceState() *Physics2DDirectSpaceState {
	log.Println("Calling Physics2DDirectBodyState.GetSpaceState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_space_state", goArguments, "*Physics2DDirectSpaceState")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Physics2DDirectSpaceState)

	return returnValue

}

/*
   Return the timestep (delta) used for the simulation.
*/
func (o *Physics2DDirectBodyState) GetStep() float64 {
	log.Println("Calling Physics2DDirectBodyState.GetStep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_step", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the rate at which the body stops rotating, if there are not any other forces moving it.
*/
func (o *Physics2DDirectBodyState) GetTotalAngularDamp() float64 {
	log.Println("Calling Physics2DDirectBodyState.GetTotalAngularDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_total_angular_damp", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the total gravity vector being currently applied to this body.
*/
func (o *Physics2DDirectBodyState) GetTotalGravity() *Vector2 {
	log.Println("Calling Physics2DDirectBodyState.GetTotalGravity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_total_gravity", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the rate at which the body stops moving, if there are not any other forces moving it.
*/
func (o *Physics2DDirectBodyState) GetTotalLinearDamp() float64 {
	log.Println("Calling Physics2DDirectBodyState.GetTotalLinearDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_total_linear_damp", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the transform matrix of the body.
*/
func (o *Physics2DDirectBodyState) GetTransform() *Transform2D {
	log.Println("Calling Physics2DDirectBodyState.GetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Call the built-in force integration code.
*/
func (o *Physics2DDirectBodyState) IntegrateForces() {
	log.Println("Calling Physics2DDirectBodyState.IntegrateForces()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "integrate_forces", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return true if this body is currently sleeping (not active).
*/
func (o *Physics2DDirectBodyState) IsSleeping() *bool {
	log.Println("Calling Physics2DDirectBodyState.IsSleeping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_sleeping", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Change the angular velocity of the body.
*/
func (o *Physics2DDirectBodyState) SetAngularVelocity(velocity float64) {
	log.Println("Calling Physics2DDirectBodyState.SetAngularVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(velocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_angular_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Change the linear velocity of the body.
*/
func (o *Physics2DDirectBodyState) SetLinearVelocity(velocity *Vector2) {
	log.Println("Calling Physics2DDirectBodyState.SetLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(velocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_linear_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the sleeping state of the body, only affects character/rigid bodies.
*/
func (o *Physics2DDirectBodyState) SetSleepState(enabled *bool) {
	log.Println("Calling Physics2DDirectBodyState.SetSleepState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sleep_state", goArguments, "")

	log.Println("Got return value!")

}

/*
   Change the transform matrix of the body.
*/
func (o *Physics2DDirectBodyState) SetTransform(transform *Transform2D) {
	log.Println("Calling Physics2DDirectBodyState.SetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   Physics2DDirectBodyStateImplementer is an interface for Physics2DDirectBodyState objects.
   Direct access object to a physics body in the [Physics2DServer]. This object is passed via the direct state callback of rigid/character bodies, and is intended for changing the direct state of that body.
*/
type Physics2DDirectBodyStateImplementer interface {
	ObjectImplementer

	GetAngularVelocity() float64

	GetContactCollider(contactIdx int64) *RID

	GetContactColliderId(contactIdx int64) int64

	GetContactColliderObject(contactIdx int64) *Object

	GetContactColliderPos(contactIdx int64) *Vector2

	GetContactColliderShape(contactIdx int64) int64

	GetContactColliderShapeMetadata(contactIdx int64) *Variant

	GetContactColliderVelocityAtPos(contactIdx int64) *Vector2

	GetContactCount() int64

	GetContactLocalNormal(contactIdx int64) *Vector2

	GetContactLocalPos(contactIdx int64) *Vector2

	GetContactLocalShape(contactIdx int64) int64

	GetInverseInertia() float64

	GetInverseMass() float64

	GetLinearVelocity() *Vector2

	GetSpaceState() *Physics2DDirectSpaceState

	GetStep() float64

	GetTotalAngularDamp() float64

	GetTotalGravity() *Vector2

	GetTotalLinearDamp() float64

	GetTransform() *Transform2D

	IntegrateForces()

	IsSleeping() *bool

	SetAngularVelocity(velocity float64)

	SetLinearVelocity(velocity *Vector2)

	SetSleepState(enabled *bool)

	SetTransform(transform *Transform2D)
}

/*
   Software implementation of [Physics2DDirectBodyState]. This object exposes no new methods or properties and should not be used, as [Physics2DDirectBodyState] selects the best implementation available.
*/
type Physics2DDirectBodyStateSW struct {
	Physics2DDirectBodyState
}

func (o *Physics2DDirectBodyStateSW) baseClass() string {
	return "Physics2DDirectBodyStateSW"
}

/*
   Physics2DDirectBodyStateSWImplementer is an interface for Physics2DDirectBodyStateSW objects.
   Software implementation of [Physics2DDirectBodyState]. This object exposes no new methods or properties and should not be used, as [Physics2DDirectBodyState] selects the best implementation available.
*/
type Physics2DDirectBodyStateSWImplementer interface {
	Physics2DDirectBodyStateImplementer
}

/*
   Direct access object to a space in the [Physics2DServer]. It's used mainly to do queries against objects and areas residing in a given space.
*/
type Physics2DDirectSpaceState struct {
	Object
}

func (o *Physics2DDirectSpaceState) baseClass() string {
	return "Physics2DDirectSpaceState"
}

/*
                Check whether the shape can travel to a point. If it can, the method will return an array with two floats: The first is the distance the shape can move in that direction without colliding, and the second is the distance at which it will collide.
	If the shape can not move, the array will be empty.
*/
func (o *Physics2DDirectSpaceState) CastMotion(shape *Physics2DShapeQueryParameters) *Array {
	log.Println("Calling Physics2DDirectSpaceState.CastMotion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "cast_motion", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Check the intersections of a shape, given through a [Physics2DShapeQueryParameters] object, against the space. The resulting array contains a list of points where the shape intersects another. Like with [method intersect_shape], the number of returned results can be limited to save processing time.
*/
func (o *Physics2DDirectSpaceState) CollideShape(shape *Physics2DShapeQueryParameters, maxResults int64) *Array {
	log.Println("Calling Physics2DDirectSpaceState.CollideShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(shape)
	goArguments[1] = reflect.ValueOf(maxResults)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "collide_shape", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
                Check the intersections of a shape, given through a [Physics2DShapeQueryParameters] object, against the space. If it collides with more than a shape, the nearest one is selected. The returned object is a dictionary containing the following fields:
				pointo: Place where the shapes intersect.
				normal: Normal of the object at the point where the shapes intersect.
				shape: Shape index within the object against which the shape intersected.
				metadata: Metadata of the shape against which the shape intersected. This metadata is different from [method Object.get_meta], and is set with [method Physics2DServer.shape_set_data].
				collider_id: Id of the object against which the shape intersected.
				collider: Object against which the shape intersected.
				rid: [RID] of the object against which the shape intersected.
				linear_velocity: The movement vector of the object the shape intersected, if it was a body. If it was an area, it is (0,0).
				If the shape did not intersect anything, then an empty dictionary (dir.empty()==true) is returned instead.
*/
func (o *Physics2DDirectSpaceState) GetRestInfo(shape *Physics2DShapeQueryParameters) *Dictionary {
	log.Println("Calling Physics2DDirectSpaceState.GetRestInfo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rest_info", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*
                Check whether a point is inside any shape. The shapes the point is inside of are returned in an array containing dictionaries with the following fields:
				shape: Shape index within the object the point is in.
				metadata: Metadata of the shape the point is in. This metadata is different from [method Object.get_meta], and is set with [method Physics2DServer.shape_set_data].
				collider_id: Id of the object the point is in.
				collider: Object the point is inside of.
				rid: [RID] of the object the point is in.
				Additionally, the method can take an array of objects or [RID]\ s that are to be excluded from collisions, a bitmask representing the physics layers to check in, and another bitmask for the types of objects to check (see TYPE_MASK_* constants).
*/
func (o *Physics2DDirectSpaceState) IntersectPoint(point *Vector2, maxResults int64, exclude *Array, collisionLayer int64, typeMask int64) *Array {
	log.Println("Calling Physics2DDirectSpaceState.IntersectPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(point)
	goArguments[1] = reflect.ValueOf(maxResults)
	goArguments[2] = reflect.ValueOf(exclude)
	goArguments[3] = reflect.ValueOf(collisionLayer)
	goArguments[4] = reflect.ValueOf(typeMask)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "intersect_point", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
                Intersect a ray in a given space. The returned object is a dictionary with the following fields:
				position: Place where ray is stopped.
				normal: Normal of the object at the point where the ray was stopped.
				shape: Shape index within the object against which the ray was stopped.
				metadata: Metadata of the shape against which the ray was stopped. This metadata is different from [method Object.get_meta], and is set with [method Physics2DServer.shape_set_data].
				collider_id: Id of the object against which the ray was stopped.
				collider: Object against which the ray was stopped.
				rid: [RID] of the object against which the ray was stopped.
				If the ray did not intersect anything, then an empty dictionary (dir.empty()==true) is returned instead.
				Additionally, the method can take an array of objects or [RID]\ s that are to be excluded from collisions, a bitmask representing the physics layers to check in, and another bitmask for the types of objects to check (see TYPE_MASK_* constants).
*/
func (o *Physics2DDirectSpaceState) IntersectRay(from *Vector2, to *Vector2, exclude *Array, collisionLayer int64, typeMask int64) *Dictionary {
	log.Println("Calling Physics2DDirectSpaceState.IntersectRay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(to)
	goArguments[2] = reflect.ValueOf(exclude)
	goArguments[3] = reflect.ValueOf(collisionLayer)
	goArguments[4] = reflect.ValueOf(typeMask)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "intersect_ray", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*
                Check the intersections of a shape, given through a [Physics2DShapeQueryParameters] object, against the space. The intersected shapes are returned in an array containing dictionaries with the following fields:
				shape: Shape index within the object the shape intersected.
				metadata: Metadata of the shape intersected by the shape given through the [Physics2DShapeQueryParameters]. This metadata is different from [method Object.get_meta], and is set with [method Physics2DServer.shape_set_data].
				collider_id: Id of the object the shape intersected.
				collider: Object the shape intersected.
				rid: [RID] of the object the shape intersected.
				The number of intersections can be limited with the second parameter, to reduce the processing time.
*/
func (o *Physics2DDirectSpaceState) IntersectShape(shape *Physics2DShapeQueryParameters, maxResults int64) *Array {
	log.Println("Calling Physics2DDirectSpaceState.IntersectShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(shape)
	goArguments[1] = reflect.ValueOf(maxResults)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "intersect_shape", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Physics2DDirectSpaceStateImplementer is an interface for Physics2DDirectSpaceState objects.
   Direct access object to a space in the [Physics2DServer]. It's used mainly to do queries against objects and areas residing in a given space.
*/
type Physics2DDirectSpaceStateImplementer interface {
	ObjectImplementer

	CastMotion(shape *Physics2DShapeQueryParameters) *Array

	CollideShape(shape *Physics2DShapeQueryParameters, maxResults int64) *Array

	GetRestInfo(shape *Physics2DShapeQueryParameters) *Dictionary

	IntersectPoint(point *Vector2, maxResults int64, exclude *Array, collisionLayer int64, typeMask int64) *Array

	IntersectRay(from *Vector2, to *Vector2, exclude *Array, collisionLayer int64, typeMask int64) *Dictionary

	IntersectShape(shape *Physics2DShapeQueryParameters, maxResults int64) *Array
}

/*
   Physics 2D Server is the server responsible for all 2D physics. It can create many kinds of physics objects, but does not insert them on the node tree.
*/
type Physics2DServer struct {
	Object
}

func (o *Physics2DServer) baseClass() string {
	return "Physics2DServer"
}

/*
   Add a shape to the area, along with a transform matrix. Shapes are usually referenced by their index, so you should track which shape has a given index.
*/
func (o *Physics2DServer) AreaAddShape(area *RID, shape *RID, transform *Transform2D) {
	log.Println("Calling Physics2DServer.AreaAddShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(shape)
	goArguments[2] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_add_shape", goArguments, "")

	log.Println("Got return value!")

}

/*
   Assign the area to a descendant of [Object], so it can exist in the node tree.
*/
func (o *Physics2DServer) AreaAttachObjectInstanceId(area *RID, id int64) {
	log.Println("Calling Physics2DServer.AreaAttachObjectInstanceId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_attach_object_instance_id", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove all shapes from an area. It does not delete the shapes, so they can be reassigned later.
*/
func (o *Physics2DServer) AreaClearShapes(area *RID) {
	log.Println("Calling Physics2DServer.AreaClearShapes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_clear_shapes", goArguments, "")

	log.Println("Got return value!")

}

/*
   Create an [Area2D].
*/
func (o *Physics2DServer) AreaCreate() *RID {
	log.Println("Calling Physics2DServer.AreaCreate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_create", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Get the instance ID of the object the area is assigned to.
*/
func (o *Physics2DServer) AreaGetObjectInstanceId(area *RID) int64 {
	log.Println("Calling Physics2DServer.AreaGetObjectInstanceId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_object_instance_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return an area parameter value.
*/
func (o *Physics2DServer) AreaGetParam(area *RID, param int64) *Variant {
	log.Println("Calling Physics2DServer.AreaGetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_param", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Return the [RID] of the nth shape of an area.
*/
func (o *Physics2DServer) AreaGetShape(area *RID, shapeIdx int64) *RID {
	log.Println("Calling Physics2DServer.AreaGetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_shape", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Return the number of shapes assigned to an area.
*/
func (o *Physics2DServer) AreaGetShapeCount(area *RID) int64 {
	log.Println("Calling Physics2DServer.AreaGetShapeCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_shape_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the transform matrix of a shape within an area.
*/
func (o *Physics2DServer) AreaGetShapeTransform(area *RID, shapeIdx int64) *Transform2D {
	log.Println("Calling Physics2DServer.AreaGetShapeTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_shape_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Return the space assigned to the area.
*/
func (o *Physics2DServer) AreaGetSpace(area *RID) *RID {
	log.Println("Calling Physics2DServer.AreaGetSpace()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_space", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Return the space override mode for the area.
*/
func (o *Physics2DServer) AreaGetSpaceOverrideMode(area *RID) int64 {
	log.Println("Calling Physics2DServer.AreaGetSpaceOverrideMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_space_override_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the transform matrix for an area.
*/
func (o *Physics2DServer) AreaGetTransform(area *RID) *Transform2D {
	log.Println("Calling Physics2DServer.AreaGetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Remove a shape from an area. It does not delete the shape, so it can be reassigned later.
*/
func (o *Physics2DServer) AreaRemoveShape(area *RID, shapeIdx int64) {
	log.Println("Calling Physics2DServer.AreaRemoveShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_remove_shape", goArguments, "")

	log.Println("Got return value!")

}

/*
   Assign the area to one or many physics layers.
*/
func (o *Physics2DServer) AreaSetCollisionLayer(area *RID, layer int64) {
	log.Println("Calling Physics2DServer.AreaSetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_collision_layer", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set which physics layers the area will monitor.
*/
func (o *Physics2DServer) AreaSetCollisionMask(area *RID, mask int64) {
	log.Println("Calling Physics2DServer.AreaSetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_collision_mask", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set the function to call when any body/area enters or exits the area. This callback will be called for any object interacting with the area, and takes five parameters:
				1: AREA_BODY_ADDED or AREA_BODY_REMOVED, depending on whether the object entered or exited the area.
				2: [RID] of the object that entered/exited the area.
				3: Instance ID of the object that entered/exited the area.
				4: The shape index of the object that entered/exited the area.
				5: The shape index of the area where the object entered/exited.
*/
func (o *Physics2DServer) AreaSetMonitorCallback(area *RID, receiver *Object, method string) {
	log.Println("Calling Physics2DServer.AreaSetMonitorCallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(receiver)
	goArguments[2] = reflect.ValueOf(method)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_monitor_callback", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the value for an area parameter. A list of available parameters is on the AREA_PARAM_* constants.
*/
func (o *Physics2DServer) AreaSetParam(area *RID, param int64, value *Variant) {
	log.Println("Calling Physics2DServer.AreaSetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(param)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_param", goArguments, "")

	log.Println("Got return value!")

}

/*
   Substitute a given area shape by another. The old shape is selected by its index, the new one by its [RID].
*/
func (o *Physics2DServer) AreaSetShape(area *RID, shapeIdx int64, shape *RID) {
	log.Println("Calling Physics2DServer.AreaSetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(shapeIdx)
	goArguments[2] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_shape", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Physics2DServer) AreaSetShapeDisabled(area *RID, shapeIdx int64, disable *bool) {
	log.Println("Calling Physics2DServer.AreaSetShapeDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(shapeIdx)
	goArguments[2] = reflect.ValueOf(disable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_shape_disabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the transform matrix for an area shape.
*/
func (o *Physics2DServer) AreaSetShapeTransform(area *RID, shapeIdx int64, transform *Transform2D) {
	log.Println("Calling Physics2DServer.AreaSetShapeTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(shapeIdx)
	goArguments[2] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_shape_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   Assign a space to the area.
*/
func (o *Physics2DServer) AreaSetSpace(area *RID, space *RID) {
	log.Println("Calling Physics2DServer.AreaSetSpace()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(space)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_space", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the space override mode for the area. The modes are described in the constants AREA_SPACE_OVERRIDE_*.
*/
func (o *Physics2DServer) AreaSetSpaceOverrideMode(area *RID, mode int64) {
	log.Println("Calling Physics2DServer.AreaSetSpaceOverrideMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_space_override_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the transform matrix for an area.
*/
func (o *Physics2DServer) AreaSetTransform(area *RID, transform *Transform2D) {
	log.Println("Calling Physics2DServer.AreaSetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a body to the list of bodies exempt from collisions.
*/
func (o *Physics2DServer) BodyAddCollisionException(body *RID, exceptedBody *RID) {
	log.Println("Calling Physics2DServer.BodyAddCollisionException()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(exceptedBody)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_add_collision_exception", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a positioned force to the applied force and torque. As with [method body_apply_impulse], both the force and the offset from the body origin are in global coordinates. A force differs from an impulse in that, while the two are forces, the impulse clears itself after being applied.
*/
func (o *Physics2DServer) BodyAddForce(body *RID, offset *Vector2, force *Vector2) {
	log.Println("Calling Physics2DServer.BodyAddForce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(offset)
	goArguments[2] = reflect.ValueOf(force)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_add_force", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a shape to the body, along with a transform matrix. Shapes are usually referenced by their index, so you should track which shape has a given index.
*/
func (o *Physics2DServer) BodyAddShape(body *RID, shape *RID, transform *Transform2D) {
	log.Println("Calling Physics2DServer.BodyAddShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shape)
	goArguments[2] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_add_shape", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a positioned impulse to the applied force and torque. Both the force and the offset from the body origin are in global coordinates.
*/
func (o *Physics2DServer) BodyApplyImpulse(body *RID, pos *Vector2, impulse *Vector2) {
	log.Println("Calling Physics2DServer.BodyApplyImpulse()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(pos)
	goArguments[2] = reflect.ValueOf(impulse)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_apply_impulse", goArguments, "")

	log.Println("Got return value!")

}

/*
   Assign the area to a descendant of [Object], so it can exist in the node tree.
*/
func (o *Physics2DServer) BodyAttachObjectInstanceId(body *RID, id int64) {
	log.Println("Calling Physics2DServer.BodyAttachObjectInstanceId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_attach_object_instance_id", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove all shapes from a body.
*/
func (o *Physics2DServer) BodyClearShapes(body *RID) {
	log.Println("Calling Physics2DServer.BodyClearShapes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_clear_shapes", goArguments, "")

	log.Println("Got return value!")

}

/*
   Create a physics body. The first parameter can be any value from constants BODY_MODE*, for the type of body created. Additionally, the body can be created in sleeping state to save processing time.
*/
func (o *Physics2DServer) BodyCreate(mode int64, initSleeping *bool) *RID {
	log.Println("Calling Physics2DServer.BodyCreate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(mode)
	goArguments[1] = reflect.ValueOf(initSleeping)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_create", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Return the physics layer or layers a body belongs to.
*/
func (o *Physics2DServer) BodyGetCollisionLayer(body *RID) int64 {
	log.Println("Calling Physics2DServer.BodyGetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_collision_layer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the physics layer or layers a body can collide with.
*/
func (o *Physics2DServer) BodyGetCollisionMask(body *RID) int64 {
	log.Println("Calling Physics2DServer.BodyGetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_collision_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the continuous collision detection mode.
*/
func (o *Physics2DServer) BodyGetContinuousCollisionDetectionMode(body *RID) int64 {
	log.Println("Calling Physics2DServer.BodyGetContinuousCollisionDetectionMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_continuous_collision_detection_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the maximum contacts that can be reported. See [method body_set_max_contacts_reported].
*/
func (o *Physics2DServer) BodyGetMaxContactsReported(body *RID) int64 {
	log.Println("Calling Physics2DServer.BodyGetMaxContactsReported()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_max_contacts_reported", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the body mode.
*/
func (o *Physics2DServer) BodyGetMode(body *RID) int64 {
	log.Println("Calling Physics2DServer.BodyGetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the instance ID of the object the area is assigned to.
*/
func (o *Physics2DServer) BodyGetObjectInstanceId(body *RID) int64 {
	log.Println("Calling Physics2DServer.BodyGetObjectInstanceId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_object_instance_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the value of a body parameter.
*/
func (o *Physics2DServer) BodyGetParam(body *RID, param int64) float64 {
	log.Println("Calling Physics2DServer.BodyGetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the [RID] of the nth shape of a body.
*/
func (o *Physics2DServer) BodyGetShape(body *RID, shapeIdx int64) *RID {
	log.Println("Calling Physics2DServer.BodyGetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_shape", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Return the number of shapes assigned to a body.
*/
func (o *Physics2DServer) BodyGetShapeCount(body *RID) int64 {
	log.Println("Calling Physics2DServer.BodyGetShapeCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_shape_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the metadata of a shape of a body.
*/
func (o *Physics2DServer) BodyGetShapeMetadata(body *RID, shapeIdx int64) *Variant {
	log.Println("Calling Physics2DServer.BodyGetShapeMetadata()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_shape_metadata", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Return the transform matrix of a body shape.
*/
func (o *Physics2DServer) BodyGetShapeTransform(body *RID, shapeIdx int64) *Transform2D {
	log.Println("Calling Physics2DServer.BodyGetShapeTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_shape_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Return the [RID] of the space assigned to a body.
*/
func (o *Physics2DServer) BodyGetSpace(body *RID) *RID {
	log.Println("Calling Physics2DServer.BodyGetSpace()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_space", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Return a body state.
*/
func (o *Physics2DServer) BodyGetState(body *RID, state int64) *Variant {
	log.Println("Calling Physics2DServer.BodyGetState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(state)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_state", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Return whether a body uses a callback function to calculate its own physics (see [method body_set_force_integration_callback]).
*/
func (o *Physics2DServer) BodyIsOmittingForceIntegration(body *RID) *bool {
	log.Println("Calling Physics2DServer.BodyIsOmittingForceIntegration()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_is_omitting_force_integration", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Remove a body from the list of bodies exempt from collisions.
*/
func (o *Physics2DServer) BodyRemoveCollisionException(body *RID, exceptedBody *RID) {
	log.Println("Calling Physics2DServer.BodyRemoveCollisionException()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(exceptedBody)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_remove_collision_exception", goArguments, "")

	log.Println("Got return value!")

}

/*
   Remove a shape from a body. The shape is not deleted, so it can be reused afterwards.
*/
func (o *Physics2DServer) BodyRemoveShape(body *RID, shapeIdx int64) {
	log.Println("Calling Physics2DServer.BodyRemoveShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_remove_shape", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set an axis velocity. The velocity in the given vector axis will be set as the given vector length. This is useful for jumping behavior.
*/
func (o *Physics2DServer) BodySetAxisVelocity(body *RID, axisVelocity *Vector2) {
	log.Println("Calling Physics2DServer.BodySetAxisVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(axisVelocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_axis_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the physics layer or layers a body belongs to.
*/
func (o *Physics2DServer) BodySetCollisionLayer(body *RID, layer int64) {
	log.Println("Calling Physics2DServer.BodySetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_collision_layer", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the physics layer or layers a body can collide with.
*/
func (o *Physics2DServer) BodySetCollisionMask(body *RID, mask int64) {
	log.Println("Calling Physics2DServer.BodySetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_collision_mask", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set the continuous collision detection mode from any of the CCD_MODE_* constants.
				Continuous collision detection tries to predict where a moving body will collide, instead of moving it and correcting its movement if it collided.
*/
func (o *Physics2DServer) BodySetContinuousCollisionDetectionMode(body *RID, mode int64) {
	log.Println("Calling Physics2DServer.BodySetContinuousCollisionDetectionMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_continuous_collision_detection_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the function used to calculate physics for an object, if that object allows it (see [method body_set_omit_force integration]).
*/
func (o *Physics2DServer) BodySetForceIntegrationCallback(body *RID, receiver *Object, method string, userdata *Variant) {
	log.Println("Calling Physics2DServer.BodySetForceIntegrationCallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(receiver)
	goArguments[2] = reflect.ValueOf(method)
	goArguments[3] = reflect.ValueOf(userdata)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_force_integration_callback", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the maximum contacts to report. Bodies can keep a log of the contacts with other bodies, this is enabled by setting the maximum amount of contacts reported to a number greater than 0.
*/
func (o *Physics2DServer) BodySetMaxContactsReported(body *RID, amount int64) {
	log.Println("Calling Physics2DServer.BodySetMaxContactsReported()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_max_contacts_reported", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the body mode, from one of the constants BODY_MODE*.
*/
func (o *Physics2DServer) BodySetMode(body *RID, mode int64) {
	log.Println("Calling Physics2DServer.BodySetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether a body uses a callback function to calculate its own physics (see [method body_set_force_integration_callback]).
*/
func (o *Physics2DServer) BodySetOmitForceIntegration(body *RID, enable *bool) {
	log.Println("Calling Physics2DServer.BodySetOmitForceIntegration()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_omit_force_integration", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set a body parameter (see BODY_PARAM* constants).
*/
func (o *Physics2DServer) BodySetParam(body *RID, param int64, value float64) {
	log.Println("Calling Physics2DServer.BodySetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(param)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_param", goArguments, "")

	log.Println("Got return value!")

}

/*
   Substitute a given body shape by another. The old shape is selected by its index, the new one by its [RID].
*/
func (o *Physics2DServer) BodySetShape(body *RID, shapeIdx int64, shape *RID) {
	log.Println("Calling Physics2DServer.BodySetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shapeIdx)
	goArguments[2] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_shape", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Physics2DServer) BodySetShapeAsOneWayCollision(body *RID, shapeIdx int64, enable *bool) {
	log.Println("Calling Physics2DServer.BodySetShapeAsOneWayCollision()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shapeIdx)
	goArguments[2] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_shape_as_one_way_collision", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Physics2DServer) BodySetShapeDisabled(body *RID, shapeIdx int64, disable *bool) {
	log.Println("Calling Physics2DServer.BodySetShapeDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shapeIdx)
	goArguments[2] = reflect.ValueOf(disable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_shape_disabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set metadata of a shape within a body. This metadata is different from [method Object.set_meta], and can be retrieved on shape queries.
*/
func (o *Physics2DServer) BodySetShapeMetadata(body *RID, shapeIdx int64, metadata *Variant) {
	log.Println("Calling Physics2DServer.BodySetShapeMetadata()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shapeIdx)
	goArguments[2] = reflect.ValueOf(metadata)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_shape_metadata", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the transform matrix for a body shape.
*/
func (o *Physics2DServer) BodySetShapeTransform(body *RID, shapeIdx int64, transform *Transform2D) {
	log.Println("Calling Physics2DServer.BodySetShapeTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shapeIdx)
	goArguments[2] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_shape_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   Assign a space to the body (see [method create_space]).
*/
func (o *Physics2DServer) BodySetSpace(body *RID, space *RID) {
	log.Println("Calling Physics2DServer.BodySetSpace()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(space)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_space", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set a body state (see BODY_STATE* constants).
*/
func (o *Physics2DServer) BodySetState(body *RID, state int64, value *Variant) {
	log.Println("Calling Physics2DServer.BodySetState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(state)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_state", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether a body can move from a given point in a given direction. Apart from the boolean return value, a [Physics2DTestMotionResult] can be passed to return additional information in.
*/
func (o *Physics2DServer) BodyTestMotion(body *RID, from *Transform2D, motion *Vector2, margin float64, result *Physics2DTestMotionResult) *bool {
	log.Println("Calling Physics2DServer.BodyTestMotion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(from)
	goArguments[2] = reflect.ValueOf(motion)
	goArguments[3] = reflect.ValueOf(margin)
	goArguments[4] = reflect.ValueOf(result)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_test_motion", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Create a damped spring joint between two bodies. If not specified, the second body is assumed to be the joint itself.
*/
func (o *Physics2DServer) DampedSpringJointCreate(anchorA *Vector2, anchorB *Vector2, bodyA *RID, bodyB *RID) *RID {
	log.Println("Calling Physics2DServer.DampedSpringJointCreate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(anchorA)
	goArguments[1] = reflect.ValueOf(anchorB)
	goArguments[2] = reflect.ValueOf(bodyA)
	goArguments[3] = reflect.ValueOf(bodyB)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "damped_spring_joint_create", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Return the value of a damped spring joint parameter.
*/
func (o *Physics2DServer) DampedStringJointGetParam(joint *RID, param int64) float64 {
	log.Println("Calling Physics2DServer.DampedStringJointGetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "damped_string_joint_get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set a damped spring joint parameter. Parameters are explained in the DAMPED_STRING* constants.
*/
func (o *Physics2DServer) DampedStringJointSetParam(joint *RID, param int64, value float64) {
	log.Println("Calling Physics2DServer.DampedStringJointSetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(param)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "damped_string_joint_set_param", goArguments, "")

	log.Println("Got return value!")

}

/*
   Destroy any of the objects created by Physics2DServer. If the [RID] passed is not one of the objects that can be created by Physics2DServer, an error will be sent to the console.
*/
func (o *Physics2DServer) FreeRid(rid *RID) {
	log.Println("Calling Physics2DServer.FreeRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rid)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "free_rid", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return information about the current state of the 2D physics engine. The states are listed under the INFO_* constants.
*/
func (o *Physics2DServer) GetProcessInfo(processInfo int64) int64 {
	log.Println("Calling Physics2DServer.GetProcessInfo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(processInfo)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_process_info", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Create a groove joint between two bodies. If not specified, the bodyies are assumed to be the joint itself.
*/
func (o *Physics2DServer) GrooveJointCreate(groove1A *Vector2, groove2A *Vector2, anchorB *Vector2, bodyA *RID, bodyB *RID) *RID {
	log.Println("Calling Physics2DServer.GrooveJointCreate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(groove1A)
	goArguments[1] = reflect.ValueOf(groove2A)
	goArguments[2] = reflect.ValueOf(anchorB)
	goArguments[3] = reflect.ValueOf(bodyA)
	goArguments[4] = reflect.ValueOf(bodyB)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "groove_joint_create", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Return the value of a joint parameter.
*/
func (o *Physics2DServer) JointGetParam(joint *RID, param int64) float64 {
	log.Println("Calling Physics2DServer.JointGetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "joint_get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the type of a joint (see JOINT_* constants).
*/
func (o *Physics2DServer) JointGetType(joint *RID) int64 {
	log.Println("Calling Physics2DServer.JointGetType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(joint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "joint_get_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set a joint parameter. Parameters are explained in the JOINT_PARAM* constants.
*/
func (o *Physics2DServer) JointSetParam(joint *RID, param int64, value float64) {
	log.Println("Calling Physics2DServer.JointSetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(param)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "joint_set_param", goArguments, "")

	log.Println("Got return value!")

}

/*
   Create a pin joint between two bodies. If not specified, the second body is assumed to be the joint itself.
*/
func (o *Physics2DServer) PinJointCreate(anchor *Vector2, bodyA *RID, bodyB *RID) *RID {
	log.Println("Calling Physics2DServer.PinJointCreate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(anchor)
	goArguments[1] = reflect.ValueOf(bodyA)
	goArguments[2] = reflect.ValueOf(bodyB)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "pin_joint_create", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Activate or deactivate the 2D physics engine.
*/
func (o *Physics2DServer) SetActive(active *bool) {
	log.Println("Calling Physics2DServer.SetActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(active)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_active", goArguments, "")

	log.Println("Got return value!")

}

/*
   Create a shape of type SHAPE_*. Does not assign it to a body or an area. To do so, you must use [method area_set_shape] or [method body_set_shape].
*/
func (o *Physics2DServer) ShapeCreate(aType int64) *RID {
	log.Println("Calling Physics2DServer.ShapeCreate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_create", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Return the shape data.
*/
func (o *Physics2DServer) ShapeGetData(shape *RID) *Variant {
	log.Println("Calling Physics2DServer.ShapeGetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_get_data", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Return the type of shape (see SHAPE_* constants).
*/
func (o *Physics2DServer) ShapeGetType(shape *RID) int64 {
	log.Println("Calling Physics2DServer.ShapeGetType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_get_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the shape data that defines its shape and size. The data to be passed depends on the kind of shape created [method shape_get_type].
*/
func (o *Physics2DServer) ShapeSetData(shape *RID, data *Variant) {
	log.Println("Calling Physics2DServer.ShapeSetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(shape)
	goArguments[1] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "shape_set_data", goArguments, "")

	log.Println("Got return value!")

}

/*
   Create a space. A space is a collection of parameters for the physics engine that can be assigned to an area or a body. It can be assigned to an area with [method area_set_space], or to a body with [method body_set_space].
*/
func (o *Physics2DServer) SpaceCreate() *RID {
	log.Println("Calling Physics2DServer.SpaceCreate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "space_create", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Return the state of a space, a [Physics2DDirectSpaceState]. This object can be used to make collision/intersection queries.
*/
func (o *Physics2DServer) SpaceGetDirectState(space *RID) *Physics2DDirectSpaceState {
	log.Println("Calling Physics2DServer.SpaceGetDirectState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(space)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "space_get_direct_state", goArguments, "*Physics2DDirectSpaceState")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Physics2DDirectSpaceState)

	return returnValue

}

/*
   Return the value of a space parameter.
*/
func (o *Physics2DServer) SpaceGetParam(space *RID, param int64) float64 {
	log.Println("Calling Physics2DServer.SpaceGetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(space)
	goArguments[1] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "space_get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return whether the space is active.
*/
func (o *Physics2DServer) SpaceIsActive(space *RID) *bool {
	log.Println("Calling Physics2DServer.SpaceIsActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(space)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "space_is_active", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Mark a space as active. It will not have an effect, unless it is assigned to an area or body.
*/
func (o *Physics2DServer) SpaceSetActive(space *RID, active *bool) {
	log.Println("Calling Physics2DServer.SpaceSetActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(space)
	goArguments[1] = reflect.ValueOf(active)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "space_set_active", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the value for a space parameter. A list of available parameters is on the SPACE_PARAM_* constants.
*/
func (o *Physics2DServer) SpaceSetParam(space *RID, param int64, value float64) {
	log.Println("Calling Physics2DServer.SpaceSetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(space)
	goArguments[1] = reflect.ValueOf(param)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "space_set_param", goArguments, "")

	log.Println("Got return value!")

}

/*
   Physics2DServerImplementer is an interface for Physics2DServer objects.
   Physics 2D Server is the server responsible for all 2D physics. It can create many kinds of physics objects, but does not insert them on the node tree.
*/
type Physics2DServerImplementer interface {
	ObjectImplementer

	AreaAddShape(area *RID, shape *RID, transform *Transform2D)

	AreaAttachObjectInstanceId(area *RID, id int64)

	AreaClearShapes(area *RID)

	AreaCreate() *RID

	AreaGetObjectInstanceId(area *RID) int64

	AreaGetParam(area *RID, param int64) *Variant

	AreaGetShape(area *RID, shapeIdx int64) *RID

	AreaGetShapeCount(area *RID) int64

	AreaGetShapeTransform(area *RID, shapeIdx int64) *Transform2D

	AreaGetSpace(area *RID) *RID

	AreaGetSpaceOverrideMode(area *RID) int64

	AreaGetTransform(area *RID) *Transform2D

	AreaRemoveShape(area *RID, shapeIdx int64)

	AreaSetCollisionLayer(area *RID, layer int64)

	AreaSetCollisionMask(area *RID, mask int64)

	AreaSetMonitorCallback(area *RID, receiver *Object, method string)

	AreaSetParam(area *RID, param int64, value *Variant)

	AreaSetShape(area *RID, shapeIdx int64, shape *RID)

	AreaSetShapeDisabled(area *RID, shapeIdx int64, disable *bool)

	AreaSetShapeTransform(area *RID, shapeIdx int64, transform *Transform2D)

	AreaSetSpace(area *RID, space *RID)

	AreaSetSpaceOverrideMode(area *RID, mode int64)

	AreaSetTransform(area *RID, transform *Transform2D)

	BodyAddCollisionException(body *RID, exceptedBody *RID)

	BodyAddForce(body *RID, offset *Vector2, force *Vector2)

	BodyAddShape(body *RID, shape *RID, transform *Transform2D)

	BodyApplyImpulse(body *RID, pos *Vector2, impulse *Vector2)

	BodyAttachObjectInstanceId(body *RID, id int64)

	BodyClearShapes(body *RID)

	BodyCreate(mode int64, initSleeping *bool) *RID

	BodyGetCollisionLayer(body *RID) int64

	BodyGetCollisionMask(body *RID) int64

	BodyGetContinuousCollisionDetectionMode(body *RID) int64

	BodyGetMaxContactsReported(body *RID) int64

	BodyGetMode(body *RID) int64

	BodyGetObjectInstanceId(body *RID) int64

	BodyGetParam(body *RID, param int64) float64

	BodyGetShape(body *RID, shapeIdx int64) *RID

	BodyGetShapeCount(body *RID) int64

	BodyGetShapeMetadata(body *RID, shapeIdx int64) *Variant

	BodyGetShapeTransform(body *RID, shapeIdx int64) *Transform2D

	BodyGetSpace(body *RID) *RID

	BodyGetState(body *RID, state int64) *Variant

	BodyIsOmittingForceIntegration(body *RID) *bool

	BodyRemoveCollisionException(body *RID, exceptedBody *RID)

	BodyRemoveShape(body *RID, shapeIdx int64)

	BodySetAxisVelocity(body *RID, axisVelocity *Vector2)

	BodySetCollisionLayer(body *RID, layer int64)

	BodySetCollisionMask(body *RID, mask int64)

	BodySetContinuousCollisionDetectionMode(body *RID, mode int64)

	BodySetForceIntegrationCallback(body *RID, receiver *Object, method string, userdata *Variant)

	BodySetMaxContactsReported(body *RID, amount int64)

	BodySetMode(body *RID, mode int64)

	BodySetOmitForceIntegration(body *RID, enable *bool)

	BodySetParam(body *RID, param int64, value float64)

	BodySetShape(body *RID, shapeIdx int64, shape *RID)

	BodySetShapeAsOneWayCollision(body *RID, shapeIdx int64, enable *bool)

	BodySetShapeDisabled(body *RID, shapeIdx int64, disable *bool)

	BodySetShapeMetadata(body *RID, shapeIdx int64, metadata *Variant)

	BodySetShapeTransform(body *RID, shapeIdx int64, transform *Transform2D)

	BodySetSpace(body *RID, space *RID)

	BodySetState(body *RID, state int64, value *Variant)

	BodyTestMotion(body *RID, from *Transform2D, motion *Vector2, margin float64, result *Physics2DTestMotionResult) *bool

	DampedSpringJointCreate(anchorA *Vector2, anchorB *Vector2, bodyA *RID, bodyB *RID) *RID

	DampedStringJointGetParam(joint *RID, param int64) float64

	DampedStringJointSetParam(joint *RID, param int64, value float64)

	FreeRid(rid *RID)

	GetProcessInfo(processInfo int64) int64

	GrooveJointCreate(groove1A *Vector2, groove2A *Vector2, anchorB *Vector2, bodyA *RID, bodyB *RID) *RID

	JointGetParam(joint *RID, param int64) float64

	JointGetType(joint *RID) int64

	JointSetParam(joint *RID, param int64, value float64)

	PinJointCreate(anchor *Vector2, bodyA *RID, bodyB *RID) *RID

	SetActive(active *bool)

	ShapeCreate(aType int64) *RID

	ShapeGetData(shape *RID) *Variant

	ShapeGetType(shape *RID) int64

	ShapeSetData(shape *RID, data *Variant)

	SpaceCreate() *RID

	SpaceGetDirectState(space *RID) *Physics2DDirectSpaceState

	SpaceGetParam(space *RID, param int64) float64

	SpaceIsActive(space *RID) *bool

	SpaceSetActive(space *RID, active *bool)

	SpaceSetParam(space *RID, param int64, value float64)
}

/*
   Software implementation of [Physics2DServer]. This class exposes no new methods or properties and should not be used, as [Physics2DServer] automatically selects the best implementation available.
*/
type Physics2DServerSW struct {
	Physics2DServer
}

func (o *Physics2DServerSW) baseClass() string {
	return "Physics2DServerSW"
}

/*
   Physics2DServerSWImplementer is an interface for Physics2DServerSW objects.
   Software implementation of [Physics2DServer]. This class exposes no new methods or properties and should not be used, as [Physics2DServer] automatically selects the best implementation available.
*/
type Physics2DServerSWImplementer interface {
	Physics2DServerImplementer
}

/*
   This class contains the shape and other parameters for intersection/collision queries.
*/
type Physics2DShapeQueryParameters struct {
	Reference
}

func (o *Physics2DShapeQueryParameters) baseClass() string {
	return "Physics2DShapeQueryParameters"
}

/*
   Return the physics layer the shape belongs to.
*/
func (o *Physics2DShapeQueryParameters) GetCollisionLayer() int64 {
	log.Println("Calling Physics2DShapeQueryParameters.GetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_layer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the list of objects, or object [RID]\ s, that will be excluded from collisions.
*/
func (o *Physics2DShapeQueryParameters) GetExclude() *Array {
	log.Println("Calling Physics2DShapeQueryParameters.GetExclude()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_exclude", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Return the collision margin for the shape.
*/
func (o *Physics2DShapeQueryParameters) GetMargin() float64 {
	log.Println("Calling Physics2DShapeQueryParameters.GetMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_margin", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the current movement speed of the shape.
*/
func (o *Physics2DShapeQueryParameters) GetMotion() *Vector2 {
	log.Println("Calling Physics2DShapeQueryParameters.GetMotion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_motion", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the type of object the shape belongs to.
*/
func (o *Physics2DShapeQueryParameters) GetObjectTypeMask() int64 {
	log.Println("Calling Physics2DShapeQueryParameters.GetObjectTypeMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_object_type_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the [RID] of the shape queried.
*/
func (o *Physics2DShapeQueryParameters) GetShapeRid() *RID {
	log.Println("Calling Physics2DShapeQueryParameters.GetShapeRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shape_rid", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Return the transform matrix of the shape queried.
*/
func (o *Physics2DShapeQueryParameters) GetTransform() *Transform2D {
	log.Println("Calling Physics2DShapeQueryParameters.GetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Set the physics layer the shape belongs to.
*/
func (o *Physics2DShapeQueryParameters) SetCollisionLayer(collisionLayer int64) {
	log.Println("Calling Physics2DShapeQueryParameters.SetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collisionLayer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the list of objects, or object [RID]\ s, that will be excluded from collisions.
*/
func (o *Physics2DShapeQueryParameters) SetExclude(exclude *Array) {
	log.Println("Calling Physics2DShapeQueryParameters.SetExclude()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(exclude)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_exclude", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the collision margin for the shape. A collision margin is an amount (in pixels) that the shape will grow when computing collisions, to account for numerical imprecision.
*/
func (o *Physics2DShapeQueryParameters) SetMargin(margin float64) {
	log.Println("Calling Physics2DShapeQueryParameters.SetMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_margin", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the current movement speed of the shape.
*/
func (o *Physics2DShapeQueryParameters) SetMotion(motion *Vector2) {
	log.Println("Calling Physics2DShapeQueryParameters.SetMotion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(motion)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_motion", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the type of object the shape belongs to (see Physics2DDirectSpaceState.TYPE_MASK_*).
*/
func (o *Physics2DShapeQueryParameters) SetObjectTypeMask(objectTypeMask int64) {
	log.Println("Calling Physics2DShapeQueryParameters.SetObjectTypeMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(objectTypeMask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_object_type_mask", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the [Shape2D] that will be used for collision/intersection queries.
*/
func (o *Physics2DShapeQueryParameters) SetShape(shape *Resource) {
	log.Println("Calling Physics2DShapeQueryParameters.SetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shape", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the [RID] of the shape to be used in queries.
*/
func (o *Physics2DShapeQueryParameters) SetShapeRid(shape *RID) {
	log.Println("Calling Physics2DShapeQueryParameters.SetShapeRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shape_rid", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the transormation matrix of the shape. This is necessary to set its position/rotation/scale.
*/
func (o *Physics2DShapeQueryParameters) SetTransform(transform *Transform2D) {
	log.Println("Calling Physics2DShapeQueryParameters.SetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   Physics2DShapeQueryParametersImplementer is an interface for Physics2DShapeQueryParameters objects.
   This class contains the shape and other parameters for intersection/collision queries.
*/
type Physics2DShapeQueryParametersImplementer interface {
	ReferenceImplementer

	GetCollisionLayer() int64

	GetExclude() *Array

	GetMargin() float64

	GetMotion() *Vector2

	GetObjectTypeMask() int64

	GetShapeRid() *RID

	GetTransform() *Transform2D

	SetCollisionLayer(collisionLayer int64)

	SetExclude(exclude *Array)

	SetMargin(margin float64)

	SetMotion(motion *Vector2)

	SetObjectTypeMask(objectTypeMask int64)

	SetShape(shape *Resource)

	SetShapeRid(shape *RID)

	SetTransform(transform *Transform2D)
}

/*

 */
type Physics2DShapeQueryResult struct {
	Reference
}

func (o *Physics2DShapeQueryResult) baseClass() string {
	return "Physics2DShapeQueryResult"
}

/*

 */
func (o *Physics2DShapeQueryResult) GetResultCount() int64 {
	log.Println("Calling Physics2DShapeQueryResult.GetResultCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_result_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Physics2DShapeQueryResult) GetResultObject(idx int64) *Object {
	log.Println("Calling Physics2DShapeQueryResult.GetResultObject()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_result_object", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*

 */
func (o *Physics2DShapeQueryResult) GetResultObjectId(idx int64) int64 {
	log.Println("Calling Physics2DShapeQueryResult.GetResultObjectId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_result_object_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Physics2DShapeQueryResult) GetResultObjectShape(idx int64) int64 {
	log.Println("Calling Physics2DShapeQueryResult.GetResultObjectShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_result_object_shape", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Physics2DShapeQueryResult) GetResultRid(idx int64) *RID {
	log.Println("Calling Physics2DShapeQueryResult.GetResultRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_result_rid", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Physics2DShapeQueryResultImplementer is an interface for Physics2DShapeQueryResult objects.

*/
type Physics2DShapeQueryResultImplementer interface {
	ReferenceImplementer

	GetResultCount() int64

	GetResultObject(idx int64) *Object

	GetResultObjectId(idx int64) int64

	GetResultObjectShape(idx int64) int64

	GetResultRid(idx int64) *RID
}

/*

 */
type Physics2DTestMotionResult struct {
	Reference
}

func (o *Physics2DTestMotionResult) baseClass() string {
	return "Physics2DTestMotionResult"
}

/*

 */
func (o *Physics2DTestMotionResult) GetCollider() *Object {
	log.Println("Calling Physics2DTestMotionResult.GetCollider()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*

 */
func (o *Physics2DTestMotionResult) GetColliderId() int64 {
	log.Println("Calling Physics2DTestMotionResult.GetColliderId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Physics2DTestMotionResult) GetColliderRid() *RID {
	log.Println("Calling Physics2DTestMotionResult.GetColliderRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider_rid", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *Physics2DTestMotionResult) GetColliderShape() int64 {
	log.Println("Calling Physics2DTestMotionResult.GetColliderShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider_shape", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Physics2DTestMotionResult) GetColliderVelocity() *Vector2 {
	log.Println("Calling Physics2DTestMotionResult.GetColliderVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider_velocity", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Physics2DTestMotionResult) GetCollisionNormal() *Vector2 {
	log.Println("Calling Physics2DTestMotionResult.GetCollisionNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_normal", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Physics2DTestMotionResult) GetCollisionPoint() *Vector2 {
	log.Println("Calling Physics2DTestMotionResult.GetCollisionPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_point", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Physics2DTestMotionResult) GetMotion() *Vector2 {
	log.Println("Calling Physics2DTestMotionResult.GetMotion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_motion", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Physics2DTestMotionResult) GetMotionRemainder() *Vector2 {
	log.Println("Calling Physics2DTestMotionResult.GetMotionRemainder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_motion_remainder", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Physics2DTestMotionResultImplementer is an interface for Physics2DTestMotionResult objects.

*/
type Physics2DTestMotionResultImplementer interface {
	ReferenceImplementer

	GetCollider() *Object

	GetColliderId() int64

	GetColliderRid() *RID

	GetColliderShape() int64

	GetColliderVelocity() *Vector2

	GetCollisionNormal() *Vector2

	GetCollisionPoint() *Vector2

	GetMotion() *Vector2

	GetMotionRemainder() *Vector2
}

/*
   PhysicsBody is an abstract base class for implementing a physics body. All PhysicsBody types inherit from it.
*/
type PhysicsBody struct {
	CollisionObject
}

func (o *PhysicsBody) baseClass() string {
	return "PhysicsBody"
}

/*
   Adds a body to the collision exception list. This list contains bodies that this body will not collide with.
*/
func (o *PhysicsBody) AddCollisionExceptionWith(body *Node) {
	log.Println("Calling PhysicsBody.AddCollisionExceptionWith()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_collision_exception_with", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsBody) GetCollisionLayer() int64 {
	log.Println("Calling PhysicsBody.GetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_layer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsBody) GetCollisionLayerBit(bit int64) *bool {
	log.Println("Calling PhysicsBody.GetCollisionLayerBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bit)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_layer_bit", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *PhysicsBody) GetCollisionMask() int64 {
	log.Println("Calling PhysicsBody.GetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsBody) GetCollisionMaskBit(bit int64) *bool {
	log.Println("Calling PhysicsBody.GetCollisionMaskBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bit)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_mask_bit", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Removes a body from the collision exception list.
*/
func (o *PhysicsBody) RemoveCollisionExceptionWith(body *Node) {
	log.Println("Calling PhysicsBody.RemoveCollisionExceptionWith()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_collision_exception_with", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsBody) SetCollisionLayer(layer int64) {
	log.Println("Calling PhysicsBody.SetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsBody) SetCollisionLayerBit(bit int64, value *bool) {
	log.Println("Calling PhysicsBody.SetCollisionLayerBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(bit)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer_bit", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsBody) SetCollisionMask(mask int64) {
	log.Println("Calling PhysicsBody.SetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_mask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsBody) SetCollisionMaskBit(bit int64, value *bool) {
	log.Println("Calling PhysicsBody.SetCollisionMaskBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(bit)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_mask_bit", goArguments, "")

	log.Println("Got return value!")

}

/*
   PhysicsBodyImplementer is an interface for PhysicsBody objects.
   PhysicsBody is an abstract base class for implementing a physics body. All PhysicsBody types inherit from it.
*/
type PhysicsBodyImplementer interface {
	CollisionObjectImplementer

	AddCollisionExceptionWith(body *Node)

	GetCollisionLayer() int64

	GetCollisionLayerBit(bit int64) *bool

	GetCollisionMask() int64

	GetCollisionMaskBit(bit int64) *bool

	RemoveCollisionExceptionWith(body *Node)

	SetCollisionLayer(layer int64)

	SetCollisionLayerBit(bit int64, value *bool)

	SetCollisionMask(mask int64)

	SetCollisionMaskBit(bit int64, value *bool)
}

/*
   PhysicsBody2D is an abstract base class for implementing a physics body. All *Body2D types inherit from it.
*/
type PhysicsBody2D struct {
	CollisionObject2D
}

func (o *PhysicsBody2D) baseClass() string {
	return "PhysicsBody2D"
}

/*

 */
func (o *PhysicsBody2D) AddCollisionExceptionWith(body *Node) {
	log.Println("Calling PhysicsBody2D.AddCollisionExceptionWith()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_collision_exception_with", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the physics layer this area is in.
*/
func (o *PhysicsBody2D) GetCollisionLayer() int64 {
	log.Println("Calling PhysicsBody2D.GetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_layer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return an individual bit on the collision mask.
*/
func (o *PhysicsBody2D) GetCollisionLayerBit(bit int64) *bool {
	log.Println("Calling PhysicsBody2D.GetCollisionLayerBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bit)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_layer_bit", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return the physics layers this area can scan for collisions.
*/
func (o *PhysicsBody2D) GetCollisionMask() int64 {
	log.Println("Calling PhysicsBody2D.GetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return an individual bit on the collision mask.
*/
func (o *PhysicsBody2D) GetCollisionMaskBit(bit int64) *bool {
	log.Println("Calling PhysicsBody2D.GetCollisionMaskBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bit)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_mask_bit", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *PhysicsBody2D) RemoveCollisionExceptionWith(body *Node) {
	log.Println("Calling PhysicsBody2D.RemoveCollisionExceptionWith()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_collision_exception_with", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set the physics layers this area is in.
				Collidable objects can exist in any of 32 different layers. These layers are not visual, but more of a tagging system instead. A collidable can use these layers/tags to select with which objects it can collide, using [method set_collision_mask].
				A contact is detected if object A is in any of the layers that object B scans, or object B is in any layer scanned by object A.
*/
func (o *PhysicsBody2D) SetCollisionLayer(layer int64) {
	log.Println("Calling PhysicsBody2D.SetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set/clear individual bits on the layer mask. This makes getting a body in/out of only one layer easier.
*/
func (o *PhysicsBody2D) SetCollisionLayerBit(bit int64, value *bool) {
	log.Println("Calling PhysicsBody2D.SetCollisionLayerBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(bit)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer_bit", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the physics layers this area can scan for collisions.
*/
func (o *PhysicsBody2D) SetCollisionMask(mask int64) {
	log.Println("Calling PhysicsBody2D.SetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_mask", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set/clear individual bits on the collision mask. This makes selecting the areas scanned easier.
*/
func (o *PhysicsBody2D) SetCollisionMaskBit(bit int64, value *bool) {
	log.Println("Calling PhysicsBody2D.SetCollisionMaskBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(bit)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_mask_bit", goArguments, "")

	log.Println("Got return value!")

}

/*
   PhysicsBody2DImplementer is an interface for PhysicsBody2D objects.
   PhysicsBody2D is an abstract base class for implementing a physics body. All *Body2D types inherit from it.
*/
type PhysicsBody2DImplementer interface {
	CollisionObject2DImplementer

	AddCollisionExceptionWith(body *Node)

	GetCollisionLayer() int64

	GetCollisionLayerBit(bit int64) *bool

	GetCollisionMask() int64

	GetCollisionMaskBit(bit int64) *bool

	RemoveCollisionExceptionWith(body *Node)

	SetCollisionLayer(layer int64)

	SetCollisionLayerBit(bit int64, value *bool)

	SetCollisionMask(mask int64)

	SetCollisionMaskBit(bit int64, value *bool)
}

/*

 */
type PhysicsDirectBodyState struct {
	Object
}

func (o *PhysicsDirectBodyState) baseClass() string {
	return "PhysicsDirectBodyState"
}

/*

 */
func (o *PhysicsDirectBodyState) AddForce(force *Vector3, pos *Vector3) {
	log.Println("Calling PhysicsDirectBodyState.AddForce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(force)
	goArguments[1] = reflect.ValueOf(pos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_force", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsDirectBodyState) ApplyImpulse(pos *Vector3, j *Vector3) {
	log.Println("Calling PhysicsDirectBodyState.ApplyImpulse()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(pos)
	goArguments[1] = reflect.ValueOf(j)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "apply_impulse", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsDirectBodyState) ApplyTorqeImpulse(j *Vector3) {
	log.Println("Calling PhysicsDirectBodyState.ApplyTorqeImpulse()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(j)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "apply_torqe_impulse", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsDirectBodyState) GetAngularVelocity() *Vector3 {
	log.Println("Calling PhysicsDirectBodyState.GetAngularVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_angular_velocity", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetCenterOfMass() *Vector3 {
	log.Println("Calling PhysicsDirectBodyState.GetCenterOfMass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_center_of_mass", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactCollider(contactIdx int64) *RID {
	log.Println("Calling PhysicsDirectBodyState.GetContactCollider()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_collider", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactColliderId(contactIdx int64) int64 {
	log.Println("Calling PhysicsDirectBodyState.GetContactColliderId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_collider_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactColliderObject(contactIdx int64) *Object {
	log.Println("Calling PhysicsDirectBodyState.GetContactColliderObject()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_collider_object", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactColliderPos(contactIdx int64) *Vector3 {
	log.Println("Calling PhysicsDirectBodyState.GetContactColliderPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_collider_pos", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactColliderShape(contactIdx int64) int64 {
	log.Println("Calling PhysicsDirectBodyState.GetContactColliderShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_collider_shape", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactColliderVelocityAtPos(contactIdx int64) *Vector3 {
	log.Println("Calling PhysicsDirectBodyState.GetContactColliderVelocityAtPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_collider_velocity_at_pos", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactCount() int64 {
	log.Println("Calling PhysicsDirectBodyState.GetContactCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactLocalNormal(contactIdx int64) *Vector3 {
	log.Println("Calling PhysicsDirectBodyState.GetContactLocalNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_local_normal", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactLocalPos(contactIdx int64) *Vector3 {
	log.Println("Calling PhysicsDirectBodyState.GetContactLocalPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_local_pos", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetContactLocalShape(contactIdx int64) int64 {
	log.Println("Calling PhysicsDirectBodyState.GetContactLocalShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(contactIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_contact_local_shape", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetInverseInertia() *Vector3 {
	log.Println("Calling PhysicsDirectBodyState.GetInverseInertia()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_inverse_inertia", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetInverseMass() float64 {
	log.Println("Calling PhysicsDirectBodyState.GetInverseMass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_inverse_mass", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetLinearVelocity() *Vector3 {
	log.Println("Calling PhysicsDirectBodyState.GetLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_linear_velocity", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetPrincipalInertiaAxes() *Basis {
	log.Println("Calling PhysicsDirectBodyState.GetPrincipalInertiaAxes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_principal_inertia_axes", goArguments, "*Basis")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Basis)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetSpaceState() *PhysicsDirectSpaceState {
	log.Println("Calling PhysicsDirectBodyState.GetSpaceState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_space_state", goArguments, "*PhysicsDirectSpaceState")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PhysicsDirectSpaceState)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetStep() float64 {
	log.Println("Calling PhysicsDirectBodyState.GetStep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_step", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetTotalAngularDamp() float64 {
	log.Println("Calling PhysicsDirectBodyState.GetTotalAngularDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_total_angular_damp", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetTotalGravity() *Vector3 {
	log.Println("Calling PhysicsDirectBodyState.GetTotalGravity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_total_gravity", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetTotalLinearDamp() float64 {
	log.Println("Calling PhysicsDirectBodyState.GetTotalLinearDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_total_linear_damp", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) GetTransform() *Transform {
	log.Println("Calling PhysicsDirectBodyState.GetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_transform", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) IntegrateForces() {
	log.Println("Calling PhysicsDirectBodyState.IntegrateForces()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "integrate_forces", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsDirectBodyState) IsSleeping() *bool {
	log.Println("Calling PhysicsDirectBodyState.IsSleeping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_sleeping", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *PhysicsDirectBodyState) SetAngularVelocity(velocity *Vector3) {
	log.Println("Calling PhysicsDirectBodyState.SetAngularVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(velocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_angular_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsDirectBodyState) SetLinearVelocity(velocity *Vector3) {
	log.Println("Calling PhysicsDirectBodyState.SetLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(velocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_linear_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsDirectBodyState) SetSleepState(enabled *bool) {
	log.Println("Calling PhysicsDirectBodyState.SetSleepState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sleep_state", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsDirectBodyState) SetTransform(transform *Transform) {
	log.Println("Calling PhysicsDirectBodyState.SetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   PhysicsDirectBodyStateImplementer is an interface for PhysicsDirectBodyState objects.

*/
type PhysicsDirectBodyStateImplementer interface {
	ObjectImplementer

	AddForce(force *Vector3, pos *Vector3)

	ApplyImpulse(pos *Vector3, j *Vector3)

	ApplyTorqeImpulse(j *Vector3)

	GetAngularVelocity() *Vector3

	GetCenterOfMass() *Vector3

	GetContactCollider(contactIdx int64) *RID

	GetContactColliderId(contactIdx int64) int64

	GetContactColliderObject(contactIdx int64) *Object

	GetContactColliderPos(contactIdx int64) *Vector3

	GetContactColliderShape(contactIdx int64) int64

	GetContactColliderVelocityAtPos(contactIdx int64) *Vector3

	GetContactCount() int64

	GetContactLocalNormal(contactIdx int64) *Vector3

	GetContactLocalPos(contactIdx int64) *Vector3

	GetContactLocalShape(contactIdx int64) int64

	GetInverseInertia() *Vector3

	GetInverseMass() float64

	GetLinearVelocity() *Vector3

	GetPrincipalInertiaAxes() *Basis

	GetSpaceState() *PhysicsDirectSpaceState

	GetStep() float64

	GetTotalAngularDamp() float64

	GetTotalGravity() *Vector3

	GetTotalLinearDamp() float64

	GetTransform() *Transform

	IntegrateForces()

	IsSleeping() *bool

	SetAngularVelocity(velocity *Vector3)

	SetLinearVelocity(velocity *Vector3)

	SetSleepState(enabled *bool)

	SetTransform(transform *Transform)
}

/*

 */
type PhysicsDirectBodyStateSW struct {
	PhysicsDirectBodyState
}

func (o *PhysicsDirectBodyStateSW) baseClass() string {
	return "PhysicsDirectBodyStateSW"
}

/*
   PhysicsDirectBodyStateSWImplementer is an interface for PhysicsDirectBodyStateSW objects.

*/
type PhysicsDirectBodyStateSWImplementer interface {
	PhysicsDirectBodyStateImplementer
}

/*

 */
type PhysicsDirectSpaceState struct {
	Object
}

func (o *PhysicsDirectSpaceState) baseClass() string {
	return "PhysicsDirectSpaceState"
}

/*

 */
func (o *PhysicsDirectSpaceState) CastMotion(shape *PhysicsShapeQueryParameters, motion *Vector3) *Array {
	log.Println("Calling PhysicsDirectSpaceState.CastMotion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(shape)
	goArguments[1] = reflect.ValueOf(motion)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "cast_motion", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *PhysicsDirectSpaceState) CollideShape(shape *PhysicsShapeQueryParameters, maxResults int64) *Array {
	log.Println("Calling PhysicsDirectSpaceState.CollideShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(shape)
	goArguments[1] = reflect.ValueOf(maxResults)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "collide_shape", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *PhysicsDirectSpaceState) GetRestInfo(shape *PhysicsShapeQueryParameters) *Dictionary {
	log.Println("Calling PhysicsDirectSpaceState.GetRestInfo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rest_info", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*

 */
func (o *PhysicsDirectSpaceState) IntersectRay(from *Vector3, to *Vector3, exclude *Array, collisionLayer int64, typeMask int64) *Dictionary {
	log.Println("Calling PhysicsDirectSpaceState.IntersectRay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(to)
	goArguments[2] = reflect.ValueOf(exclude)
	goArguments[3] = reflect.ValueOf(collisionLayer)
	goArguments[4] = reflect.ValueOf(typeMask)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "intersect_ray", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*

 */
func (o *PhysicsDirectSpaceState) IntersectShape(shape *PhysicsShapeQueryParameters, maxResults int64) *Array {
	log.Println("Calling PhysicsDirectSpaceState.IntersectShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(shape)
	goArguments[1] = reflect.ValueOf(maxResults)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "intersect_shape", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   PhysicsDirectSpaceStateImplementer is an interface for PhysicsDirectSpaceState objects.

*/
type PhysicsDirectSpaceStateImplementer interface {
	ObjectImplementer

	CastMotion(shape *PhysicsShapeQueryParameters, motion *Vector3) *Array

	CollideShape(shape *PhysicsShapeQueryParameters, maxResults int64) *Array

	GetRestInfo(shape *PhysicsShapeQueryParameters) *Dictionary

	IntersectRay(from *Vector3, to *Vector3, exclude *Array, collisionLayer int64, typeMask int64) *Dictionary

	IntersectShape(shape *PhysicsShapeQueryParameters, maxResults int64) *Array
}

/*

 */
type PhysicsServer struct {
	Object
}

func (o *PhysicsServer) baseClass() string {
	return "PhysicsServer"
}

/*

 */
func (o *PhysicsServer) AreaAddShape(area *RID, shape *RID, transform *Transform) {
	log.Println("Calling PhysicsServer.AreaAddShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(shape)
	goArguments[2] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_add_shape", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) AreaAttachObjectInstanceId(area *RID, id int64) {
	log.Println("Calling PhysicsServer.AreaAttachObjectInstanceId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_attach_object_instance_id", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) AreaClearShapes(area *RID) {
	log.Println("Calling PhysicsServer.AreaClearShapes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_clear_shapes", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) AreaCreate() *RID {
	log.Println("Calling PhysicsServer.AreaCreate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_create", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *PhysicsServer) AreaGetObjectInstanceId(area *RID) int64 {
	log.Println("Calling PhysicsServer.AreaGetObjectInstanceId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_object_instance_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsServer) AreaGetParam(area *RID, param int64) *Variant {
	log.Println("Calling PhysicsServer.AreaGetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_param", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *PhysicsServer) AreaGetShape(area *RID, shapeIdx int64) *RID {
	log.Println("Calling PhysicsServer.AreaGetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_shape", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *PhysicsServer) AreaGetShapeCount(area *RID) int64 {
	log.Println("Calling PhysicsServer.AreaGetShapeCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_shape_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsServer) AreaGetShapeTransform(area *RID, shapeIdx int64) *Transform {
	log.Println("Calling PhysicsServer.AreaGetShapeTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_shape_transform", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*

 */
func (o *PhysicsServer) AreaGetSpace(area *RID) *RID {
	log.Println("Calling PhysicsServer.AreaGetSpace()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_space", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *PhysicsServer) AreaGetSpaceOverrideMode(area *RID) int64 {
	log.Println("Calling PhysicsServer.AreaGetSpaceOverrideMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_space_override_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsServer) AreaGetTransform(area *RID) *Transform {
	log.Println("Calling PhysicsServer.AreaGetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_get_transform", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*

 */
func (o *PhysicsServer) AreaIsRayPickable(area *RID) *bool {
	log.Println("Calling PhysicsServer.AreaIsRayPickable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(area)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "area_is_ray_pickable", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *PhysicsServer) AreaRemoveShape(area *RID, shapeIdx int64) {
	log.Println("Calling PhysicsServer.AreaRemoveShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_remove_shape", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) AreaSetCollisionLayer(area *RID, layer int64) {
	log.Println("Calling PhysicsServer.AreaSetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_collision_layer", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) AreaSetCollisionMask(area *RID, mask int64) {
	log.Println("Calling PhysicsServer.AreaSetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_collision_mask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) AreaSetMonitorCallback(area *RID, receiver *Object, method string) {
	log.Println("Calling PhysicsServer.AreaSetMonitorCallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(receiver)
	goArguments[2] = reflect.ValueOf(method)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_monitor_callback", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) AreaSetParam(area *RID, param int64, value *Variant) {
	log.Println("Calling PhysicsServer.AreaSetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(param)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_param", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) AreaSetRayPickable(area *RID, enable *bool) {
	log.Println("Calling PhysicsServer.AreaSetRayPickable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_ray_pickable", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) AreaSetShape(area *RID, shapeIdx int64, shape *RID) {
	log.Println("Calling PhysicsServer.AreaSetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(shapeIdx)
	goArguments[2] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_shape", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) AreaSetShapeTransform(area *RID, shapeIdx int64, transform *Transform) {
	log.Println("Calling PhysicsServer.AreaSetShapeTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(shapeIdx)
	goArguments[2] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_shape_transform", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) AreaSetSpace(area *RID, space *RID) {
	log.Println("Calling PhysicsServer.AreaSetSpace()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(space)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_space", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) AreaSetSpaceOverrideMode(area *RID, mode int64) {
	log.Println("Calling PhysicsServer.AreaSetSpaceOverrideMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_space_override_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) AreaSetTransform(area *RID, transform *Transform) {
	log.Println("Calling PhysicsServer.AreaSetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(area)
	goArguments[1] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "area_set_transform", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) BodyAddCollisionException(body *RID, exceptedBody *RID) {
	log.Println("Calling PhysicsServer.BodyAddCollisionException()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(exceptedBody)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_add_collision_exception", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) BodyAddShape(body *RID, shape *RID, transform *Transform) {
	log.Println("Calling PhysicsServer.BodyAddShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shape)
	goArguments[2] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_add_shape", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) BodyApplyImpulse(body *RID, pos *Vector3, impulse *Vector3) {
	log.Println("Calling PhysicsServer.BodyApplyImpulse()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(pos)
	goArguments[2] = reflect.ValueOf(impulse)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_apply_impulse", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) BodyApplyTorqueImpulse(body *RID, impulse *Vector3) {
	log.Println("Calling PhysicsServer.BodyApplyTorqueImpulse()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(impulse)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_apply_torque_impulse", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) BodyAttachObjectInstanceId(body *RID, id int64) {
	log.Println("Calling PhysicsServer.BodyAttachObjectInstanceId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_attach_object_instance_id", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) BodyClearShapes(body *RID) {
	log.Println("Calling PhysicsServer.BodyClearShapes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_clear_shapes", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) BodyCreate(mode int64, initSleeping *bool) *RID {
	log.Println("Calling PhysicsServer.BodyCreate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(mode)
	goArguments[1] = reflect.ValueOf(initSleeping)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_create", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *PhysicsServer) BodyGetAxisLock(body *RID) int64 {
	log.Println("Calling PhysicsServer.BodyGetAxisLock()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_axis_lock", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsServer) BodyGetCollisionLayer(body *RID) int64 {
	log.Println("Calling PhysicsServer.BodyGetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_collision_layer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsServer) BodyGetCollisionMask(body *RID) int64 {
	log.Println("Calling PhysicsServer.BodyGetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_collision_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsServer) BodyGetMaxContactsReported(body *RID) int64 {
	log.Println("Calling PhysicsServer.BodyGetMaxContactsReported()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_max_contacts_reported", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsServer) BodyGetMode(body *RID) int64 {
	log.Println("Calling PhysicsServer.BodyGetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsServer) BodyGetObjectInstanceId(body *RID) int64 {
	log.Println("Calling PhysicsServer.BodyGetObjectInstanceId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_object_instance_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsServer) BodyGetParam(body *RID, param int64) float64 {
	log.Println("Calling PhysicsServer.BodyGetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *PhysicsServer) BodyGetShape(body *RID, shapeIdx int64) *RID {
	log.Println("Calling PhysicsServer.BodyGetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_shape", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *PhysicsServer) BodyGetShapeCount(body *RID) int64 {
	log.Println("Calling PhysicsServer.BodyGetShapeCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_shape_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsServer) BodyGetShapeTransform(body *RID, shapeIdx int64) *Transform {
	log.Println("Calling PhysicsServer.BodyGetShapeTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_shape_transform", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*

 */
func (o *PhysicsServer) BodyGetSpace(body *RID) *RID {
	log.Println("Calling PhysicsServer.BodyGetSpace()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_space", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *PhysicsServer) BodyGetState(body *RID, state int64) *Variant {
	log.Println("Calling PhysicsServer.BodyGetState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(state)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_get_state", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *PhysicsServer) BodyIsContinuousCollisionDetectionEnabled(body *RID) *bool {
	log.Println("Calling PhysicsServer.BodyIsContinuousCollisionDetectionEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_is_continuous_collision_detection_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *PhysicsServer) BodyIsOmittingForceIntegration(body *RID) *bool {
	log.Println("Calling PhysicsServer.BodyIsOmittingForceIntegration()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_is_omitting_force_integration", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *PhysicsServer) BodyIsRayPickable(body *RID) *bool {
	log.Println("Calling PhysicsServer.BodyIsRayPickable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "body_is_ray_pickable", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *PhysicsServer) BodyRemoveCollisionException(body *RID, exceptedBody *RID) {
	log.Println("Calling PhysicsServer.BodyRemoveCollisionException()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(exceptedBody)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_remove_collision_exception", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) BodyRemoveShape(body *RID, shapeIdx int64) {
	log.Println("Calling PhysicsServer.BodyRemoveShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shapeIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_remove_shape", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) BodySetAxisLock(body *RID, axis int64) {
	log.Println("Calling PhysicsServer.BodySetAxisLock()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(axis)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_axis_lock", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) BodySetAxisVelocity(body *RID, axisVelocity *Vector3) {
	log.Println("Calling PhysicsServer.BodySetAxisVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(axisVelocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_axis_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) BodySetCollisionLayer(body *RID, layer int64) {
	log.Println("Calling PhysicsServer.BodySetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_collision_layer", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) BodySetCollisionMask(body *RID, mask int64) {
	log.Println("Calling PhysicsServer.BodySetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_collision_mask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) BodySetEnableContinuousCollisionDetection(body *RID, enable *bool) {
	log.Println("Calling PhysicsServer.BodySetEnableContinuousCollisionDetection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_enable_continuous_collision_detection", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) BodySetForceIntegrationCallback(body *RID, receiver *Object, method string, userdata *Variant) {
	log.Println("Calling PhysicsServer.BodySetForceIntegrationCallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(receiver)
	goArguments[2] = reflect.ValueOf(method)
	goArguments[3] = reflect.ValueOf(userdata)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_force_integration_callback", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) BodySetMaxContactsReported(body *RID, amount int64) {
	log.Println("Calling PhysicsServer.BodySetMaxContactsReported()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_max_contacts_reported", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) BodySetMode(body *RID, mode int64) {
	log.Println("Calling PhysicsServer.BodySetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) BodySetOmitForceIntegration(body *RID, enable *bool) {
	log.Println("Calling PhysicsServer.BodySetOmitForceIntegration()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_omit_force_integration", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) BodySetParam(body *RID, param int64, value float64) {
	log.Println("Calling PhysicsServer.BodySetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(param)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_param", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) BodySetRayPickable(body *RID, enable *bool) {
	log.Println("Calling PhysicsServer.BodySetRayPickable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_ray_pickable", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) BodySetShape(body *RID, shapeIdx int64, shape *RID) {
	log.Println("Calling PhysicsServer.BodySetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shapeIdx)
	goArguments[2] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_shape", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) BodySetShapeTransform(body *RID, shapeIdx int64, transform *Transform) {
	log.Println("Calling PhysicsServer.BodySetShapeTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(shapeIdx)
	goArguments[2] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_shape_transform", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) BodySetSpace(body *RID, space *RID) {
	log.Println("Calling PhysicsServer.BodySetSpace()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(space)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_space", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) BodySetState(body *RID, state int64, value *Variant) {
	log.Println("Calling PhysicsServer.BodySetState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(body)
	goArguments[1] = reflect.ValueOf(state)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "body_set_state", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) ConeTwistJointGetParam(joint *RID, param int64) float64 {
	log.Println("Calling PhysicsServer.ConeTwistJointGetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "cone_twist_joint_get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *PhysicsServer) ConeTwistJointSetParam(joint *RID, param int64, value float64) {
	log.Println("Calling PhysicsServer.ConeTwistJointSetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(param)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "cone_twist_joint_set_param", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) FreeRid(rid *RID) {
	log.Println("Calling PhysicsServer.FreeRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rid)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "free_rid", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) Generic6DofJointGetFlag(joint *RID, axis int64, flag int64) *bool {
	log.Println("Calling PhysicsServer.Generic6DofJointGetFlag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(axis)
	goArguments[2] = reflect.ValueOf(flag)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "generic_6dof_joint_get_flag", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *PhysicsServer) Generic6DofJointGetParam(joint *RID, axis int64, param int64) float64 {
	log.Println("Calling PhysicsServer.Generic6DofJointGetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(axis)
	goArguments[2] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "generic_6dof_joint_get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *PhysicsServer) Generic6DofJointSetFlag(joint *RID, axis int64, flag int64, enable *bool) {
	log.Println("Calling PhysicsServer.Generic6DofJointSetFlag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(axis)
	goArguments[2] = reflect.ValueOf(flag)
	goArguments[3] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "generic_6dof_joint_set_flag", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) Generic6DofJointSetParam(joint *RID, axis int64, param int64, value float64) {
	log.Println("Calling PhysicsServer.Generic6DofJointSetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(axis)
	goArguments[2] = reflect.ValueOf(param)
	goArguments[3] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "generic_6dof_joint_set_param", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) GetProcessInfo(processInfo int64) int64 {
	log.Println("Calling PhysicsServer.GetProcessInfo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(processInfo)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_process_info", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsServer) HingeJointGetFlag(joint *RID, flag int64) *bool {
	log.Println("Calling PhysicsServer.HingeJointGetFlag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(flag)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "hinge_joint_get_flag", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *PhysicsServer) HingeJointGetParam(joint *RID, param int64) float64 {
	log.Println("Calling PhysicsServer.HingeJointGetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "hinge_joint_get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *PhysicsServer) HingeJointSetFlag(joint *RID, flag int64, enabled *bool) {
	log.Println("Calling PhysicsServer.HingeJointSetFlag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(flag)
	goArguments[2] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "hinge_joint_set_flag", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) HingeJointSetParam(joint *RID, param int64, value float64) {
	log.Println("Calling PhysicsServer.HingeJointSetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(param)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "hinge_joint_set_param", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) JointCreateConeTwist(bodyA *RID, localRefA *Transform, bodyB *RID, localRefB *Transform) *RID {
	log.Println("Calling PhysicsServer.JointCreateConeTwist()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(bodyA)
	goArguments[1] = reflect.ValueOf(localRefA)
	goArguments[2] = reflect.ValueOf(bodyB)
	goArguments[3] = reflect.ValueOf(localRefB)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "joint_create_cone_twist", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *PhysicsServer) JointCreateGeneric6Dof(bodyA *RID, localRefA *Transform, bodyB *RID, localRefB *Transform) *RID {
	log.Println("Calling PhysicsServer.JointCreateGeneric6Dof()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(bodyA)
	goArguments[1] = reflect.ValueOf(localRefA)
	goArguments[2] = reflect.ValueOf(bodyB)
	goArguments[3] = reflect.ValueOf(localRefB)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "joint_create_generic_6dof", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *PhysicsServer) JointCreateHinge(bodyA *RID, hingeA *Transform, bodyB *RID, hingeB *Transform) *RID {
	log.Println("Calling PhysicsServer.JointCreateHinge()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(bodyA)
	goArguments[1] = reflect.ValueOf(hingeA)
	goArguments[2] = reflect.ValueOf(bodyB)
	goArguments[3] = reflect.ValueOf(hingeB)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "joint_create_hinge", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *PhysicsServer) JointCreatePin(bodyA *RID, localA *Vector3, bodyB *RID, localB *Vector3) *RID {
	log.Println("Calling PhysicsServer.JointCreatePin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(bodyA)
	goArguments[1] = reflect.ValueOf(localA)
	goArguments[2] = reflect.ValueOf(bodyB)
	goArguments[3] = reflect.ValueOf(localB)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "joint_create_pin", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *PhysicsServer) JointCreateSlider(bodyA *RID, localRefA *Transform, bodyB *RID, localRefB *Transform) *RID {
	log.Println("Calling PhysicsServer.JointCreateSlider()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(bodyA)
	goArguments[1] = reflect.ValueOf(localRefA)
	goArguments[2] = reflect.ValueOf(bodyB)
	goArguments[3] = reflect.ValueOf(localRefB)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "joint_create_slider", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *PhysicsServer) JointGetSolverPriority(joint *RID) int64 {
	log.Println("Calling PhysicsServer.JointGetSolverPriority()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(joint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "joint_get_solver_priority", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsServer) JointGetType(joint *RID) int64 {
	log.Println("Calling PhysicsServer.JointGetType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(joint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "joint_get_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsServer) JointSetSolverPriority(joint *RID, priority int64) {
	log.Println("Calling PhysicsServer.JointSetSolverPriority()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(priority)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "joint_set_solver_priority", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) PinJointGetLocalA(joint *RID) *Vector3 {
	log.Println("Calling PhysicsServer.PinJointGetLocalA()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(joint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "pin_joint_get_local_a", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *PhysicsServer) PinJointGetLocalB(joint *RID) *Vector3 {
	log.Println("Calling PhysicsServer.PinJointGetLocalB()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(joint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "pin_joint_get_local_b", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *PhysicsServer) PinJointGetParam(joint *RID, param int64) float64 {
	log.Println("Calling PhysicsServer.PinJointGetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "pin_joint_get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *PhysicsServer) PinJointSetLocalA(joint *RID, localA *Vector3) {
	log.Println("Calling PhysicsServer.PinJointSetLocalA()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(localA)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "pin_joint_set_local_a", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) PinJointSetLocalB(joint *RID, localB *Vector3) {
	log.Println("Calling PhysicsServer.PinJointSetLocalB()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(localB)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "pin_joint_set_local_b", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) PinJointSetParam(joint *RID, param int64, value float64) {
	log.Println("Calling PhysicsServer.PinJointSetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(param)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "pin_joint_set_param", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) SetActive(active *bool) {
	log.Println("Calling PhysicsServer.SetActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(active)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_active", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) ShapeCreate(aType int64) *RID {
	log.Println("Calling PhysicsServer.ShapeCreate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_create", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *PhysicsServer) ShapeGetData(shape *RID) *Variant {
	log.Println("Calling PhysicsServer.ShapeGetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_get_data", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *PhysicsServer) ShapeGetType(shape *RID) int64 {
	log.Println("Calling PhysicsServer.ShapeGetType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "shape_get_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsServer) ShapeSetData(shape *RID, data *Variant) {
	log.Println("Calling PhysicsServer.ShapeSetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(shape)
	goArguments[1] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "shape_set_data", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) SliderJointGetParam(joint *RID, param int64) float64 {
	log.Println("Calling PhysicsServer.SliderJointGetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "slider_joint_get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *PhysicsServer) SliderJointSetParam(joint *RID, param int64, value float64) {
	log.Println("Calling PhysicsServer.SliderJointSetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(joint)
	goArguments[1] = reflect.ValueOf(param)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "slider_joint_set_param", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) SpaceCreate() *RID {
	log.Println("Calling PhysicsServer.SpaceCreate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "space_create", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *PhysicsServer) SpaceGetDirectState(space *RID) *PhysicsDirectSpaceState {
	log.Println("Calling PhysicsServer.SpaceGetDirectState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(space)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "space_get_direct_state", goArguments, "*PhysicsDirectSpaceState")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PhysicsDirectSpaceState)

	return returnValue

}

/*

 */
func (o *PhysicsServer) SpaceGetParam(space *RID, param int64) float64 {
	log.Println("Calling PhysicsServer.SpaceGetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(space)
	goArguments[1] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "space_get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *PhysicsServer) SpaceIsActive(space *RID) *bool {
	log.Println("Calling PhysicsServer.SpaceIsActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(space)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "space_is_active", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *PhysicsServer) SpaceSetActive(space *RID, active *bool) {
	log.Println("Calling PhysicsServer.SpaceSetActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(space)
	goArguments[1] = reflect.ValueOf(active)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "space_set_active", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsServer) SpaceSetParam(space *RID, param int64, value float64) {
	log.Println("Calling PhysicsServer.SpaceSetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(space)
	goArguments[1] = reflect.ValueOf(param)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "space_set_param", goArguments, "")

	log.Println("Got return value!")

}

/*
   PhysicsServerImplementer is an interface for PhysicsServer objects.

*/
type PhysicsServerImplementer interface {
	ObjectImplementer

	AreaAddShape(area *RID, shape *RID, transform *Transform)

	AreaAttachObjectInstanceId(area *RID, id int64)

	AreaClearShapes(area *RID)

	AreaCreate() *RID

	AreaGetObjectInstanceId(area *RID) int64

	AreaGetParam(area *RID, param int64) *Variant

	AreaGetShape(area *RID, shapeIdx int64) *RID

	AreaGetShapeCount(area *RID) int64

	AreaGetShapeTransform(area *RID, shapeIdx int64) *Transform

	AreaGetSpace(area *RID) *RID

	AreaGetSpaceOverrideMode(area *RID) int64

	AreaGetTransform(area *RID) *Transform

	AreaIsRayPickable(area *RID) *bool

	AreaRemoveShape(area *RID, shapeIdx int64)

	AreaSetCollisionLayer(area *RID, layer int64)

	AreaSetCollisionMask(area *RID, mask int64)

	AreaSetMonitorCallback(area *RID, receiver *Object, method string)

	AreaSetParam(area *RID, param int64, value *Variant)

	AreaSetRayPickable(area *RID, enable *bool)

	AreaSetShape(area *RID, shapeIdx int64, shape *RID)

	AreaSetShapeTransform(area *RID, shapeIdx int64, transform *Transform)

	AreaSetSpace(area *RID, space *RID)

	AreaSetSpaceOverrideMode(area *RID, mode int64)

	AreaSetTransform(area *RID, transform *Transform)

	BodyAddCollisionException(body *RID, exceptedBody *RID)

	BodyAddShape(body *RID, shape *RID, transform *Transform)

	BodyApplyImpulse(body *RID, pos *Vector3, impulse *Vector3)

	BodyApplyTorqueImpulse(body *RID, impulse *Vector3)

	BodyAttachObjectInstanceId(body *RID, id int64)

	BodyClearShapes(body *RID)

	BodyCreate(mode int64, initSleeping *bool) *RID

	BodyGetAxisLock(body *RID) int64

	BodyGetCollisionLayer(body *RID) int64

	BodyGetCollisionMask(body *RID) int64

	BodyGetMaxContactsReported(body *RID) int64

	BodyGetMode(body *RID) int64

	BodyGetObjectInstanceId(body *RID) int64

	BodyGetParam(body *RID, param int64) float64

	BodyGetShape(body *RID, shapeIdx int64) *RID

	BodyGetShapeCount(body *RID) int64

	BodyGetShapeTransform(body *RID, shapeIdx int64) *Transform

	BodyGetSpace(body *RID) *RID

	BodyGetState(body *RID, state int64) *Variant

	BodyIsContinuousCollisionDetectionEnabled(body *RID) *bool

	BodyIsOmittingForceIntegration(body *RID) *bool

	BodyIsRayPickable(body *RID) *bool

	BodyRemoveCollisionException(body *RID, exceptedBody *RID)

	BodyRemoveShape(body *RID, shapeIdx int64)

	BodySetAxisLock(body *RID, axis int64)

	BodySetAxisVelocity(body *RID, axisVelocity *Vector3)

	BodySetCollisionLayer(body *RID, layer int64)

	BodySetCollisionMask(body *RID, mask int64)

	BodySetEnableContinuousCollisionDetection(body *RID, enable *bool)

	BodySetForceIntegrationCallback(body *RID, receiver *Object, method string, userdata *Variant)

	BodySetMaxContactsReported(body *RID, amount int64)

	BodySetMode(body *RID, mode int64)

	BodySetOmitForceIntegration(body *RID, enable *bool)

	BodySetParam(body *RID, param int64, value float64)

	BodySetRayPickable(body *RID, enable *bool)

	BodySetShape(body *RID, shapeIdx int64, shape *RID)

	BodySetShapeTransform(body *RID, shapeIdx int64, transform *Transform)

	BodySetSpace(body *RID, space *RID)

	BodySetState(body *RID, state int64, value *Variant)

	ConeTwistJointGetParam(joint *RID, param int64) float64

	ConeTwistJointSetParam(joint *RID, param int64, value float64)

	FreeRid(rid *RID)

	Generic6DofJointGetFlag(joint *RID, axis int64, flag int64) *bool

	Generic6DofJointGetParam(joint *RID, axis int64, param int64) float64

	Generic6DofJointSetFlag(joint *RID, axis int64, flag int64, enable *bool)

	Generic6DofJointSetParam(joint *RID, axis int64, param int64, value float64)

	GetProcessInfo(processInfo int64) int64

	HingeJointGetFlag(joint *RID, flag int64) *bool

	HingeJointGetParam(joint *RID, param int64) float64

	HingeJointSetFlag(joint *RID, flag int64, enabled *bool)

	HingeJointSetParam(joint *RID, param int64, value float64)

	JointCreateConeTwist(bodyA *RID, localRefA *Transform, bodyB *RID, localRefB *Transform) *RID

	JointCreateGeneric6Dof(bodyA *RID, localRefA *Transform, bodyB *RID, localRefB *Transform) *RID

	JointCreateHinge(bodyA *RID, hingeA *Transform, bodyB *RID, hingeB *Transform) *RID

	JointCreatePin(bodyA *RID, localA *Vector3, bodyB *RID, localB *Vector3) *RID

	JointCreateSlider(bodyA *RID, localRefA *Transform, bodyB *RID, localRefB *Transform) *RID

	JointGetSolverPriority(joint *RID) int64

	JointGetType(joint *RID) int64

	JointSetSolverPriority(joint *RID, priority int64)

	PinJointGetLocalA(joint *RID) *Vector3

	PinJointGetLocalB(joint *RID) *Vector3

	PinJointGetParam(joint *RID, param int64) float64

	PinJointSetLocalA(joint *RID, localA *Vector3)

	PinJointSetLocalB(joint *RID, localB *Vector3)

	PinJointSetParam(joint *RID, param int64, value float64)

	SetActive(active *bool)

	ShapeCreate(aType int64) *RID

	ShapeGetData(shape *RID) *Variant

	ShapeGetType(shape *RID) int64

	ShapeSetData(shape *RID, data *Variant)

	SliderJointGetParam(joint *RID, param int64) float64

	SliderJointSetParam(joint *RID, param int64, value float64)

	SpaceCreate() *RID

	SpaceGetDirectState(space *RID) *PhysicsDirectSpaceState

	SpaceGetParam(space *RID, param int64) float64

	SpaceIsActive(space *RID) *bool

	SpaceSetActive(space *RID, active *bool)

	SpaceSetParam(space *RID, param int64, value float64)
}

/*

 */
type PhysicsServerSW struct {
	PhysicsServer
}

func (o *PhysicsServerSW) baseClass() string {
	return "PhysicsServerSW"
}

/*
   PhysicsServerSWImplementer is an interface for PhysicsServerSW objects.

*/
type PhysicsServerSWImplementer interface {
	PhysicsServerImplementer
}

/*

 */
type PhysicsShapeQueryParameters struct {
	Reference
}

func (o *PhysicsShapeQueryParameters) baseClass() string {
	return "PhysicsShapeQueryParameters"
}

/*

 */
func (o *PhysicsShapeQueryParameters) GetCollisionLayer() int64 {
	log.Println("Calling PhysicsShapeQueryParameters.GetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_layer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsShapeQueryParameters) GetExclude() *Array {
	log.Println("Calling PhysicsShapeQueryParameters.GetExclude()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_exclude", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *PhysicsShapeQueryParameters) GetMargin() float64 {
	log.Println("Calling PhysicsShapeQueryParameters.GetMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_margin", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *PhysicsShapeQueryParameters) GetObjectTypeMask() int64 {
	log.Println("Calling PhysicsShapeQueryParameters.GetObjectTypeMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_object_type_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsShapeQueryParameters) GetShapeRid() *RID {
	log.Println("Calling PhysicsShapeQueryParameters.GetShapeRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shape_rid", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *PhysicsShapeQueryParameters) GetTransform() *Transform {
	log.Println("Calling PhysicsShapeQueryParameters.GetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_transform", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*

 */
func (o *PhysicsShapeQueryParameters) SetCollisionLayer(collisionLayer int64) {
	log.Println("Calling PhysicsShapeQueryParameters.SetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collisionLayer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsShapeQueryParameters) SetExclude(exclude *Array) {
	log.Println("Calling PhysicsShapeQueryParameters.SetExclude()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(exclude)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_exclude", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsShapeQueryParameters) SetMargin(margin float64) {
	log.Println("Calling PhysicsShapeQueryParameters.SetMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_margin", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsShapeQueryParameters) SetObjectTypeMask(objectTypeMask int64) {
	log.Println("Calling PhysicsShapeQueryParameters.SetObjectTypeMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(objectTypeMask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_object_type_mask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsShapeQueryParameters) SetShape(shape *Resource) {
	log.Println("Calling PhysicsShapeQueryParameters.SetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shape", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsShapeQueryParameters) SetShapeRid(shape *RID) {
	log.Println("Calling PhysicsShapeQueryParameters.SetShapeRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shape_rid", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PhysicsShapeQueryParameters) SetTransform(transform *Transform) {
	log.Println("Calling PhysicsShapeQueryParameters.SetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   PhysicsShapeQueryParametersImplementer is an interface for PhysicsShapeQueryParameters objects.

*/
type PhysicsShapeQueryParametersImplementer interface {
	ReferenceImplementer

	GetCollisionLayer() int64

	GetExclude() *Array

	GetMargin() float64

	GetObjectTypeMask() int64

	GetShapeRid() *RID

	GetTransform() *Transform

	SetCollisionLayer(collisionLayer int64)

	SetExclude(exclude *Array)

	SetMargin(margin float64)

	SetObjectTypeMask(objectTypeMask int64)

	SetShape(shape *Resource)

	SetShapeRid(shape *RID)

	SetTransform(transform *Transform)
}

/*

 */
type PhysicsShapeQueryResult struct {
	Reference
}

func (o *PhysicsShapeQueryResult) baseClass() string {
	return "PhysicsShapeQueryResult"
}

/*

 */
func (o *PhysicsShapeQueryResult) GetResultCount() int64 {
	log.Println("Calling PhysicsShapeQueryResult.GetResultCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_result_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsShapeQueryResult) GetResultObject(idx int64) *Object {
	log.Println("Calling PhysicsShapeQueryResult.GetResultObject()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_result_object", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*

 */
func (o *PhysicsShapeQueryResult) GetResultObjectId(idx int64) int64 {
	log.Println("Calling PhysicsShapeQueryResult.GetResultObjectId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_result_object_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsShapeQueryResult) GetResultObjectShape(idx int64) int64 {
	log.Println("Calling PhysicsShapeQueryResult.GetResultObjectShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_result_object_shape", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PhysicsShapeQueryResult) GetResultRid(idx int64) *RID {
	log.Println("Calling PhysicsShapeQueryResult.GetResultRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_result_rid", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   PhysicsShapeQueryResultImplementer is an interface for PhysicsShapeQueryResult objects.

*/
type PhysicsShapeQueryResultImplementer interface {
	ReferenceImplementer

	GetResultCount() int64

	GetResultObject(idx int64) *Object

	GetResultObjectId(idx int64) int64

	GetResultObjectShape(idx int64) int64

	GetResultRid(idx int64) *RID
}

/*

 */
type PinJoint struct {
	Joint
}

func (o *PinJoint) baseClass() string {
	return "PinJoint"
}

/*

 */
func (o *PinJoint) GetParam(param int64) float64 {
	log.Println("Calling PinJoint.GetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *PinJoint) SetParam(param int64, value float64) {
	log.Println("Calling PinJoint.SetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(param)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_param", goArguments, "")

	log.Println("Got return value!")

}

/*
   PinJointImplementer is an interface for PinJoint objects.

*/
type PinJointImplementer interface {
	JointImplementer

	GetParam(param int64) float64

	SetParam(param int64, value float64)
}

/*
   Pin Joint for 2D Rigid Bodies. It pins 2 bodies (rigid or static) together, or a single body to a fixed position in space.
*/
type PinJoint2D struct {
	Joint2D
}

func (o *PinJoint2D) baseClass() string {
	return "PinJoint2D"
}

/*

 */
func (o *PinJoint2D) GetSoftness() float64 {
	log.Println("Calling PinJoint2D.GetSoftness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_softness", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *PinJoint2D) SetSoftness(softness float64) {
	log.Println("Calling PinJoint2D.SetSoftness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(softness)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_softness", goArguments, "")

	log.Println("Got return value!")

}

/*
   PinJoint2DImplementer is an interface for PinJoint2D objects.
   Pin Joint for 2D Rigid Bodies. It pins 2 bodies (rigid or static) together, or a single body to a fixed position in space.
*/
type PinJoint2DImplementer interface {
	Joint2DImplementer

	GetSoftness() float64

	SetSoftness(softness float64)
}

/*

 */
type PlaneMesh struct {
	PrimitiveMesh
}

func (o *PlaneMesh) baseClass() string {
	return "PlaneMesh"
}

/*

 */
func (o *PlaneMesh) GetSize() *Vector2 {
	log.Println("Calling PlaneMesh.GetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *PlaneMesh) GetSubdivideDepth() int64 {
	log.Println("Calling PlaneMesh.GetSubdivideDepth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_subdivide_depth", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PlaneMesh) GetSubdivideWidth() int64 {
	log.Println("Calling PlaneMesh.GetSubdivideWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_subdivide_width", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PlaneMesh) SetSize(size *Vector2) {
	log.Println("Calling PlaneMesh.SetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PlaneMesh) SetSubdivideDepth(subdivide int64) {
	log.Println("Calling PlaneMesh.SetSubdivideDepth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(subdivide)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_subdivide_depth", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PlaneMesh) SetSubdivideWidth(subdivide int64) {
	log.Println("Calling PlaneMesh.SetSubdivideWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(subdivide)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_subdivide_width", goArguments, "")

	log.Println("Got return value!")

}

/*
   PlaneMeshImplementer is an interface for PlaneMesh objects.

*/
type PlaneMeshImplementer interface {
	PrimitiveMeshImplementer

	GetSize() *Vector2

	GetSubdivideDepth() int64

	GetSubdivideWidth() int64

	SetSize(size *Vector2)

	SetSubdivideDepth(subdivide int64)

	SetSubdivideWidth(subdivide int64)
}

/*

 */
type PlaneShape struct {
	Shape
}

func (o *PlaneShape) baseClass() string {
	return "PlaneShape"
}

/*

 */
func (o *PlaneShape) GetPlane() *Plane {
	log.Println("Calling PlaneShape.GetPlane()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_plane", goArguments, "*Plane")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Plane)

	return returnValue

}

/*

 */
func (o *PlaneShape) SetPlane(plane *Plane) {
	log.Println("Calling PlaneShape.SetPlane()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(plane)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_plane", goArguments, "")

	log.Println("Got return value!")

}

/*
   PlaneShapeImplementer is an interface for PlaneShape objects.

*/
type PlaneShapeImplementer interface {
	ShapeImplementer

	GetPlane() *Plane

	SetPlane(plane *Plane)
}

/*
   A Polygon2D is defined by a set of n vertices connected together by line segments, meaning that the vertex 1 will be connected with vertex 2, vertex 2 with vertex 3 ..., vertex n-1 with vertex n and vertex n with vertex 1 in order to close the loop and define a polygon.
*/
type Polygon2D struct {
	Node2D
}

func (o *Polygon2D) baseClass() string {
	return "Polygon2D"
}

/*

 */
func (o *Polygon2D) GetAntialiased() *bool {
	log.Println("Calling Polygon2D.GetAntialiased()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_antialiased", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return the polygon fill color.
*/
func (o *Polygon2D) GetColor() *Color {
	log.Println("Calling Polygon2D.GetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*
   Return whether this polygon is inverted or not.
*/
func (o *Polygon2D) GetInvert() *bool {
	log.Println("Calling Polygon2D.GetInvert()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_invert", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return the added padding around the bounding box.
*/
func (o *Polygon2D) GetInvertBorder() float64 {
	log.Println("Calling Polygon2D.GetInvertBorder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_invert_border", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the offset for the polygon vertices.
*/
func (o *Polygon2D) GetOffset() *Vector2 {
	log.Println("Calling Polygon2D.GetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the set of vertices that defines this polygon.
*/
func (o *Polygon2D) GetPolygon() *PoolVector2Array {
	log.Println("Calling Polygon2D.GetPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_polygon", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*
   Return the polygon texture
*/
func (o *Polygon2D) GetTexture() *Texture {
	log.Println("Calling Polygon2D.GetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   Return the polygon texture offset.
*/
func (o *Polygon2D) GetTextureOffset() *Vector2 {
	log.Println("Calling Polygon2D.GetTextureOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the rotation in radians of the texture polygon.
*/
func (o *Polygon2D) GetTextureRotation() float64 {
	log.Println("Calling Polygon2D.GetTextureRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture_rotation", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the uv coordinate multiplier.
*/
func (o *Polygon2D) GetTextureScale() *Vector2 {
	log.Println("Calling Polygon2D.GetTextureScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture_scale", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the texture coordinates associated with every vertex of the polygon.
*/
func (o *Polygon2D) GetUv() *PoolVector2Array {
	log.Println("Calling Polygon2D.GetUv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_uv", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*
   Return the list of vertex colors.
*/
func (o *Polygon2D) GetVertexColors() *PoolColorArray {
	log.Println("Calling Polygon2D.GetVertexColors()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vertex_colors", goArguments, "*PoolColorArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolColorArray)

	return returnValue

}

/*

 */
func (o *Polygon2D) SetAntialiased(antialiased *bool) {
	log.Println("Calling Polygon2D.SetAntialiased()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(antialiased)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_antialiased", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the polygon fill color. If the polygon has a texture defined, the defined texture will be multiplied by the polygon fill color. This, also, is the default color for those vertices that are not defined by [method get_vertex_colors].
*/
func (o *Polygon2D) SetColor(color *Color) {
	log.Println("Calling Polygon2D.SetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_color", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the polygon as the defined polygon bounding box minus the defined polygon (the defined polygon will appear as a hole on the square that contains the defined polygon).
*/
func (o *Polygon2D) SetInvert(invert *bool) {
	log.Println("Calling Polygon2D.SetInvert()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(invert)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_invert", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add extra padding around the bounding box, making it bigger. Too small a value can make the polygon triangulate strangely, due to numerical imprecision.
*/
func (o *Polygon2D) SetInvertBorder(invertBorder float64) {
	log.Println("Calling Polygon2D.SetInvertBorder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(invertBorder)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_invert_border", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the an offset that will be added to the vertices' position. E.g. if the offset is set to (10,10) then all the polygon points will move 10 units to the right and 10 units to the bottom.
*/
func (o *Polygon2D) SetOffset(offset *Vector2) {
	log.Println("Calling Polygon2D.SetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Define the set of vertices that will represent the polygon.
*/
func (o *Polygon2D) SetPolygon(polygon *PoolVector2Array) {
	log.Println("Calling Polygon2D.SetPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(polygon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_polygon", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Polygon2D) SetTexture(texture *Texture) {
	log.Println("Calling Polygon2D.SetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the offset of the polygon texture. Initially the texture will appear anchored to the polygon position, the offset is used to move the texture location away from that point (notice that the texture origin is set to its top left corner, so when offset is 0,0 the top left corner of the texture is at the polygon position), for example setting the offset to 10, 10 will move the texture 10 units to the left and 10 units to the top.
*/
func (o *Polygon2D) SetTextureOffset(textureOffset *Vector2) {
	log.Println("Calling Polygon2D.SetTextureOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(textureOffset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the amount of rotation of the polygon texture, [code]texture_rotation[/code] is specified in radians and clockwise rotation.
*/
func (o *Polygon2D) SetTextureRotation(textureRotation float64) {
	log.Println("Calling Polygon2D.SetTextureRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(textureRotation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture_rotation", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the value that will multiply the uv coordinates ([method get_uv]) when applying the texture. Larger values make the texture smaller, and vice versa.
*/
func (o *Polygon2D) SetTextureScale(textureScale *Vector2) {
	log.Println("Calling Polygon2D.SetTextureScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(textureScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the texture coordinates for every vertex of the polygon. There should be one uv vertex for every vertex in the polygon. If there are less, the undefined ones will be assumed to be (0,0). Extra uv vertices are ignored.
*/
func (o *Polygon2D) SetUv(uv *PoolVector2Array) {
	log.Println("Calling Polygon2D.SetUv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(uv)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_uv", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set the color for each vertex of the polygon. There should be one color for every vertex in the polygon. If there are less, the undefined ones will be assumed to be [method get_color]. Extra color entries are ignored.
	Colors are interpolated between vertices, resulting in smooth gradients when they differ.
*/
func (o *Polygon2D) SetVertexColors(vertexColors *PoolColorArray) {
	log.Println("Calling Polygon2D.SetVertexColors()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vertexColors)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vertex_colors", goArguments, "")

	log.Println("Got return value!")

}

/*
   Polygon2DImplementer is an interface for Polygon2D objects.
   A Polygon2D is defined by a set of n vertices connected together by line segments, meaning that the vertex 1 will be connected with vertex 2, vertex 2 with vertex 3 ..., vertex n-1 with vertex n and vertex n with vertex 1 in order to close the loop and define a polygon.
*/
type Polygon2DImplementer interface {
	Node2DImplementer

	GetAntialiased() *bool

	GetColor() *Color

	GetInvert() *bool

	GetInvertBorder() float64

	GetOffset() *Vector2

	GetPolygon() *PoolVector2Array

	GetTexture() *Texture

	GetTextureOffset() *Vector2

	GetTextureRotation() float64

	GetTextureScale() *Vector2

	GetUv() *PoolVector2Array

	GetVertexColors() *PoolColorArray

	SetAntialiased(antialiased *bool)

	SetColor(color *Color)

	SetInvert(invert *bool)

	SetInvertBorder(invertBorder float64)

	SetOffset(offset *Vector2)

	SetPolygon(polygon *PoolVector2Array)

	SetTexture(texture *Texture)

	SetTextureOffset(textureOffset *Vector2)

	SetTextureRotation(textureRotation float64)

	SetTextureScale(textureScale *Vector2)

	SetUv(uv *PoolVector2Array)

	SetVertexColors(vertexColors *PoolColorArray)
}

/*

 */
type PolygonPathFinder struct {
	Resource
}

func (o *PolygonPathFinder) baseClass() string {
	return "PolygonPathFinder"
}

/*

 */
func (o *PolygonPathFinder) FindPath(from *Vector2, to *Vector2) *PoolVector2Array {
	log.Println("Calling PolygonPathFinder.FindPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(to)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "find_path", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*

 */
func (o *PolygonPathFinder) GetBounds() *Rect2 {
	log.Println("Calling PolygonPathFinder.GetBounds()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bounds", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*

 */
func (o *PolygonPathFinder) GetClosestPoint(point *Vector2) *Vector2 {
	log.Println("Calling PolygonPathFinder.GetClosestPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(point)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_closest_point", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *PolygonPathFinder) GetIntersections(from *Vector2, to *Vector2) *PoolVector2Array {
	log.Println("Calling PolygonPathFinder.GetIntersections()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(to)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_intersections", goArguments, "*PoolVector2Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolVector2Array)

	return returnValue

}

/*

 */
func (o *PolygonPathFinder) GetPointPenalty(idx int64) float64 {
	log.Println("Calling PolygonPathFinder.GetPointPenalty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_penalty", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *PolygonPathFinder) IsPointInside(point *Vector2) *bool {
	log.Println("Calling PolygonPathFinder.IsPointInside()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(point)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_point_inside", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *PolygonPathFinder) SetPointPenalty(idx int64, penalty float64) {
	log.Println("Calling PolygonPathFinder.SetPointPenalty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(penalty)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_penalty", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PolygonPathFinder) Setup(points *PoolVector2Array, connections *PoolIntArray) {
	log.Println("Calling PolygonPathFinder.Setup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(points)
	goArguments[1] = reflect.ValueOf(connections)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "setup", goArguments, "")

	log.Println("Got return value!")

}

/*
   PolygonPathFinderImplementer is an interface for PolygonPathFinder objects.

*/
type PolygonPathFinderImplementer interface {
	ResourceImplementer

	FindPath(from *Vector2, to *Vector2) *PoolVector2Array

	GetBounds() *Rect2

	GetClosestPoint(point *Vector2) *Vector2

	GetIntersections(from *Vector2, to *Vector2) *PoolVector2Array

	GetPointPenalty(idx int64) float64

	IsPointInside(point *Vector2) *bool

	SetPointPenalty(idx int64, penalty float64)

	Setup(points *PoolVector2Array, connections *PoolIntArray)
}

/*
   Popup is a base [Control] used to show dialogs and popups. It's a subwindow and modal by default (see [Control]) and has helpers for custom popup behavior.
*/
type Popup struct {
	Control
}

func (o *Popup) baseClass() string {
	return "Popup"
}

/*
   Returns whether the popup will hide other popups when shown on the screen.
*/
func (o *Popup) IsExclusive() *bool {
	log.Println("Calling Popup.IsExclusive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_exclusive", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Popup (show the control in modal form).
*/
func (o *Popup) Popup(bounds *Rect2) {
	log.Println("Calling Popup.Popup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bounds)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "popup", goArguments, "")

	log.Println("Got return value!")

}

/*
   Popup (show the control in modal form) in the center of the screen, at the current size, or at a size determined by "size".
*/
func (o *Popup) PopupCentered(size *Vector2) {
	log.Println("Calling Popup.PopupCentered()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "popup_centered", goArguments, "")

	log.Println("Got return value!")

}

/*
   Popup (show the control in modal form) in the center of the screen, ensuring the size is never smaller than [code]minsize[/code].
*/
func (o *Popup) PopupCenteredMinsize(minsize *Vector2) {
	log.Println("Calling Popup.PopupCenteredMinsize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(minsize)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "popup_centered_minsize", goArguments, "")

	log.Println("Got return value!")

}

/*
   Popup (show the control in modal form) in the center of the screen, scaled at a ratio of size of the screen.
*/
func (o *Popup) PopupCenteredRatio(ratio float64) {
	log.Println("Calling Popup.PopupCenteredRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ratio)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "popup_centered_ratio", goArguments, "")

	log.Println("Got return value!")

}

/*
   Make the popup hide other popups when shown on the screen.
*/
func (o *Popup) SetExclusive(enable *bool) {
	log.Println("Calling Popup.SetExclusive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_exclusive", goArguments, "")

	log.Println("Got return value!")

}

/*
   PopupImplementer is an interface for Popup objects.
   Popup is a base [Control] used to show dialogs and popups. It's a subwindow and modal by default (see [Control]) and has helpers for custom popup behavior.
*/
type PopupImplementer interface {
	ControlImplementer

	IsExclusive() *bool

	Popup(bounds *Rect2)

	PopupCentered(size *Vector2)

	PopupCenteredMinsize(minsize *Vector2)

	PopupCenteredRatio(ratio float64)

	SetExclusive(enable *bool)
}

/*
   PopupDialog is a base class for popup dialogs, along with [WindowDialog].
*/
type PopupDialog struct {
	Popup
}

func (o *PopupDialog) baseClass() string {
	return "PopupDialog"
}

/*
   PopupDialogImplementer is an interface for PopupDialog objects.
   PopupDialog is a base class for popup dialogs, along with [WindowDialog].
*/
type PopupDialogImplementer interface {
	PopupImplementer
}

/*
   PopupMenu is the typical Control that displays a list of options. They are popular in toolbars or context menus.
*/
type PopupMenu struct {
	Popup
}

func (o *PopupMenu) baseClass() string {
	return "PopupMenu"
}

/*
   Add a new checkable item with text "label". An id can optionally be provided, as well as an accelerator. If no id is provided, one will be created from the index. Note that checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually.
*/
func (o *PopupMenu) AddCheckItem(label string, id int64, accel int64) {
	log.Println("Calling PopupMenu.AddCheckItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(label)
	goArguments[1] = reflect.ValueOf(id)
	goArguments[2] = reflect.ValueOf(accel)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_check_item", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PopupMenu) AddCheckShortcut(shortcut *ShortCut, id int64, global *bool) {
	log.Println("Calling PopupMenu.AddCheckShortcut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(shortcut)
	goArguments[1] = reflect.ValueOf(id)
	goArguments[2] = reflect.ValueOf(global)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_check_shortcut", goArguments, "")

	log.Println("Got return value!")

}

/*
                Add a new checkable item with text "label" and icon "texture". An id can optionally be provided, as well as an accelerator. If no id is provided, one will be
				created from the index. Note that checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually.
*/
func (o *PopupMenu) AddIconCheckItem(texture *Texture, label string, id int64, accel int64) {
	log.Println("Calling PopupMenu.AddIconCheckItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(texture)
	goArguments[1] = reflect.ValueOf(label)
	goArguments[2] = reflect.ValueOf(id)
	goArguments[3] = reflect.ValueOf(accel)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_icon_check_item", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PopupMenu) AddIconCheckShortcut(texture *Texture, shortcut *ShortCut, id int64, global *bool) {
	log.Println("Calling PopupMenu.AddIconCheckShortcut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(texture)
	goArguments[1] = reflect.ValueOf(shortcut)
	goArguments[2] = reflect.ValueOf(id)
	goArguments[3] = reflect.ValueOf(global)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_icon_check_shortcut", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a new item with text "label" and icon "texture". An id can optionally be provided, as well as an accelerator keybinding. If no id is provided, one will be created from the index.
*/
func (o *PopupMenu) AddIconItem(texture *Texture, label string, id int64, accel int64) {
	log.Println("Calling PopupMenu.AddIconItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(texture)
	goArguments[1] = reflect.ValueOf(label)
	goArguments[2] = reflect.ValueOf(id)
	goArguments[3] = reflect.ValueOf(accel)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_icon_item", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PopupMenu) AddIconShortcut(texture *Texture, shortcut *ShortCut, id int64, global *bool) {
	log.Println("Calling PopupMenu.AddIconShortcut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(texture)
	goArguments[1] = reflect.ValueOf(shortcut)
	goArguments[2] = reflect.ValueOf(id)
	goArguments[3] = reflect.ValueOf(global)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_icon_shortcut", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a new item with text "label". An id can optionally be provided, as well as an accelerator keybinding. If no id is provided, one will be created from the index.
*/
func (o *PopupMenu) AddItem(label string, id int64, accel int64) {
	log.Println("Calling PopupMenu.AddItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(label)
	goArguments[1] = reflect.ValueOf(id)
	goArguments[2] = reflect.ValueOf(accel)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_item", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a separator between items. Separators also occupy an index.
*/
func (o *PopupMenu) AddSeparator() {
	log.Println("Calling PopupMenu.AddSeparator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_separator", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PopupMenu) AddShortcut(shortcut *ShortCut, id int64, global *bool) {
	log.Println("Calling PopupMenu.AddShortcut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(shortcut)
	goArguments[1] = reflect.ValueOf(id)
	goArguments[2] = reflect.ValueOf(global)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_shortcut", goArguments, "")

	log.Println("Got return value!")

}

/*
   Adds an item with a submenu. The submenu is the name of a child PopupMenu node that would be shown when the item is clicked. An id can optionally be provided, but if is isn't provided, one will be created from the index.
*/
func (o *PopupMenu) AddSubmenuItem(label string, submenu string, id int64) {
	log.Println("Calling PopupMenu.AddSubmenuItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(label)
	goArguments[1] = reflect.ValueOf(submenu)
	goArguments[2] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_submenu_item", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear the popup menu, in effect removing all items.
*/
func (o *PopupMenu) Clear() {
	log.Println("Calling PopupMenu.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the accelerator of the item at index "idx". Accelerators are special combinations of keys that activate the item, no matter which control is focused.
*/
func (o *PopupMenu) GetItemAccelerator(idx int64) int64 {
	log.Println("Calling PopupMenu.GetItemAccelerator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_accelerator", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the amount of items.
*/
func (o *PopupMenu) GetItemCount() int64 {
	log.Println("Calling PopupMenu.GetItemCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the icon of the item at index "idx".
*/
func (o *PopupMenu) GetItemIcon(idx int64) *Texture {
	log.Println("Calling PopupMenu.GetItemIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_icon", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   Return the id of the item at index "idx".
*/
func (o *PopupMenu) GetItemId(idx int64) int64 {
	log.Println("Calling PopupMenu.GetItemId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Find and return the index of the item containing a given id.
*/
func (o *PopupMenu) GetItemIndex(id int64) int64 {
	log.Println("Calling PopupMenu.GetItemIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_index", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the metadata of an item, which might be of any type. You can set it with [method set_item_metadata], which provides a simple way of assigning context data to items.
*/
func (o *PopupMenu) GetItemMetadata(idx int64) *Variant {
	log.Println("Calling PopupMenu.GetItemMetadata()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_metadata", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *PopupMenu) GetItemShortcut(idx int64) *ShortCut {
	log.Println("Calling PopupMenu.GetItemShortcut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_shortcut", goArguments, "*ShortCut")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*ShortCut)

	return returnValue

}

/*
   Return the submenu name of the item at index "idx".
*/
func (o *PopupMenu) GetItemSubmenu(idx int64) string {
	log.Println("Calling PopupMenu.GetItemSubmenu()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_submenu", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the text of the item at index "idx".
*/
func (o *PopupMenu) GetItemText(idx int64) string {
	log.Println("Calling PopupMenu.GetItemText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *PopupMenu) GetItemTooltip(idx int64) string {
	log.Println("Calling PopupMenu.GetItemTooltip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_tooltip", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Returns a boolean that indicates whether or not the PopupMenu will hide on checkable item selection.
*/
func (o *PopupMenu) IsHideOnCheckableItemSelection() *bool {
	log.Println("Calling PopupMenu.IsHideOnCheckableItemSelection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_hide_on_checkable_item_selection", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns a boolean that indicates whether or not the PopupMenu will hide on item selection.
*/
func (o *PopupMenu) IsHideOnItemSelection() *bool {
	log.Println("Calling PopupMenu.IsHideOnItemSelection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_hide_on_item_selection", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether the item at index "idx" has a checkbox. Note that checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually.
*/
func (o *PopupMenu) IsItemCheckable(idx int64) *bool {
	log.Println("Calling PopupMenu.IsItemCheckable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_item_checkable", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return the checkstate status of the item at index "idx".
*/
func (o *PopupMenu) IsItemChecked(idx int64) *bool {
	log.Println("Calling PopupMenu.IsItemChecked()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_item_checked", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether the item at index "idx" is disabled. When it is disabled it can't be selected, or its action invoked.
*/
func (o *PopupMenu) IsItemDisabled(idx int64) *bool {
	log.Println("Calling PopupMenu.IsItemDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_item_disabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether the item is a seperator. If it is, it would be displayed as a line.
*/
func (o *PopupMenu) IsItemSeparator(idx int64) *bool {
	log.Println("Calling PopupMenu.IsItemSeparator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_item_separator", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Removes the item at index "idx" from the menu. Note that the indexes of items after the removed item are going to be shifted by one.
*/
func (o *PopupMenu) RemoveItem(idx int64) {
	log.Println("Calling PopupMenu.RemoveItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_item", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets whether or not the PopupMenu will hide on checkable item selection.
*/
func (o *PopupMenu) SetHideOnCheckableItemSelection(enable *bool) {
	log.Println("Calling PopupMenu.SetHideOnCheckableItemSelection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_hide_on_checkable_item_selection", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets whether or not the PopupMenu will hide on item selection.
*/
func (o *PopupMenu) SetHideOnItemSelection(enable *bool) {
	log.Println("Calling PopupMenu.SetHideOnItemSelection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_hide_on_item_selection", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the accelerator of the item at index "idx". Accelerators are special combinations of keys that activate the item, no matter which control is focused.
*/
func (o *PopupMenu) SetItemAccelerator(idx int64, accel int64) {
	log.Println("Calling PopupMenu.SetItemAccelerator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(accel)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_accelerator", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether the item at index "idx" has a checkbox. Note that checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually.
*/
func (o *PopupMenu) SetItemAsCheckable(idx int64, enable *bool) {
	log.Println("Calling PopupMenu.SetItemAsCheckable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_as_checkable", goArguments, "")

	log.Println("Got return value!")

}

/*
   Mark the item at index "idx" as a seperator, which means that it would be displayed as a mere line.
*/
func (o *PopupMenu) SetItemAsSeparator(idx int64, enable *bool) {
	log.Println("Calling PopupMenu.SetItemAsSeparator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_as_separator", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the checkstate status of the item at index "idx".
*/
func (o *PopupMenu) SetItemChecked(idx int64, checked *bool) {
	log.Println("Calling PopupMenu.SetItemChecked()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(checked)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_checked", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets whether the item at index "idx" is disabled or not. When it is disabled it can't be selected, or its action invoked.
*/
func (o *PopupMenu) SetItemDisabled(idx int64, disabled *bool) {
	log.Println("Calling PopupMenu.SetItemDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(disabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_disabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PopupMenu) SetItemIcon(idx int64, icon *Texture) {
	log.Println("Calling PopupMenu.SetItemIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(icon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_icon", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the id of the item at index "idx".
*/
func (o *PopupMenu) SetItemId(idx int64, id int64) {
	log.Println("Calling PopupMenu.SetItemId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_id", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the metadata of an item, which might be of any type. You can later get it with [method get_item_metadata], which provides a simple way of assigning context data to items.
*/
func (o *PopupMenu) SetItemMetadata(idx int64, metadata *Variant) {
	log.Println("Calling PopupMenu.SetItemMetadata()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(metadata)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_metadata", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PopupMenu) SetItemShortcut(idx int64, shortcut *ShortCut, global *bool) {
	log.Println("Calling PopupMenu.SetItemShortcut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(shortcut)
	goArguments[2] = reflect.ValueOf(global)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_shortcut", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the submenu of the item at index "idx". The submenu is the name of a child PopupMenu node that would be shown when the item is clicked.
*/
func (o *PopupMenu) SetItemSubmenu(idx int64, submenu string) {
	log.Println("Calling PopupMenu.SetItemSubmenu()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(submenu)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_submenu", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the text of the item at index "idx".
*/
func (o *PopupMenu) SetItemText(idx int64, text string) {
	log.Println("Calling PopupMenu.SetItemText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_text", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PopupMenu) SetItemTooltip(idx int64, tooltip string) {
	log.Println("Calling PopupMenu.SetItemTooltip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(tooltip)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_item_tooltip", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PopupMenu) ToggleItemChecked(idx int64) {
	log.Println("Calling PopupMenu.ToggleItemChecked()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "toggle_item_checked", goArguments, "")

	log.Println("Got return value!")

}

/*
   PopupMenuImplementer is an interface for PopupMenu objects.
   PopupMenu is the typical Control that displays a list of options. They are popular in toolbars or context menus.
*/
type PopupMenuImplementer interface {
	PopupImplementer

	AddCheckItem(label string, id int64, accel int64)

	AddCheckShortcut(shortcut *ShortCut, id int64, global *bool)

	AddIconCheckItem(texture *Texture, label string, id int64, accel int64)

	AddIconCheckShortcut(texture *Texture, shortcut *ShortCut, id int64, global *bool)

	AddIconItem(texture *Texture, label string, id int64, accel int64)

	AddIconShortcut(texture *Texture, shortcut *ShortCut, id int64, global *bool)

	AddItem(label string, id int64, accel int64)

	AddSeparator()

	AddShortcut(shortcut *ShortCut, id int64, global *bool)

	AddSubmenuItem(label string, submenu string, id int64)

	Clear()

	GetItemAccelerator(idx int64) int64

	GetItemCount() int64

	GetItemIcon(idx int64) *Texture

	GetItemId(idx int64) int64

	GetItemIndex(id int64) int64

	GetItemMetadata(idx int64) *Variant

	GetItemShortcut(idx int64) *ShortCut

	GetItemSubmenu(idx int64) string

	GetItemText(idx int64) string

	GetItemTooltip(idx int64) string

	IsHideOnCheckableItemSelection() *bool

	IsHideOnItemSelection() *bool

	IsItemCheckable(idx int64) *bool

	IsItemChecked(idx int64) *bool

	IsItemDisabled(idx int64) *bool

	IsItemSeparator(idx int64) *bool

	RemoveItem(idx int64)

	SetHideOnCheckableItemSelection(enable *bool)

	SetHideOnItemSelection(enable *bool)

	SetItemAccelerator(idx int64, accel int64)

	SetItemAsCheckable(idx int64, enable *bool)

	SetItemAsSeparator(idx int64, enable *bool)

	SetItemChecked(idx int64, checked *bool)

	SetItemDisabled(idx int64, disabled *bool)

	SetItemIcon(idx int64, icon *Texture)

	SetItemId(idx int64, id int64)

	SetItemMetadata(idx int64, metadata *Variant)

	SetItemShortcut(idx int64, shortcut *ShortCut, global *bool)

	SetItemSubmenu(idx int64, submenu string)

	SetItemText(idx int64, text string)

	SetItemTooltip(idx int64, tooltip string)

	ToggleItemChecked(idx int64)
}

/*
   Class for displaying popups with a panel background. In some cases it might be simpler to use than [Popup], since it provides a configurable background. If you are making windows, better check [WindowDialog].
*/
type PopupPanel struct {
	Popup
}

func (o *PopupPanel) baseClass() string {
	return "PopupPanel"
}

/*
   PopupPanelImplementer is an interface for PopupPanel objects.
   Class for displaying popups with a panel background. In some cases it might be simpler to use than [Popup], since it provides a configurable background. If you are making windows, better check [WindowDialog].
*/
type PopupPanelImplementer interface {
	PopupImplementer
}

/*
   Generic 2D Position hint for editing. It's just like a plain [Node2D] but displays as a cross in the 2D-Editor at all times.
*/
type Position2D struct {
	Node2D
}

func (o *Position2D) baseClass() string {
	return "Position2D"
}

/*
   Position2DImplementer is an interface for Position2D objects.
   Generic 2D Position hint for editing. It's just like a plain [Node2D] but displays as a cross in the 2D-Editor at all times.
*/
type Position2DImplementer interface {
	Node2DImplementer
}

/*
   Generic 3D Position hint for editing. It's just like a plain [Spatial] but displays as a cross in the 3D-Editor at all times.
*/
type Position3D struct {
	Spatial
}

func (o *Position3D) baseClass() string {
	return "Position3D"
}

/*
   Position3DImplementer is an interface for Position3D objects.
   Generic 3D Position hint for editing. It's just like a plain [Spatial] but displays as a cross in the 3D-Editor at all times.
*/
type Position3DImplementer interface {
	SpatialImplementer
}

/*

 */
type PrimitiveMesh struct {
	Mesh
}

func (o *PrimitiveMesh) baseClass() string {
	return "PrimitiveMesh"
}

/*

 */
func (o *PrimitiveMesh) GetMaterial() *Material {
	log.Println("Calling PrimitiveMesh.GetMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_material", goArguments, "*Material")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Material)

	return returnValue

}

/*

 */
func (o *PrimitiveMesh) SetMaterial(material *Material) {
	log.Println("Calling PrimitiveMesh.SetMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(material)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_material", goArguments, "")

	log.Println("Got return value!")

}

/*
   PrimitiveMeshImplementer is an interface for PrimitiveMesh objects.

*/
type PrimitiveMeshImplementer interface {
	MeshImplementer

	GetMaterial() *Material

	SetMaterial(material *Material)
}

/*

 */
type PrismMesh struct {
	PrimitiveMesh
}

func (o *PrismMesh) baseClass() string {
	return "PrismMesh"
}

/*

 */
func (o *PrismMesh) GetLeftToRight() float64 {
	log.Println("Calling PrismMesh.GetLeftToRight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_left_to_right", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *PrismMesh) GetSize() *Vector3 {
	log.Println("Calling PrismMesh.GetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_size", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *PrismMesh) GetSubdivideDepth() int64 {
	log.Println("Calling PrismMesh.GetSubdivideDepth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_subdivide_depth", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PrismMesh) GetSubdivideHeight() int64 {
	log.Println("Calling PrismMesh.GetSubdivideHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_subdivide_height", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PrismMesh) GetSubdivideWidth() int64 {
	log.Println("Calling PrismMesh.GetSubdivideWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_subdivide_width", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *PrismMesh) SetLeftToRight(leftToRight float64) {
	log.Println("Calling PrismMesh.SetLeftToRight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(leftToRight)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_left_to_right", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PrismMesh) SetSize(size *Vector3) {
	log.Println("Calling PrismMesh.SetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PrismMesh) SetSubdivideDepth(segments int64) {
	log.Println("Calling PrismMesh.SetSubdivideDepth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(segments)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_subdivide_depth", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PrismMesh) SetSubdivideHeight(segments int64) {
	log.Println("Calling PrismMesh.SetSubdivideHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(segments)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_subdivide_height", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *PrismMesh) SetSubdivideWidth(segments int64) {
	log.Println("Calling PrismMesh.SetSubdivideWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(segments)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_subdivide_width", goArguments, "")

	log.Println("Got return value!")

}

/*
   PrismMeshImplementer is an interface for PrismMesh objects.

*/
type PrismMeshImplementer interface {
	PrimitiveMeshImplementer

	GetLeftToRight() float64

	GetSize() *Vector3

	GetSubdivideDepth() int64

	GetSubdivideHeight() int64

	GetSubdivideWidth() int64

	SetLeftToRight(leftToRight float64)

	SetSize(size *Vector3)

	SetSubdivideDepth(segments int64)

	SetSubdivideHeight(segments int64)

	SetSubdivideWidth(segments int64)
}

/*

 */
type ProceduralSky struct {
	Sky
}

func (o *ProceduralSky) baseClass() string {
	return "ProceduralSky"
}

/*

 */
func (o *ProceduralSky) GetGroundBottomColor() *Color {
	log.Println("Calling ProceduralSky.GetGroundBottomColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ground_bottom_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *ProceduralSky) GetGroundCurve() float64 {
	log.Println("Calling ProceduralSky.GetGroundCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ground_curve", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ProceduralSky) GetGroundEnergy() float64 {
	log.Println("Calling ProceduralSky.GetGroundEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ground_energy", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ProceduralSky) GetGroundHorizonColor() *Color {
	log.Println("Calling ProceduralSky.GetGroundHorizonColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ground_horizon_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *ProceduralSky) GetSkyCurve() float64 {
	log.Println("Calling ProceduralSky.GetSkyCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sky_curve", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ProceduralSky) GetSkyEnergy() float64 {
	log.Println("Calling ProceduralSky.GetSkyEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sky_energy", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ProceduralSky) GetSkyHorizonColor() *Color {
	log.Println("Calling ProceduralSky.GetSkyHorizonColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sky_horizon_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *ProceduralSky) GetSkyTopColor() *Color {
	log.Println("Calling ProceduralSky.GetSkyTopColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sky_top_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *ProceduralSky) GetSunAngleMax() float64 {
	log.Println("Calling ProceduralSky.GetSunAngleMax()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sun_angle_max", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ProceduralSky) GetSunAngleMin() float64 {
	log.Println("Calling ProceduralSky.GetSunAngleMin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sun_angle_min", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ProceduralSky) GetSunColor() *Color {
	log.Println("Calling ProceduralSky.GetSunColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sun_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *ProceduralSky) GetSunCurve() float64 {
	log.Println("Calling ProceduralSky.GetSunCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sun_curve", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ProceduralSky) GetSunEnergy() float64 {
	log.Println("Calling ProceduralSky.GetSunEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sun_energy", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ProceduralSky) GetSunLatitude() float64 {
	log.Println("Calling ProceduralSky.GetSunLatitude()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sun_latitude", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ProceduralSky) GetSunLongitude() float64 {
	log.Println("Calling ProceduralSky.GetSunLongitude()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_sun_longitude", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ProceduralSky) GetTextureSize() int64 {
	log.Println("Calling ProceduralSky.GetTextureSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ProceduralSky) SetGroundBottomColor(color *Color) {
	log.Println("Calling ProceduralSky.SetGroundBottomColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ground_bottom_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) SetGroundCurve(curve float64) {
	log.Println("Calling ProceduralSky.SetGroundCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(curve)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ground_curve", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) SetGroundEnergy(energy float64) {
	log.Println("Calling ProceduralSky.SetGroundEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(energy)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ground_energy", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) SetGroundHorizonColor(color *Color) {
	log.Println("Calling ProceduralSky.SetGroundHorizonColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ground_horizon_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) SetSkyCurve(curve float64) {
	log.Println("Calling ProceduralSky.SetSkyCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(curve)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sky_curve", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) SetSkyEnergy(energy float64) {
	log.Println("Calling ProceduralSky.SetSkyEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(energy)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sky_energy", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) SetSkyHorizonColor(color *Color) {
	log.Println("Calling ProceduralSky.SetSkyHorizonColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sky_horizon_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) SetSkyTopColor(color *Color) {
	log.Println("Calling ProceduralSky.SetSkyTopColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sky_top_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) SetSunAngleMax(degrees float64) {
	log.Println("Calling ProceduralSky.SetSunAngleMax()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sun_angle_max", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) SetSunAngleMin(degrees float64) {
	log.Println("Calling ProceduralSky.SetSunAngleMin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sun_angle_min", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) SetSunColor(color *Color) {
	log.Println("Calling ProceduralSky.SetSunColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sun_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) SetSunCurve(curve float64) {
	log.Println("Calling ProceduralSky.SetSunCurve()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(curve)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sun_curve", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) SetSunEnergy(energy float64) {
	log.Println("Calling ProceduralSky.SetSunEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(energy)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sun_energy", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) SetSunLatitude(degrees float64) {
	log.Println("Calling ProceduralSky.SetSunLatitude()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sun_latitude", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) SetSunLongitude(degrees float64) {
	log.Println("Calling ProceduralSky.SetSunLongitude()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sun_longitude", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProceduralSky) SetTextureSize(size int64) {
	log.Println("Calling ProceduralSky.SetTextureSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture_size", goArguments, "")

	log.Println("Got return value!")

}

/*
   ProceduralSkyImplementer is an interface for ProceduralSky objects.

*/
type ProceduralSkyImplementer interface {
	SkyImplementer

	GetGroundBottomColor() *Color

	GetGroundCurve() float64

	GetGroundEnergy() float64

	GetGroundHorizonColor() *Color

	GetSkyCurve() float64

	GetSkyEnergy() float64

	GetSkyHorizonColor() *Color

	GetSkyTopColor() *Color

	GetSunAngleMax() float64

	GetSunAngleMin() float64

	GetSunColor() *Color

	GetSunCurve() float64

	GetSunEnergy() float64

	GetSunLatitude() float64

	GetSunLongitude() float64

	GetTextureSize() int64

	SetGroundBottomColor(color *Color)

	SetGroundCurve(curve float64)

	SetGroundEnergy(energy float64)

	SetGroundHorizonColor(color *Color)

	SetSkyCurve(curve float64)

	SetSkyEnergy(energy float64)

	SetSkyHorizonColor(color *Color)

	SetSkyTopColor(color *Color)

	SetSunAngleMax(degrees float64)

	SetSunAngleMin(degrees float64)

	SetSunColor(color *Color)

	SetSunCurve(curve float64)

	SetSunEnergy(energy float64)

	SetSunLatitude(degrees float64)

	SetSunLongitude(degrees float64)

	SetTextureSize(size int64)
}

/*
   General purpose progress bar. Shows fill percentage from right to left.
*/
type ProgressBar struct {
	Range
}

func (o *ProgressBar) baseClass() string {
	return "ProgressBar"
}

/*

 */
func (o *ProgressBar) IsPercentVisible() *bool {
	log.Println("Calling ProgressBar.IsPercentVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_percent_visible", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ProgressBar) SetPercentVisible(visible *bool) {
	log.Println("Calling ProgressBar.SetPercentVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(visible)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_percent_visible", goArguments, "")

	log.Println("Got return value!")

}

/*
   ProgressBarImplementer is an interface for ProgressBar objects.
   General purpose progress bar. Shows fill percentage from right to left.
*/
type ProgressBarImplementer interface {
	RangeImplementer

	IsPercentVisible() *bool

	SetPercentVisible(visible *bool)
}

/*
   Contains global variables accessible from everywhere. Use the normal [Object] API, such as "ProjectSettings.get(variable)", "ProjectSettings.set(variable,value)" or "ProjectSettings.has(variable)" to access them. Variables stored in project.godot are also loaded into ProjectSettings, making this object very useful for reading custom game configuration options.
*/
type ProjectSettings struct {
	Object
}

func (o *ProjectSettings) baseClass() string {
	return "ProjectSettings"
}

/*
                Add a custom property info to a property. The dictionary must contain: name:[String](the name of the property) and type:[int](see TYPE_* in [@Global Scope]), and optionally hint:[int](see PROPERTY_HINT_* in [@Global Scope]), hint_string:[String].
				Example:
				[codeblock]
				ProjectSettings.set("category/property_name", 0)

				var property_info = {
				    "name": "category/property_name",
				    "type": TYPE_INT,
				    "hint": PROPERTY_HINT_ENUM,
				    "hint_string": "one,two,three"
				}

				ProjectSettings.add_property_info(property_info)
				[/codeblock]
*/
func (o *ProjectSettings) AddPropertyInfo(hint *Dictionary) {
	log.Println("Calling ProjectSettings.AddPropertyInfo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(hint)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_property_info", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear the whole configuration (not recommended, may break things).
*/
func (o *ProjectSettings) Clear(name string) {
	log.Println("Calling ProjectSettings.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the order of a configuration value (influences when saved to the config file).
*/
func (o *ProjectSettings) GetOrder(name string) int64 {
	log.Println("Calling ProjectSettings.GetOrder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_order", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ProjectSettings) GetSingleton(name string) *Object {
	log.Println("Calling ProjectSettings.GetSingleton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_singleton", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*
   Convert a localized path (res://) to a full native OS path.
*/
func (o *ProjectSettings) GlobalizePath(path string) string {
	log.Println("Calling ProjectSettings.GlobalizePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "globalize_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return true if a configuration value is present.
*/
func (o *ProjectSettings) Has(name string) *bool {
	log.Println("Calling ProjectSettings.Has()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ProjectSettings) HasSingleton(name string) *bool {
	log.Println("Calling ProjectSettings.HasSingleton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_singleton", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ProjectSettings) LoadResourcePack(pack string) *bool {
	log.Println("Calling ProjectSettings.LoadResourcePack()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pack)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "load_resource_pack", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Convert a path to a localized path (res:// path).
*/
func (o *ProjectSettings) LocalizePath(path string) string {
	log.Println("Calling ProjectSettings.LocalizePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "localize_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *ProjectSettings) PropertyCanRevert(name string) *bool {
	log.Println("Calling ProjectSettings.PropertyCanRevert()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "property_can_revert", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ProjectSettings) PropertyGetRevert(name string) *Variant {
	log.Println("Calling ProjectSettings.PropertyGetRevert()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "property_get_revert", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *ProjectSettings) Save() int64 {
	log.Println("Calling ProjectSettings.Save()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "save", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ProjectSettings) SaveCustom(file string) int64 {
	log.Println("Calling ProjectSettings.SaveCustom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(file)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "save_custom", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ProjectSettings) SetInitialValue(name string, value *Variant) {
	log.Println("Calling ProjectSettings.SetInitialValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_initial_value", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the order of a configuration value (influences when saved to the config file).
*/
func (o *ProjectSettings) SetOrder(name string, pos int64) {
	log.Println("Calling ProjectSettings.SetOrder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(pos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_order", goArguments, "")

	log.Println("Got return value!")

}

/*
   ProjectSettingsImplementer is an interface for ProjectSettings objects.
   Contains global variables accessible from everywhere. Use the normal [Object] API, such as "ProjectSettings.get(variable)", "ProjectSettings.set(variable,value)" or "ProjectSettings.has(variable)" to access them. Variables stored in project.godot are also loaded into ProjectSettings, making this object very useful for reading custom game configuration options.
*/
type ProjectSettingsImplementer interface {
	ObjectImplementer

	AddPropertyInfo(hint *Dictionary)

	Clear(name string)

	GetOrder(name string) int64

	GetSingleton(name string) *Object

	GlobalizePath(path string) string

	Has(name string) *bool

	HasSingleton(name string) *bool

	LoadResourcePack(pack string) *bool

	LocalizePath(path string) string

	PropertyCanRevert(name string) *bool

	PropertyGetRevert(name string) *Variant

	Save() int64

	SaveCustom(file string) int64

	SetInitialValue(name string, value *Variant)

	SetOrder(name string, pos int64)
}

/*
   General purpose proximity-detection node.
*/
type ProximityGroup struct {
	Spatial
}

func (o *ProximityGroup) baseClass() string {
	return "ProximityGroup"
}

/*

 */
func (o *ProximityGroup) Broadcast(name string, parameters *Variant) {
	log.Println("Calling ProximityGroup.Broadcast()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(parameters)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "broadcast", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProximityGroup) GetGridRadius() *Vector3 {
	log.Println("Calling ProximityGroup.GetGridRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_grid_radius", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *ProximityGroup) SetDispatchMode(mode int64) {
	log.Println("Calling ProximityGroup.SetDispatchMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dispatch_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProximityGroup) SetGridRadius(radius *Vector3) {
	log.Println("Calling ProximityGroup.SetGridRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radius)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_grid_radius", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ProximityGroup) SetGroupName(name string) {
	log.Println("Calling ProximityGroup.SetGroupName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_group_name", goArguments, "")

	log.Println("Got return value!")

}

/*
   ProximityGroupImplementer is an interface for ProximityGroup objects.
   General purpose proximity-detection node.
*/
type ProximityGroupImplementer interface {
	SpatialImplementer

	Broadcast(name string, parameters *Variant)

	GetGridRadius() *Vector3

	SetDispatchMode(mode int64)

	SetGridRadius(radius *Vector3)

	SetGroupName(name string)
}

/*

 */
type QuadMesh struct {
	PrimitiveMesh
}

func (o *QuadMesh) baseClass() string {
	return "QuadMesh"
}

/*
   QuadMeshImplementer is an interface for QuadMesh objects.

*/
type QuadMeshImplementer interface {
	PrimitiveMeshImplementer
}

/*
   Range is a base class for [Control] nodes that change a floating point [i]value[/i] between a [i]minimum[/i] and a [i]maximum[/i], using [i]step[/i] and [i]page[/i], for example a [ScrollBar].
*/
type Range struct {
	Control
}

func (o *Range) baseClass() string {
	return "Range"
}

/*
   Return value mapped to 0 to 1 range.
*/
func (o *Range) GetAsRatio() float64 {
	log.Println("Calling Range.GetAsRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_as_ratio", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the maximum value.
*/
func (o *Range) GetMax() float64 {
	log.Println("Calling Range.GetMax()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_max", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the minimum value.
*/
func (o *Range) GetMin() float64 {
	log.Println("Calling Range.GetMin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_min", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the page size, if page is 0, paging is disabled.
*/
func (o *Range) GetPage() float64 {
	log.Println("Calling Range.GetPage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_page", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the stepping, if step is 0, stepping is disabled.
*/
func (o *Range) GetStep() float64 {
	log.Println("Calling Range.GetStep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_step", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Range) GetValue() float64 {
	log.Println("Calling Range.GetValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_value", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *Range) IsRatioExp() *bool {
	log.Println("Calling Range.IsRatioExp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_ratio_exp", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Range) IsUsingRoundedValues() *bool {
	log.Println("Calling Range.IsUsingRoundedValues()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_using_rounded_values", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Set value mapped to 0 to 1 (unit) range, it will then be converted to the actual value within min and max.
*/
func (o *Range) SetAsRatio(value float64) {
	log.Println("Calling Range.SetAsRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_as_ratio", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Range) SetExpRatio(enabled *bool) {
	log.Println("Calling Range.SetExpRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_exp_ratio", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Range) SetMax(maximum float64) {
	log.Println("Calling Range.SetMax()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(maximum)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set minimum value, clamped range value to it if it's less.
*/
func (o *Range) SetMin(minimum float64) {
	log.Println("Calling Range.SetMin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(minimum)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_min", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set page size. Page is mainly used for scrollbars or anything that controls text scrolling.
*/
func (o *Range) SetPage(pagesize float64) {
	log.Println("Calling Range.SetPage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pagesize)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_page", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set step value. If step is 0, stepping will be disabled.
*/
func (o *Range) SetStep(step float64) {
	log.Println("Calling Range.SetStep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(step)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_step", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Range) SetUseRoundedValues(enabled *bool) {
	log.Println("Calling Range.SetUseRoundedValues()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_rounded_values", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Range) SetValue(value float64) {
	log.Println("Calling Range.SetValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_value", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Range) Share(with *Node) {
	log.Println("Calling Range.Share()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(with)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "share", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Range) Unshare() {
	log.Println("Calling Range.Unshare()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "unshare", goArguments, "")

	log.Println("Got return value!")

}

/*
   RangeImplementer is an interface for Range objects.
   Range is a base class for [Control] nodes that change a floating point [i]value[/i] between a [i]minimum[/i] and a [i]maximum[/i], using [i]step[/i] and [i]page[/i], for example a [ScrollBar].
*/
type RangeImplementer interface {
	ControlImplementer

	GetAsRatio() float64

	GetMax() float64

	GetMin() float64

	GetPage() float64

	GetStep() float64

	GetValue() float64

	IsRatioExp() *bool

	IsUsingRoundedValues() *bool

	SetAsRatio(value float64)

	SetExpRatio(enabled *bool)

	SetMax(maximum float64)

	SetMin(minimum float64)

	SetPage(pagesize float64)

	SetStep(step float64)

	SetUseRoundedValues(enabled *bool)

	SetValue(value float64)

	Share(with *Node)

	Unshare()
}

/*
        A RayCast represents a line from its origin to its destination position [code]cast_to[/code], it is used to query the 3D space in order to find the closest object intersecting with the ray.

		RayCast can ignore some objects by adding them to the exception list via [code]add_exception[/code], setting proper filtering with layers, or by filtering object types with type masks.

		Only enabled raycasts will be able to query the space and report collisions!

		RayCast calculates intersection every fixed frame (see [Node]), and the result is cached so it can be used later until the next frame. If multiple queries are required between fixed frames (or during the same frame) use [method force_raycast_update] after adjusting the raycast.
*/
type RayCast struct {
	Spatial
}

func (o *RayCast) baseClass() string {
	return "RayCast"
}

/*
   Adds a collision exception so the ray does not report collisions with the specified [code]node[/code].
*/
func (o *RayCast) AddException(node *Object) {
	log.Println("Calling RayCast.AddException()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_exception", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RayCast) AddExceptionRid(rid *RID) {
	log.Println("Calling RayCast.AddExceptionRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rid)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_exception_rid", goArguments, "")

	log.Println("Got return value!")

}

/*
   Removes all collision exception for this ray.
*/
func (o *RayCast) ClearExceptions() {
	log.Println("Calling RayCast.ClearExceptions()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_exceptions", goArguments, "")

	log.Println("Got return value!")

}

/*
   Updates the collision information in case if this object's properties changed during the current frame (for example position, rotation or the cast_point). Note, [code]set_enabled[/code] is not required for this to work.
*/
func (o *RayCast) ForceRaycastUpdate() {
	log.Println("Calling RayCast.ForceRaycastUpdate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "force_raycast_update", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the destination point of this ray object.
*/
func (o *RayCast) GetCastTo() *Vector3 {
	log.Println("Calling RayCast.GetCastTo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cast_to", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Return the closest object the ray is pointing to. Note that this does not consider the length of the vector, so you must also use [method is_colliding] to check if the object returned is actually colliding with the ray.
*/
func (o *RayCast) GetCollider() *Object {
	log.Println("Calling RayCast.GetCollider()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*
   Returns the collision shape of the closest object the ray is pointing to.
*/
func (o *RayCast) GetColliderShape() int64 {
	log.Println("Calling RayCast.GetColliderShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider_shape", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the collision layer for this ray.
*/
func (o *RayCast) GetCollisionLayer() int64 {
	log.Println("Calling RayCast.GetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_layer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the normal of the intersecting object shape face containing the collision point.
*/
func (o *RayCast) GetCollisionNormal() *Vector3 {
	log.Println("Calling RayCast.GetCollisionNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_normal", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Returns collision point. This point is in [b]global[/b] coordinate system.
*/
func (o *RayCast) GetCollisionPoint() *Vector3 {
	log.Println("Calling RayCast.GetCollisionPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_point", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Returns the type mask (types of objects to detect) for this ray. The value is a sum (bitwise OR'd) of constants available for [PhysicsDirectSpaceState].
*/
func (o *RayCast) GetTypeMask() int64 {
	log.Println("Calling RayCast.GetTypeMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_type_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return whether the closest object the ray is pointing to is colliding with the vector (considering the vector length).
*/
func (o *RayCast) IsColliding() *bool {
	log.Println("Calling RayCast.IsColliding()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_colliding", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns whether this raycast is enabled or not.
*/
func (o *RayCast) IsEnabled() *bool {
	log.Println("Calling RayCast.IsEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Removes a collision exception so the ray does report collisions with the specified [code]node[/code].
*/
func (o *RayCast) RemoveException(node *Object) {
	log.Println("Calling RayCast.RemoveException()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_exception", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RayCast) RemoveExceptionRid(rid *RID) {
	log.Println("Calling RayCast.RemoveExceptionRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rid)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_exception_rid", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets to which point ray should be casted. This point is in [b]local[/b] coordinate system.
*/
func (o *RayCast) SetCastTo(localPoint *Vector3) {
	log.Println("Calling RayCast.SetCastTo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(localPoint)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cast_to", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the mask to filter objects. Only objects with at least the same mask element set will be detected.
*/
func (o *RayCast) SetCollisionLayer(layer int64) {
	log.Println("Calling RayCast.SetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer", goArguments, "")

	log.Println("Got return value!")

}

/*
   Enables the RayCast2D. Only enabled raycasts will be able to query the space and report collisions.
*/
func (o *RayCast) SetEnabled(enabled *bool) {
	log.Println("Calling RayCast.SetEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the types of objects to detect. For [code]mask[/code] use a logic sum (OR operation) of constants defined in [PhysicsDirectSpaceState], eg. [code]PhysicsDirectSpaceState.TYPE_MASK_STATIC_BODY | PhysicsDirectSpaceState.TYPE_MASK_KINEMATIC_BODY[/code] to detect only those two types.
*/
func (o *RayCast) SetTypeMask(mask int64) {
	log.Println("Calling RayCast.SetTypeMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_type_mask", goArguments, "")

	log.Println("Got return value!")

}

/*
        RayCastImplementer is an interface for RayCast objects.
        A RayCast represents a line from its origin to its destination position [code]cast_to[/code], it is used to query the 3D space in order to find the closest object intersecting with the ray.

		RayCast can ignore some objects by adding them to the exception list via [code]add_exception[/code], setting proper filtering with layers, or by filtering object types with type masks.

		Only enabled raycasts will be able to query the space and report collisions!

		RayCast calculates intersection every fixed frame (see [Node]), and the result is cached so it can be used later until the next frame. If multiple queries are required between fixed frames (or during the same frame) use [method force_raycast_update] after adjusting the raycast.
*/
type RayCastImplementer interface {
	SpatialImplementer

	AddException(node *Object)

	AddExceptionRid(rid *RID)

	ClearExceptions()

	ForceRaycastUpdate()

	GetCastTo() *Vector3

	GetCollider() *Object

	GetColliderShape() int64

	GetCollisionLayer() int64

	GetCollisionNormal() *Vector3

	GetCollisionPoint() *Vector3

	GetTypeMask() int64

	IsColliding() *bool

	IsEnabled() *bool

	RemoveException(node *Object)

	RemoveExceptionRid(rid *RID)

	SetCastTo(localPoint *Vector3)

	SetCollisionLayer(layer int64)

	SetEnabled(enabled *bool)

	SetTypeMask(mask int64)
}

/*
        A RayCast2D represents a line from its origin to its destination position [code]cast_to[/code], it is used to query the 2D space in order to find the closest object intersecting with the ray.

		RayCast2D can ignore some objects by adding them to the exception list via [code]add_exception[/code], setting proper filtering with layers, or by filtering object types with type masks.

		Only enabled raycasts will be able to query the space and report collisions!

		RayCast2D calculates intersection every fixed frame (see [Node]), and the result is cached so it can be used later until the next frame. If multiple queries are required between fixed frames (or during the same frame) use [method force_raycast_update] after adjusting the raycast.
*/
type RayCast2D struct {
	Node2D
}

func (o *RayCast2D) baseClass() string {
	return "RayCast2D"
}

/*
   Adds a collision exception so the ray does not report collisions with the specified [code]node[/code].
*/
func (o *RayCast2D) AddException(node *Object) {
	log.Println("Calling RayCast2D.AddException()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_exception", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RayCast2D) AddExceptionRid(rid *RID) {
	log.Println("Calling RayCast2D.AddExceptionRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rid)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_exception_rid", goArguments, "")

	log.Println("Got return value!")

}

/*
   Removes all collision exception for this ray.
*/
func (o *RayCast2D) ClearExceptions() {
	log.Println("Calling RayCast2D.ClearExceptions()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_exceptions", goArguments, "")

	log.Println("Got return value!")

}

/*
   Updates the collision information in case if this object's properties changed during the current frame (for example position, rotation or the cast_point). Note, [code]set_enabled[/code] is not required for this to work.
*/
func (o *RayCast2D) ForceRaycastUpdate() {
	log.Println("Calling RayCast2D.ForceRaycastUpdate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "force_raycast_update", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the destination point of this ray object.
*/
func (o *RayCast2D) GetCastTo() *Vector2 {
	log.Println("Calling RayCast2D.GetCastTo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cast_to", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the closest object the ray is pointing to. Note that this does not consider the length of the vector, so you must also use [method is_colliding] to check if the object returned is actually colliding with the ray.
*/
func (o *RayCast2D) GetCollider() *Object {
	log.Println("Calling RayCast2D.GetCollider()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*
   Returns the collision shape of the closest object the ray is pointing to.
*/
func (o *RayCast2D) GetColliderShape() int64 {
	log.Println("Calling RayCast2D.GetColliderShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collider_shape", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the collision layer for this ray.
*/
func (o *RayCast2D) GetCollisionLayer() int64 {
	log.Println("Calling RayCast2D.GetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_layer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the normal of the intersecting object shape face containing the collision point.
*/
func (o *RayCast2D) GetCollisionNormal() *Vector2 {
	log.Println("Calling RayCast2D.GetCollisionNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_normal", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Returns the collision point in which the ray intersects the closest object. This point is in [b]global[/b] coordinate system.
*/
func (o *RayCast2D) GetCollisionPoint() *Vector2 {
	log.Println("Calling RayCast2D.GetCollisionPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_point", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Returns whether this ray should hit your parent node, if it's a body.
*/
func (o *RayCast2D) GetExcludeParentBody() *bool {
	log.Println("Calling RayCast2D.GetExcludeParentBody()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_exclude_parent_body", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns the type mask (types of objects to detect) for this ray. The value is a sum (bitwise OR'd) of constants available for [Physics2DDirectSpaceState].
*/
func (o *RayCast2D) GetTypeMask() int64 {
	log.Println("Calling RayCast2D.GetTypeMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_type_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return whether the closest object the ray is pointing to is colliding with the vector (considering the vector length).
*/
func (o *RayCast2D) IsColliding() *bool {
	log.Println("Calling RayCast2D.IsColliding()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_colliding", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns whether this raycast is enabled or not.
*/
func (o *RayCast2D) IsEnabled() *bool {
	log.Println("Calling RayCast2D.IsEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Removes a collision exception so the ray does report collisions with the specified [code]node[/code].
*/
func (o *RayCast2D) RemoveException(node *Object) {
	log.Println("Calling RayCast2D.RemoveException()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_exception", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RayCast2D) RemoveExceptionRid(rid *RID) {
	log.Println("Calling RayCast2D.RemoveExceptionRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rid)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_exception_rid", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets the ray destination point, so that the ray will test from the ray's origin to [code]local_point[/code]
*/
func (o *RayCast2D) SetCastTo(localPoint *Vector2) {
	log.Println("Calling RayCast2D.SetCastTo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(localPoint)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cast_to", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the mask to filter objects. Only objects with at least the same mask element set will be detected.
*/
func (o *RayCast2D) SetCollisionLayer(layer int64) {
	log.Println("Calling RayCast2D.SetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer", goArguments, "")

	log.Println("Got return value!")

}

/*
   Enables the RayCast2D. Only enabled raycasts will be able to query the space and report collisions.
*/
func (o *RayCast2D) SetEnabled(enabled *bool) {
	log.Println("Calling RayCast2D.SetEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Toggle whether this ray should hit your parent node, if it's a body.
*/
func (o *RayCast2D) SetExcludeParentBody(mask *bool) {
	log.Println("Calling RayCast2D.SetExcludeParentBody()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_exclude_parent_body", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the types of objects to detect. For [code]mask[/code] use a logic sum (OR operation) of constants defined in [Physics2DDirectSpaceState], eg. [code]Physics2DDirectSpaceState.TYPE_MASK_STATIC_BODY | Physics2DDirectSpaceState.TYPE_MASK_KINEMATIC_BODY[/code] to detect only those two types.
*/
func (o *RayCast2D) SetTypeMask(mask int64) {
	log.Println("Calling RayCast2D.SetTypeMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_type_mask", goArguments, "")

	log.Println("Got return value!")

}

/*
        RayCast2DImplementer is an interface for RayCast2D objects.
        A RayCast2D represents a line from its origin to its destination position [code]cast_to[/code], it is used to query the 2D space in order to find the closest object intersecting with the ray.

		RayCast2D can ignore some objects by adding them to the exception list via [code]add_exception[/code], setting proper filtering with layers, or by filtering object types with type masks.

		Only enabled raycasts will be able to query the space and report collisions!

		RayCast2D calculates intersection every fixed frame (see [Node]), and the result is cached so it can be used later until the next frame. If multiple queries are required between fixed frames (or during the same frame) use [method force_raycast_update] after adjusting the raycast.
*/
type RayCast2DImplementer interface {
	Node2DImplementer

	AddException(node *Object)

	AddExceptionRid(rid *RID)

	ClearExceptions()

	ForceRaycastUpdate()

	GetCastTo() *Vector2

	GetCollider() *Object

	GetColliderShape() int64

	GetCollisionLayer() int64

	GetCollisionNormal() *Vector2

	GetCollisionPoint() *Vector2

	GetExcludeParentBody() *bool

	GetTypeMask() int64

	IsColliding() *bool

	IsEnabled() *bool

	RemoveException(node *Object)

	RemoveExceptionRid(rid *RID)

	SetCastTo(localPoint *Vector2)

	SetCollisionLayer(layer int64)

	SetEnabled(enabled *bool)

	SetExcludeParentBody(mask *bool)

	SetTypeMask(mask int64)
}

/*

 */
type RayShape struct {
	Shape
}

func (o *RayShape) baseClass() string {
	return "RayShape"
}

/*

 */
func (o *RayShape) GetLength() float64 {
	log.Println("Calling RayShape.GetLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_length", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *RayShape) SetLength(length float64) {
	log.Println("Calling RayShape.SetLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(length)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_length", goArguments, "")

	log.Println("Got return value!")

}

/*
   RayShapeImplementer is an interface for RayShape objects.

*/
type RayShapeImplementer interface {
	ShapeImplementer

	GetLength() float64

	SetLength(length float64)
}

/*
   Ray 2D shape resource for physics. A ray is not really a collision body, instead it tries to separate itself from whatever is touching its far endpoint. It's often useful for characters.
*/
type RayShape2D struct {
	Shape2D
}

func (o *RayShape2D) baseClass() string {
	return "RayShape2D"
}

/*
   Return the length of the ray.
*/
func (o *RayShape2D) GetLength() float64 {
	log.Println("Calling RayShape2D.GetLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_length", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the length of the ray.
*/
func (o *RayShape2D) SetLength(length float64) {
	log.Println("Calling RayShape2D.SetLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(length)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_length", goArguments, "")

	log.Println("Got return value!")

}

/*
   RayShape2DImplementer is an interface for RayShape2D objects.
   Ray 2D shape resource for physics. A ray is not really a collision body, instead it tries to separate itself from whatever is touching its far endpoint. It's often useful for characters.
*/
type RayShape2DImplementer interface {
	Shape2DImplementer

	GetLength() float64

	SetLength(length float64)
}

/*
   Rectangle Shape for 2D Physics. This shape is useful for modeling box-like 2D objects.
*/
type RectangleShape2D struct {
	Shape2D
}

func (o *RectangleShape2D) baseClass() string {
	return "RectangleShape2D"
}

/*
   Return the half extents, the actual width and height of this shape is twice the half extents.
*/
func (o *RectangleShape2D) GetExtents() *Vector2 {
	log.Println("Calling RectangleShape2D.GetExtents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_extents", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Set the half extents, the actual width and height of this shape is twice the half extents.
*/
func (o *RectangleShape2D) SetExtents(extents *Vector2) {
	log.Println("Calling RectangleShape2D.SetExtents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(extents)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_extents", goArguments, "")

	log.Println("Got return value!")

}

/*
   RectangleShape2DImplementer is an interface for RectangleShape2D objects.
   Rectangle Shape for 2D Physics. This shape is useful for modeling box-like 2D objects.
*/
type RectangleShape2DImplementer interface {
	Shape2DImplementer

	GetExtents() *Vector2

	SetExtents(extents *Vector2)
}

/*
   Base class for anything that keeps a reference count. Resource and many other helper objects inherit this. References keep an internal reference counter so they are only released when no longer in use.
*/
type Reference struct {
	Object
}

func (o *Reference) baseClass() string {
	return "Reference"
}

/*

 */
func (o *Reference) InitRef() *bool {
	log.Println("Calling Reference.InitRef()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "init_ref", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Increase the internal reference counter. Use this only if you really know what you are doing.
*/
func (o *Reference) Reference() {
	log.Println("Calling Reference.Reference()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "reference", goArguments, "")

	log.Println("Got return value!")

}

/*
   Decrease the internal reference counter. Use this only if you really know what you are doing.
*/
func (o *Reference) Unreference() *bool {
	log.Println("Calling Reference.Unreference()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "unreference", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   ReferenceImplementer is an interface for Reference objects.
   Base class for anything that keeps a reference count. Resource and many other helper objects inherit this. References keep an internal reference counter so they are only released when no longer in use.
*/
type ReferenceImplementer interface {
	ObjectImplementer

	InitRef() *bool

	Reference()

	Unreference() *bool
}

/*
   Reference frame for GUI. It's just like an empty control, except a red box is displayed while editing around its size at all times.
*/
type ReferenceRect struct {
	Control
}

func (o *ReferenceRect) baseClass() string {
	return "ReferenceRect"
}

/*
   ReferenceRectImplementer is an interface for ReferenceRect objects.
   Reference frame for GUI. It's just like an empty control, except a red box is displayed while editing around its size at all times.
*/
type ReferenceRectImplementer interface {
	ControlImplementer
}

/*

 */
type ReflectionProbe struct {
	VisualInstance
}

func (o *ReflectionProbe) baseClass() string {
	return "ReflectionProbe"
}

/*

 */
func (o *ReflectionProbe) AreShadowsEnabled() *bool {
	log.Println("Calling ReflectionProbe.AreShadowsEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "are_shadows_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ReflectionProbe) GetCullMask() int64 {
	log.Println("Calling ReflectionProbe.GetCullMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cull_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ReflectionProbe) GetExtents() *Vector3 {
	log.Println("Calling ReflectionProbe.GetExtents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_extents", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *ReflectionProbe) GetIntensity() float64 {
	log.Println("Calling ReflectionProbe.GetIntensity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_intensity", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ReflectionProbe) GetInteriorAmbient() *Color {
	log.Println("Calling ReflectionProbe.GetInteriorAmbient()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_interior_ambient", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *ReflectionProbe) GetInteriorAmbientEnergy() float64 {
	log.Println("Calling ReflectionProbe.GetInteriorAmbientEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_interior_ambient_energy", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ReflectionProbe) GetInteriorAmbientProbeContribution() float64 {
	log.Println("Calling ReflectionProbe.GetInteriorAmbientProbeContribution()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_interior_ambient_probe_contribution", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ReflectionProbe) GetMaxDistance() float64 {
	log.Println("Calling ReflectionProbe.GetMaxDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_max_distance", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ReflectionProbe) GetOriginOffset() *Vector3 {
	log.Println("Calling ReflectionProbe.GetOriginOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_origin_offset", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *ReflectionProbe) GetUpdateMode() int64 {
	log.Println("Calling ReflectionProbe.GetUpdateMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_update_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ReflectionProbe) IsBoxProjectionEnabled() *bool {
	log.Println("Calling ReflectionProbe.IsBoxProjectionEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_box_projection_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ReflectionProbe) IsSetAsInterior() *bool {
	log.Println("Calling ReflectionProbe.IsSetAsInterior()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_set_as_interior", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ReflectionProbe) SetAsInterior(enable *bool) {
	log.Println("Calling ReflectionProbe.SetAsInterior()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_as_interior", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ReflectionProbe) SetCullMask(layers int64) {
	log.Println("Calling ReflectionProbe.SetCullMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(layers)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cull_mask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ReflectionProbe) SetEnableBoxProjection(enable *bool) {
	log.Println("Calling ReflectionProbe.SetEnableBoxProjection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_enable_box_projection", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ReflectionProbe) SetEnableShadows(enable *bool) {
	log.Println("Calling ReflectionProbe.SetEnableShadows()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_enable_shadows", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ReflectionProbe) SetExtents(extents *Vector3) {
	log.Println("Calling ReflectionProbe.SetExtents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(extents)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_extents", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ReflectionProbe) SetIntensity(intensity float64) {
	log.Println("Calling ReflectionProbe.SetIntensity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(intensity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_intensity", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ReflectionProbe) SetInteriorAmbient(ambient *Color) {
	log.Println("Calling ReflectionProbe.SetInteriorAmbient()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ambient)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_interior_ambient", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ReflectionProbe) SetInteriorAmbientEnergy(ambientEnergy float64) {
	log.Println("Calling ReflectionProbe.SetInteriorAmbientEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ambientEnergy)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_interior_ambient_energy", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ReflectionProbe) SetInteriorAmbientProbeContribution(ambientProbeContribution float64) {
	log.Println("Calling ReflectionProbe.SetInteriorAmbientProbeContribution()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ambientProbeContribution)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_interior_ambient_probe_contribution", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ReflectionProbe) SetMaxDistance(maxDistance float64) {
	log.Println("Calling ReflectionProbe.SetMaxDistance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(maxDistance)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max_distance", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ReflectionProbe) SetOriginOffset(originOffset *Vector3) {
	log.Println("Calling ReflectionProbe.SetOriginOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(originOffset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_origin_offset", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ReflectionProbe) SetUpdateMode(mode int64) {
	log.Println("Calling ReflectionProbe.SetUpdateMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_update_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   ReflectionProbeImplementer is an interface for ReflectionProbe objects.

*/
type ReflectionProbeImplementer interface {
	VisualInstanceImplementer

	AreShadowsEnabled() *bool

	GetCullMask() int64

	GetExtents() *Vector3

	GetIntensity() float64

	GetInteriorAmbient() *Color

	GetInteriorAmbientEnergy() float64

	GetInteriorAmbientProbeContribution() float64

	GetMaxDistance() float64

	GetOriginOffset() *Vector3

	GetUpdateMode() int64

	IsBoxProjectionEnabled() *bool

	IsSetAsInterior() *bool

	SetAsInterior(enable *bool)

	SetCullMask(layers int64)

	SetEnableBoxProjection(enable *bool)

	SetEnableShadows(enable *bool)

	SetExtents(extents *Vector3)

	SetIntensity(intensity float64)

	SetInteriorAmbient(ambient *Color)

	SetInteriorAmbientEnergy(ambientEnergy float64)

	SetInteriorAmbientProbeContribution(ambientProbeContribution float64)

	SetMaxDistance(maxDistance float64)

	SetOriginOffset(originOffset *Vector3)

	SetUpdateMode(mode int64)
}

/*
        Class for finding text patterns in a string using regular expressions. It can not perform replacements. Regular expressions are a way to define patterns of text to be searched. Details on writing patterns are too long to explain here but the Internet is full of tutorials and detailed explanations.
		Once created, the RegEx object needs to be compiled with the pattern before it can be used. The pattern must be escaped first for gdscript before it is escaped for the expression. For example:
		[code]var exp = RegEx.new()[/code]
		[code]exp.compile("\\d+")[/code]
		would be read by RegEx as [code]\d+[/code]
		Similarly:
		[code]exp.compile("\"(?:\\\\.|[^\"])*\"")[/code]
		would be read as [code]"(?:\\.|[^"])*"[/code]
		Currently supported features:
		* Capturing [code]()[/code] and non-capturing [code](?:)[/code] groups
		* Named capturing groups [code](?P<name>)[/code]
		* Any character [code].[/code]
		* Shorthand character classes [code]\w \W \s \S \d \D[/code]
		* User-defined character classes such as [code][A-Za-z][/code]
		* Simple quantifiers [code]?[/code], [code]*[/code] and [code]+[/code]
		* Range quantifiers [code]{x,y}[/code]
		* Lazy (non-greedy) quantifiers [code]*?[/code]
		* Beginning [code]^[/code] and end [code]$[/code] anchors
		* Alternation [code]|[/code]
		* Backreferences [code]\1[/code], [code]\g{1}[/code], and [code]\g<name>[/code]
		* POSIX character classes [code][[:alnum:]][/code]
		* Lookahead [code](?=)[/code], [code](?!)[/code] and lookbehind [code](?<=)[/code], [code](?<!)[/code]
		* ASCII [code]\xFF[/code] and Unicode [code]\uFFFF[/code] code points (in a style similar to Python)
		* Word boundaries [code]\b[/code], [code]\B[/code]
*/
type RegEx struct {
	Reference
}

func (o *RegEx) baseClass() string {
	return "RegEx"
}

/*
   This method resets the state of the object, as it was freshly created. Namely, it unassigns the regular expression of this object.
*/
func (o *RegEx) Clear() {
	log.Println("Calling RegEx.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Compiles and assign the regular expression pattern to use.
*/
func (o *RegEx) Compile(pattern string) int64 {
	log.Println("Calling RegEx.Compile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pattern)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "compile", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the number of numeric capturing groups.
*/
func (o *RegEx) GetGroupCount() int64 {
	log.Println("Calling RegEx.GetGroupCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_group_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns an array of names of named capturing groups.
*/
func (o *RegEx) GetNames() *Array {
	log.Println("Calling RegEx.GetNames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_names", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Returns the expression used to compile the code.
*/
func (o *RegEx) GetPattern() string {
	log.Println("Calling RegEx.GetPattern()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pattern", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Returns whether this object has a valid regular expression assigned.
*/
func (o *RegEx) IsValid() *bool {
	log.Println("Calling RegEx.IsValid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_valid", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Searches the text for the compiled pattern. Returns a [RegExMatch] container of the first matching reult if found, otherwise null. The region to search within can be specified without modifying where the start and end anchor would be.
*/
func (o *RegEx) Search(subject string, offset int64, end int64) *RegExMatch {
	log.Println("Calling RegEx.Search()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(subject)
	goArguments[1] = reflect.ValueOf(offset)
	goArguments[2] = reflect.ValueOf(end)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "search", goArguments, "*RegExMatch")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RegExMatch)

	return returnValue

}

/*
   Searches the text for the compiled pattern and replaces it with the specified string. Escapes and backreferences such as [code]\1[/code] and [code]\g<name>[/code] expanded and resolved. By default only the first instance is replaced but it can be changed for all instances (global replacement). The region to search within can be specified without modifying where the start and end anchor would be.
*/
func (o *RegEx) Sub(subject string, replacement string, all *bool, offset int64, end int64) string {
	log.Println("Calling RegEx.Sub()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(subject)
	goArguments[1] = reflect.ValueOf(replacement)
	goArguments[2] = reflect.ValueOf(all)
	goArguments[3] = reflect.ValueOf(offset)
	goArguments[4] = reflect.ValueOf(end)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "sub", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
        RegExImplementer is an interface for RegEx objects.
        Class for finding text patterns in a string using regular expressions. It can not perform replacements. Regular expressions are a way to define patterns of text to be searched. Details on writing patterns are too long to explain here but the Internet is full of tutorials and detailed explanations.
		Once created, the RegEx object needs to be compiled with the pattern before it can be used. The pattern must be escaped first for gdscript before it is escaped for the expression. For example:
		[code]var exp = RegEx.new()[/code]
		[code]exp.compile("\\d+")[/code]
		would be read by RegEx as [code]\d+[/code]
		Similarly:
		[code]exp.compile("\"(?:\\\\.|[^\"])*\"")[/code]
		would be read as [code]"(?:\\.|[^"])*"[/code]
		Currently supported features:
		* Capturing [code]()[/code] and non-capturing [code](?:)[/code] groups
		* Named capturing groups [code](?P<name>)[/code]
		* Any character [code].[/code]
		* Shorthand character classes [code]\w \W \s \S \d \D[/code]
		* User-defined character classes such as [code][A-Za-z][/code]
		* Simple quantifiers [code]?[/code], [code]*[/code] and [code]+[/code]
		* Range quantifiers [code]{x,y}[/code]
		* Lazy (non-greedy) quantifiers [code]*?[/code]
		* Beginning [code]^[/code] and end [code]$[/code] anchors
		* Alternation [code]|[/code]
		* Backreferences [code]\1[/code], [code]\g{1}[/code], and [code]\g<name>[/code]
		* POSIX character classes [code][[:alnum:]][/code]
		* Lookahead [code](?=)[/code], [code](?!)[/code] and lookbehind [code](?<=)[/code], [code](?<!)[/code]
		* ASCII [code]\xFF[/code] and Unicode [code]\uFFFF[/code] code points (in a style similar to Python)
		* Word boundaries [code]\b[/code], [code]\B[/code]
*/
type RegExImplementer interface {
	ReferenceImplementer

	Clear()

	Compile(pattern string) int64

	GetGroupCount() int64

	GetNames() *Array

	GetPattern() string

	IsValid() *bool

	Search(subject string, offset int64, end int64) *RegExMatch

	Sub(subject string, replacement string, all *bool, offset int64, end int64) string
}

/*

 */
type RegExMatch struct {
	Reference
}

func (o *RegExMatch) baseClass() string {
	return "RegExMatch"
}

/*
   Returns the end position of the match in the string. An integer can be specified for numeric groups or a string for named groups. Returns -1 if that group wasn't found or doesn't exist. Defaults to 0 (whole pattern).
*/
func (o *RegExMatch) GetEnd(name *Variant) int64 {
	log.Println("Calling RegExMatch.GetEnd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_end", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the number of numeric capturing groups.
*/
func (o *RegExMatch) GetGroupCount() int64 {
	log.Println("Calling RegExMatch.GetGroupCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_group_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns an array of names of named capturing groups.
*/
func (o *RegExMatch) GetNames() *Dictionary {
	log.Println("Calling RegExMatch.GetNames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_names", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*
   Returns the starting position of the match in the string. An integer can be specified for numeric groups or a string for named groups. Returns -1 if that group wasn't found or doesn't exist. Defaults to 0 (whole pattern).
*/
func (o *RegExMatch) GetStart(name *Variant) int64 {
	log.Println("Calling RegExMatch.GetStart()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_start", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the result of the match in the string. An integer can be specified for numeric groups or a string for named groups. Returns -1 if that group wasn't found or doesn't exist. Defaults to 0 (whole pattern).
*/
func (o *RegExMatch) GetString(name *Variant) string {
	log.Println("Calling RegExMatch.GetString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_string", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *RegExMatch) GetStrings() *Array {
	log.Println("Calling RegExMatch.GetStrings()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_strings", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *RegExMatch) GetSubject() string {
	log.Println("Calling RegExMatch.GetSubject()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_subject", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   RegExMatchImplementer is an interface for RegExMatch objects.

*/
type RegExMatchImplementer interface {
	ReferenceImplementer

	GetEnd(name *Variant) int64

	GetGroupCount() int64

	GetNames() *Dictionary

	GetStart(name *Variant) int64

	GetString(name *Variant) string

	GetStrings() *Array

	GetSubject() string
}

/*

 */
type RemoteTransform struct {
	Spatial
}

func (o *RemoteTransform) baseClass() string {
	return "RemoteTransform"
}

/*

 */
func (o *RemoteTransform) GetRemoteNode() *NodePath {
	log.Println("Calling RemoteTransform.GetRemoteNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_remote_node", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *RemoteTransform) GetUpdatePosition() *bool {
	log.Println("Calling RemoteTransform.GetUpdatePosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_update_position", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *RemoteTransform) GetUpdateRotation() *bool {
	log.Println("Calling RemoteTransform.GetUpdateRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_update_rotation", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *RemoteTransform) GetUpdateScale() *bool {
	log.Println("Calling RemoteTransform.GetUpdateScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_update_scale", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *RemoteTransform) GetUseGlobalCoordinates() *bool {
	log.Println("Calling RemoteTransform.GetUseGlobalCoordinates()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_use_global_coordinates", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *RemoteTransform) SetRemoteNode(path *NodePath) {
	log.Println("Calling RemoteTransform.SetRemoteNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_remote_node", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RemoteTransform) SetUpdatePosition(updateRemotePosition *bool) {
	log.Println("Calling RemoteTransform.SetUpdatePosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(updateRemotePosition)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_update_position", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RemoteTransform) SetUpdateRotation(updateRemoteRotation *bool) {
	log.Println("Calling RemoteTransform.SetUpdateRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(updateRemoteRotation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_update_rotation", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RemoteTransform) SetUpdateScale(updateRemoteScale *bool) {
	log.Println("Calling RemoteTransform.SetUpdateScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(updateRemoteScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_update_scale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RemoteTransform) SetUseGlobalCoordinates(useGlobalCoordinates *bool) {
	log.Println("Calling RemoteTransform.SetUseGlobalCoordinates()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(useGlobalCoordinates)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_global_coordinates", goArguments, "")

	log.Println("Got return value!")

}

/*
   RemoteTransformImplementer is an interface for RemoteTransform objects.

*/
type RemoteTransformImplementer interface {
	SpatialImplementer

	GetRemoteNode() *NodePath

	GetUpdatePosition() *bool

	GetUpdateRotation() *bool

	GetUpdateScale() *bool

	GetUseGlobalCoordinates() *bool

	SetRemoteNode(path *NodePath)

	SetUpdatePosition(updateRemotePosition *bool)

	SetUpdateRotation(updateRemoteRotation *bool)

	SetUpdateScale(updateRemoteScale *bool)

	SetUseGlobalCoordinates(useGlobalCoordinates *bool)
}

/*

 */
type RemoteTransform2D struct {
	Node2D
}

func (o *RemoteTransform2D) baseClass() string {
	return "RemoteTransform2D"
}

/*

 */
func (o *RemoteTransform2D) GetRemoteNode() *NodePath {
	log.Println("Calling RemoteTransform2D.GetRemoteNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_remote_node", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *RemoteTransform2D) GetUpdatePosition() *bool {
	log.Println("Calling RemoteTransform2D.GetUpdatePosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_update_position", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *RemoteTransform2D) GetUpdateRotation() *bool {
	log.Println("Calling RemoteTransform2D.GetUpdateRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_update_rotation", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *RemoteTransform2D) GetUpdateScale() *bool {
	log.Println("Calling RemoteTransform2D.GetUpdateScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_update_scale", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *RemoteTransform2D) GetUseGlobalCoordinates() *bool {
	log.Println("Calling RemoteTransform2D.GetUseGlobalCoordinates()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_use_global_coordinates", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *RemoteTransform2D) SetRemoteNode(path *NodePath) {
	log.Println("Calling RemoteTransform2D.SetRemoteNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_remote_node", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RemoteTransform2D) SetUpdatePosition(updateRemotePosition *bool) {
	log.Println("Calling RemoteTransform2D.SetUpdatePosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(updateRemotePosition)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_update_position", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RemoteTransform2D) SetUpdateRotation(updateRemoteRotation *bool) {
	log.Println("Calling RemoteTransform2D.SetUpdateRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(updateRemoteRotation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_update_rotation", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RemoteTransform2D) SetUpdateScale(updateRemoteScale *bool) {
	log.Println("Calling RemoteTransform2D.SetUpdateScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(updateRemoteScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_update_scale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RemoteTransform2D) SetUseGlobalCoordinates(useGlobalCoordinates *bool) {
	log.Println("Calling RemoteTransform2D.SetUseGlobalCoordinates()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(useGlobalCoordinates)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_global_coordinates", goArguments, "")

	log.Println("Got return value!")

}

/*
   RemoteTransform2DImplementer is an interface for RemoteTransform2D objects.

*/
type RemoteTransform2DImplementer interface {
	Node2DImplementer

	GetRemoteNode() *NodePath

	GetUpdatePosition() *bool

	GetUpdateRotation() *bool

	GetUpdateScale() *bool

	GetUseGlobalCoordinates() *bool

	SetRemoteNode(path *NodePath)

	SetUpdatePosition(updateRemotePosition *bool)

	SetUpdateRotation(updateRemoteRotation *bool)

	SetUpdateScale(updateRemoteScale *bool)

	SetUseGlobalCoordinates(useGlobalCoordinates *bool)
}

/*
   Resource is the base class for all resource types. Resources are primarily data containers. They are reference counted and freed when no longer in use. They are also loaded only once from disk, and further attempts to load the resource will return the same reference (all this in contrast to a [Node], which is not reference counted and can be instanced from disk as many times as desired). Resources can be saved externally on disk or bundled into another object, such as a [Node] or another resource.
*/
type Resource struct {
	Reference
}

func (o *Resource) baseClass() string {
	return "Resource"
}

/*

 */
func (o *Resource) X_SetupLocalToScene() {
	log.Println("Calling Resource.X_SetupLocalToScene()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_setup_local_to_scene", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Resource) Duplicate(subresources *bool) *Resource {
	log.Println("Calling Resource.Duplicate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(subresources)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "duplicate", goArguments, "*Resource")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Resource)

	return returnValue

}

/*

 */
func (o *Resource) GetLocalScene() *Node {
	log.Println("Calling Resource.GetLocalScene()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_local_scene", goArguments, "*Node")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Node)

	return returnValue

}

/*
   Return the name of the resources, any name is valid (it doesn't have to be unique). Name is for descriptive purposes only.
*/
func (o *Resource) GetName() string {
	log.Println("Calling Resource.GetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the path of the resource. This is useful mainly for editors when saving/loading, and shouldn't be changed by anything else.
*/
func (o *Resource) GetPath() string {
	log.Println("Calling Resource.GetPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the RID of the resource (or an empty RID). Many resources (such as [Texture], [Mesh], etc) are high level abstractions of resources stored in a server, so this function will return the original RID.
*/
func (o *Resource) GetRid() *RID {
	log.Println("Calling Resource.GetRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rid", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *Resource) IsLocalToScene() *bool {
	log.Println("Calling Resource.IsLocalToScene()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_local_to_scene", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Resource) SetLocalToScene(enable *bool) {
	log.Println("Calling Resource.SetLocalToScene()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_local_to_scene", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the name of the resources, any name is valid (it doesn't have to be unique). Name is for descriptive purposes only.
*/
func (o *Resource) SetName(name string) {
	log.Println("Calling Resource.SetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_name", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the path of the resource. This is useful mainly for editors when saving/loading, and shouldn't be changed by anything else. Fails if another [Resource] already has path "path".
*/
func (o *Resource) SetPath(path string) {
	log.Println("Calling Resource.SetPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_path", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Resource) SetupLocalToScene() {
	log.Println("Calling Resource.SetupLocalToScene()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "setup_local_to_scene", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the path of the resource. Differs from set_path(), if another [Resource] exists with "path" it over-takes it, instead of failing.
*/
func (o *Resource) TakeOverPath(path string) {
	log.Println("Calling Resource.TakeOverPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "take_over_path", goArguments, "")

	log.Println("Got return value!")

}

/*
   ResourceImplementer is an interface for Resource objects.
   Resource is the base class for all resource types. Resources are primarily data containers. They are reference counted and freed when no longer in use. They are also loaded only once from disk, and further attempts to load the resource will return the same reference (all this in contrast to a [Node], which is not reference counted and can be instanced from disk as many times as desired). Resources can be saved externally on disk or bundled into another object, such as a [Node] or another resource.
*/
type ResourceImplementer interface {
	ReferenceImplementer

	X_SetupLocalToScene()

	Duplicate(subresources *bool) *Resource

	GetLocalScene() *Node

	GetName() string

	GetPath() string

	GetRid() *RID

	IsLocalToScene() *bool

	SetLocalToScene(enable *bool)

	SetName(name string)

	SetPath(path string)

	SetupLocalToScene()

	TakeOverPath(path string)
}

/*

 */
type ResourceImporter struct {
	Reference
}

func (o *ResourceImporter) baseClass() string {
	return "ResourceImporter"
}

/*
   ResourceImporterImplementer is an interface for ResourceImporter objects.

*/
type ResourceImporterImplementer interface {
	ReferenceImplementer
}

/*

 */
type ResourceImporterOGGVorbis struct {
	ResourceImporter
}

func (o *ResourceImporterOGGVorbis) baseClass() string {
	return "ResourceImporterOGGVorbis"
}

/*
   ResourceImporterOGGVorbisImplementer is an interface for ResourceImporterOGGVorbis objects.

*/
type ResourceImporterOGGVorbisImplementer interface {
	ResourceImporterImplementer
}

/*
   Interactive Resource Loader. This object is returned by ResourceLoader when performing an interactive load. It allows to load with high granularity, so this is mainly useful for displaying load bars/percentages.
*/
type ResourceInteractiveLoader struct {
	Reference
}

func (o *ResourceInteractiveLoader) baseClass() string {
	return "ResourceInteractiveLoader"
}

/*
   Return the loaded resource (only if loaded). Otherwise, returns null.
*/
func (o *ResourceInteractiveLoader) GetResource() *Resource {
	log.Println("Calling ResourceInteractiveLoader.GetResource()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_resource", goArguments, "*Resource")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Resource)

	return returnValue

}

/*
   Return the load stage. The total amount of stages can be queried with [method get_stage_count]
*/
func (o *ResourceInteractiveLoader) GetStage() int64 {
	log.Println("Calling ResourceInteractiveLoader.GetStage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stage", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the total amount of stages (calls to [method poll]) needed to completely load this resource.
*/
func (o *ResourceInteractiveLoader) GetStageCount() int64 {
	log.Println("Calling ResourceInteractiveLoader.GetStageCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stage_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Poll the load. If OK is returned, this means poll will have to be called again. If ERR_FILE_EOF is returned, them the load has finished and the resource can be obtained by calling [method get_resource].
*/
func (o *ResourceInteractiveLoader) Poll() int64 {
	log.Println("Calling ResourceInteractiveLoader.Poll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "poll", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *ResourceInteractiveLoader) Wait() int64 {
	log.Println("Calling ResourceInteractiveLoader.Wait()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "wait", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   ResourceInteractiveLoaderImplementer is an interface for ResourceInteractiveLoader objects.
   Interactive Resource Loader. This object is returned by ResourceLoader when performing an interactive load. It allows to load with high granularity, so this is mainly useful for displaying load bars/percentages.
*/
type ResourceInteractiveLoaderImplementer interface {
	ReferenceImplementer

	GetResource() *Resource

	GetStage() int64

	GetStageCount() int64

	Poll() int64

	Wait() int64
}

/*
   Resource Loader. This is a static object accessible as [ResourceLoader]. GDScript has a simplified load() function, though.
*/
type ResourceLoader struct {
	Object
}

func (o *ResourceLoader) baseClass() string {
	return "ResourceLoader"
}

/*

 */
func (o *ResourceLoader) GetDependencies(path string) *PoolStringArray {
	log.Println("Calling ResourceLoader.GetDependencies()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dependencies", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   Return the list of recognized extensions for a resource type.
*/
func (o *ResourceLoader) GetRecognizedExtensionsForType(aType string) *PoolStringArray {
	log.Println("Calling ResourceLoader.GetRecognizedExtensionsForType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_recognized_extensions_for_type", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*

 */
func (o *ResourceLoader) Has(path string) *bool {
	log.Println("Calling ResourceLoader.Has()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ResourceLoader) Load(path string, typeHint string, pNoCache *bool) *Resource {
	log.Println("Calling ResourceLoader.Load()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(path)
	goArguments[1] = reflect.ValueOf(typeHint)
	goArguments[2] = reflect.ValueOf(pNoCache)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "load", goArguments, "*Resource")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Resource)

	return returnValue

}

/*
   Load a resource interactively, the returned object allows to load with high granularity.
*/
func (o *ResourceLoader) LoadInteractive(path string, typeHint string) *ResourceInteractiveLoader {
	log.Println("Calling ResourceLoader.LoadInteractive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(path)
	goArguments[1] = reflect.ValueOf(typeHint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "load_interactive", goArguments, "*ResourceInteractiveLoader")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*ResourceInteractiveLoader)

	return returnValue

}

/*
   Change the behavior on missing sub-resources. Default is to abort load.
*/
func (o *ResourceLoader) SetAbortOnMissingResources(abort *bool) {
	log.Println("Calling ResourceLoader.SetAbortOnMissingResources()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(abort)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_abort_on_missing_resources", goArguments, "")

	log.Println("Got return value!")

}

/*
   ResourceLoaderImplementer is an interface for ResourceLoader objects.
   Resource Loader. This is a static object accessible as [ResourceLoader]. GDScript has a simplified load() function, though.
*/
type ResourceLoaderImplementer interface {
	ObjectImplementer

	GetDependencies(path string) *PoolStringArray

	GetRecognizedExtensionsForType(aType string) *PoolStringArray

	Has(path string) *bool

	Load(path string, typeHint string, pNoCache *bool) *Resource

	LoadInteractive(path string, typeHint string) *ResourceInteractiveLoader

	SetAbortOnMissingResources(abort *bool)
}

/*
   Resource Preloader Node. This node is used to preload sub-resources inside a scene, so when the scene is loaded all the resources are ready to use and be retrieved from here.
*/
type ResourcePreloader struct {
	Node
}

func (o *ResourcePreloader) baseClass() string {
	return "ResourcePreloader"
}

/*

 */
func (o *ResourcePreloader) AddResource(name string, resource *Resource) {
	log.Println("Calling ResourcePreloader.AddResource()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(resource)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_resource", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the resource given a text-id.
*/
func (o *ResourcePreloader) GetResource(name string) *Resource {
	log.Println("Calling ResourcePreloader.GetResource()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_resource", goArguments, "*Resource")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Resource)

	return returnValue

}

/*
   Return the list of resources inside the preloader.
*/
func (o *ResourcePreloader) GetResourceList() *PoolStringArray {
	log.Println("Calling ResourcePreloader.GetResourceList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_resource_list", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   Return true if the preloader has a given resource.
*/
func (o *ResourcePreloader) HasResource(name string) *bool {
	log.Println("Calling ResourcePreloader.HasResource()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_resource", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Remove a resource from the preloader by text id.
*/
func (o *ResourcePreloader) RemoveResource(name string) {
	log.Println("Calling ResourcePreloader.RemoveResource()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_resource", goArguments, "")

	log.Println("Got return value!")

}

/*
   Rename a resource inside the preloader, from a text-id to a new text-id.
*/
func (o *ResourcePreloader) RenameResource(name string, newname string) {
	log.Println("Calling ResourcePreloader.RenameResource()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(newname)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rename_resource", goArguments, "")

	log.Println("Got return value!")

}

/*
   ResourcePreloaderImplementer is an interface for ResourcePreloader objects.
   Resource Preloader Node. This node is used to preload sub-resources inside a scene, so when the scene is loaded all the resources are ready to use and be retrieved from here.
*/
type ResourcePreloaderImplementer interface {
	NodeImplementer

	AddResource(name string, resource *Resource)

	GetResource(name string) *Resource

	GetResourceList() *PoolStringArray

	HasResource(name string) *bool

	RemoveResource(name string)

	RenameResource(name string, newname string)
}

/*
   Resource Saving Interface. This interface is used for saving resources to disk.
*/
type ResourceSaver struct {
	Object
}

func (o *ResourceSaver) baseClass() string {
	return "ResourceSaver"
}

/*
   Return the list of extensions available for saving a resource of a given type.
*/
func (o *ResourceSaver) GetRecognizedExtensions(aType *Resource) *PoolStringArray {
	log.Println("Calling ResourceSaver.GetRecognizedExtensions()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_recognized_extensions", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   Save a resource to disk, to a given path.
*/
func (o *ResourceSaver) Save(path string, resource *Resource, flags int64) int64 {
	log.Println("Calling ResourceSaver.Save()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(path)
	goArguments[1] = reflect.ValueOf(resource)
	goArguments[2] = reflect.ValueOf(flags)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "save", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   ResourceSaverImplementer is an interface for ResourceSaver objects.
   Resource Saving Interface. This interface is used for saving resources to disk.
*/
type ResourceSaverImplementer interface {
	ObjectImplementer

	GetRecognizedExtensions(aType *Resource) *PoolStringArray

	Save(path string, resource *Resource, flags int64) int64
}

/*
   Label that displays rich text. Rich text can contain custom text, fonts, images and some basic formatting. It also adapts itself to given width/heights.
*/
type RichTextLabel struct {
	Control
}

func (o *RichTextLabel) baseClass() string {
	return "RichTextLabel"
}

/*

 */
func (o *RichTextLabel) AddImage(image *Texture) {
	log.Println("Calling RichTextLabel.AddImage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(image)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_image", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) AddText(text string) {
	log.Println("Calling RichTextLabel.AddText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_text", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) AppendBbcode(bbcode string) int64 {
	log.Println("Calling RichTextLabel.AppendBbcode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bbcode)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "append_bbcode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *RichTextLabel) Clear() {
	log.Println("Calling RichTextLabel.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) GetBbcode() string {
	log.Println("Calling RichTextLabel.GetBbcode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bbcode", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *RichTextLabel) GetPercentVisible() float64 {
	log.Println("Calling RichTextLabel.GetPercentVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_percent_visible", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *RichTextLabel) GetTabSize() int64 {
	log.Println("Calling RichTextLabel.GetTabSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tab_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns the raw text, stripping out the formatting information.
*/
func (o *RichTextLabel) GetText() string {
	log.Println("Calling RichTextLabel.GetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *RichTextLabel) GetTotalCharacterCount() int64 {
	log.Println("Calling RichTextLabel.GetTotalCharacterCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_total_character_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *RichTextLabel) GetVScroll() *VScrollBar {
	log.Println("Calling RichTextLabel.GetVScroll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_v_scroll", goArguments, "*VScrollBar")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*VScrollBar)

	return returnValue

}

/*

 */
func (o *RichTextLabel) GetVisibleCharacters() int64 {
	log.Println("Calling RichTextLabel.GetVisibleCharacters()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_visible_characters", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *RichTextLabel) IsMetaUnderlined() *bool {
	log.Println("Calling RichTextLabel.IsMetaUnderlined()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_meta_underlined", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *RichTextLabel) IsScrollActive() *bool {
	log.Println("Calling RichTextLabel.IsScrollActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_scroll_active", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *RichTextLabel) IsScrollFollowing() *bool {
	log.Println("Calling RichTextLabel.IsScrollFollowing()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_scroll_following", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if selecting the text inside this richtext is allowed.
*/
func (o *RichTextLabel) IsSelectionEnabled() *bool {
	log.Println("Calling RichTextLabel.IsSelectionEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_selection_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *RichTextLabel) IsUsingBbcode() *bool {
	log.Println("Calling RichTextLabel.IsUsingBbcode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_using_bbcode", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *RichTextLabel) Newline() {
	log.Println("Calling RichTextLabel.Newline()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "newline", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) ParseBbcode(bbcode string) int64 {
	log.Println("Calling RichTextLabel.ParseBbcode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bbcode)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "parse_bbcode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *RichTextLabel) Pop() {
	log.Println("Calling RichTextLabel.Pop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "pop", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) PushAlign(align int64) {
	log.Println("Calling RichTextLabel.PushAlign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(align)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "push_align", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) PushCell() {
	log.Println("Calling RichTextLabel.PushCell()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "push_cell", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) PushColor(color *Color) {
	log.Println("Calling RichTextLabel.PushColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "push_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) PushFont(font *Font) {
	log.Println("Calling RichTextLabel.PushFont()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(font)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "push_font", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) PushIndent(level int64) {
	log.Println("Calling RichTextLabel.PushIndent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(level)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "push_indent", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) PushList(aType int64) {
	log.Println("Calling RichTextLabel.PushList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "push_list", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) PushMeta(data *Variant) {
	log.Println("Calling RichTextLabel.PushMeta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "push_meta", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) PushTable(columns int64) {
	log.Println("Calling RichTextLabel.PushTable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(columns)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "push_table", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) PushUnderline() {
	log.Println("Calling RichTextLabel.PushUnderline()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "push_underline", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) RemoveLine(line int64) *bool {
	log.Println("Calling RichTextLabel.RemoveLine()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(line)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "remove_line", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *RichTextLabel) ScrollToLine(line int64) {
	log.Println("Calling RichTextLabel.ScrollToLine()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(line)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "scroll_to_line", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) SetBbcode(text string) {
	log.Println("Calling RichTextLabel.SetBbcode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bbcode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) SetMetaUnderline(enable *bool) {
	log.Println("Calling RichTextLabel.SetMetaUnderline()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_meta_underline", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) SetPercentVisible(percentVisible float64) {
	log.Println("Calling RichTextLabel.SetPercentVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(percentVisible)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_percent_visible", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) SetScrollActive(active *bool) {
	log.Println("Calling RichTextLabel.SetScrollActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(active)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_scroll_active", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) SetScrollFollow(follow *bool) {
	log.Println("Calling RichTextLabel.SetScrollFollow()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(follow)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_scroll_follow", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set to true if selecting the text inside this richtext is allowed.
*/
func (o *RichTextLabel) SetSelectionEnabled(enabled *bool) {
	log.Println("Calling RichTextLabel.SetSelectionEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_selection_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) SetTabSize(spaces int64) {
	log.Println("Calling RichTextLabel.SetTabSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(spaces)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tab_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) SetTableColumnExpand(column int64, expand *bool, ratio int64) {
	log.Println("Calling RichTextLabel.SetTableColumnExpand()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(expand)
	goArguments[2] = reflect.ValueOf(ratio)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_table_column_expand", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) SetText(text string) {
	log.Println("Calling RichTextLabel.SetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_text", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) SetUseBbcode(enable *bool) {
	log.Println("Calling RichTextLabel.SetUseBbcode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_bbcode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *RichTextLabel) SetVisibleCharacters(amount int64) {
	log.Println("Calling RichTextLabel.SetVisibleCharacters()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_visible_characters", goArguments, "")

	log.Println("Got return value!")

}

/*
   RichTextLabelImplementer is an interface for RichTextLabel objects.
   Label that displays rich text. Rich text can contain custom text, fonts, images and some basic formatting. It also adapts itself to given width/heights.
*/
type RichTextLabelImplementer interface {
	ControlImplementer

	AddImage(image *Texture)

	AddText(text string)

	AppendBbcode(bbcode string) int64

	Clear()

	GetBbcode() string

	GetPercentVisible() float64

	GetTabSize() int64

	GetText() string

	GetTotalCharacterCount() int64

	GetVScroll() *VScrollBar

	GetVisibleCharacters() int64

	IsMetaUnderlined() *bool

	IsScrollActive() *bool

	IsScrollFollowing() *bool

	IsSelectionEnabled() *bool

	IsUsingBbcode() *bool

	Newline()

	ParseBbcode(bbcode string) int64

	Pop()

	PushAlign(align int64)

	PushCell()

	PushColor(color *Color)

	PushFont(font *Font)

	PushIndent(level int64)

	PushList(aType int64)

	PushMeta(data *Variant)

	PushTable(columns int64)

	PushUnderline()

	RemoveLine(line int64) *bool

	ScrollToLine(line int64)

	SetBbcode(text string)

	SetMetaUnderline(enable *bool)

	SetPercentVisible(percentVisible float64)

	SetScrollActive(active *bool)

	SetScrollFollow(follow *bool)

	SetSelectionEnabled(enabled *bool)

	SetTabSize(spaces int64)

	SetTableColumnExpand(column int64, expand *bool, ratio int64)

	SetText(text string)

	SetUseBbcode(enable *bool)

	SetVisibleCharacters(amount int64)
}

/*
   Rigid body node. This node is used for placing rigid bodies in the scene. It can contain a number of shapes, and also shift mode between regular Rigid body, Kinematic, Character or Static.
*/
type RigidBody struct {
	PhysicsBody
}

func (o *RigidBody) baseClass() string {
	return "RigidBody"
}

/*
   Called during physics processing, allowing you to read and safely modify the simulation state for the object. By default it works in addition to the usual physics behavior, but [method set_use_custom_integrator] allows you to disable the default behavior and do fully custom force integration for a body.
*/
func (o *RigidBody) X_IntegrateForces(state *PhysicsDirectBodyState) {
	log.Println("Calling RigidBody.X_IntegrateForces()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(state)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_integrate_forces", goArguments, "")

	log.Println("Got return value!")

}

/*
   Apply a positioned impulse (which will be affected by the body mass and shape). This is the equivalent of hitting a billiard ball with a cue: a force that is applied once, and only once. Both the impulse and the offset from the body origin are in global coordinates.
*/
func (o *RigidBody) ApplyImpulse(pos *Vector3, impulse *Vector3) {
	log.Println("Calling RigidBody.ApplyImpulse()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(pos)
	goArguments[1] = reflect.ValueOf(impulse)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "apply_impulse", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the current body angular damp. Default is -1.
*/
func (o *RigidBody) GetAngularDamp() float64 {
	log.Println("Calling RigidBody.GetAngularDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_angular_damp", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the current body angular velocity.
*/
func (o *RigidBody) GetAngularVelocity() *Vector3 {
	log.Println("Calling RigidBody.GetAngularVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_angular_velocity", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Return the current axis lock of the body. One of AXIS_LOCK_* enum.
*/
func (o *RigidBody) GetAxisLock() int64 {
	log.Println("Calling RigidBody.GetAxisLock()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_axis_lock", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the current body bounciness.
*/
func (o *RigidBody) GetBounce() float64 {
	log.Println("Calling RigidBody.GetBounce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bounce", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return a list of the bodies colliding with this one. By default, number of max contacts reported is at 0 , see [method set_max_contacts_reported] to increase it.
*/
func (o *RigidBody) GetCollidingBodies() *Array {
	log.Println("Calling RigidBody.GetCollidingBodies()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_colliding_bodies", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Return the current body friction, from 0 (frictionless) to 1 (max friction).
*/
func (o *RigidBody) GetFriction() float64 {
	log.Println("Calling RigidBody.GetFriction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_friction", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the current body gravity scale.
*/
func (o *RigidBody) GetGravityScale() float64 {
	log.Println("Calling RigidBody.GetGravityScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gravity_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the current body linear damp. Default is -1.
*/
func (o *RigidBody) GetLinearDamp() float64 {
	log.Println("Calling RigidBody.GetLinearDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_linear_damp", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the current body linear velocity.
*/
func (o *RigidBody) GetLinearVelocity() *Vector3 {
	log.Println("Calling RigidBody.GetLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_linear_velocity", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Return the current body mass.
*/
func (o *RigidBody) GetMass() float64 {
	log.Println("Calling RigidBody.GetMass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mass", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the maximum contacts that can be reported. See [method set_max_contacts_reported].
*/
func (o *RigidBody) GetMaxContactsReported() int64 {
	log.Println("Calling RigidBody.GetMaxContactsReported()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_max_contacts_reported", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the current body mode, see [method set_mode].
*/
func (o *RigidBody) GetMode() int64 {
	log.Println("Calling RigidBody.GetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the current body weight, given standard earth-weight (gravity 9.8).
*/
func (o *RigidBody) GetWeight() float64 {
	log.Println("Calling RigidBody.GetWeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_weight", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return whether the body has the ability to fall asleep when not moving. See [method set_can_sleep].
*/
func (o *RigidBody) IsAbleToSleep() *bool {
	log.Println("Calling RigidBody.IsAbleToSleep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_able_to_sleep", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether contact monitoring is enabled.
*/
func (o *RigidBody) IsContactMonitorEnabled() *bool {
	log.Println("Calling RigidBody.IsContactMonitorEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_contact_monitor_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether the body is sleeping.
*/
func (o *RigidBody) IsSleeping() *bool {
	log.Println("Calling RigidBody.IsSleeping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_sleeping", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether this body is using continuous collision detection.
*/
func (o *RigidBody) IsUsingContinuousCollisionDetection() *bool {
	log.Println("Calling RigidBody.IsUsingContinuousCollisionDetection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_using_continuous_collision_detection", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether the body is using a custom integrator.
*/
func (o *RigidBody) IsUsingCustomIntegrator() *bool {
	log.Println("Calling RigidBody.IsUsingCustomIntegrator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_using_custom_integrator", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Set the angular damp for this body. Default of -1, cannot be less than -1. If this value is different from -1, any angular damp derived from the world or areas will be overridden.
*/
func (o *RigidBody) SetAngularDamp(angularDamp float64) {
	log.Println("Calling RigidBody.SetAngularDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(angularDamp)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_angular_damp", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the body angular velocity. Can be used sporadically, but [b]DON'T SET THIS IN EVERY FRAME[/b], because physics may be running in another thread and definitely runs at a different granularity. Use [method _integrate_forces] as your process loop if you want to have precise control of the body state.
*/
func (o *RigidBody) SetAngularVelocity(angularVelocity *Vector3) {
	log.Println("Calling RigidBody.SetAngularVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(angularVelocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_angular_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the axis lock of the body, from the AXIS_LOCK_* enum. Axis lock stops the body from moving along the specified axis(X/Y/Z) and rotating along the other two axes.
*/
func (o *RigidBody) SetAxisLock(axisLock int64) {
	log.Println("Calling RigidBody.SetAxisLock()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(axisLock)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_axis_lock", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set an axis velocity. The velocity in the given vector axis will be set as the given vector length. This is useful for jumping behavior.
*/
func (o *RigidBody) SetAxisVelocity(axisVelocity *Vector3) {
	log.Println("Calling RigidBody.SetAxisVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(axisVelocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_axis_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the body bounciness, from 0 (no bounciness) to 1 (max bounciness).
*/
func (o *RigidBody) SetBounce(bounce float64) {
	log.Println("Calling RigidBody.SetBounce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bounce)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bounce", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set the body ability to fall asleep when not moving. This saves an enormous amount of processor time when there are plenty of rigid bodies (non static) in a scene.
				Sleeping bodies are not affected by forces until a collision or an [method apply_impulse] / [method set_applied_force] wakes them up. Until then, they behave like a static body.
*/
func (o *RigidBody) SetCanSleep(ableToSleep *bool) {
	log.Println("Calling RigidBody.SetCanSleep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ableToSleep)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_can_sleep", goArguments, "")

	log.Println("Got return value!")

}

/*
   Enable contact monitoring. This allows the body to emit signals when it collides with another.
*/
func (o *RigidBody) SetContactMonitor(enabled *bool) {
	log.Println("Calling RigidBody.SetContactMonitor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_contact_monitor", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the body friction, from 0 (frictionless) to 1 (max friction).
*/
func (o *RigidBody) SetFriction(friction float64) {
	log.Println("Calling RigidBody.SetFriction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(friction)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_friction", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the gravity factor. This factor multiplies gravity intensity just for this body.
*/
func (o *RigidBody) SetGravityScale(gravityScale float64) {
	log.Println("Calling RigidBody.SetGravityScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(gravityScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the linear damp for this body. Default of -1, cannot be less than -1. If this value is different from -1, any linear damp derived from the world or areas will be overridden.
*/
func (o *RigidBody) SetLinearDamp(linearDamp float64) {
	log.Println("Calling RigidBody.SetLinearDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(linearDamp)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_linear_damp", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the body linear velocity. Can be used sporadically, but [b]DON'T SET THIS IN EVERY FRAME[/b], because physics may be running in another thread and definitely runs at a different granularity. Use [method _integrate_forces] as your process loop if you want to have precise control of the body state.
*/
func (o *RigidBody) SetLinearVelocity(linearVelocity *Vector3) {
	log.Println("Calling RigidBody.SetLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(linearVelocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_linear_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the body mass.
*/
func (o *RigidBody) SetMass(mass float64) {
	log.Println("Calling RigidBody.SetMass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mass)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mass", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the maximum contacts to report. Bodies can keep a log of the contacts with other bodies, this is enabled by setting the maximum amount of contacts reported to a number greater than 0.
*/
func (o *RigidBody) SetMaxContactsReported(amount int64) {
	log.Println("Calling RigidBody.SetMaxContactsReported()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max_contacts_reported", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the body mode, from the MODE_* enum. This allows to change to a static body or a character body.
*/
func (o *RigidBody) SetMode(mode int64) {
	log.Println("Calling RigidBody.SetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether a body is sleeping or not. Sleeping bodies are not affected by forces until a collision or an [method apply_impulse] wakes them up. Until then, they behave like a static body.
*/
func (o *RigidBody) SetSleeping(sleeping *bool) {
	log.Println("Calling RigidBody.SetSleeping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(sleeping)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sleeping", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set the continuous collision detection mode from the enum CCD_MODE_*.
				Continuous collision detection tries to predict where a moving body will collide, instead of moving it and correcting its movement if it collided. The first is more precise, and misses less impacts by small, fast-moving objects. The second is faster to compute, but can miss small, fast-moving objects.
*/
func (o *RigidBody) SetUseContinuousCollisionDetection(enable *bool) {
	log.Println("Calling RigidBody.SetUseContinuousCollisionDetection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_continuous_collision_detection", goArguments, "")

	log.Println("Got return value!")

}

/*
   Pass true to disable the internal force integration (like gravity or air friction) for this body. Other than collision response, the body will only move as determined by the [method _integrate_forces] function, if defined.
*/
func (o *RigidBody) SetUseCustomIntegrator(enable *bool) {
	log.Println("Calling RigidBody.SetUseCustomIntegrator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_custom_integrator", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the body weight given standard earth-weight (gravity 9.8).
*/
func (o *RigidBody) SetWeight(weight float64) {
	log.Println("Calling RigidBody.SetWeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(weight)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_weight", goArguments, "")

	log.Println("Got return value!")

}

/*
   RigidBodyImplementer is an interface for RigidBody objects.
   Rigid body node. This node is used for placing rigid bodies in the scene. It can contain a number of shapes, and also shift mode between regular Rigid body, Kinematic, Character or Static.
*/
type RigidBodyImplementer interface {
	PhysicsBodyImplementer

	X_IntegrateForces(state *PhysicsDirectBodyState)

	ApplyImpulse(pos *Vector3, impulse *Vector3)

	GetAngularDamp() float64

	GetAngularVelocity() *Vector3

	GetAxisLock() int64

	GetBounce() float64

	GetCollidingBodies() *Array

	GetFriction() float64

	GetGravityScale() float64

	GetLinearDamp() float64

	GetLinearVelocity() *Vector3

	GetMass() float64

	GetMaxContactsReported() int64

	GetMode() int64

	GetWeight() float64

	IsAbleToSleep() *bool

	IsContactMonitorEnabled() *bool

	IsSleeping() *bool

	IsUsingContinuousCollisionDetection() *bool

	IsUsingCustomIntegrator() *bool

	SetAngularDamp(angularDamp float64)

	SetAngularVelocity(angularVelocity *Vector3)

	SetAxisLock(axisLock int64)

	SetAxisVelocity(axisVelocity *Vector3)

	SetBounce(bounce float64)

	SetCanSleep(ableToSleep *bool)

	SetContactMonitor(enabled *bool)

	SetFriction(friction float64)

	SetGravityScale(gravityScale float64)

	SetLinearDamp(linearDamp float64)

	SetLinearVelocity(linearVelocity *Vector3)

	SetMass(mass float64)

	SetMaxContactsReported(amount int64)

	SetMode(mode int64)

	SetSleeping(sleeping *bool)

	SetUseContinuousCollisionDetection(enable *bool)

	SetUseCustomIntegrator(enable *bool)

	SetWeight(weight float64)
}

/*
        Rigid body 2D node. This node is used for placing rigid bodies in the scene. It can contain a number of shapes, and also shift state between regular Rigid body, Kinematic, Character or Static.
		Character mode forbids the node from being rotated. This node can have a custom force integrator function, for writing complex physics motion behavior per node.
		As a warning, don't change this node position every frame or very often. Sporadic changes work fine, but physics runs at a different granularity (fixed hz) than usual rendering (process callback) and maybe even in a separate thread, so changing this from a process loop will yield strange behavior.
*/
type RigidBody2D struct {
	PhysicsBody2D
}

func (o *RigidBody2D) baseClass() string {
	return "RigidBody2D"
}

/*
   Called during physics processing, allowing you to read and safely modify the simulation state for the object. By default it works in addition to the usual physics behavior, but [method set_use_custom_integrator] allows you to disable the default behavior and do fully custom force integration for a body.
*/
func (o *RigidBody2D) X_IntegrateForces(state *Physics2DDirectBodyState) {
	log.Println("Calling RigidBody2D.X_IntegrateForces()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(state)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "_integrate_forces", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a positioned force to the applied force and torque. As with [method apply_impulse], both the force and the offset from the body origin are in global coordinates.
*/
func (o *RigidBody2D) AddForce(offset *Vector2, force *Vector2) {
	log.Println("Calling RigidBody2D.AddForce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(offset)
	goArguments[1] = reflect.ValueOf(force)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_force", goArguments, "")

	log.Println("Got return value!")

}

/*
   Apply a positioned impulse (which will be affected by the body mass and shape). This is the equivalent of hitting a billiard ball with a cue: a force that is applied once, and only once. Both the impulse and the offset from the body origin are in global coordinates.
*/
func (o *RigidBody2D) ApplyImpulse(offset *Vector2, impulse *Vector2) {
	log.Println("Calling RigidBody2D.ApplyImpulse()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(offset)
	goArguments[1] = reflect.ValueOf(impulse)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "apply_impulse", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the angular damp for this body.
*/
func (o *RigidBody2D) GetAngularDamp() float64 {
	log.Println("Calling RigidBody2D.GetAngularDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_angular_damp", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the body angular velocity. This changes by physics granularity. See [method set_angular_velocity].
*/
func (o *RigidBody2D) GetAngularVelocity() float64 {
	log.Println("Calling RigidBody2D.GetAngularVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_angular_velocity", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the applied force vector.
*/
func (o *RigidBody2D) GetAppliedForce() *Vector2 {
	log.Println("Calling RigidBody2D.GetAppliedForce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_applied_force", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the torque which is being applied to this body.
*/
func (o *RigidBody2D) GetAppliedTorque() float64 {
	log.Println("Calling RigidBody2D.GetAppliedTorque()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_applied_torque", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the body bounciness.
*/
func (o *RigidBody2D) GetBounce() float64 {
	log.Println("Calling RigidBody2D.GetBounce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bounce", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return a list of the bodies colliding with this one. By default, number of max contacts reported is at 0 , see [method set_max_contacts_reported] to increase it. You must also enable contact monitor, see [method set_contact_monitor]
*/
func (o *RigidBody2D) GetCollidingBodies() *Array {
	log.Println("Calling RigidBody2D.GetCollidingBodies()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_colliding_bodies", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Return whether this body is using continuous collision detection.
*/
func (o *RigidBody2D) GetContinuousCollisionDetectionMode() int64 {
	log.Println("Calling RigidBody2D.GetContinuousCollisionDetectionMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_continuous_collision_detection_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the body friction.
*/
func (o *RigidBody2D) GetFriction() float64 {
	log.Println("Calling RigidBody2D.GetFriction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_friction", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the gravity factor.
*/
func (o *RigidBody2D) GetGravityScale() float64 {
	log.Println("Calling RigidBody2D.GetGravityScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gravity_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the body's moment of inertia. This is usually automatically computed from the mass and the shapes. Note that this doesn't seem to work in a [code]_ready[/code] function: it apparently has not been auto-computed yet.
*/
func (o *RigidBody2D) GetInertia() float64 {
	log.Println("Calling RigidBody2D.GetInertia()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_inertia", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the linear damp for this body.
*/
func (o *RigidBody2D) GetLinearDamp() float64 {
	log.Println("Calling RigidBody2D.GetLinearDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_linear_damp", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the body linear velocity. This changes by physics granularity. See [method set_linear_velocity].
*/
func (o *RigidBody2D) GetLinearVelocity() *Vector2 {
	log.Println("Calling RigidBody2D.GetLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_linear_velocity", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the body mass.
*/
func (o *RigidBody2D) GetMass() float64 {
	log.Println("Calling RigidBody2D.GetMass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mass", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the maximum contacts that can be reported. See [method set_max_contacts_reported].
*/
func (o *RigidBody2D) GetMaxContactsReported() int64 {
	log.Println("Calling RigidBody2D.GetMaxContactsReported()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_max_contacts_reported", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the current body mode, see [method set_mode].
*/
func (o *RigidBody2D) GetMode() int64 {
	log.Println("Calling RigidBody2D.GetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the body weight given standard earth-weight (gravity 9.8).
*/
func (o *RigidBody2D) GetWeight() float64 {
	log.Println("Calling RigidBody2D.GetWeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_weight", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return true if the body has the ability to fall asleep when not moving. See [method set_can_sleep].
*/
func (o *RigidBody2D) IsAbleToSleep() *bool {
	log.Println("Calling RigidBody2D.IsAbleToSleep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_able_to_sleep", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether contact monitoring is enabled.
*/
func (o *RigidBody2D) IsContactMonitorEnabled() *bool {
	log.Println("Calling RigidBody2D.IsContactMonitorEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_contact_monitor_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether the body is sleeping.
*/
func (o *RigidBody2D) IsSleeping() *bool {
	log.Println("Calling RigidBody2D.IsSleeping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_sleeping", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if the body is not doing any built-in force integration.
*/
func (o *RigidBody2D) IsUsingCustomIntegrator() *bool {
	log.Println("Calling RigidBody2D.IsUsingCustomIntegrator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_using_custom_integrator", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Set the angular damp for this body. If this value is different from -1, any angular damp derived from the world or areas will be overridden.
*/
func (o *RigidBody2D) SetAngularDamp(angularDamp float64) {
	log.Println("Calling RigidBody2D.SetAngularDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(angularDamp)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_angular_damp", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the body angular velocity. Can be used sporadically, but [b]DON'T SET THIS IN EVERY FRAME[/b], because physics may be running in another thread and definitely runs at a different granularity. Use [method _integrate_forces] as your process loop if you want to have precise control of the body state.
*/
func (o *RigidBody2D) SetAngularVelocity(angularVelocity float64) {
	log.Println("Calling RigidBody2D.SetAngularVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(angularVelocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_angular_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the applied force vector. This is the equivalent of pushing a box over the ground: the force applied is applied constantly.
*/
func (o *RigidBody2D) SetAppliedForce(force *Vector2) {
	log.Println("Calling RigidBody2D.SetAppliedForce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(force)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_applied_force", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set a constant torque which will be applied to this body.
*/
func (o *RigidBody2D) SetAppliedTorque(torque float64) {
	log.Println("Calling RigidBody2D.SetAppliedTorque()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(torque)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_applied_torque", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set an axis velocity. The velocity in the given vector axis will be set as the given vector length. This is useful for jumping behavior.
*/
func (o *RigidBody2D) SetAxisVelocity(axisVelocity *Vector2) {
	log.Println("Calling RigidBody2D.SetAxisVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(axisVelocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_axis_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the body bounciness, from 0 (no bounce) to 1 (full bounce).
*/
func (o *RigidBody2D) SetBounce(bounce float64) {
	log.Println("Calling RigidBody2D.SetBounce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bounce)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bounce", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set the body ability to fall asleep when not moving. This saves an enormous amount of processor time when there are plenty of rigid bodies (non static) in a scene.
				Sleeping bodies are not affected by forces until a collision or an [method apply_impulse] / [method set_applied_force] wakes them up. Until then, they behave like a static body.
*/
func (o *RigidBody2D) SetCanSleep(ableToSleep *bool) {
	log.Println("Calling RigidBody2D.SetCanSleep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ableToSleep)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_can_sleep", goArguments, "")

	log.Println("Got return value!")

}

/*
   Enable contact monitoring. This allows the body to emit signals when it collides with another.
*/
func (o *RigidBody2D) SetContactMonitor(enabled *bool) {
	log.Println("Calling RigidBody2D.SetContactMonitor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_contact_monitor", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set the continuous collision detection mode from the enum CCD_MODE_*.
				Continuous collision detection tries to predict where a moving body will collide, instead of moving it and correcting its movement if it collided. The first is more precise, and misses less impacts by small, fast-moving objects. The second is faster to compute, but can miss small, fast-moving objects.
*/
func (o *RigidBody2D) SetContinuousCollisionDetectionMode(mode int64) {
	log.Println("Calling RigidBody2D.SetContinuousCollisionDetectionMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_continuous_collision_detection_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the body friction, from 0 (frictionless) to 1 (full friction).
*/
func (o *RigidBody2D) SetFriction(friction float64) {
	log.Println("Calling RigidBody2D.SetFriction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(friction)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_friction", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the gravity factor. This factor multiplies gravity intensity just for this body.
*/
func (o *RigidBody2D) SetGravityScale(gravityScale float64) {
	log.Println("Calling RigidBody2D.SetGravityScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(gravityScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gravity_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the body's moment of inertia. This is like mass, but for rotation: it determines how much torque it takes to rotate the body. The moment of inertia is usually computed automatically from the mass and the shapes, but this function allows you to set a custom value. Set 0 (or negative) inertia to return to automatically computing it.
*/
func (o *RigidBody2D) SetInertia(inertia float64) {
	log.Println("Calling RigidBody2D.SetInertia()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(inertia)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_inertia", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the linear damp for this body. If this value is different from -1, any linear damp derived from the world or areas will be overridden.
*/
func (o *RigidBody2D) SetLinearDamp(linearDamp float64) {
	log.Println("Calling RigidBody2D.SetLinearDamp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(linearDamp)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_linear_damp", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the body linear velocity. Can be used sporadically, but [b]DON'T SET THIS IN EVERY FRAME[/b], because physics may be running in another thread and definitely runs at a different granularity. Use [method _integrate_forces] as your process loop if you want to have precise control of the body state.
*/
func (o *RigidBody2D) SetLinearVelocity(linearVelocity *Vector2) {
	log.Println("Calling RigidBody2D.SetLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(linearVelocity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_linear_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the body mass.
*/
func (o *RigidBody2D) SetMass(mass float64) {
	log.Println("Calling RigidBody2D.SetMass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mass)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mass", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the maximum contacts to report. Bodies can keep a log of the contacts with other bodies, this is enabled by setting the maximum amount of contacts reported to a number greater than 0.
*/
func (o *RigidBody2D) SetMaxContactsReported(amount int64) {
	log.Println("Calling RigidBody2D.SetMaxContactsReported()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max_contacts_reported", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the body mode, from the MODE_* enum. This allows to change to a static body or a character body.
*/
func (o *RigidBody2D) SetMode(mode int64) {
	log.Println("Calling RigidBody2D.SetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether a body is sleeping or not. Sleeping bodies are not affected by forces until a collision or an [method apply_impulse] / [method set_applied_force] wakes them up. Until then, they behave like a static body.
*/
func (o *RigidBody2D) SetSleeping(sleeping *bool) {
	log.Println("Calling RigidBody2D.SetSleeping()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(sleeping)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sleeping", goArguments, "")

	log.Println("Got return value!")

}

/*
   Pass true to disable the internal force integration (like gravity or air friction) for this body. Other than collision response, the body will only move as determined by the [method _integrate_forces] function, if defined.
*/
func (o *RigidBody2D) SetUseCustomIntegrator(enable *bool) {
	log.Println("Calling RigidBody2D.SetUseCustomIntegrator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_custom_integrator", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the body weight given standard earth-weight (gravity 9.8). Not really useful for 2D since most measures for this node are in pixels.
*/
func (o *RigidBody2D) SetWeight(weight float64) {
	log.Println("Calling RigidBody2D.SetWeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(weight)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_weight", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return whether the body would collide, if it tried to move in the given vector. This method allows two extra parameters: A margin, which increases slightly the size of the shapes involved in the collision detection, and an object of type [Physics2DTestMotionResult], which will store additional information about the collision (should there be one).
*/
func (o *RigidBody2D) TestMotion(motion *Vector2, margin float64, result *Physics2DTestMotionResult) *bool {
	log.Println("Calling RigidBody2D.TestMotion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(motion)
	goArguments[1] = reflect.ValueOf(margin)
	goArguments[2] = reflect.ValueOf(result)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "test_motion", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
        RigidBody2DImplementer is an interface for RigidBody2D objects.
        Rigid body 2D node. This node is used for placing rigid bodies in the scene. It can contain a number of shapes, and also shift state between regular Rigid body, Kinematic, Character or Static.
		Character mode forbids the node from being rotated. This node can have a custom force integrator function, for writing complex physics motion behavior per node.
		As a warning, don't change this node position every frame or very often. Sporadic changes work fine, but physics runs at a different granularity (fixed hz) than usual rendering (process callback) and maybe even in a separate thread, so changing this from a process loop will yield strange behavior.
*/
type RigidBody2DImplementer interface {
	PhysicsBody2DImplementer

	X_IntegrateForces(state *Physics2DDirectBodyState)

	AddForce(offset *Vector2, force *Vector2)

	ApplyImpulse(offset *Vector2, impulse *Vector2)

	GetAngularDamp() float64

	GetAngularVelocity() float64

	GetAppliedForce() *Vector2

	GetAppliedTorque() float64

	GetBounce() float64

	GetCollidingBodies() *Array

	GetContinuousCollisionDetectionMode() int64

	GetFriction() float64

	GetGravityScale() float64

	GetInertia() float64

	GetLinearDamp() float64

	GetLinearVelocity() *Vector2

	GetMass() float64

	GetMaxContactsReported() int64

	GetMode() int64

	GetWeight() float64

	IsAbleToSleep() *bool

	IsContactMonitorEnabled() *bool

	IsSleeping() *bool

	IsUsingCustomIntegrator() *bool

	SetAngularDamp(angularDamp float64)

	SetAngularVelocity(angularVelocity float64)

	SetAppliedForce(force *Vector2)

	SetAppliedTorque(torque float64)

	SetAxisVelocity(axisVelocity *Vector2)

	SetBounce(bounce float64)

	SetCanSleep(ableToSleep *bool)

	SetContactMonitor(enabled *bool)

	SetContinuousCollisionDetectionMode(mode int64)

	SetFriction(friction float64)

	SetGravityScale(gravityScale float64)

	SetInertia(inertia float64)

	SetLinearDamp(linearDamp float64)

	SetLinearVelocity(linearVelocity *Vector2)

	SetMass(mass float64)

	SetMaxContactsReported(amount int64)

	SetMode(mode int64)

	SetSleeping(sleeping *bool)

	SetUseCustomIntegrator(enable *bool)

	SetWeight(weight float64)

	TestMotion(motion *Vector2, margin float64, result *Physics2DTestMotionResult) *bool
}

/*

 */
type SceneState struct {
	Reference
}

func (o *SceneState) baseClass() string {
	return "SceneState"
}

/*

 */
func (o *SceneState) GetConnectionBinds(idx int64) *Array {
	log.Println("Calling SceneState.GetConnectionBinds()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_binds", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *SceneState) GetConnectionCount() int64 {
	log.Println("Calling SceneState.GetConnectionCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SceneState) GetConnectionFlags(idx int64) int64 {
	log.Println("Calling SceneState.GetConnectionFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_flags", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SceneState) GetConnectionMethod(idx int64) string {
	log.Println("Calling SceneState.GetConnectionMethod()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_method", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *SceneState) GetConnectionSignal(idx int64) string {
	log.Println("Calling SceneState.GetConnectionSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_signal", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *SceneState) GetConnectionSource(idx int64) *NodePath {
	log.Println("Calling SceneState.GetConnectionSource()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_source", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *SceneState) GetConnectionTarget(idx int64) *NodePath {
	log.Println("Calling SceneState.GetConnectionTarget()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connection_target", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *SceneState) GetNodeCount() int64 {
	log.Println("Calling SceneState.GetNodeCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SceneState) GetNodeGroups(idx int64) *PoolStringArray {
	log.Println("Calling SceneState.GetNodeGroups()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_groups", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*

 */
func (o *SceneState) GetNodeInstance(idx int64) *PackedScene {
	log.Println("Calling SceneState.GetNodeInstance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_instance", goArguments, "*PackedScene")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PackedScene)

	return returnValue

}

/*

 */
func (o *SceneState) GetNodeInstancePlaceholder(idx int64) string {
	log.Println("Calling SceneState.GetNodeInstancePlaceholder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_instance_placeholder", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *SceneState) GetNodeName(idx int64) string {
	log.Println("Calling SceneState.GetNodeName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *SceneState) GetNodeOwnerPath(idx int64) *NodePath {
	log.Println("Calling SceneState.GetNodeOwnerPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_owner_path", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *SceneState) GetNodePath(idx int64, forParent *bool) *NodePath {
	log.Println("Calling SceneState.GetNodePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(forParent)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_path", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *SceneState) GetNodePropertyCount(idx int64) int64 {
	log.Println("Calling SceneState.GetNodePropertyCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_property_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SceneState) GetNodePropertyName(idx int64, propIdx int64) string {
	log.Println("Calling SceneState.GetNodePropertyName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(propIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_property_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *SceneState) GetNodePropertyValue(idx int64, propIdx int64) *Variant {
	log.Println("Calling SceneState.GetNodePropertyValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(propIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_property_value", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *SceneState) GetNodeType(idx int64) string {
	log.Println("Calling SceneState.GetNodeType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_type", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *SceneState) IsNodeInstancePlaceholder(idx int64) *bool {
	log.Println("Calling SceneState.IsNodeInstancePlaceholder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_node_instance_placeholder", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   SceneStateImplementer is an interface for SceneState objects.

*/
type SceneStateImplementer interface {
	ReferenceImplementer

	GetConnectionBinds(idx int64) *Array

	GetConnectionCount() int64

	GetConnectionFlags(idx int64) int64

	GetConnectionMethod(idx int64) string

	GetConnectionSignal(idx int64) string

	GetConnectionSource(idx int64) *NodePath

	GetConnectionTarget(idx int64) *NodePath

	GetNodeCount() int64

	GetNodeGroups(idx int64) *PoolStringArray

	GetNodeInstance(idx int64) *PackedScene

	GetNodeInstancePlaceholder(idx int64) string

	GetNodeName(idx int64) string

	GetNodeOwnerPath(idx int64) *NodePath

	GetNodePath(idx int64, forParent *bool) *NodePath

	GetNodePropertyCount(idx int64) int64

	GetNodePropertyName(idx int64, propIdx int64) string

	GetNodePropertyValue(idx int64, propIdx int64) *Variant

	GetNodeType(idx int64) string

	IsNodeInstancePlaceholder(idx int64) *bool
}

/*

 */
type SceneTree struct {
	MainLoop
}

func (o *SceneTree) baseClass() string {
	return "SceneTree"
}

/*

 */
func (o *SceneTree) CallGroup(group string, method string) *Variant {
	log.Println("Calling SceneTree.CallGroup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(group)
	goArguments[1] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "call_group", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *SceneTree) CallGroupFlags(flags int64, group string, method string) *Variant {
	log.Println("Calling SceneTree.CallGroupFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(flags)
	goArguments[1] = reflect.ValueOf(group)
	goArguments[2] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "call_group_flags", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *SceneTree) ChangeScene(path string) int64 {
	log.Println("Calling SceneTree.ChangeScene()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "change_scene", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SceneTree) ChangeSceneTo(packedScene *PackedScene) int64 {
	log.Println("Calling SceneTree.ChangeSceneTo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(packedScene)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "change_scene_to", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SceneTree) CreateTimer(timeSec float64, pauseModeProcess *bool) *SceneTreeTimer {
	log.Println("Calling SceneTree.CreateTimer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(timeSec)
	goArguments[1] = reflect.ValueOf(pauseModeProcess)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "create_timer", goArguments, "*SceneTreeTimer")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*SceneTreeTimer)

	return returnValue

}

/*

 */
func (o *SceneTree) GetCurrentScene() *Node {
	log.Println("Calling SceneTree.GetCurrentScene()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_scene", goArguments, "*Node")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Node)

	return returnValue

}

/*

 */
func (o *SceneTree) GetEditedSceneRoot() *Node {
	log.Println("Calling SceneTree.GetEditedSceneRoot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_edited_scene_root", goArguments, "*Node")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Node)

	return returnValue

}

/*

 */
func (o *SceneTree) GetFrame() int64 {
	log.Println("Calling SceneTree.GetFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_frame", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SceneTree) GetNetworkConnectedPeers() *PoolIntArray {
	log.Println("Calling SceneTree.GetNetworkConnectedPeers()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_network_connected_peers", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*

 */
func (o *SceneTree) GetNetworkUniqueId() int64 {
	log.Println("Calling SceneTree.GetNetworkUniqueId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_network_unique_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SceneTree) GetNodeCount() int64 {
	log.Println("Calling SceneTree.GetNodeCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SceneTree) GetNodesInGroup(group string) *Array {
	log.Println("Calling SceneTree.GetNodesInGroup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(group)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_nodes_in_group", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *SceneTree) GetRoot() *Viewport {
	log.Println("Calling SceneTree.GetRoot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_root", goArguments, "*Viewport")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Viewport)

	return returnValue

}

/*

 */
func (o *SceneTree) GetRpcSenderId() int64 {
	log.Println("Calling SceneTree.GetRpcSenderId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rpc_sender_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SceneTree) HasGroup(name string) *bool {
	log.Println("Calling SceneTree.HasGroup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_group", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns true if there is a [NetworkedMultiplayerPeer] set (with [method SceneTree.set_network_peer]).
*/
func (o *SceneTree) HasNetworkPeer() *bool {
	log.Println("Calling SceneTree.HasNetworkPeer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_network_peer", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *SceneTree) IsDebuggingCollisionsHint() *bool {
	log.Println("Calling SceneTree.IsDebuggingCollisionsHint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_debugging_collisions_hint", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *SceneTree) IsDebuggingNavigationHint() *bool {
	log.Println("Calling SceneTree.IsDebuggingNavigationHint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_debugging_navigation_hint", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *SceneTree) IsInputHandled() *bool {
	log.Println("Calling SceneTree.IsInputHandled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_input_handled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns true if this SceneTree's [NetworkedMultiplayerPeer] is in server mode (listening for connections).
*/
func (o *SceneTree) IsNetworkServer() *bool {
	log.Println("Calling SceneTree.IsNetworkServer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_network_server", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *SceneTree) IsPaused() *bool {
	log.Println("Calling SceneTree.IsPaused()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_paused", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *SceneTree) IsRefusingNewNetworkConnections() *bool {
	log.Println("Calling SceneTree.IsRefusingNewNetworkConnections()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_refusing_new_network_connections", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *SceneTree) NotifyGroup(group string, notification int64) {
	log.Println("Calling SceneTree.NotifyGroup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(group)
	goArguments[1] = reflect.ValueOf(notification)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "notify_group", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTree) NotifyGroupFlags(callFlags int64, group string, notification int64) {
	log.Println("Calling SceneTree.NotifyGroupFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(callFlags)
	goArguments[1] = reflect.ValueOf(group)
	goArguments[2] = reflect.ValueOf(notification)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "notify_group_flags", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTree) QueueDelete(obj *Object) {
	log.Println("Calling SceneTree.QueueDelete()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(obj)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "queue_delete", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTree) Quit() {
	log.Println("Calling SceneTree.Quit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "quit", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTree) ReloadCurrentScene() int64 {
	log.Println("Calling SceneTree.ReloadCurrentScene()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "reload_current_scene", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SceneTree) SetAutoAcceptQuit(enabled *bool) {
	log.Println("Calling SceneTree.SetAutoAcceptQuit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_auto_accept_quit", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTree) SetCurrentScene(childNode *Node) {
	log.Println("Calling SceneTree.SetCurrentScene()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(childNode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_current_scene", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTree) SetDebugCollisionsHint(enable *bool) {
	log.Println("Calling SceneTree.SetDebugCollisionsHint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_debug_collisions_hint", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTree) SetDebugNavigationHint(enable *bool) {
	log.Println("Calling SceneTree.SetDebugNavigationHint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_debug_navigation_hint", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTree) SetEditedSceneRoot(scene *Node) {
	log.Println("Calling SceneTree.SetEditedSceneRoot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scene)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_edited_scene_root", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTree) SetGroup(group string, property string, value *Variant) {
	log.Println("Calling SceneTree.SetGroup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(group)
	goArguments[1] = reflect.ValueOf(property)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_group", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTree) SetGroupFlags(callFlags int64, group string, property string, value *Variant) {
	log.Println("Calling SceneTree.SetGroupFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(callFlags)
	goArguments[1] = reflect.ValueOf(group)
	goArguments[2] = reflect.ValueOf(property)
	goArguments[3] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_group_flags", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTree) SetInputAsHandled() {
	log.Println("Calling SceneTree.SetInputAsHandled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_input_as_handled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the peer object to handle the RPC system (effectively enabling networking). Depending on the peer itself, the SceneTree will become a network server (check with [method is_network_server()]) and will set root node's network mode to master (see NETWORK_MODE_* constants in [Node]), or it will become a regular peer with root node set to slave. All child nodes are set to inherit the network mode by default. Handling of networking-related events (connection, disconnection, new clients) is done by connecting to SceneTree's signals.
*/
func (o *SceneTree) SetNetworkPeer(peer *NetworkedMultiplayerPeer) {
	log.Println("Calling SceneTree.SetNetworkPeer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(peer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_network_peer", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTree) SetPause(enable *bool) {
	log.Println("Calling SceneTree.SetPause()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pause", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTree) SetRefuseNewNetworkConnections(refuse *bool) {
	log.Println("Calling SceneTree.SetRefuseNewNetworkConnections()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(refuse)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_refuse_new_network_connections", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SceneTree) SetScreenStretch(mode int64, aspect int64, minsize *Vector2, shrink int64) {
	log.Println("Calling SceneTree.SetScreenStretch()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(mode)
	goArguments[1] = reflect.ValueOf(aspect)
	goArguments[2] = reflect.ValueOf(minsize)
	goArguments[3] = reflect.ValueOf(shrink)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_screen_stretch", goArguments, "")

	log.Println("Got return value!")

}

/*
   SceneTreeImplementer is an interface for SceneTree objects.

*/
type SceneTreeImplementer interface {
	MainLoopImplementer

	CallGroup(group string, method string) *Variant

	CallGroupFlags(flags int64, group string, method string) *Variant

	ChangeScene(path string) int64

	ChangeSceneTo(packedScene *PackedScene) int64

	CreateTimer(timeSec float64, pauseModeProcess *bool) *SceneTreeTimer

	GetCurrentScene() *Node

	GetEditedSceneRoot() *Node

	GetFrame() int64

	GetNetworkConnectedPeers() *PoolIntArray

	GetNetworkUniqueId() int64

	GetNodeCount() int64

	GetNodesInGroup(group string) *Array

	GetRoot() *Viewport

	GetRpcSenderId() int64

	HasGroup(name string) *bool

	HasNetworkPeer() *bool

	IsDebuggingCollisionsHint() *bool

	IsDebuggingNavigationHint() *bool

	IsInputHandled() *bool

	IsNetworkServer() *bool

	IsPaused() *bool

	IsRefusingNewNetworkConnections() *bool

	NotifyGroup(group string, notification int64)

	NotifyGroupFlags(callFlags int64, group string, notification int64)

	QueueDelete(obj *Object)

	Quit()

	ReloadCurrentScene() int64

	SetAutoAcceptQuit(enabled *bool)

	SetCurrentScene(childNode *Node)

	SetDebugCollisionsHint(enable *bool)

	SetDebugNavigationHint(enable *bool)

	SetEditedSceneRoot(scene *Node)

	SetGroup(group string, property string, value *Variant)

	SetGroupFlags(callFlags int64, group string, property string, value *Variant)

	SetInputAsHandled()

	SetNetworkPeer(peer *NetworkedMultiplayerPeer)

	SetPause(enable *bool)

	SetRefuseNewNetworkConnections(refuse *bool)

	SetScreenStretch(mode int64, aspect int64, minsize *Vector2, shrink int64)
}

/*

 */
type SceneTreeTimer struct {
	Reference
}

func (o *SceneTreeTimer) baseClass() string {
	return "SceneTreeTimer"
}

/*

 */
func (o *SceneTreeTimer) GetTimeLeft() float64 {
	log.Println("Calling SceneTreeTimer.GetTimeLeft()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_time_left", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SceneTreeTimer) SetTimeLeft(time float64) {
	log.Println("Calling SceneTreeTimer.SetTimeLeft()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(time)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_time_left", goArguments, "")

	log.Println("Got return value!")

}

/*
   SceneTreeTimerImplementer is an interface for SceneTreeTimer objects.

*/
type SceneTreeTimerImplementer interface {
	ReferenceImplementer

	GetTimeLeft() float64

	SetTimeLeft(time float64)
}

/*
   Base class for scripts. Any script that is loaded becomes one of these resources, which can then create instances.
*/
type Script struct {
	Resource
}

func (o *Script) baseClass() string {
	return "Script"
}

/*
   Return true if this script can be instance (ie not a library).
*/
func (o *Script) CanInstance() *bool {
	log.Println("Calling Script.CanInstance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "can_instance", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Script) GetNodeType() string {
	log.Println("Calling Script.GetNodeType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_type", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the script source code (if available).
*/
func (o *Script) GetSourceCode() string {
	log.Println("Calling Script.GetSourceCode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_source_code", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *Script) HasScriptSignal(signalName string) *bool {
	log.Println("Calling Script.HasScriptSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(signalName)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_script_signal", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if the script contains source code.
*/
func (o *Script) HasSourceCode() *bool {
	log.Println("Calling Script.HasSourceCode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_source_code", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if a given object uses an instance of this script.
*/
func (o *Script) InstanceHas(baseObject *Object) *bool {
	log.Println("Calling Script.InstanceHas()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(baseObject)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "instance_has", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Script) IsTool() *bool {
	log.Println("Calling Script.IsTool()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_tool", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Script) Reload(keepState *bool) int64 {
	log.Println("Calling Script.Reload()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(keepState)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "reload", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set the script source code.
*/
func (o *Script) SetSourceCode(source string) {
	log.Println("Calling Script.SetSourceCode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(source)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_source_code", goArguments, "")

	log.Println("Got return value!")

}

/*
   ScriptImplementer is an interface for Script objects.
   Base class for scripts. Any script that is loaded becomes one of these resources, which can then create instances.
*/
type ScriptImplementer interface {
	ResourceImplementer

	CanInstance() *bool

	GetNodeType() string

	GetSourceCode() string

	HasScriptSignal(signalName string) *bool

	HasSourceCode() *bool

	InstanceHas(baseObject *Object) *bool

	IsTool() *bool

	Reload(keepState *bool) int64

	SetSourceCode(source string)
}

/*

 */
type ScriptEditor struct {
	PanelContainer
}

func (o *ScriptEditor) baseClass() string {
	return "ScriptEditor"
}

/*
   Returns a [Script] that is currently active in editor.
*/
func (o *ScriptEditor) GetCurrentScript() *Script {
	log.Println("Calling ScriptEditor.GetCurrentScript()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_script", goArguments, "*Script")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Script)

	return returnValue

}

/*
   Returns an array with all [Script] objects which are currently open in editor.
*/
func (o *ScriptEditor) GetOpenScripts() *Array {
	log.Println("Calling ScriptEditor.GetOpenScripts()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_open_scripts", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   ScriptEditorImplementer is an interface for ScriptEditor objects.

*/
type ScriptEditorImplementer interface {
	PanelContainerImplementer

	GetCurrentScript() *Script

	GetOpenScripts() *Array
}

/*
   Scrollbars are a [Range] based [Control], that display a draggable area (the size of the page). Horizontal ([HScrollBar]) and Vertical ([VScrollBar]) versions are available.
*/
type ScrollBar struct {
	Range
}

func (o *ScrollBar) baseClass() string {
	return "ScrollBar"
}

/*

 */
func (o *ScrollBar) GetCustomStep() float64 {
	log.Println("Calling ScrollBar.GetCustomStep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_custom_step", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *ScrollBar) SetCustomStep(step float64) {
	log.Println("Calling ScrollBar.SetCustomStep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(step)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_custom_step", goArguments, "")

	log.Println("Got return value!")

}

/*
   ScrollBarImplementer is an interface for ScrollBar objects.
   Scrollbars are a [Range] based [Control], that display a draggable area (the size of the page). Horizontal ([HScrollBar]) and Vertical ([VScrollBar]) versions are available.
*/
type ScrollBarImplementer interface {
	RangeImplementer

	GetCustomStep() float64

	SetCustomStep(step float64)
}

/*
   A ScrollContainer node with a [Control] child and scrollbar child ([HScrollbar], [VScrollBar], or both) will only draw the Control within the ScrollContainer area.  Scrollbars will automatically be drawn at the right (for vertical) or bottom (for horizontal) and will enable dragging to move the viewable Control (and its children) within the ScrollContainer.  Scrollbars will also automatically resize the grabber based on the minimum_size of the Control relative to the ScrollContainer.  Works great with a [Panel] control.  You can set EXPAND on children size flags, so they will upscale to ScrollContainer size if ScrollContainer size is bigger (scroll is invisible for chosen dimension).
*/
type ScrollContainer struct {
	Container
}

func (o *ScrollContainer) baseClass() string {
	return "ScrollContainer"
}

/*
   Return current horizontal scroll value.
*/
func (o *ScrollContainer) GetHScroll() int64 {
	log.Println("Calling ScrollContainer.GetHScroll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_h_scroll", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return current vertical scroll value.
*/
func (o *ScrollContainer) GetVScroll() int64 {
	log.Println("Calling ScrollContainer.GetVScroll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_v_scroll", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return true if horizontal scroll is allowed.
*/
func (o *ScrollContainer) IsHScrollEnabled() *bool {
	log.Println("Calling ScrollContainer.IsHScrollEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_h_scroll_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if vertical scroll is allowed.
*/
func (o *ScrollContainer) IsVScrollEnabled() *bool {
	log.Println("Calling ScrollContainer.IsVScrollEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_v_scroll_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Set allows horizontal scroll.
*/
func (o *ScrollContainer) SetEnableHScroll(enable *bool) {
	log.Println("Calling ScrollContainer.SetEnableHScroll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_enable_h_scroll", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set allows vertical scroll.
*/
func (o *ScrollContainer) SetEnableVScroll(enable *bool) {
	log.Println("Calling ScrollContainer.SetEnableVScroll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_enable_v_scroll", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set horizontal scroll value.
*/
func (o *ScrollContainer) SetHScroll(val int64) {
	log.Println("Calling ScrollContainer.SetHScroll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(val)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_h_scroll", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set vertical scroll value.
*/
func (o *ScrollContainer) SetVScroll(val int64) {
	log.Println("Calling ScrollContainer.SetVScroll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(val)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_v_scroll", goArguments, "")

	log.Println("Got return value!")

}

/*
   ScrollContainerImplementer is an interface for ScrollContainer objects.
   A ScrollContainer node with a [Control] child and scrollbar child ([HScrollbar], [VScrollBar], or both) will only draw the Control within the ScrollContainer area.  Scrollbars will automatically be drawn at the right (for vertical) or bottom (for horizontal) and will enable dragging to move the viewable Control (and its children) within the ScrollContainer.  Scrollbars will also automatically resize the grabber based on the minimum_size of the Control relative to the ScrollContainer.  Works great with a [Panel] control.  You can set EXPAND on children size flags, so they will upscale to ScrollContainer size if ScrollContainer size is bigger (scroll is invisible for chosen dimension).
*/
type ScrollContainerImplementer interface {
	ContainerImplementer

	GetHScroll() int64

	GetVScroll() int64

	IsHScrollEnabled() *bool

	IsVScrollEnabled() *bool

	SetEnableHScroll(enable *bool)

	SetEnableVScroll(enable *bool)

	SetHScroll(val int64)

	SetVScroll(val int64)
}

/*
   Segment Shape for 2D Collision Detection, consists of two points, 'a' and 'b'.
*/
type SegmentShape2D struct {
	Shape2D
}

func (o *SegmentShape2D) baseClass() string {
	return "SegmentShape2D"
}

/*
   Return the first point's position.
*/
func (o *SegmentShape2D) GetA() *Vector2 {
	log.Println("Calling SegmentShape2D.GetA()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_a", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the second point's position.
*/
func (o *SegmentShape2D) GetB() *Vector2 {
	log.Println("Calling SegmentShape2D.GetB()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_b", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Set the first point's position.
*/
func (o *SegmentShape2D) SetA(a *Vector2) {
	log.Println("Calling SegmentShape2D.SetA()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(a)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_a", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the second point's position.
*/
func (o *SegmentShape2D) SetB(b *Vector2) {
	log.Println("Calling SegmentShape2D.SetB()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(b)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_b", goArguments, "")

	log.Println("Got return value!")

}

/*
   SegmentShape2DImplementer is an interface for SegmentShape2D objects.
   Segment Shape for 2D Collision Detection, consists of two points, 'a' and 'b'.
*/
type SegmentShape2DImplementer interface {
	Shape2DImplementer

	GetA() *Vector2

	GetB() *Vector2

	SetA(a *Vector2)

	SetB(b *Vector2)
}

/*
   A synchronization Semaphore. Element used in multi-threadding. Initialized to zero on creation.
*/
type Semaphore struct {
	Reference
}

func (o *Semaphore) baseClass() string {
	return "Semaphore"
}

/*
   Lowers the [Semaphore], allowing one more thread in.
*/
func (o *Semaphore) Post() int64 {
	log.Println("Calling Semaphore.Post()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "post", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Tries to wait for the [Semaphore], if its value is zero, blocks until non-zero.
*/
func (o *Semaphore) Wait() int64 {
	log.Println("Calling Semaphore.Wait()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "wait", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   SemaphoreImplementer is an interface for Semaphore objects.
   A synchronization Semaphore. Element used in multi-threadding. Initialized to zero on creation.
*/
type SemaphoreImplementer interface {
	ReferenceImplementer

	Post() int64

	Wait() int64
}

/*
   Separator is a [Control] used for separating other controls. It's purely a visual decoration. Horizontal ([HSeparator]) and Vertical ([VSeparator]) versions are available.
*/
type Separator struct {
	Control
}

func (o *Separator) baseClass() string {
	return "Separator"
}

/*
   SeparatorImplementer is an interface for Separator objects.
   Separator is a [Control] used for separating other controls. It's purely a visual decoration. Horizontal ([HSeparator]) and Vertical ([VSeparator]) versions are available.
*/
type SeparatorImplementer interface {
	ControlImplementer
}

/*
   To be changed, ignore.
*/
type Shader struct {
	Resource
}

func (o *Shader) baseClass() string {
	return "Shader"
}

/*

 */
func (o *Shader) GetCode() string {
	log.Println("Calling Shader.GetCode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_code", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *Shader) GetDefaultTextureParam(param string) *Texture {
	log.Println("Calling Shader.GetDefaultTextureParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_default_texture_param", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *Shader) GetMode() int64 {
	log.Println("Calling Shader.GetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Shader) HasParam(name string) *bool {
	log.Println("Calling Shader.HasParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_param", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Shader) SetCode(code string) {
	log.Println("Calling Shader.SetCode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(code)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_code", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Shader) SetDefaultTextureParam(param string, texture *Texture) {
	log.Println("Calling Shader.SetDefaultTextureParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(param)
	goArguments[1] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_default_texture_param", goArguments, "")

	log.Println("Got return value!")

}

/*
   ShaderImplementer is an interface for Shader objects.
   To be changed, ignore.
*/
type ShaderImplementer interface {
	ResourceImplementer

	GetCode() string

	GetDefaultTextureParam(param string) *Texture

	GetMode() int64

	HasParam(name string) *bool

	SetCode(code string)

	SetDefaultTextureParam(param string, texture *Texture)
}

/*

 */
type ShaderMaterial struct {
	Material
}

func (o *ShaderMaterial) baseClass() string {
	return "ShaderMaterial"
}

/*

 */
func (o *ShaderMaterial) GetShader() *Shader {
	log.Println("Calling ShaderMaterial.GetShader()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shader", goArguments, "*Shader")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Shader)

	return returnValue

}

/*

 */
func (o *ShaderMaterial) GetShaderParam(param string) *Variant {
	log.Println("Calling ShaderMaterial.GetShaderParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shader_param", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *ShaderMaterial) SetShader(shader *Shader) {
	log.Println("Calling ShaderMaterial.SetShader()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shader)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shader", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *ShaderMaterial) SetShaderParam(param string, value *Variant) {
	log.Println("Calling ShaderMaterial.SetShaderParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(param)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shader_param", goArguments, "")

	log.Println("Got return value!")

}

/*
   ShaderMaterialImplementer is an interface for ShaderMaterial objects.

*/
type ShaderMaterialImplementer interface {
	MaterialImplementer

	GetShader() *Shader

	GetShaderParam(param string) *Variant

	SetShader(shader *Shader)

	SetShaderParam(param string, value *Variant)
}

/*

 */
type Shape struct {
	Resource
}

func (o *Shape) baseClass() string {
	return "Shape"
}

/*
   ShapeImplementer is an interface for Shape objects.

*/
type ShapeImplementer interface {
	ResourceImplementer
}

/*
   Base class for all 2D Shapes. All 2D shape types inherit from this.
*/
type Shape2D struct {
	Resource
}

func (o *Shape2D) baseClass() string {
	return "Shape2D"
}

/*
                Return whether this shape is colliding with another.
				This method needs the transformation matrix for this shape ([code]local_xform[/code]), the shape to check collisions with ([code]with_shape[/code]), and the transformation matrix of that shape ([code]shape_xform[/code]).
*/
func (o *Shape2D) Collide(localXform *Transform2D, withShape *Shape2D, shapeXform *Transform2D) *bool {
	log.Println("Calling Shape2D.Collide()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(localXform)
	goArguments[1] = reflect.ValueOf(withShape)
	goArguments[2] = reflect.ValueOf(shapeXform)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "collide", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
                Return a list of the points where this shape touches another. If there are no collisions, the list is empty.
				This method needs the transformation matrix for this shape ([code]local_xform[/code]), the shape to check collisions with ([code]with_shape[/code]), and the transformation matrix of that shape ([code]shape_xform[/code]).
*/
func (o *Shape2D) CollideAndGetContacts(localXform *Transform2D, withShape *Shape2D, shapeXform *Transform2D) *Variant {
	log.Println("Calling Shape2D.CollideAndGetContacts()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(localXform)
	goArguments[1] = reflect.ValueOf(withShape)
	goArguments[2] = reflect.ValueOf(shapeXform)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "collide_and_get_contacts", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
                Return whether this shape would collide with another, if a given movement was applied.
				This method needs the transformation matrix for this shape ([code]local_xform[/code]), the movement to test on this shape ([code]local_motion[/code]), the shape to check collisions with ([code]with_shape[/code]), the transformation matrix of that shape ([code]shape_xform[/code]), and the movement to test onto the other object ([code]shape_motion[/code]).
*/
func (o *Shape2D) CollideWithMotion(localXform *Transform2D, localMotion *Vector2, withShape *Shape2D, shapeXform *Transform2D, shapeMotion *Vector2) *bool {
	log.Println("Calling Shape2D.CollideWithMotion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(localXform)
	goArguments[1] = reflect.ValueOf(localMotion)
	goArguments[2] = reflect.ValueOf(withShape)
	goArguments[3] = reflect.ValueOf(shapeXform)
	goArguments[4] = reflect.ValueOf(shapeMotion)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "collide_with_motion", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
                Return a list of the points where this shape would touch another, if a given movement was applied. If there are no collisions, the list is empty.
				This method needs the transformation matrix for this shape ([code]local_xform[/code]), the movement to test on this shape ([code]local_motion[/code]), the shape to check collisions with ([code]with_shape[/code]), the transformation matrix of that shape ([code]shape_xform[/code]), and the movement to test onto the other object ([code]shape_motion[/code]).
*/
func (o *Shape2D) CollideWithMotionAndGetContacts(localXform *Transform2D, localMotion *Vector2, withShape *Shape2D, shapeXform *Transform2D, shapeMotion *Vector2) *Variant {
	log.Println("Calling Shape2D.CollideWithMotionAndGetContacts()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(localXform)
	goArguments[1] = reflect.ValueOf(localMotion)
	goArguments[2] = reflect.ValueOf(withShape)
	goArguments[3] = reflect.ValueOf(shapeXform)
	goArguments[4] = reflect.ValueOf(shapeMotion)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "collide_with_motion_and_get_contacts", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Return the custom solver bias.
*/
func (o *Shape2D) GetCustomSolverBias() float64 {
	log.Println("Calling Shape2D.GetCustomSolverBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_custom_solver_bias", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
                Use a custom solver bias. No need to change this unless you really know what you are doing.
				The solver bias is a factor controlling how much two objects "rebound" off each other, when colliding, to avoid them getting into each other because of numerical imprecision.
*/
func (o *Shape2D) SetCustomSolverBias(bias float64) {
	log.Println("Calling Shape2D.SetCustomSolverBias()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bias)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_custom_solver_bias", goArguments, "")

	log.Println("Got return value!")

}

/*
   Shape2DImplementer is an interface for Shape2D objects.
   Base class for all 2D Shapes. All 2D shape types inherit from this.
*/
type Shape2DImplementer interface {
	ResourceImplementer

	Collide(localXform *Transform2D, withShape *Shape2D, shapeXform *Transform2D) *bool

	CollideAndGetContacts(localXform *Transform2D, withShape *Shape2D, shapeXform *Transform2D) *Variant

	CollideWithMotion(localXform *Transform2D, localMotion *Vector2, withShape *Shape2D, shapeXform *Transform2D, shapeMotion *Vector2) *bool

	CollideWithMotionAndGetContacts(localXform *Transform2D, localMotion *Vector2, withShape *Shape2D, shapeXform *Transform2D, shapeMotion *Vector2) *Variant

	GetCustomSolverBias() float64

	SetCustomSolverBias(bias float64)
}

/*

 */
type ShortCut struct {
	Resource
}

func (o *ShortCut) baseClass() string {
	return "ShortCut"
}

/*

 */
func (o *ShortCut) GetAsText() string {
	log.Println("Calling ShortCut.GetAsText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_as_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *ShortCut) GetShortcut() *InputEvent {
	log.Println("Calling ShortCut.GetShortcut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shortcut", goArguments, "*InputEvent")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*InputEvent)

	return returnValue

}

/*

 */
func (o *ShortCut) IsShortcut(event *InputEvent) *bool {
	log.Println("Calling ShortCut.IsShortcut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(event)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_shortcut", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ShortCut) IsValid() *bool {
	log.Println("Calling ShortCut.IsValid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_valid", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ShortCut) SetShortcut(event *InputEvent) {
	log.Println("Calling ShortCut.SetShortcut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(event)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shortcut", goArguments, "")

	log.Println("Got return value!")

}

/*
   ShortCutImplementer is an interface for ShortCut objects.

*/
type ShortCutImplementer interface {
	ResourceImplementer

	GetAsText() string

	GetShortcut() *InputEvent

	IsShortcut(event *InputEvent) *bool

	IsValid() *bool

	SetShortcut(event *InputEvent)
}

/*
   Skeleton provides a hierarchical interface for managing bones, including pose, rest and animation (see [Animation]). Skeleton will support rag doll dynamics in the future.
*/
type Skeleton struct {
	Spatial
}

func (o *Skeleton) baseClass() string {
	return "Skeleton"
}

/*
   Add a bone, with name "name". [method get_bone_count] will become the bone index.
*/
func (o *Skeleton) AddBone(name string) {
	log.Println("Calling Skeleton.AddBone()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_bone", goArguments, "")

	log.Println("Got return value!")

}

/*
   Deprecated soon.
*/
func (o *Skeleton) BindChildNodeToBone(boneIdx int64, node *Node) {
	log.Println("Calling Skeleton.BindChildNodeToBone()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(boneIdx)
	goArguments[1] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "bind_child_node_to_bone", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear all the bones in this skeleton.
*/
func (o *Skeleton) ClearBones() {
	log.Println("Calling Skeleton.ClearBones()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_bones", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the bone index that matches "name" as its name.
*/
func (o *Skeleton) FindBone(name string) int64 {
	log.Println("Calling Skeleton.FindBone()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "find_bone", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the amount of bones in the skeleton.
*/
func (o *Skeleton) GetBoneCount() int64 {
	log.Println("Calling Skeleton.GetBoneCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bone_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Skeleton) GetBoneCustomPose(boneIdx int64) *Transform {
	log.Println("Calling Skeleton.GetBoneCustomPose()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(boneIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bone_custom_pose", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*

 */
func (o *Skeleton) GetBoneGlobalPose(boneIdx int64) *Transform {
	log.Println("Calling Skeleton.GetBoneGlobalPose()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(boneIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bone_global_pose", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*
   Return the name of the bone at index "index"
*/
func (o *Skeleton) GetBoneName(boneIdx int64) string {
	log.Println("Calling Skeleton.GetBoneName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(boneIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bone_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the bone index which is the parent of the bone at "bone_idx". If -1, then bone has no parent. Note that the parent bone returned will always be less than "bone_idx".
*/
func (o *Skeleton) GetBoneParent(boneIdx int64) int64 {
	log.Println("Calling Skeleton.GetBoneParent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(boneIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bone_parent", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the pose transform for bone "bone_idx".
*/
func (o *Skeleton) GetBonePose(boneIdx int64) *Transform {
	log.Println("Calling Skeleton.GetBonePose()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(boneIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bone_pose", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*
   Return the rest transform for a bone "bone_idx".
*/
func (o *Skeleton) GetBoneRest(boneIdx int64) *Transform {
	log.Println("Calling Skeleton.GetBoneRest()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(boneIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bone_rest", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*

 */
func (o *Skeleton) GetBoneTransform(boneIdx int64) *Transform {
	log.Println("Calling Skeleton.GetBoneTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(boneIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bone_transform", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*
   Deprecated soon.
*/
func (o *Skeleton) GetBoundChildNodesToBone(boneIdx int64) *Array {
	log.Println("Calling Skeleton.GetBoundChildNodesToBone()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(boneIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bound_child_nodes_to_bone", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *Skeleton) IsBoneRestDisabled(boneIdx int64) *bool {
	log.Println("Calling Skeleton.IsBoneRestDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(boneIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_bone_rest_disabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Skeleton) SetBoneCustomPose(boneIdx int64, customPose *Transform) {
	log.Println("Calling Skeleton.SetBoneCustomPose()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(boneIdx)
	goArguments[1] = reflect.ValueOf(customPose)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bone_custom_pose", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Skeleton) SetBoneDisableRest(boneIdx int64, disable *bool) {
	log.Println("Calling Skeleton.SetBoneDisableRest()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(boneIdx)
	goArguments[1] = reflect.ValueOf(disable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bone_disable_rest", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Skeleton) SetBoneGlobalPose(boneIdx int64, pose *Transform) {
	log.Println("Calling Skeleton.SetBoneGlobalPose()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(boneIdx)
	goArguments[1] = reflect.ValueOf(pose)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bone_global_pose", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the bone index "parent_idx" as the parent of the bone at "bone_idx". If -1, then bone has no parent. Note: "parent_idx" must be less than "bone_idx".
*/
func (o *Skeleton) SetBoneParent(boneIdx int64, parentIdx int64) {
	log.Println("Calling Skeleton.SetBoneParent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(boneIdx)
	goArguments[1] = reflect.ValueOf(parentIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bone_parent", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the pose transform for bone "bone_idx".
*/
func (o *Skeleton) SetBonePose(boneIdx int64, pose *Transform) {
	log.Println("Calling Skeleton.SetBonePose()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(boneIdx)
	goArguments[1] = reflect.ValueOf(pose)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bone_pose", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the rest transform for bone "bone_idx"
*/
func (o *Skeleton) SetBoneRest(boneIdx int64, rest *Transform) {
	log.Println("Calling Skeleton.SetBoneRest()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(boneIdx)
	goArguments[1] = reflect.ValueOf(rest)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bone_rest", goArguments, "")

	log.Println("Got return value!")

}

/*
   Deprecated soon.
*/
func (o *Skeleton) UnbindChildNodeFromBone(boneIdx int64, node *Node) {
	log.Println("Calling Skeleton.UnbindChildNodeFromBone()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(boneIdx)
	goArguments[1] = reflect.ValueOf(node)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "unbind_child_node_from_bone", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Skeleton) UnparentBoneAndRest(boneIdx int64) {
	log.Println("Calling Skeleton.UnparentBoneAndRest()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(boneIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "unparent_bone_and_rest", goArguments, "")

	log.Println("Got return value!")

}

/*
   SkeletonImplementer is an interface for Skeleton objects.
   Skeleton provides a hierarchical interface for managing bones, including pose, rest and animation (see [Animation]). Skeleton will support rag doll dynamics in the future.
*/
type SkeletonImplementer interface {
	SpatialImplementer

	AddBone(name string)

	BindChildNodeToBone(boneIdx int64, node *Node)

	ClearBones()

	FindBone(name string) int64

	GetBoneCount() int64

	GetBoneCustomPose(boneIdx int64) *Transform

	GetBoneGlobalPose(boneIdx int64) *Transform

	GetBoneName(boneIdx int64) string

	GetBoneParent(boneIdx int64) int64

	GetBonePose(boneIdx int64) *Transform

	GetBoneRest(boneIdx int64) *Transform

	GetBoneTransform(boneIdx int64) *Transform

	GetBoundChildNodesToBone(boneIdx int64) *Array

	IsBoneRestDisabled(boneIdx int64) *bool

	SetBoneCustomPose(boneIdx int64, customPose *Transform)

	SetBoneDisableRest(boneIdx int64, disable *bool)

	SetBoneGlobalPose(boneIdx int64, pose *Transform)

	SetBoneParent(boneIdx int64, parentIdx int64)

	SetBonePose(boneIdx int64, pose *Transform)

	SetBoneRest(boneIdx int64, rest *Transform)

	UnbindChildNodeFromBone(boneIdx int64, node *Node)

	UnparentBoneAndRest(boneIdx int64)
}

/*

 */
type Sky struct {
	Resource
}

func (o *Sky) baseClass() string {
	return "Sky"
}

/*

 */
func (o *Sky) GetRadianceSize() int64 {
	log.Println("Calling Sky.GetRadianceSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_radiance_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Sky) SetRadianceSize(size int64) {
	log.Println("Calling Sky.SetRadianceSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_radiance_size", goArguments, "")

	log.Println("Got return value!")

}

/*
   SkyImplementer is an interface for Sky objects.

*/
type SkyImplementer interface {
	ResourceImplementer

	GetRadianceSize() int64

	SetRadianceSize(size int64)
}

/*
   Base class for GUI Sliders.
*/
type Slider struct {
	Range
}

func (o *Slider) baseClass() string {
	return "Slider"
}

/*
   Return amounts of ticks to display on slider.
*/
func (o *Slider) GetTicks() int64 {
	log.Println("Calling Slider.GetTicks()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ticks", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return true if ticks are visible on borders.
*/
func (o *Slider) GetTicksOnBorders() *bool {
	log.Println("Calling Slider.GetTicksOnBorders()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ticks_on_borders", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Slider) IsEditable() *bool {
	log.Println("Calling Slider.IsEditable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_editable", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Slider) SetEditable(editable *bool) {
	log.Println("Calling Slider.SetEditable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(editable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_editable", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set amount of ticks to display in slider.
*/
func (o *Slider) SetTicks(count int64) {
	log.Println("Calling Slider.SetTicks()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(count)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ticks", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set true if ticks are visible on borders.
*/
func (o *Slider) SetTicksOnBorders(ticksOnBorder *bool) {
	log.Println("Calling Slider.SetTicksOnBorders()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ticksOnBorder)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ticks_on_borders", goArguments, "")

	log.Println("Got return value!")

}

/*
   SliderImplementer is an interface for Slider objects.
   Base class for GUI Sliders.
*/
type SliderImplementer interface {
	RangeImplementer

	GetTicks() int64

	GetTicksOnBorders() *bool

	IsEditable() *bool

	SetEditable(editable *bool)

	SetTicks(count int64)

	SetTicksOnBorders(ticksOnBorder *bool)
}

/*

 */
type SliderJoint struct {
	Joint
}

func (o *SliderJoint) baseClass() string {
	return "SliderJoint"
}

/*

 */
func (o *SliderJoint) GetParam(param int64) float64 {
	log.Println("Calling SliderJoint.GetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_param", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SliderJoint) SetParam(param int64, value float64) {
	log.Println("Calling SliderJoint.SetParam()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(param)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_param", goArguments, "")

	log.Println("Got return value!")

}

/*
   SliderJointImplementer is an interface for SliderJoint objects.

*/
type SliderJointImplementer interface {
	JointImplementer

	GetParam(param int64) float64

	SetParam(param int64, value float64)
}

/*
   Spatial is the base for every type of 3D [Node]. It contains a 3D [Transform] which can be set or get as local or global. If a Spatial [Node] has Spatial children, their transforms will be relative to the parent.
*/
type Spatial struct {
	Node
}

func (o *Spatial) baseClass() string {
	return "Spatial"
}

/*

 */
func (o *Spatial) GetGizmo() *SpatialGizmo {
	log.Println("Calling Spatial.GetGizmo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_gizmo", goArguments, "*SpatialGizmo")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*SpatialGizmo)

	return returnValue

}

/*
   Return the global transform, relative to worldspace.
*/
func (o *Spatial) GetGlobalTransform() *Transform {
	log.Println("Calling Spatial.GetGlobalTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_global_transform", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*
   Return the parent [Spatial], or an empty [Object] if no parent exists or parent is not of type [Spatial].
*/
func (o *Spatial) GetParentSpatial() *Spatial {
	log.Println("Calling Spatial.GetParentSpatial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_parent_spatial", goArguments, "*Spatial")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Spatial)

	return returnValue

}

/*
   Return the rotation (in radians).
*/
func (o *Spatial) GetRotation() *Vector3 {
	log.Println("Calling Spatial.GetRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rotation", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Return the rotation (in degrees).
*/
func (o *Spatial) GetRotationDeg() *Vector3 {
	log.Println("Calling Spatial.GetRotationDeg()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rotation_deg", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *Spatial) GetScale() *Vector3 {
	log.Println("Calling Spatial.GetScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scale", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Return the local transform, relative to the bone parent.
*/
func (o *Spatial) GetTransform() *Transform {
	log.Println("Calling Spatial.GetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_transform", goArguments, "*Transform")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform)

	return returnValue

}

/*

 */
func (o *Spatial) GetTranslation() *Vector3 {
	log.Println("Calling Spatial.GetTranslation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_translation", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *Spatial) GetWorld() *World {
	log.Println("Calling Spatial.GetWorld()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_world", goArguments, "*World")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*World)

	return returnValue

}

/*

 */
func (o *Spatial) GlobalRotate(normal *Vector3, radians float64) {
	log.Println("Calling Spatial.GlobalRotate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(normal)
	goArguments[1] = reflect.ValueOf(radians)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "global_rotate", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Spatial) GlobalTranslate(offset *Vector3) {
	log.Println("Calling Spatial.GlobalTranslate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "global_translate", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Spatial) Hide() {
	log.Println("Calling Spatial.Hide()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "hide", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Spatial) IsLocalTransformNotificationEnabled() *bool {
	log.Println("Calling Spatial.IsLocalTransformNotificationEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_local_transform_notification_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Spatial) IsSetAsToplevel() *bool {
	log.Println("Calling Spatial.IsSetAsToplevel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_set_as_toplevel", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Spatial) IsTransformNotificationEnabled() *bool {
	log.Println("Calling Spatial.IsTransformNotificationEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_transform_notification_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Spatial) IsVisible() *bool {
	log.Println("Calling Spatial.IsVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_visible", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Spatial) IsVisibleInTree() *bool {
	log.Println("Calling Spatial.IsVisibleInTree()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_visible_in_tree", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Spatial) LookAt(target *Vector3, up *Vector3) {
	log.Println("Calling Spatial.LookAt()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(target)
	goArguments[1] = reflect.ValueOf(up)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "look_at", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Spatial) LookAtFromPos(pos *Vector3, target *Vector3, up *Vector3) {
	log.Println("Calling Spatial.LookAtFromPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(pos)
	goArguments[1] = reflect.ValueOf(target)
	goArguments[2] = reflect.ValueOf(up)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "look_at_from_pos", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Spatial) Orthonormalize() {
	log.Println("Calling Spatial.Orthonormalize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "orthonormalize", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Spatial) Rotate(normal *Vector3, radians float64) {
	log.Println("Calling Spatial.Rotate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(normal)
	goArguments[1] = reflect.ValueOf(radians)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rotate", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Spatial) RotateX(radians float64) {
	log.Println("Calling Spatial.RotateX()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radians)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rotate_x", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Spatial) RotateY(radians float64) {
	log.Println("Calling Spatial.RotateY()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radians)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rotate_y", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Spatial) RotateZ(radians float64) {
	log.Println("Calling Spatial.RotateZ()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radians)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rotate_z", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Spatial) SetAsToplevel(enable *bool) {
	log.Println("Calling Spatial.SetAsToplevel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_as_toplevel", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Spatial) SetGizmo(gizmo *SpatialGizmo) {
	log.Println("Calling Spatial.SetGizmo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(gizmo)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_gizmo", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the transform globally, relative to worldspace.
*/
func (o *Spatial) SetGlobalTransform(global *Transform) {
	log.Println("Calling Spatial.SetGlobalTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(global)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_global_transform", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Spatial) SetIdentity() {
	log.Println("Calling Spatial.SetIdentity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_identity", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Spatial) SetIgnoreTransformNotification(enabled *bool) {
	log.Println("Calling Spatial.SetIgnoreTransformNotification()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ignore_transform_notification", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Spatial) SetNotifyLocalTransform(enable *bool) {
	log.Println("Calling Spatial.SetNotifyLocalTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_notify_local_transform", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Spatial) SetNotifyTransform(enable *bool) {
	log.Println("Calling Spatial.SetNotifyTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_notify_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the rotation (in radians).
*/
func (o *Spatial) SetRotation(rotationRad *Vector3) {
	log.Println("Calling Spatial.SetRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rotationRad)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rotation", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the rotation (in degrees).
*/
func (o *Spatial) SetRotationDeg(rotationDeg *Vector3) {
	log.Println("Calling Spatial.SetRotationDeg()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rotationDeg)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rotation_deg", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Spatial) SetScale(scale *Vector3) {
	log.Println("Calling Spatial.SetScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the transform locally, relative to the parent spatial node.
*/
func (o *Spatial) SetTransform(local *Transform) {
	log.Println("Calling Spatial.SetTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(local)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_transform", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Spatial) SetTranslation(translation *Vector3) {
	log.Println("Calling Spatial.SetTranslation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(translation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_translation", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Spatial) SetVisible(visible *bool) {
	log.Println("Calling Spatial.SetVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(visible)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_visible", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Spatial) Show() {
	log.Println("Calling Spatial.Show()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "show", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Spatial) ToGlobal(localPoint *Vector3) *Vector3 {
	log.Println("Calling Spatial.ToGlobal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(localPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "to_global", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *Spatial) ToLocal(globalPoint *Vector3) *Vector3 {
	log.Println("Calling Spatial.ToLocal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(globalPoint)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "to_local", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *Spatial) Translate(offset *Vector3) {
	log.Println("Calling Spatial.Translate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "translate", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Spatial) UpdateGizmo() {
	log.Println("Calling Spatial.UpdateGizmo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "update_gizmo", goArguments, "")

	log.Println("Got return value!")

}

/*
   SpatialImplementer is an interface for Spatial objects.
   Spatial is the base for every type of 3D [Node]. It contains a 3D [Transform] which can be set or get as local or global. If a Spatial [Node] has Spatial children, their transforms will be relative to the parent.
*/
type SpatialImplementer interface {
	NodeImplementer

	GetGizmo() *SpatialGizmo

	GetGlobalTransform() *Transform

	GetParentSpatial() *Spatial

	GetRotation() *Vector3

	GetRotationDeg() *Vector3

	GetScale() *Vector3

	GetTransform() *Transform

	GetTranslation() *Vector3

	GetWorld() *World

	GlobalRotate(normal *Vector3, radians float64)

	GlobalTranslate(offset *Vector3)

	Hide()

	IsLocalTransformNotificationEnabled() *bool

	IsSetAsToplevel() *bool

	IsTransformNotificationEnabled() *bool

	IsVisible() *bool

	IsVisibleInTree() *bool

	LookAt(target *Vector3, up *Vector3)

	LookAtFromPos(pos *Vector3, target *Vector3, up *Vector3)

	Orthonormalize()

	Rotate(normal *Vector3, radians float64)

	RotateX(radians float64)

	RotateY(radians float64)

	RotateZ(radians float64)

	SetAsToplevel(enable *bool)

	SetGizmo(gizmo *SpatialGizmo)

	SetGlobalTransform(global *Transform)

	SetIdentity()

	SetIgnoreTransformNotification(enabled *bool)

	SetNotifyLocalTransform(enable *bool)

	SetNotifyTransform(enable *bool)

	SetRotation(rotationRad *Vector3)

	SetRotationDeg(rotationDeg *Vector3)

	SetScale(scale *Vector3)

	SetTransform(local *Transform)

	SetTranslation(translation *Vector3)

	SetVisible(visible *bool)

	Show()

	ToGlobal(localPoint *Vector3) *Vector3

	ToLocal(globalPoint *Vector3) *Vector3

	Translate(offset *Vector3)

	UpdateGizmo()
}

/*

 */
type SpatialGizmo struct {
	Reference
}

func (o *SpatialGizmo) baseClass() string {
	return "SpatialGizmo"
}

/*
   SpatialGizmoImplementer is an interface for SpatialGizmo objects.

*/
type SpatialGizmoImplementer interface {
	ReferenceImplementer
}

/*

 */
type SpatialMaterial struct {
	Material
}

func (o *SpatialMaterial) baseClass() string {
	return "SpatialMaterial"
}

/*

 */
func (o *SpatialMaterial) GetAlbedo() *Color {
	log.Println("Calling SpatialMaterial.GetAlbedo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_albedo", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetAlphaScissorThreshold() float64 {
	log.Println("Calling SpatialMaterial.GetAlphaScissorThreshold()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_alpha_scissor_threshold", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetAnisotropy() float64 {
	log.Println("Calling SpatialMaterial.GetAnisotropy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_anisotropy", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetAoTextureChannel() int64 {
	log.Println("Calling SpatialMaterial.GetAoTextureChannel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ao_texture_channel", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetBillboardMode() int64 {
	log.Println("Calling SpatialMaterial.GetBillboardMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_billboard_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetBlendMode() int64 {
	log.Println("Calling SpatialMaterial.GetBlendMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_blend_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetClearcoat() float64 {
	log.Println("Calling SpatialMaterial.GetClearcoat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_clearcoat", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetClearcoatGloss() float64 {
	log.Println("Calling SpatialMaterial.GetClearcoatGloss()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_clearcoat_gloss", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetCullMode() int64 {
	log.Println("Calling SpatialMaterial.GetCullMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cull_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetDepthDeepParallaxMaxLayers() int64 {
	log.Println("Calling SpatialMaterial.GetDepthDeepParallaxMaxLayers()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_depth_deep_parallax_max_layers", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetDepthDeepParallaxMinLayers() int64 {
	log.Println("Calling SpatialMaterial.GetDepthDeepParallaxMinLayers()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_depth_deep_parallax_min_layers", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetDepthDrawMode() int64 {
	log.Println("Calling SpatialMaterial.GetDepthDrawMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_depth_draw_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetDepthScale() float64 {
	log.Println("Calling SpatialMaterial.GetDepthScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_depth_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetDetailBlendMode() int64 {
	log.Println("Calling SpatialMaterial.GetDetailBlendMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_detail_blend_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetDetailUv() int64 {
	log.Println("Calling SpatialMaterial.GetDetailUv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_detail_uv", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetDiffuseMode() int64 {
	log.Println("Calling SpatialMaterial.GetDiffuseMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_diffuse_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetEmission() *Color {
	log.Println("Calling SpatialMaterial.GetEmission()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_emission", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetEmissionEnergy() float64 {
	log.Println("Calling SpatialMaterial.GetEmissionEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_emission_energy", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetFeature(feature int64) *bool {
	log.Println("Calling SpatialMaterial.GetFeature()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(feature)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_feature", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetFlag(flag int64) *bool {
	log.Println("Calling SpatialMaterial.GetFlag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flag)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_flag", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetGrow() float64 {
	log.Println("Calling SpatialMaterial.GetGrow()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_grow", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetLineWidth() float64 {
	log.Println("Calling SpatialMaterial.GetLineWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_line_width", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetMetallic() float64 {
	log.Println("Calling SpatialMaterial.GetMetallic()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_metallic", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetMetallicTextureChannel() int64 {
	log.Println("Calling SpatialMaterial.GetMetallicTextureChannel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_metallic_texture_channel", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetNormalScale() float64 {
	log.Println("Calling SpatialMaterial.GetNormalScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_normal_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetParticlesAnimHFrames() int64 {
	log.Println("Calling SpatialMaterial.GetParticlesAnimHFrames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_particles_anim_h_frames", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetParticlesAnimLoop() int64 {
	log.Println("Calling SpatialMaterial.GetParticlesAnimLoop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_particles_anim_loop", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetParticlesAnimVFrames() int64 {
	log.Println("Calling SpatialMaterial.GetParticlesAnimVFrames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_particles_anim_v_frames", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetPointSize() float64 {
	log.Println("Calling SpatialMaterial.GetPointSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_point_size", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetRefraction() float64 {
	log.Println("Calling SpatialMaterial.GetRefraction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_refraction", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetRefractionTextureChannel() int64 {
	log.Println("Calling SpatialMaterial.GetRefractionTextureChannel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_refraction_texture_channel", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetRim() float64 {
	log.Println("Calling SpatialMaterial.GetRim()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rim", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetRimTint() float64 {
	log.Println("Calling SpatialMaterial.GetRimTint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rim_tint", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetRoughness() float64 {
	log.Println("Calling SpatialMaterial.GetRoughness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_roughness", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetRoughnessTextureChannel() int64 {
	log.Println("Calling SpatialMaterial.GetRoughnessTextureChannel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_roughness_texture_channel", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetSpecular() float64 {
	log.Println("Calling SpatialMaterial.GetSpecular()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_specular", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetSpecularMode() int64 {
	log.Println("Calling SpatialMaterial.GetSpecularMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_specular_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetSubsurfaceScatteringStrength() float64 {
	log.Println("Calling SpatialMaterial.GetSubsurfaceScatteringStrength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_subsurface_scattering_strength", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetTexture(param int64) *Texture {
	log.Println("Calling SpatialMaterial.GetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(param)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetUv1Offset() *Vector3 {
	log.Println("Calling SpatialMaterial.GetUv1Offset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_uv1_offset", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetUv1Scale() *Vector3 {
	log.Println("Calling SpatialMaterial.GetUv1Scale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_uv1_scale", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetUv1TriplanarBlendSharpness() float64 {
	log.Println("Calling SpatialMaterial.GetUv1TriplanarBlendSharpness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_uv1_triplanar_blend_sharpness", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetUv2Offset() *Vector3 {
	log.Println("Calling SpatialMaterial.GetUv2Offset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_uv2_offset", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetUv2Scale() *Vector3 {
	log.Println("Calling SpatialMaterial.GetUv2Scale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_uv2_scale", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) GetUv2TriplanarBlendSharpness() float64 {
	log.Println("Calling SpatialMaterial.GetUv2TriplanarBlendSharpness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_uv2_triplanar_blend_sharpness", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) IsDepthDeepParallaxEnabled() *bool {
	log.Println("Calling SpatialMaterial.IsDepthDeepParallaxEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_depth_deep_parallax_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) IsGrowEnabled() *bool {
	log.Println("Calling SpatialMaterial.IsGrowEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_grow_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *SpatialMaterial) SetAlbedo(albedo *Color) {
	log.Println("Calling SpatialMaterial.SetAlbedo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(albedo)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_albedo", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetAlphaScissorThreshold(threshold float64) {
	log.Println("Calling SpatialMaterial.SetAlphaScissorThreshold()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(threshold)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_alpha_scissor_threshold", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetAnisotropy(anisotropy float64) {
	log.Println("Calling SpatialMaterial.SetAnisotropy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(anisotropy)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_anisotropy", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetAoTextureChannel(channel int64) {
	log.Println("Calling SpatialMaterial.SetAoTextureChannel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(channel)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_ao_texture_channel", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetBillboardMode(mode int64) {
	log.Println("Calling SpatialMaterial.SetBillboardMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_billboard_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetBlendMode(blendMode int64) {
	log.Println("Calling SpatialMaterial.SetBlendMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(blendMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_blend_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetClearcoat(clearcoat float64) {
	log.Println("Calling SpatialMaterial.SetClearcoat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(clearcoat)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_clearcoat", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetClearcoatGloss(clearcoatGloss float64) {
	log.Println("Calling SpatialMaterial.SetClearcoatGloss()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(clearcoatGloss)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_clearcoat_gloss", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetCullMode(cullMode int64) {
	log.Println("Calling SpatialMaterial.SetCullMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(cullMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cull_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetDepthDeepParallax(enable *bool) {
	log.Println("Calling SpatialMaterial.SetDepthDeepParallax()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_depth_deep_parallax", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetDepthDeepParallaxMaxLayers(layer int64) {
	log.Println("Calling SpatialMaterial.SetDepthDeepParallaxMaxLayers()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_depth_deep_parallax_max_layers", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetDepthDeepParallaxMinLayers(layer int64) {
	log.Println("Calling SpatialMaterial.SetDepthDeepParallaxMinLayers()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_depth_deep_parallax_min_layers", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetDepthDrawMode(depthDrawMode int64) {
	log.Println("Calling SpatialMaterial.SetDepthDrawMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(depthDrawMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_depth_draw_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetDepthScale(depthScale float64) {
	log.Println("Calling SpatialMaterial.SetDepthScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(depthScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_depth_scale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetDetailBlendMode(detailBlendMode int64) {
	log.Println("Calling SpatialMaterial.SetDetailBlendMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(detailBlendMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_detail_blend_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetDetailUv(detailUv int64) {
	log.Println("Calling SpatialMaterial.SetDetailUv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(detailUv)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_detail_uv", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetDiffuseMode(diffuseMode int64) {
	log.Println("Calling SpatialMaterial.SetDiffuseMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(diffuseMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_diffuse_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetEmission(emission *Color) {
	log.Println("Calling SpatialMaterial.SetEmission()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(emission)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_emission", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetEmissionEnergy(emissionEnergy float64) {
	log.Println("Calling SpatialMaterial.SetEmissionEnergy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(emissionEnergy)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_emission_energy", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetFeature(feature int64, enable *bool) {
	log.Println("Calling SpatialMaterial.SetFeature()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(feature)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_feature", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetFlag(flag int64, enable *bool) {
	log.Println("Calling SpatialMaterial.SetFlag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(flag)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flag", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetGrow(amount float64) {
	log.Println("Calling SpatialMaterial.SetGrow()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_grow", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetGrowEnabled(enable *bool) {
	log.Println("Calling SpatialMaterial.SetGrowEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_grow_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetLineWidth(lineWidth float64) {
	log.Println("Calling SpatialMaterial.SetLineWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(lineWidth)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_line_width", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetMetallic(metallic float64) {
	log.Println("Calling SpatialMaterial.SetMetallic()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(metallic)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_metallic", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetMetallicTextureChannel(channel int64) {
	log.Println("Calling SpatialMaterial.SetMetallicTextureChannel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(channel)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_metallic_texture_channel", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetNormalScale(normalScale float64) {
	log.Println("Calling SpatialMaterial.SetNormalScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(normalScale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_normal_scale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetParticlesAnimHFrames(frames int64) {
	log.Println("Calling SpatialMaterial.SetParticlesAnimHFrames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(frames)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_particles_anim_h_frames", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetParticlesAnimLoop(frames int64) {
	log.Println("Calling SpatialMaterial.SetParticlesAnimLoop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(frames)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_particles_anim_loop", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetParticlesAnimVFrames(frames int64) {
	log.Println("Calling SpatialMaterial.SetParticlesAnimVFrames()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(frames)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_particles_anim_v_frames", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetPointSize(pointSize float64) {
	log.Println("Calling SpatialMaterial.SetPointSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pointSize)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_point_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetRefraction(refraction float64) {
	log.Println("Calling SpatialMaterial.SetRefraction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(refraction)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_refraction", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetRefractionTextureChannel(channel int64) {
	log.Println("Calling SpatialMaterial.SetRefractionTextureChannel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(channel)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_refraction_texture_channel", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetRim(rim float64) {
	log.Println("Calling SpatialMaterial.SetRim()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rim)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rim", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetRimTint(rimTint float64) {
	log.Println("Calling SpatialMaterial.SetRimTint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rimTint)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rim_tint", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetRoughness(roughness float64) {
	log.Println("Calling SpatialMaterial.SetRoughness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(roughness)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_roughness", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetRoughnessTextureChannel(channel int64) {
	log.Println("Calling SpatialMaterial.SetRoughnessTextureChannel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(channel)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_roughness_texture_channel", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetSpecular(specular float64) {
	log.Println("Calling SpatialMaterial.SetSpecular()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(specular)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_specular", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetSpecularMode(specularMode int64) {
	log.Println("Calling SpatialMaterial.SetSpecularMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(specularMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_specular_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetSubsurfaceScatteringStrength(strength float64) {
	log.Println("Calling SpatialMaterial.SetSubsurfaceScatteringStrength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(strength)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_subsurface_scattering_strength", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetTexture(param int64, texture *Texture) {
	log.Println("Calling SpatialMaterial.SetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(param)
	goArguments[1] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetUv1Offset(offset *Vector3) {
	log.Println("Calling SpatialMaterial.SetUv1Offset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_uv1_offset", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetUv1Scale(scale *Vector3) {
	log.Println("Calling SpatialMaterial.SetUv1Scale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_uv1_scale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetUv1TriplanarBlendSharpness(sharpness float64) {
	log.Println("Calling SpatialMaterial.SetUv1TriplanarBlendSharpness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(sharpness)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_uv1_triplanar_blend_sharpness", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetUv2Offset(offset *Vector3) {
	log.Println("Calling SpatialMaterial.SetUv2Offset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_uv2_offset", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetUv2Scale(scale *Vector3) {
	log.Println("Calling SpatialMaterial.SetUv2Scale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_uv2_scale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialMaterial) SetUv2TriplanarBlendSharpness(sharpness float64) {
	log.Println("Calling SpatialMaterial.SetUv2TriplanarBlendSharpness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(sharpness)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_uv2_triplanar_blend_sharpness", goArguments, "")

	log.Println("Got return value!")

}

/*
   SpatialMaterialImplementer is an interface for SpatialMaterial objects.

*/
type SpatialMaterialImplementer interface {
	MaterialImplementer

	GetAlbedo() *Color

	GetAlphaScissorThreshold() float64

	GetAnisotropy() float64

	GetAoTextureChannel() int64

	GetBillboardMode() int64

	GetBlendMode() int64

	GetClearcoat() float64

	GetClearcoatGloss() float64

	GetCullMode() int64

	GetDepthDeepParallaxMaxLayers() int64

	GetDepthDeepParallaxMinLayers() int64

	GetDepthDrawMode() int64

	GetDepthScale() float64

	GetDetailBlendMode() int64

	GetDetailUv() int64

	GetDiffuseMode() int64

	GetEmission() *Color

	GetEmissionEnergy() float64

	GetFeature(feature int64) *bool

	GetFlag(flag int64) *bool

	GetGrow() float64

	GetLineWidth() float64

	GetMetallic() float64

	GetMetallicTextureChannel() int64

	GetNormalScale() float64

	GetParticlesAnimHFrames() int64

	GetParticlesAnimLoop() int64

	GetParticlesAnimVFrames() int64

	GetPointSize() float64

	GetRefraction() float64

	GetRefractionTextureChannel() int64

	GetRim() float64

	GetRimTint() float64

	GetRoughness() float64

	GetRoughnessTextureChannel() int64

	GetSpecular() float64

	GetSpecularMode() int64

	GetSubsurfaceScatteringStrength() float64

	GetTexture(param int64) *Texture

	GetUv1Offset() *Vector3

	GetUv1Scale() *Vector3

	GetUv1TriplanarBlendSharpness() float64

	GetUv2Offset() *Vector3

	GetUv2Scale() *Vector3

	GetUv2TriplanarBlendSharpness() float64

	IsDepthDeepParallaxEnabled() *bool

	IsGrowEnabled() *bool

	SetAlbedo(albedo *Color)

	SetAlphaScissorThreshold(threshold float64)

	SetAnisotropy(anisotropy float64)

	SetAoTextureChannel(channel int64)

	SetBillboardMode(mode int64)

	SetBlendMode(blendMode int64)

	SetClearcoat(clearcoat float64)

	SetClearcoatGloss(clearcoatGloss float64)

	SetCullMode(cullMode int64)

	SetDepthDeepParallax(enable *bool)

	SetDepthDeepParallaxMaxLayers(layer int64)

	SetDepthDeepParallaxMinLayers(layer int64)

	SetDepthDrawMode(depthDrawMode int64)

	SetDepthScale(depthScale float64)

	SetDetailBlendMode(detailBlendMode int64)

	SetDetailUv(detailUv int64)

	SetDiffuseMode(diffuseMode int64)

	SetEmission(emission *Color)

	SetEmissionEnergy(emissionEnergy float64)

	SetFeature(feature int64, enable *bool)

	SetFlag(flag int64, enable *bool)

	SetGrow(amount float64)

	SetGrowEnabled(enable *bool)

	SetLineWidth(lineWidth float64)

	SetMetallic(metallic float64)

	SetMetallicTextureChannel(channel int64)

	SetNormalScale(normalScale float64)

	SetParticlesAnimHFrames(frames int64)

	SetParticlesAnimLoop(frames int64)

	SetParticlesAnimVFrames(frames int64)

	SetPointSize(pointSize float64)

	SetRefraction(refraction float64)

	SetRefractionTextureChannel(channel int64)

	SetRim(rim float64)

	SetRimTint(rimTint float64)

	SetRoughness(roughness float64)

	SetRoughnessTextureChannel(channel int64)

	SetSpecular(specular float64)

	SetSpecularMode(specularMode int64)

	SetSubsurfaceScatteringStrength(strength float64)

	SetTexture(param int64, texture *Texture)

	SetUv1Offset(offset *Vector3)

	SetUv1Scale(scale *Vector3)

	SetUv1TriplanarBlendSharpness(sharpness float64)

	SetUv2Offset(offset *Vector3)

	SetUv2Scale(scale *Vector3)

	SetUv2TriplanarBlendSharpness(sharpness float64)
}

/*

 */
type SpatialVelocityTracker struct {
	Reference
}

func (o *SpatialVelocityTracker) baseClass() string {
	return "SpatialVelocityTracker"
}

/*

 */
func (o *SpatialVelocityTracker) GetTrackedLinearVelocity() *Vector3 {
	log.Println("Calling SpatialVelocityTracker.GetTrackedLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tracked_linear_velocity", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *SpatialVelocityTracker) IsTrackingFixedStep() *bool {
	log.Println("Calling SpatialVelocityTracker.IsTrackingFixedStep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_tracking_fixed_step", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *SpatialVelocityTracker) Reset(position *Vector3) {
	log.Println("Calling SpatialVelocityTracker.Reset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "reset", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialVelocityTracker) SetTrackFixedStep(enable *bool) {
	log.Println("Calling SpatialVelocityTracker.SetTrackFixedStep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_track_fixed_step", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpatialVelocityTracker) UpdatePosition(position *Vector3) {
	log.Println("Calling SpatialVelocityTracker.UpdatePosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "update_position", goArguments, "")

	log.Println("Got return value!")

}

/*
   SpatialVelocityTrackerImplementer is an interface for SpatialVelocityTracker objects.

*/
type SpatialVelocityTrackerImplementer interface {
	ReferenceImplementer

	GetTrackedLinearVelocity() *Vector3

	IsTrackingFixedStep() *bool

	Reset(position *Vector3)

	SetTrackFixedStep(enable *bool)

	UpdatePosition(position *Vector3)
}

/*

 */
type SphereMesh struct {
	PrimitiveMesh
}

func (o *SphereMesh) baseClass() string {
	return "SphereMesh"
}

/*

 */
func (o *SphereMesh) GetHeight() float64 {
	log.Println("Calling SphereMesh.GetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_height", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SphereMesh) GetIsHemisphere() *bool {
	log.Println("Calling SphereMesh.GetIsHemisphere()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_is_hemisphere", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *SphereMesh) GetRadialSegments() int64 {
	log.Println("Calling SphereMesh.GetRadialSegments()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_radial_segments", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SphereMesh) GetRadius() float64 {
	log.Println("Calling SphereMesh.GetRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_radius", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SphereMesh) GetRings() int64 {
	log.Println("Calling SphereMesh.GetRings()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rings", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SphereMesh) SetHeight(height float64) {
	log.Println("Calling SphereMesh.SetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(height)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_height", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SphereMesh) SetIsHemisphere(isHemisphere *bool) {
	log.Println("Calling SphereMesh.SetIsHemisphere()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(isHemisphere)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_is_hemisphere", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SphereMesh) SetRadialSegments(radialSegments int64) {
	log.Println("Calling SphereMesh.SetRadialSegments()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radialSegments)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_radial_segments", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SphereMesh) SetRadius(radius float64) {
	log.Println("Calling SphereMesh.SetRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radius)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_radius", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SphereMesh) SetRings(rings int64) {
	log.Println("Calling SphereMesh.SetRings()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rings)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rings", goArguments, "")

	log.Println("Got return value!")

}

/*
   SphereMeshImplementer is an interface for SphereMesh objects.

*/
type SphereMeshImplementer interface {
	PrimitiveMeshImplementer

	GetHeight() float64

	GetIsHemisphere() *bool

	GetRadialSegments() int64

	GetRadius() float64

	GetRings() int64

	SetHeight(height float64)

	SetIsHemisphere(isHemisphere *bool)

	SetRadialSegments(radialSegments int64)

	SetRadius(radius float64)

	SetRings(rings int64)
}

/*

 */
type SphereShape struct {
	Shape
}

func (o *SphereShape) baseClass() string {
	return "SphereShape"
}

/*

 */
func (o *SphereShape) GetRadius() float64 {
	log.Println("Calling SphereShape.GetRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_radius", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SphereShape) SetRadius(radius float64) {
	log.Println("Calling SphereShape.SetRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radius)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_radius", goArguments, "")

	log.Println("Got return value!")

}

/*
   SphereShapeImplementer is an interface for SphereShape objects.

*/
type SphereShapeImplementer interface {
	ShapeImplementer

	GetRadius() float64

	SetRadius(radius float64)
}

/*
   SpinBox is a numerical input text field. It allows entering integers and floats.
*/
type SpinBox struct {
	Range
}

func (o *SpinBox) baseClass() string {
	return "SpinBox"
}

/*

 */
func (o *SpinBox) GetLineEdit() *LineEdit {
	log.Println("Calling SpinBox.GetLineEdit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_line_edit", goArguments, "*LineEdit")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*LineEdit)

	return returnValue

}

/*

 */
func (o *SpinBox) GetPrefix() string {
	log.Println("Calling SpinBox.GetPrefix()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_prefix", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the specific suffix.
*/
func (o *SpinBox) GetSuffix() string {
	log.Println("Calling SpinBox.GetSuffix()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_suffix", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return if the spinbox is editable.
*/
func (o *SpinBox) IsEditable() *bool {
	log.Println("Calling SpinBox.IsEditable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_editable", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Set whether the spinbox is editable.
*/
func (o *SpinBox) SetEditable(editable *bool) {
	log.Println("Calling SpinBox.SetEditable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(editable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_editable", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set a prefix.
*/
func (o *SpinBox) SetPrefix(prefix string) {
	log.Println("Calling SpinBox.SetPrefix()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(prefix)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_prefix", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set a specific suffix.
*/
func (o *SpinBox) SetSuffix(suffix string) {
	log.Println("Calling SpinBox.SetSuffix()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(suffix)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_suffix", goArguments, "")

	log.Println("Got return value!")

}

/*
   SpinBoxImplementer is an interface for SpinBox objects.
   SpinBox is a numerical input text field. It allows entering integers and floats.
*/
type SpinBoxImplementer interface {
	RangeImplementer

	GetLineEdit() *LineEdit

	GetPrefix() string

	GetSuffix() string

	IsEditable() *bool

	SetEditable(editable *bool)

	SetPrefix(prefix string)

	SetSuffix(suffix string)
}

/*
   Container for splitting two controls vertically or horizontally, with a grabber that allows adjusting the split offset or ratio.
*/
type SplitContainer struct {
	Container
}

func (o *SplitContainer) baseClass() string {
	return "SplitContainer"
}

/*
   Return visibility of the split dragger (one of [DRAGGER_VISIBLE], [DRAGGER_HIDDEN] or [DRAGGER_HIDDEN_COLLAPSED]).
*/
func (o *SplitContainer) GetDraggerVisibility() int64 {
	log.Println("Calling SplitContainer.GetDraggerVisibility()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_dragger_visibility", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the split offset.
*/
func (o *SplitContainer) GetSplitOffset() int64 {
	log.Println("Calling SplitContainer.GetSplitOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_split_offset", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return true if the split is collapsed.
*/
func (o *SplitContainer) IsCollapsed() *bool {
	log.Println("Calling SplitContainer.IsCollapsed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_collapsed", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Set if the split must be collapsed.
*/
func (o *SplitContainer) SetCollapsed(collapsed *bool) {
	log.Println("Calling SplitContainer.SetCollapsed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(collapsed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collapsed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set visibility of the split dragger ([i]mode[/i] must be one of [DRAGGER_VISIBLE], [DRAGGER_HIDDEN] or [DRAGGER_HIDDEN_COLLAPSED]).
*/
func (o *SplitContainer) SetDraggerVisibility(mode int64) {
	log.Println("Calling SplitContainer.SetDraggerVisibility()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_dragger_visibility", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the split offset.
*/
func (o *SplitContainer) SetSplitOffset(offset int64) {
	log.Println("Calling SplitContainer.SetSplitOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_split_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   SplitContainerImplementer is an interface for SplitContainer objects.
   Container for splitting two controls vertically or horizontally, with a grabber that allows adjusting the split offset or ratio.
*/
type SplitContainerImplementer interface {
	ContainerImplementer

	GetDraggerVisibility() int64

	GetSplitOffset() int64

	IsCollapsed() *bool

	SetCollapsed(collapsed *bool)

	SetDraggerVisibility(mode int64)

	SetSplitOffset(offset int64)
}

/*
   A SpotLight light is a type of [Light] node that emits lights in a specific direction, in the shape of a cone. The light is attenuated through the distance and this attenuation can be configured by changing the energy, radius and attenuation parameters of [Light]. TODO: Image of a spotlight.
*/
type SpotLight struct {
	Light
}

func (o *SpotLight) baseClass() string {
	return "SpotLight"
}

/*
   SpotLightImplementer is an interface for SpotLight objects.
   A SpotLight light is a type of [Light] node that emits lights in a specific direction, in the shape of a cone. The light is attenuated through the distance and this attenuation can be configured by changing the energy, radius and attenuation parameters of [Light]. TODO: Image of a spotlight.
*/
type SpotLightImplementer interface {
	LightImplementer
}

/*
   General purpose Sprite node. This Sprite node can show any texture as a sprite. The texture can be used as a spritesheet for animation, or only a region from a bigger texture can referenced, like an atlas.
*/
type Sprite struct {
	Node2D
}

func (o *Sprite) baseClass() string {
	return "Sprite"
}

/*
   Return the texture frame for a sprite-sheet, works when vframes or hframes are greater than 1.
*/
func (o *Sprite) GetFrame() int64 {
	log.Println("Calling Sprite.GetFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_frame", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the amount of horizontal frames. See [method set_hframes].
*/
func (o *Sprite) GetHframes() int64 {
	log.Println("Calling Sprite.GetHframes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_hframes", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Sprite) GetNormalMap() *Texture {
	log.Println("Calling Sprite.GetNormalMap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_normal_map", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   Return sprite draw offset.
*/
func (o *Sprite) GetOffset() *Vector2 {
	log.Println("Calling Sprite.GetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the region rect to read from.
*/
func (o *Sprite) GetRegionRect() *Rect2 {
	log.Println("Calling Sprite.GetRegionRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_region_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   Return the base texture for the sprite.
*/
func (o *Sprite) GetTexture() *Texture {
	log.Println("Calling Sprite.GetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   Return the amount of vertical frames. See [method set_vframes].
*/
func (o *Sprite) GetVframes() int64 {
	log.Println("Calling Sprite.GetVframes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vframes", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return if the sprite is centered at the local origin.
*/
func (o *Sprite) IsCentered() *bool {
	log.Println("Calling Sprite.IsCentered()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_centered", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if the sprite is flipped horizontally.
*/
func (o *Sprite) IsFlippedH() *bool {
	log.Println("Calling Sprite.IsFlippedH()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_flipped_h", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if the sprite is flipped vertically.
*/
func (o *Sprite) IsFlippedV() *bool {
	log.Println("Calling Sprite.IsFlippedV()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_flipped_v", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return if the sprite reads from a region.
*/
func (o *Sprite) IsRegion() *bool {
	log.Println("Calling Sprite.IsRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_region", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Sprite) IsRegionFilterClipEnabled() *bool {
	log.Println("Calling Sprite.IsRegionFilterClipEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_region_filter_clip_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Set whether the sprite should be centered on the origin.
*/
func (o *Sprite) SetCentered(centered *bool) {
	log.Println("Calling Sprite.SetCentered()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(centered)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_centered", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set true to flip the sprite horizontally.
*/
func (o *Sprite) SetFlipH(flipH *bool) {
	log.Println("Calling Sprite.SetFlipH()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flipH)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flip_h", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set true to flip the sprite vertically.
*/
func (o *Sprite) SetFlipV(flipV *bool) {
	log.Println("Calling Sprite.SetFlipV()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flipV)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flip_v", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the texture frame for a sprite-sheet, works when vframes or hframes are greater than 1.
*/
func (o *Sprite) SetFrame(frame int64) {
	log.Println("Calling Sprite.SetFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(frame)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_frame", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the amount of horizontal frames and converts the sprite into a sprite-sheet. This is useful for animation.
*/
func (o *Sprite) SetHframes(hframes int64) {
	log.Println("Calling Sprite.SetHframes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(hframes)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_hframes", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Sprite) SetNormalMap(normalMap *Texture) {
	log.Println("Calling Sprite.SetNormalMap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(normalMap)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_normal_map", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the sprite draw offset, useful for setting rotation pivots.
*/
func (o *Sprite) SetOffset(offset *Vector2) {
	log.Println("Calling Sprite.SetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the sprite as a sub-region of a bigger texture. Useful for texture-atlases.
*/
func (o *Sprite) SetRegion(enabled *bool) {
	log.Println("Calling Sprite.SetRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_region", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Sprite) SetRegionFilterClip(enabled *bool) {
	log.Println("Calling Sprite.SetRegionFilterClip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_region_filter_clip", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the region rect to read from.
*/
func (o *Sprite) SetRegionRect(rect *Rect2) {
	log.Println("Calling Sprite.SetRegionRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rect)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_region_rect", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the base texture for the sprite.
*/
func (o *Sprite) SetTexture(texture *Texture) {
	log.Println("Calling Sprite.SetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the amount of vertical frames and converts the sprite into a sprite-sheet. This is useful for animation.
*/
func (o *Sprite) SetVframes(vframes int64) {
	log.Println("Calling Sprite.SetVframes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vframes)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vframes", goArguments, "")

	log.Println("Got return value!")

}

/*
   SpriteImplementer is an interface for Sprite objects.
   General purpose Sprite node. This Sprite node can show any texture as a sprite. The texture can be used as a spritesheet for animation, or only a region from a bigger texture can referenced, like an atlas.
*/
type SpriteImplementer interface {
	Node2DImplementer

	GetFrame() int64

	GetHframes() int64

	GetNormalMap() *Texture

	GetOffset() *Vector2

	GetRegionRect() *Rect2

	GetTexture() *Texture

	GetVframes() int64

	IsCentered() *bool

	IsFlippedH() *bool

	IsFlippedV() *bool

	IsRegion() *bool

	IsRegionFilterClipEnabled() *bool

	SetCentered(centered *bool)

	SetFlipH(flipH *bool)

	SetFlipV(flipV *bool)

	SetFrame(frame int64)

	SetHframes(hframes int64)

	SetNormalMap(normalMap *Texture)

	SetOffset(offset *Vector2)

	SetRegion(enabled *bool)

	SetRegionFilterClip(enabled *bool)

	SetRegionRect(rect *Rect2)

	SetTexture(texture *Texture)

	SetVframes(vframes int64)
}

/*

 */
type Sprite3D struct {
	SpriteBase3D
}

func (o *Sprite3D) baseClass() string {
	return "Sprite3D"
}

/*

 */
func (o *Sprite3D) GetFrame() int64 {
	log.Println("Calling Sprite3D.GetFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_frame", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Sprite3D) GetHframes() int64 {
	log.Println("Calling Sprite3D.GetHframes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_hframes", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Sprite3D) GetRegionRect() *Rect2 {
	log.Println("Calling Sprite3D.GetRegionRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_region_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*

 */
func (o *Sprite3D) GetTexture() *Texture {
	log.Println("Calling Sprite3D.GetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *Sprite3D) GetVframes() int64 {
	log.Println("Calling Sprite3D.GetVframes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vframes", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Sprite3D) IsRegion() *bool {
	log.Println("Calling Sprite3D.IsRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_region", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Sprite3D) SetFrame(frame int64) {
	log.Println("Calling Sprite3D.SetFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(frame)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_frame", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Sprite3D) SetHframes(hframes int64) {
	log.Println("Calling Sprite3D.SetHframes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(hframes)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_hframes", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Sprite3D) SetRegion(enabled *bool) {
	log.Println("Calling Sprite3D.SetRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_region", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Sprite3D) SetRegionRect(rect *Rect2) {
	log.Println("Calling Sprite3D.SetRegionRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rect)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_region_rect", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Sprite3D) SetTexture(texture *Texture) {
	log.Println("Calling Sprite3D.SetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Sprite3D) SetVframes(vframes int64) {
	log.Println("Calling Sprite3D.SetVframes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vframes)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vframes", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sprite3DImplementer is an interface for Sprite3D objects.

*/
type Sprite3DImplementer interface {
	SpriteBase3DImplementer

	GetFrame() int64

	GetHframes() int64

	GetRegionRect() *Rect2

	GetTexture() *Texture

	GetVframes() int64

	IsRegion() *bool

	SetFrame(frame int64)

	SetHframes(hframes int64)

	SetRegion(enabled *bool)

	SetRegionRect(rect *Rect2)

	SetTexture(texture *Texture)

	SetVframes(vframes int64)
}

/*

 */
type SpriteBase3D struct {
	GeometryInstance
}

func (o *SpriteBase3D) baseClass() string {
	return "SpriteBase3D"
}

/*

 */
func (o *SpriteBase3D) GetAlphaCutMode() int64 {
	log.Println("Calling SpriteBase3D.GetAlphaCutMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_alpha_cut_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpriteBase3D) GetAxis() int64 {
	log.Println("Calling SpriteBase3D.GetAxis()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_axis", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpriteBase3D) GetDrawFlag(flag int64) *bool {
	log.Println("Calling SpriteBase3D.GetDrawFlag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flag)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_draw_flag", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *SpriteBase3D) GetItemRect() *Rect2 {
	log.Println("Calling SpriteBase3D.GetItemRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*

 */
func (o *SpriteBase3D) GetModulate() *Color {
	log.Println("Calling SpriteBase3D.GetModulate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_modulate", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *SpriteBase3D) GetOffset() *Vector2 {
	log.Println("Calling SpriteBase3D.GetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *SpriteBase3D) GetOpacity() float64 {
	log.Println("Calling SpriteBase3D.GetOpacity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_opacity", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpriteBase3D) GetPixelSize() float64 {
	log.Println("Calling SpriteBase3D.GetPixelSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pixel_size", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpriteBase3D) IsCentered() *bool {
	log.Println("Calling SpriteBase3D.IsCentered()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_centered", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *SpriteBase3D) IsFlippedH() *bool {
	log.Println("Calling SpriteBase3D.IsFlippedH()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_flipped_h", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *SpriteBase3D) IsFlippedV() *bool {
	log.Println("Calling SpriteBase3D.IsFlippedV()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_flipped_v", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *SpriteBase3D) SetAlphaCutMode(mode int64) {
	log.Println("Calling SpriteBase3D.SetAlphaCutMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_alpha_cut_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpriteBase3D) SetAxis(axis int64) {
	log.Println("Calling SpriteBase3D.SetAxis()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(axis)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_axis", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpriteBase3D) SetCentered(centered *bool) {
	log.Println("Calling SpriteBase3D.SetCentered()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(centered)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_centered", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpriteBase3D) SetDrawFlag(flag int64, enabled *bool) {
	log.Println("Calling SpriteBase3D.SetDrawFlag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(flag)
	goArguments[1] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_draw_flag", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpriteBase3D) SetFlipH(flipH *bool) {
	log.Println("Calling SpriteBase3D.SetFlipH()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flipH)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flip_h", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpriteBase3D) SetFlipV(flipV *bool) {
	log.Println("Calling SpriteBase3D.SetFlipV()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flipV)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flip_v", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpriteBase3D) SetModulate(modulate *Color) {
	log.Println("Calling SpriteBase3D.SetModulate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(modulate)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_modulate", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpriteBase3D) SetOffset(offset *Vector2) {
	log.Println("Calling SpriteBase3D.SetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_offset", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpriteBase3D) SetOpacity(opacity float64) {
	log.Println("Calling SpriteBase3D.SetOpacity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(opacity)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_opacity", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpriteBase3D) SetPixelSize(pixelSize float64) {
	log.Println("Calling SpriteBase3D.SetPixelSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pixelSize)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pixel_size", goArguments, "")

	log.Println("Got return value!")

}

/*
   SpriteBase3DImplementer is an interface for SpriteBase3D objects.

*/
type SpriteBase3DImplementer interface {
	GeometryInstanceImplementer

	GetAlphaCutMode() int64

	GetAxis() int64

	GetDrawFlag(flag int64) *bool

	GetItemRect() *Rect2

	GetModulate() *Color

	GetOffset() *Vector2

	GetOpacity() float64

	GetPixelSize() float64

	IsCentered() *bool

	IsFlippedH() *bool

	IsFlippedV() *bool

	SetAlphaCutMode(mode int64)

	SetAxis(axis int64)

	SetCentered(centered *bool)

	SetDrawFlag(flag int64, enabled *bool)

	SetFlipH(flipH *bool)

	SetFlipV(flipV *bool)

	SetModulate(modulate *Color)

	SetOffset(offset *Vector2)

	SetOpacity(opacity float64)

	SetPixelSize(pixelSize float64)
}

/*
   Sprite frame library for [AnimatedSprite].
*/
type SpriteFrames struct {
	Resource
}

func (o *SpriteFrames) baseClass() string {
	return "SpriteFrames"
}

/*

 */
func (o *SpriteFrames) AddAnimation(anim string) {
	log.Println("Calling SpriteFrames.AddAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(anim)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_animation", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpriteFrames) AddFrame(anim string, frame *Texture, atpos int64) {
	log.Println("Calling SpriteFrames.AddFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(anim)
	goArguments[1] = reflect.ValueOf(frame)
	goArguments[2] = reflect.ValueOf(atpos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_frame", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpriteFrames) Clear(anim string) {
	log.Println("Calling SpriteFrames.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(anim)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpriteFrames) ClearAll() {
	log.Println("Calling SpriteFrames.ClearAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_all", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpriteFrames) GetAnimationLoop(anim string) *bool {
	log.Println("Calling SpriteFrames.GetAnimationLoop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(anim)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_animation_loop", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *SpriteFrames) GetAnimationSpeed(anim string) float64 {
	log.Println("Calling SpriteFrames.GetAnimationSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(anim)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_animation_speed", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *SpriteFrames) GetFrame(anim string, idx int64) *Texture {
	log.Println("Calling SpriteFrames.GetFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(anim)
	goArguments[1] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_frame", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *SpriteFrames) GetFrameCount(anim string) int64 {
	log.Println("Calling SpriteFrames.GetFrameCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(anim)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_frame_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *SpriteFrames) HasAnimation(anim string) *bool {
	log.Println("Calling SpriteFrames.HasAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(anim)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_animation", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *SpriteFrames) RemoveAnimation(anim string) {
	log.Println("Calling SpriteFrames.RemoveAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(anim)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_animation", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpriteFrames) RemoveFrame(anim string, idx int64) {
	log.Println("Calling SpriteFrames.RemoveFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(anim)
	goArguments[1] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_frame", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpriteFrames) RenameAnimation(anim string, newname string) {
	log.Println("Calling SpriteFrames.RenameAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(anim)
	goArguments[1] = reflect.ValueOf(newname)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rename_animation", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpriteFrames) SetAnimationLoop(anim string, loop *bool) {
	log.Println("Calling SpriteFrames.SetAnimationLoop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(anim)
	goArguments[1] = reflect.ValueOf(loop)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_animation_loop", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpriteFrames) SetAnimationSpeed(anim string, speed float64) {
	log.Println("Calling SpriteFrames.SetAnimationSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(anim)
	goArguments[1] = reflect.ValueOf(speed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_animation_speed", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SpriteFrames) SetFrame(anim string, idx int64, txt *Texture) {
	log.Println("Calling SpriteFrames.SetFrame()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(anim)
	goArguments[1] = reflect.ValueOf(idx)
	goArguments[2] = reflect.ValueOf(txt)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_frame", goArguments, "")

	log.Println("Got return value!")

}

/*
   SpriteFramesImplementer is an interface for SpriteFrames objects.
   Sprite frame library for [AnimatedSprite].
*/
type SpriteFramesImplementer interface {
	ResourceImplementer

	AddAnimation(anim string)

	AddFrame(anim string, frame *Texture, atpos int64)

	Clear(anim string)

	ClearAll()

	GetAnimationLoop(anim string) *bool

	GetAnimationSpeed(anim string) float64

	GetFrame(anim string, idx int64) *Texture

	GetFrameCount(anim string) int64

	HasAnimation(anim string) *bool

	RemoveAnimation(anim string)

	RemoveFrame(anim string, idx int64)

	RenameAnimation(anim string, newname string)

	SetAnimationLoop(anim string, loop *bool)

	SetAnimationSpeed(anim string, speed float64)

	SetFrame(anim string, idx int64, txt *Texture)
}

/*
        Static body for 3D Physics. A static body is a simple body that is not intended to move. They don't consume any CPU resources in contrast to a [RigidBody3D] so they are great for scenario collision.
		A static body can also be animated by using simulated motion mode. This is useful for implementing functionalities such as moving platforms. When this mode is active the body can be animated and automatically computes linear and angular velocity to apply in that frame and to influence other bodies.
		Alternatively, a constant linear or angular velocity can be set for the static body, so even if it doesn't move, it affects other bodies as if it was moving (this is useful for simulating conveyor belts or conveyor wheels).
*/
type StaticBody struct {
	PhysicsBody
}

func (o *StaticBody) baseClass() string {
	return "StaticBody"
}

/*
   Return the body bounciness.
*/
func (o *StaticBody) GetBounce() float64 {
	log.Println("Calling StaticBody.GetBounce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bounce", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the constant angular velocity for the body.
*/
func (o *StaticBody) GetConstantAngularVelocity() *Vector3 {
	log.Println("Calling StaticBody.GetConstantAngularVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_constant_angular_velocity", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Return the constant linear velocity for the body.
*/
func (o *StaticBody) GetConstantLinearVelocity() *Vector3 {
	log.Println("Calling StaticBody.GetConstantLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_constant_linear_velocity", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*
   Return the body friction.
*/
func (o *StaticBody) GetFriction() float64 {
	log.Println("Calling StaticBody.GetFriction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_friction", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the body bounciness, from 0 (not bouncy) to 1 (bouncy).
*/
func (o *StaticBody) SetBounce(bounce float64) {
	log.Println("Calling StaticBody.SetBounce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bounce)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bounce", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set a constant angular velocity for the body. This does not rotate the body, but affects other bodies touching it, as if it was rotating.
*/
func (o *StaticBody) SetConstantAngularVelocity(vel *Vector3) {
	log.Println("Calling StaticBody.SetConstantAngularVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vel)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_constant_angular_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set a constant linear velocity for the body. This does not move the body, but affects other bodies touching it, as if it was moving.
*/
func (o *StaticBody) SetConstantLinearVelocity(vel *Vector3) {
	log.Println("Calling StaticBody.SetConstantLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vel)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_constant_linear_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the body friction, from 0 (frictionless) to 1 (full friction).
*/
func (o *StaticBody) SetFriction(friction float64) {
	log.Println("Calling StaticBody.SetFriction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(friction)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_friction", goArguments, "")

	log.Println("Got return value!")

}

/*
        StaticBodyImplementer is an interface for StaticBody objects.
        Static body for 3D Physics. A static body is a simple body that is not intended to move. They don't consume any CPU resources in contrast to a [RigidBody3D] so they are great for scenario collision.
		A static body can also be animated by using simulated motion mode. This is useful for implementing functionalities such as moving platforms. When this mode is active the body can be animated and automatically computes linear and angular velocity to apply in that frame and to influence other bodies.
		Alternatively, a constant linear or angular velocity can be set for the static body, so even if it doesn't move, it affects other bodies as if it was moving (this is useful for simulating conveyor belts or conveyor wheels).
*/
type StaticBodyImplementer interface {
	PhysicsBodyImplementer

	GetBounce() float64

	GetConstantAngularVelocity() *Vector3

	GetConstantLinearVelocity() *Vector3

	GetFriction() float64

	SetBounce(bounce float64)

	SetConstantAngularVelocity(vel *Vector3)

	SetConstantLinearVelocity(vel *Vector3)

	SetFriction(friction float64)
}

/*
        Static body for 2D Physics. A static body is a simple body that is not intended to move. They don't consume any CPU resources in contrast to a [RigidBody2D] so they are great for scenario collision.
		A static body can also be animated by using simulated motion mode. This is useful for implementing functionalities such as moving platforms. When this mode is active the body can be animated and automatically computes linear and angular velocity to apply in that frame and to influence other bodies.
		Alternatively, a constant linear or angular velocity can be set for the static body, so even if it doesn't move, it affects other bodies as if it was moving (this is useful for simulating conveyor belts or conveyor wheels).
*/
type StaticBody2D struct {
	PhysicsBody2D
}

func (o *StaticBody2D) baseClass() string {
	return "StaticBody2D"
}

/*
   Return the body bounciness.
*/
func (o *StaticBody2D) GetBounce() float64 {
	log.Println("Calling StaticBody2D.GetBounce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bounce", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the constant angular velocity for the body.
*/
func (o *StaticBody2D) GetConstantAngularVelocity() float64 {
	log.Println("Calling StaticBody2D.GetConstantAngularVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_constant_angular_velocity", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the constant linear velocity for the body.
*/
func (o *StaticBody2D) GetConstantLinearVelocity() *Vector2 {
	log.Println("Calling StaticBody2D.GetConstantLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_constant_linear_velocity", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the body friction.
*/
func (o *StaticBody2D) GetFriction() float64 {
	log.Println("Calling StaticBody2D.GetFriction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_friction", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Set the body bounciness, from 0 (not bouncy) to 1 (bouncy).
*/
func (o *StaticBody2D) SetBounce(bounce float64) {
	log.Println("Calling StaticBody2D.SetBounce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bounce)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bounce", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set a constant angular velocity for the body. This does not rotate the body, but affects other bodies touching it, as if it was rotating.
*/
func (o *StaticBody2D) SetConstantAngularVelocity(vel float64) {
	log.Println("Calling StaticBody2D.SetConstantAngularVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vel)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_constant_angular_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set a constant linear velocity for the body. This does not move the body, but affects other bodies touching it, as if it was moving.
*/
func (o *StaticBody2D) SetConstantLinearVelocity(vel *Vector2) {
	log.Println("Calling StaticBody2D.SetConstantLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vel)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_constant_linear_velocity", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the body friction, from 0 (frictionless) to 1 (full friction).
*/
func (o *StaticBody2D) SetFriction(friction float64) {
	log.Println("Calling StaticBody2D.SetFriction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(friction)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_friction", goArguments, "")

	log.Println("Got return value!")

}

/*
        StaticBody2DImplementer is an interface for StaticBody2D objects.
        Static body for 2D Physics. A static body is a simple body that is not intended to move. They don't consume any CPU resources in contrast to a [RigidBody2D] so they are great for scenario collision.
		A static body can also be animated by using simulated motion mode. This is useful for implementing functionalities such as moving platforms. When this mode is active the body can be animated and automatically computes linear and angular velocity to apply in that frame and to influence other bodies.
		Alternatively, a constant linear or angular velocity can be set for the static body, so even if it doesn't move, it affects other bodies as if it was moving (this is useful for simulating conveyor belts or conveyor wheels).
*/
type StaticBody2DImplementer interface {
	PhysicsBody2DImplementer

	GetBounce() float64

	GetConstantAngularVelocity() float64

	GetConstantLinearVelocity() *Vector2

	GetFriction() float64

	SetBounce(bounce float64)

	SetConstantAngularVelocity(vel float64)

	SetConstantLinearVelocity(vel *Vector2)

	SetFriction(friction float64)
}

/*
   StreamPeer is an abstraction and base class for stream-based protocols (such as TCP or Unix Sockets). It provides an API for sending and receiving data through streams as raw data or strings.
*/
type StreamPeer struct {
	Reference
}

func (o *StreamPeer) baseClass() string {
	return "StreamPeer"
}

/*
   Get a signed 16 bit value from the stream.
*/
func (o *StreamPeer) Get16() int64 {
	log.Println("Calling StreamPeer.Get16()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_16", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get a signed 32 bit value from the stream.
*/
func (o *StreamPeer) Get32() int64 {
	log.Println("Calling StreamPeer.Get32()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_32", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get a signed 64 bit value from the stream.
*/
func (o *StreamPeer) Get64() int64 {
	log.Println("Calling StreamPeer.Get64()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_64", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get a signed byte from the stream.
*/
func (o *StreamPeer) Get8() int64 {
	log.Println("Calling StreamPeer.Get8()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_8", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the amount of bytes this [StreamPeer] has available.
*/
func (o *StreamPeer) GetAvailableBytes() int64 {
	log.Println("Calling StreamPeer.GetAvailableBytes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_available_bytes", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return a chunk data with the received bytes. The amount of bytes to be received can be requested in the "bytes" argument. If not enough bytes are available, the function will block until the desired amount is received. This function returns two values, an Error code and a data array.
*/
func (o *StreamPeer) GetData(bytes int64) *Array {
	log.Println("Calling StreamPeer.GetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bytes)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_data", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Get a double-precision float from the stream.
*/
func (o *StreamPeer) GetDouble() float64 {
	log.Println("Calling StreamPeer.GetDouble()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_double", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Get a single-precision float from the stream.
*/
func (o *StreamPeer) GetFloat() float64 {
	log.Println("Calling StreamPeer.GetFloat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_float", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return a chunk data with the received bytes. The amount of bytes to be received can be requested in the "bytes" argument. If not enough bytes are available, the function will return how many were actually received. This function returns two values, an Error code, and a data array.
*/
func (o *StreamPeer) GetPartialData(bytes int64) *Array {
	log.Println("Calling StreamPeer.GetPartialData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bytes)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_partial_data", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Get a string with byte-length "bytes" from the stream.
*/
func (o *StreamPeer) GetString(bytes int64) string {
	log.Println("Calling StreamPeer.GetString()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bytes)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_string", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get an unsigned 16 bit value from the stream.
*/
func (o *StreamPeer) GetU16() int64 {
	log.Println("Calling StreamPeer.GetU16()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_u16", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get an unsigned 32 bit value from the stream.
*/
func (o *StreamPeer) GetU32() int64 {
	log.Println("Calling StreamPeer.GetU32()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_u32", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get an unsigned 16 bit value from the stream.
*/
func (o *StreamPeer) GetU64() int64 {
	log.Println("Calling StreamPeer.GetU64()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_u64", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get an unsigned byte from the stream.
*/
func (o *StreamPeer) GetU8() int64 {
	log.Println("Calling StreamPeer.GetU8()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_u8", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get a utf8 string with byte-length "bytes" from the stream (this decodes the string sent as utf8).
*/
func (o *StreamPeer) GetUtf8String(bytes int64) string {
	log.Println("Calling StreamPeer.GetUtf8String()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bytes)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_utf8_string", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get a Variant from the stream.
*/
func (o *StreamPeer) GetVar() *Variant {
	log.Println("Calling StreamPeer.GetVar()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_var", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Return whether this [StreamPeer] is using big-endian format.
*/
func (o *StreamPeer) IsBigEndianEnabled() *bool {
	log.Println("Calling StreamPeer.IsBigEndianEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_big_endian_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Put a signed 16 bit value into the stream.
*/
func (o *StreamPeer) Put16(val int64) {
	log.Println("Calling StreamPeer.Put16()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(val)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "put_16", goArguments, "")

	log.Println("Got return value!")

}

/*
   Put a signed 32 bit value into the stream.
*/
func (o *StreamPeer) Put32(val int64) {
	log.Println("Calling StreamPeer.Put32()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(val)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "put_32", goArguments, "")

	log.Println("Got return value!")

}

/*
   Put a signed 64 bit value into the stream.
*/
func (o *StreamPeer) Put64(val int64) {
	log.Println("Calling StreamPeer.Put64()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(val)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "put_64", goArguments, "")

	log.Println("Got return value!")

}

/*
   Put a signed byte into the stream.
*/
func (o *StreamPeer) Put8(val int64) {
	log.Println("Calling StreamPeer.Put8()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(val)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "put_8", goArguments, "")

	log.Println("Got return value!")

}

/*
   Send a chunk of data through the connection, blocking if necessary until the data is done sending. This function returns an Error code.
*/
func (o *StreamPeer) PutData(data *PoolByteArray) int64 {
	log.Println("Calling StreamPeer.PutData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(data)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "put_data", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Put a double-precision float into the stream.
*/
func (o *StreamPeer) PutDouble(val float64) {
	log.Println("Calling StreamPeer.PutDouble()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(val)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "put_double", goArguments, "")

	log.Println("Got return value!")

}

/*
   Put a single-precision float into the stream.
*/
func (o *StreamPeer) PutFloat(val float64) {
	log.Println("Calling StreamPeer.PutFloat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(val)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "put_float", goArguments, "")

	log.Println("Got return value!")

}

/*
   Send a chunk of data through the connection, if all the data could not be sent at once, only part of it will. This function returns two values, an Error code and an integer, describing how much data was actually sent.
*/
func (o *StreamPeer) PutPartialData(data *PoolByteArray) *Array {
	log.Println("Calling StreamPeer.PutPartialData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(data)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "put_partial_data", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Put an unsigned 16 bit value into the stream.
*/
func (o *StreamPeer) PutU16(val int64) {
	log.Println("Calling StreamPeer.PutU16()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(val)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "put_u16", goArguments, "")

	log.Println("Got return value!")

}

/*
   Put an unsigned 32 bit value into the stream.
*/
func (o *StreamPeer) PutU32(val int64) {
	log.Println("Calling StreamPeer.PutU32()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(val)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "put_u32", goArguments, "")

	log.Println("Got return value!")

}

/*
   Put an unsigned 64 bit value into the stream.
*/
func (o *StreamPeer) PutU64(val int64) {
	log.Println("Calling StreamPeer.PutU64()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(val)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "put_u64", goArguments, "")

	log.Println("Got return value!")

}

/*
   Put an unsigned byte into the stream.
*/
func (o *StreamPeer) PutU8(val int64) {
	log.Println("Calling StreamPeer.PutU8()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(val)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "put_u8", goArguments, "")

	log.Println("Got return value!")

}

/*
   Put a zero-terminated utf8 string into the stream.
*/
func (o *StreamPeer) PutUtf8String(val string) {
	log.Println("Calling StreamPeer.PutUtf8String()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(val)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "put_utf8_string", goArguments, "")

	log.Println("Got return value!")

}

/*
   Put a Variant into the stream.
*/
func (o *StreamPeer) PutVar(val *Variant) {
	log.Println("Calling StreamPeer.PutVar()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(val)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "put_var", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set this [StreamPeer] to use big-endian format. Default is false.
*/
func (o *StreamPeer) SetBigEndian(enable *bool) {
	log.Println("Calling StreamPeer.SetBigEndian()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_big_endian", goArguments, "")

	log.Println("Got return value!")

}

/*
   StreamPeerImplementer is an interface for StreamPeer objects.
   StreamPeer is an abstraction and base class for stream-based protocols (such as TCP or Unix Sockets). It provides an API for sending and receiving data through streams as raw data or strings.
*/
type StreamPeerImplementer interface {
	ReferenceImplementer

	Get16() int64

	Get32() int64

	Get64() int64

	Get8() int64

	GetAvailableBytes() int64

	GetData(bytes int64) *Array

	GetDouble() float64

	GetFloat() float64

	GetPartialData(bytes int64) *Array

	GetString(bytes int64) string

	GetU16() int64

	GetU32() int64

	GetU64() int64

	GetU8() int64

	GetUtf8String(bytes int64) string

	GetVar() *Variant

	IsBigEndianEnabled() *bool

	Put16(val int64)

	Put32(val int64)

	Put64(val int64)

	Put8(val int64)

	PutData(data *PoolByteArray) int64

	PutDouble(val float64)

	PutFloat(val float64)

	PutPartialData(data *PoolByteArray) *Array

	PutU16(val int64)

	PutU32(val int64)

	PutU64(val int64)

	PutU8(val int64)

	PutUtf8String(val string)

	PutVar(val *Variant)

	SetBigEndian(enable *bool)
}

/*

 */
type StreamPeerBuffer struct {
	StreamPeer
}

func (o *StreamPeerBuffer) baseClass() string {
	return "StreamPeerBuffer"
}

/*

 */
func (o *StreamPeerBuffer) Clear() {
	log.Println("Calling StreamPeerBuffer.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StreamPeerBuffer) Duplicate() *StreamPeerBuffer {
	log.Println("Calling StreamPeerBuffer.Duplicate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "duplicate", goArguments, "*StreamPeerBuffer")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*StreamPeerBuffer)

	return returnValue

}

/*

 */
func (o *StreamPeerBuffer) GetDataArray() *PoolByteArray {
	log.Println("Calling StreamPeerBuffer.GetDataArray()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_data_array", goArguments, "*PoolByteArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolByteArray)

	return returnValue

}

/*

 */
func (o *StreamPeerBuffer) GetPos() int64 {
	log.Println("Calling StreamPeerBuffer.GetPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pos", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *StreamPeerBuffer) GetSize() int64 {
	log.Println("Calling StreamPeerBuffer.GetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *StreamPeerBuffer) Resize(size int64) {
	log.Println("Calling StreamPeerBuffer.Resize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "resize", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StreamPeerBuffer) Seek(pos int64) {
	log.Println("Calling StreamPeerBuffer.Seek()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "seek", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StreamPeerBuffer) SetDataArray(data *PoolByteArray) {
	log.Println("Calling StreamPeerBuffer.SetDataArray()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_data_array", goArguments, "")

	log.Println("Got return value!")

}

/*
   StreamPeerBufferImplementer is an interface for StreamPeerBuffer objects.

*/
type StreamPeerBufferImplementer interface {
	StreamPeerImplementer

	Clear()

	Duplicate() *StreamPeerBuffer

	GetDataArray() *PoolByteArray

	GetPos() int64

	GetSize() int64

	Resize(size int64)

	Seek(pos int64)

	SetDataArray(data *PoolByteArray)
}

/*
   SSL Stream peer. This object can be used to connect to SSL servers.
*/
type StreamPeerSSL struct {
	StreamPeer
}

func (o *StreamPeerSSL) baseClass() string {
	return "StreamPeerSSL"
}

/*

 */
func (o *StreamPeerSSL) AcceptStream(stream *StreamPeer) int64 {
	log.Println("Calling StreamPeerSSL.AcceptStream()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(stream)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "accept_stream", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Connect to a peer using an underlying [StreamPeer] "stream", when "validate_certs" is true, [StreamPeerSSL] will validate that the certificate presented by the peer matches the "for_hostname".
*/
func (o *StreamPeerSSL) ConnectToStream(stream *StreamPeer, validateCerts *bool, forHostname string) int64 {
	log.Println("Calling StreamPeerSSL.ConnectToStream()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(stream)
	goArguments[1] = reflect.ValueOf(validateCerts)
	goArguments[2] = reflect.ValueOf(forHostname)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "connect_to_stream", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Disconnect from host.
*/
func (o *StreamPeerSSL) DisconnectFromStream() {
	log.Println("Calling StreamPeerSSL.DisconnectFromStream()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "disconnect_from_stream", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the status of the connection, one of STATUS_* enum.
*/
func (o *StreamPeerSSL) GetStatus() int64 {
	log.Println("Calling StreamPeerSSL.GetStatus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_status", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   StreamPeerSSLImplementer is an interface for StreamPeerSSL objects.
   SSL Stream peer. This object can be used to connect to SSL servers.
*/
type StreamPeerSSLImplementer interface {
	StreamPeerImplementer

	AcceptStream(stream *StreamPeer) int64

	ConnectToStream(stream *StreamPeer, validateCerts *bool, forHostname string) int64

	DisconnectFromStream()

	GetStatus() int64
}

/*
   TCP Stream peer. This object can be used to connect to TCP servers, or also is returned by a tcp server.
*/
type StreamPeerTCP struct {
	StreamPeer
}

func (o *StreamPeerTCP) baseClass() string {
	return "StreamPeerTCP"
}

/*
   Connect to the specified host:port pair. A hostname will be resolved if valid. Returns [OK] on success or [FAILED] on failure.
*/
func (o *StreamPeerTCP) ConnectToHost(host string, port int64) int64 {
	log.Println("Calling StreamPeerTCP.ConnectToHost()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(host)
	goArguments[1] = reflect.ValueOf(port)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "connect_to_host", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Disconnect from host.
*/
func (o *StreamPeerTCP) DisconnectFromHost() {
	log.Println("Calling StreamPeerTCP.DisconnectFromHost()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "disconnect_from_host", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the IP of this peer.
*/
func (o *StreamPeerTCP) GetConnectedHost() string {
	log.Println("Calling StreamPeerTCP.GetConnectedHost()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connected_host", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the port of this peer.
*/
func (o *StreamPeerTCP) GetConnectedPort() int64 {
	log.Println("Calling StreamPeerTCP.GetConnectedPort()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_connected_port", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the status of the connection, one of STATUS_* enum.
*/
func (o *StreamPeerTCP) GetStatus() int64 {
	log.Println("Calling StreamPeerTCP.GetStatus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_status", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *StreamPeerTCP) IsConnectedToHost() *bool {
	log.Println("Calling StreamPeerTCP.IsConnectedToHost()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_connected_to_host", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   StreamPeerTCPImplementer is an interface for StreamPeerTCP objects.
   TCP Stream peer. This object can be used to connect to TCP servers, or also is returned by a tcp server.
*/
type StreamPeerTCPImplementer interface {
	StreamPeerImplementer

	ConnectToHost(host string, port int64) int64

	DisconnectFromHost()

	GetConnectedHost() string

	GetConnectedPort() int64

	GetStatus() int64

	IsConnectedToHost() *bool
}

/*

 */
type StreamTexture struct {
	Texture
}

func (o *StreamTexture) baseClass() string {
	return "StreamTexture"
}

/*

 */
func (o *StreamTexture) GetLoadPath() string {
	log.Println("Calling StreamTexture.GetLoadPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_load_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *StreamTexture) Load(path string) int64 {
	log.Println("Calling StreamTexture.Load()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "load", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   StreamTextureImplementer is an interface for StreamTexture objects.

*/
type StreamTextureImplementer interface {
	TextureImplementer

	GetLoadPath() string

	Load(path string) int64
}

/*
   StyleBox is [Resource] that provides an abstract base class for drawing stylized boxes for the UI. StyleBoxes are used for drawing the styles of buttons, line edit backgrounds, tree backgrounds, etc. and also for testing a transparency mask for pointer signals. If mask test fails on a StyleBox assigned as mask to a control, clicks and motion signals will go through it to the one below.
*/
type StyleBox struct {
	Resource
}

func (o *StyleBox) baseClass() string {
	return "StyleBox"
}

/*

 */
func (o *StyleBox) Draw(canvasItem *RID, rect *Rect2) {
	log.Println("Calling StyleBox.Draw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(canvasItem)
	goArguments[1] = reflect.ValueOf(rect)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBox) GetCenterSize() *Vector2 {
	log.Println("Calling StyleBox.GetCenterSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_center_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the default offset of the margin "margin" (see MARGIN_* enum) of a StyleBox, Controls that draw styleboxes with context inside need to know the margin, so the border of the stylebox is not occluded.
*/
func (o *StyleBox) GetDefaultMargin(margin int64) float64 {
	log.Println("Calling StyleBox.GetDefaultMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_default_margin", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the offset of margin "margin" (see MARGIN_* enum).
*/
func (o *StyleBox) GetMargin(margin int64) float64 {
	log.Println("Calling StyleBox.GetMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_margin", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the minimum size that this stylebox can be shrunk to.
*/
func (o *StyleBox) GetMinimumSize() *Vector2 {
	log.Println("Calling StyleBox.GetMinimumSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_minimum_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the "offset" of a stylebox, this is a helper function, like writing [code]Vector2(style.get_margin(MARGIN_LEFT), style.get_margin(MARGIN_TOP))[/code].
*/
func (o *StyleBox) GetOffset() *Vector2 {
	log.Println("Calling StyleBox.GetOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Set the default offset "offset" of the margin "margin" (see MARGIN_* enum) for a StyleBox, Controls that draw styleboxes with context inside need to know the margin, so the border of the stylebox is not occluded.
*/
func (o *StyleBox) SetDefaultMargin(margin int64, offset float64) {
	log.Println("Calling StyleBox.SetDefaultMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_default_margin", goArguments, "")

	log.Println("Got return value!")

}

/*
   Test a position in a rectangle, return whether it passes the mask test.
*/
func (o *StyleBox) TestMask(point *Vector2, rect *Rect2) *bool {
	log.Println("Calling StyleBox.TestMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(point)
	goArguments[1] = reflect.ValueOf(rect)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "test_mask", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   StyleBoxImplementer is an interface for StyleBox objects.
   StyleBox is [Resource] that provides an abstract base class for drawing stylized boxes for the UI. StyleBoxes are used for drawing the styles of buttons, line edit backgrounds, tree backgrounds, etc. and also for testing a transparency mask for pointer signals. If mask test fails on a StyleBox assigned as mask to a control, clicks and motion signals will go through it to the one below.
*/
type StyleBoxImplementer interface {
	ResourceImplementer

	Draw(canvasItem *RID, rect *Rect2)

	GetCenterSize() *Vector2

	GetDefaultMargin(margin int64) float64

	GetMargin(margin int64) float64

	GetMinimumSize() *Vector2

	GetOffset() *Vector2

	SetDefaultMargin(margin int64, offset float64)

	TestMask(point *Vector2, rect *Rect2) *bool
}

/*
   Empty stylebox (really does not display anything).
*/
type StyleBoxEmpty struct {
	StyleBox
}

func (o *StyleBoxEmpty) baseClass() string {
	return "StyleBoxEmpty"
}

/*
   StyleBoxEmptyImplementer is an interface for StyleBoxEmpty objects.
   Empty stylebox (really does not display anything).
*/
type StyleBoxEmptyImplementer interface {
	StyleBoxImplementer
}

/*
        This stylebox can be used to achieve all kinds of looks without the need of a texture. Those properties are customizable:
		 - Color
		 - Border width (individual width for each border)
		 - Rounded corners (individual radius for each corner)
		 - Shadow
		 About corner radius:
		 	Setting corner radius to high values is allowed. As soon as corners would overlap the stylebox will switch to a relative system. Example:
			[codeblock]
			height = 30
			corner_radius_top_left = 50
			corner_raidus_bottom_left = 100
			[/codeblock]
			The relative system now would take the 1:2 ratio of the two left corners to calculate the actual corner width. Both corners added will [b]never[/b] be more than the height. Result:
			[codeblock]
			corner_radius_top_left: 10
			corner_raidus_bottom_left: 20
			[/codeblock]
*/
type StyleBoxFlat struct {
	StyleBox
}

func (o *StyleBoxFlat) baseClass() string {
	return "StyleBoxFlat"
}

/*

 */
func (o *StyleBoxFlat) GetAaSize() int64 {
	log.Println("Calling StyleBoxFlat.GetAaSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_aa_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *StyleBoxFlat) GetBgColor() *Color {
	log.Println("Calling StyleBoxFlat.GetBgColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bg_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *StyleBoxFlat) GetBorderBlend() *bool {
	log.Println("Calling StyleBoxFlat.GetBorderBlend()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_border_blend", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *StyleBoxFlat) GetBorderColor() *Color {
	log.Println("Calling StyleBoxFlat.GetBorderColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_border_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *StyleBoxFlat) GetBorderWidth(margin int64) int64 {
	log.Println("Calling StyleBoxFlat.GetBorderWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_border_width", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *StyleBoxFlat) GetBorderWidthMin() int64 {
	log.Println("Calling StyleBoxFlat.GetBorderWidthMin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_border_width_min", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *StyleBoxFlat) GetCornerDetail() int64 {
	log.Println("Calling StyleBoxFlat.GetCornerDetail()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_corner_detail", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *StyleBoxFlat) GetCornerRadius(corner int64) int64 {
	log.Println("Calling StyleBoxFlat.GetCornerRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(corner)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_corner_radius", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *StyleBoxFlat) GetExpandMargin(margin int64) float64 {
	log.Println("Calling StyleBoxFlat.GetExpandMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_expand_margin", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *StyleBoxFlat) GetShadowColor() *Color {
	log.Println("Calling StyleBoxFlat.GetShadowColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shadow_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *StyleBoxFlat) GetShadowSize() int64 {
	log.Println("Calling StyleBoxFlat.GetShadowSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shadow_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *StyleBoxFlat) IsAntiAliased() *bool {
	log.Println("Calling StyleBoxFlat.IsAntiAliased()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_anti_aliased", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *StyleBoxFlat) IsDrawCenterEnabled() *bool {
	log.Println("Calling StyleBoxFlat.IsDrawCenterEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_draw_center_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *StyleBoxFlat) SetAaSize(size int64) {
	log.Println("Calling StyleBoxFlat.SetAaSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_aa_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) SetAntiAliased(antiAliased *bool) {
	log.Println("Calling StyleBoxFlat.SetAntiAliased()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(antiAliased)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_anti_aliased", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) SetBgColor(color *Color) {
	log.Println("Calling StyleBoxFlat.SetBgColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bg_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) SetBorderBlend(blend *bool) {
	log.Println("Calling StyleBoxFlat.SetBorderBlend()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(blend)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_border_blend", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) SetBorderColor(color *Color) {
	log.Println("Calling StyleBoxFlat.SetBorderColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_border_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) SetBorderWidth(margin int64, width int64) {
	log.Println("Calling StyleBoxFlat.SetBorderWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(width)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_border_width", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) SetBorderWidthAll(width int64) {
	log.Println("Calling StyleBoxFlat.SetBorderWidthAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(width)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_border_width_all", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) SetCornerDetail(detail int64) {
	log.Println("Calling StyleBoxFlat.SetCornerDetail()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(detail)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_corner_detail", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) SetCornerRadius(corner int64, radius int64) {
	log.Println("Calling StyleBoxFlat.SetCornerRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(corner)
	goArguments[1] = reflect.ValueOf(radius)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_corner_radius", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) SetCornerRadiusAll(radius int64) {
	log.Println("Calling StyleBoxFlat.SetCornerRadiusAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radius)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_corner_radius_all", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) SetCornerRadiusIndividual(radiusTopLeft int64, radiusTopRight int64, radiusBottonRight int64, radiusBottomLeft int64) {
	log.Println("Calling StyleBoxFlat.SetCornerRadiusIndividual()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(radiusTopLeft)
	goArguments[1] = reflect.ValueOf(radiusTopRight)
	goArguments[2] = reflect.ValueOf(radiusBottonRight)
	goArguments[3] = reflect.ValueOf(radiusBottomLeft)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_corner_radius_individual", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) SetDrawCenter(drawCenter *bool) {
	log.Println("Calling StyleBoxFlat.SetDrawCenter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(drawCenter)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_draw_center", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) SetExpandMargin(margin int64, size float64) {
	log.Println("Calling StyleBoxFlat.SetExpandMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_expand_margin", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) SetExpandMarginAll(size float64) {
	log.Println("Calling StyleBoxFlat.SetExpandMarginAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_expand_margin_all", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) SetExpandMarginIndividual(sizeLeft float64, sizeTop float64, sizeRight float64, sizeBottom float64) {
	log.Println("Calling StyleBoxFlat.SetExpandMarginIndividual()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(sizeLeft)
	goArguments[1] = reflect.ValueOf(sizeTop)
	goArguments[2] = reflect.ValueOf(sizeRight)
	goArguments[3] = reflect.ValueOf(sizeBottom)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_expand_margin_individual", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) SetShadowColor(color *Color) {
	log.Println("Calling StyleBoxFlat.SetShadowColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxFlat) SetShadowSize(size int64) {
	log.Println("Calling StyleBoxFlat.SetShadowSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_size", goArguments, "")

	log.Println("Got return value!")

}

/*
        StyleBoxFlatImplementer is an interface for StyleBoxFlat objects.
        This stylebox can be used to achieve all kinds of looks without the need of a texture. Those properties are customizable:
		 - Color
		 - Border width (individual width for each border)
		 - Rounded corners (individual radius for each corner)
		 - Shadow
		 About corner radius:
		 	Setting corner radius to high values is allowed. As soon as corners would overlap the stylebox will switch to a relative system. Example:
			[codeblock]
			height = 30
			corner_radius_top_left = 50
			corner_raidus_bottom_left = 100
			[/codeblock]
			The relative system now would take the 1:2 ratio of the two left corners to calculate the actual corner width. Both corners added will [b]never[/b] be more than the height. Result:
			[codeblock]
			corner_radius_top_left: 10
			corner_raidus_bottom_left: 20
			[/codeblock]
*/
type StyleBoxFlatImplementer interface {
	StyleBoxImplementer

	GetAaSize() int64

	GetBgColor() *Color

	GetBorderBlend() *bool

	GetBorderColor() *Color

	GetBorderWidth(margin int64) int64

	GetBorderWidthMin() int64

	GetCornerDetail() int64

	GetCornerRadius(corner int64) int64

	GetExpandMargin(margin int64) float64

	GetShadowColor() *Color

	GetShadowSize() int64

	IsAntiAliased() *bool

	IsDrawCenterEnabled() *bool

	SetAaSize(size int64)

	SetAntiAliased(antiAliased *bool)

	SetBgColor(color *Color)

	SetBorderBlend(blend *bool)

	SetBorderColor(color *Color)

	SetBorderWidth(margin int64, width int64)

	SetBorderWidthAll(width int64)

	SetCornerDetail(detail int64)

	SetCornerRadius(corner int64, radius int64)

	SetCornerRadiusAll(radius int64)

	SetCornerRadiusIndividual(radiusTopLeft int64, radiusTopRight int64, radiusBottonRight int64, radiusBottomLeft int64)

	SetDrawCenter(drawCenter *bool)

	SetExpandMargin(margin int64, size float64)

	SetExpandMarginAll(size float64)

	SetExpandMarginIndividual(sizeLeft float64, sizeTop float64, sizeRight float64, sizeBottom float64)

	SetShadowColor(color *Color)

	SetShadowSize(size int64)
}

/*
   Texture Based 3x3 scale style. This stylebox performs a 3x3 scaling of a texture, where only the center cell is fully stretched. This allows for the easy creation of bordered styles.
*/
type StyleBoxTexture struct {
	StyleBox
}

func (o *StyleBoxTexture) baseClass() string {
	return "StyleBoxTexture"
}

/*

 */
func (o *StyleBoxTexture) GetExpandMarginSize(margin int64) float64 {
	log.Println("Calling StyleBoxTexture.GetExpandMarginSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_expand_margin_size", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *StyleBoxTexture) GetHAxisStretchMode() int64 {
	log.Println("Calling StyleBoxTexture.GetHAxisStretchMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_h_axis_stretch_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *StyleBoxTexture) GetMarginSize(margin int64) float64 {
	log.Println("Calling StyleBoxTexture.GetMarginSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_margin_size", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *StyleBoxTexture) GetModulate() *Color {
	log.Println("Calling StyleBoxTexture.GetModulate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_modulate", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *StyleBoxTexture) GetNormalMap() *Resource {
	log.Println("Calling StyleBoxTexture.GetNormalMap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_normal_map", goArguments, "*Resource")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Resource)

	return returnValue

}

/*

 */
func (o *StyleBoxTexture) GetRegionRect() *Rect2 {
	log.Println("Calling StyleBoxTexture.GetRegionRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_region_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*

 */
func (o *StyleBoxTexture) GetTexture() *Resource {
	log.Println("Calling StyleBoxTexture.GetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture", goArguments, "*Resource")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Resource)

	return returnValue

}

/*

 */
func (o *StyleBoxTexture) GetVAxisStretchMode() int64 {
	log.Println("Calling StyleBoxTexture.GetVAxisStretchMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_v_axis_stretch_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *StyleBoxTexture) IsDrawCenterEnabled() *bool {
	log.Println("Calling StyleBoxTexture.IsDrawCenterEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_draw_center_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *StyleBoxTexture) SetDrawCenter(enable *bool) {
	log.Println("Calling StyleBoxTexture.SetDrawCenter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_draw_center", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxTexture) SetExpandMarginAll(size float64) {
	log.Println("Calling StyleBoxTexture.SetExpandMarginAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_expand_margin_all", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxTexture) SetExpandMarginIndividual(sizeLeft float64, sizeTop float64, sizeRight float64, sizeBottom float64) {
	log.Println("Calling StyleBoxTexture.SetExpandMarginIndividual()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(sizeLeft)
	goArguments[1] = reflect.ValueOf(sizeTop)
	goArguments[2] = reflect.ValueOf(sizeRight)
	goArguments[3] = reflect.ValueOf(sizeBottom)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_expand_margin_individual", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxTexture) SetExpandMarginSize(margin int64, size float64) {
	log.Println("Calling StyleBoxTexture.SetExpandMarginSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_expand_margin_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxTexture) SetHAxisStretchMode(mode int64) {
	log.Println("Calling StyleBoxTexture.SetHAxisStretchMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_h_axis_stretch_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxTexture) SetMarginSize(margin int64, size float64) {
	log.Println("Calling StyleBoxTexture.SetMarginSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_margin_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxTexture) SetModulate(color *Color) {
	log.Println("Calling StyleBoxTexture.SetModulate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_modulate", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxTexture) SetNormalMap(normalMap *Resource) {
	log.Println("Calling StyleBoxTexture.SetNormalMap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(normalMap)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_normal_map", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxTexture) SetRegionRect(region *Rect2) {
	log.Println("Calling StyleBoxTexture.SetRegionRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(region)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_region_rect", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxTexture) SetTexture(texture *Resource) {
	log.Println("Calling StyleBoxTexture.SetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *StyleBoxTexture) SetVAxisStretchMode(mode int64) {
	log.Println("Calling StyleBoxTexture.SetVAxisStretchMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_v_axis_stretch_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   StyleBoxTextureImplementer is an interface for StyleBoxTexture objects.
   Texture Based 3x3 scale style. This stylebox performs a 3x3 scaling of a texture, where only the center cell is fully stretched. This allows for the easy creation of bordered styles.
*/
type StyleBoxTextureImplementer interface {
	StyleBoxImplementer

	GetExpandMarginSize(margin int64) float64

	GetHAxisStretchMode() int64

	GetMarginSize(margin int64) float64

	GetModulate() *Color

	GetNormalMap() *Resource

	GetRegionRect() *Rect2

	GetTexture() *Resource

	GetVAxisStretchMode() int64

	IsDrawCenterEnabled() *bool

	SetDrawCenter(enable *bool)

	SetExpandMarginAll(size float64)

	SetExpandMarginIndividual(sizeLeft float64, sizeTop float64, sizeRight float64, sizeBottom float64)

	SetExpandMarginSize(margin int64, size float64)

	SetHAxisStretchMode(mode int64)

	SetMarginSize(margin int64, size float64)

	SetModulate(color *Color)

	SetNormalMap(normalMap *Resource)

	SetRegionRect(region *Rect2)

	SetTexture(texture *Resource)

	SetVAxisStretchMode(mode int64)
}

/*
        The [SurfaceTool] is used to construct a [Mesh] by specifying vertex attributes individually. It can be used to construct a [Mesh] from script. All properties except index need to be added before a call to [method add_vertex]. For example adding vertex colors and UVs looks like
		[codeblock]
		var st = SurfaceTool.new()
		st.begin(Mesh.PRIMITIVE_TRIANGLES)
		st.add_color(Color(1, 0, 0))
		st.add_uv(Vector2(0, 0))
		st.add_vertex(Vector3(0, 0, 0))
		[/codeblock]
		The [SurfaceTool] now contains one vertex of a triangle which has a UV coordinate and a specified [Color]. If another vertex were added without calls to [method add_uv] or [method add_color] then the last values would be used.
		It is very important that vertex attributes are passed [b]before[/b] the call to [method add_vertex], failure to do this will result in an error when committing the vertex information to a mesh.
*/
type SurfaceTool struct {
	Reference
}

func (o *SurfaceTool) baseClass() string {
	return "SurfaceTool"
}

/*
   Add an array of bones for the next Vertex to use.
*/
func (o *SurfaceTool) AddBones(bones *PoolIntArray) {
	log.Println("Calling SurfaceTool.AddBones()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bones)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_bones", goArguments, "")

	log.Println("Got return value!")

}

/*
   Specify a [Color] for the next Vertex to use.
*/
func (o *SurfaceTool) AddColor(color *Color) {
	log.Println("Calling SurfaceTool.AddColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_color", goArguments, "")

	log.Println("Got return value!")

}

/*
   Adds an index to index array if you are using indexed Vertices. Does not need to be called before adding Vertex.
*/
func (o *SurfaceTool) AddIndex(index int64) {
	log.Println("Calling SurfaceTool.AddIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_index", goArguments, "")

	log.Println("Got return value!")

}

/*
   Specify a normal for the next Vertex to use.
*/
func (o *SurfaceTool) AddNormal(normal *Vector3) {
	log.Println("Calling SurfaceTool.AddNormal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(normal)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_normal", goArguments, "")

	log.Println("Got return value!")

}

/*
   Specify whether current Vertex (if using only Vertex arrays) or current index (if also using index arrays) should utilize smooth normals for normal calculation.
*/
func (o *SurfaceTool) AddSmoothGroup(smooth *bool) {
	log.Println("Calling SurfaceTool.AddSmoothGroup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(smooth)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_smooth_group", goArguments, "")

	log.Println("Got return value!")

}

/*
   Specify a Tangent for the next Vertex to use.
*/
func (o *SurfaceTool) AddTangent(tangent *Plane) {
	log.Println("Calling SurfaceTool.AddTangent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tangent)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_tangent", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SurfaceTool) AddToFormat(flags int64) {
	log.Println("Calling SurfaceTool.AddToFormat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flags)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_to_format", goArguments, "")

	log.Println("Got return value!")

}

/*
   Insert a triangle fan made of array data into [Mesh] being constructed.
*/
func (o *SurfaceTool) AddTriangleFan(vertexes *PoolVector3Array, uvs *PoolVector2Array, colors *PoolColorArray, uv2S *PoolVector2Array, normals *PoolVector3Array, tangents *Array) {
	log.Println("Calling SurfaceTool.AddTriangleFan()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 6, 6)
	goArguments[0] = reflect.ValueOf(vertexes)
	goArguments[1] = reflect.ValueOf(uvs)
	goArguments[2] = reflect.ValueOf(colors)
	goArguments[3] = reflect.ValueOf(uv2S)
	goArguments[4] = reflect.ValueOf(normals)
	goArguments[5] = reflect.ValueOf(tangents)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_triangle_fan", goArguments, "")

	log.Println("Got return value!")

}

/*
   Specify UV Coordinate for next Vertex to use.
*/
func (o *SurfaceTool) AddUv(uv *Vector2) {
	log.Println("Calling SurfaceTool.AddUv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(uv)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_uv", goArguments, "")

	log.Println("Got return value!")

}

/*
   Specify an optional second set of UV coordinates for next Vertex to use.
*/
func (o *SurfaceTool) AddUv2(uv2 *Vector2) {
	log.Println("Calling SurfaceTool.AddUv2()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(uv2)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_uv2", goArguments, "")

	log.Println("Got return value!")

}

/*
   Specify position of current Vertex. Should be called after specifying other vertex properties (e.g. Color, UV).
*/
func (o *SurfaceTool) AddVertex(vertex *Vector3) {
	log.Println("Calling SurfaceTool.AddVertex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(vertex)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_vertex", goArguments, "")

	log.Println("Got return value!")

}

/*
   Specify weight value for next Vertex to use.
*/
func (o *SurfaceTool) AddWeights(weights *PoolRealArray) {
	log.Println("Calling SurfaceTool.AddWeights()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(weights)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_weights", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SurfaceTool) AppendFrom(existing *Mesh, surface int64, transform *Transform) {
	log.Println("Calling SurfaceTool.AppendFrom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(existing)
	goArguments[1] = reflect.ValueOf(surface)
	goArguments[2] = reflect.ValueOf(transform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "append_from", goArguments, "")

	log.Println("Got return value!")

}

/*
   Called before adding any Vertices. Takes the primitive type as an argument (e.g. Mesh.PRIMITIVE_TRIANGLES).
*/
func (o *SurfaceTool) Begin(primitive int64) {
	log.Println("Calling SurfaceTool.Begin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(primitive)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "begin", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear all information passed into the surface tool so far.
*/
func (o *SurfaceTool) Clear() {
	log.Println("Calling SurfaceTool.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns a constructed [ArrayMesh] from current information passed in. If an existing [ArrayMesh] is passed in as an argument, will add an extra surface to the existing [ArrayMesh].
*/
func (o *SurfaceTool) Commit(existing *ArrayMesh) *ArrayMesh {
	log.Println("Calling SurfaceTool.Commit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(existing)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "commit", goArguments, "*ArrayMesh")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*ArrayMesh)

	return returnValue

}

/*

 */
func (o *SurfaceTool) CreateFrom(existing *Mesh, surface int64) {
	log.Println("Calling SurfaceTool.CreateFrom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(existing)
	goArguments[1] = reflect.ValueOf(surface)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "create_from", goArguments, "")

	log.Println("Got return value!")

}

/*
   Removes index array by expanding Vertex array.
*/
func (o *SurfaceTool) Deindex() {
	log.Println("Calling SurfaceTool.Deindex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "deindex", goArguments, "")

	log.Println("Got return value!")

}

/*
   Generates normals from Vertices so you do not have to do it manually.
*/
func (o *SurfaceTool) GenerateNormals() {
	log.Println("Calling SurfaceTool.GenerateNormals()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "generate_normals", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *SurfaceTool) GenerateTangents() {
	log.Println("Calling SurfaceTool.GenerateTangents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "generate_tangents", goArguments, "")

	log.Println("Got return value!")

}

/*
   Shrinks Vertex array by creating an index array. Avoids reusing Vertices.
*/
func (o *SurfaceTool) Index() {
	log.Println("Calling SurfaceTool.Index()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "index", goArguments, "")

	log.Println("Got return value!")

}

/*
   Sets [Material] to be used by the [Mesh] you are constructing.
*/
func (o *SurfaceTool) SetMaterial(material *Material) {
	log.Println("Calling SurfaceTool.SetMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(material)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_material", goArguments, "")

	log.Println("Got return value!")

}

/*
        SurfaceToolImplementer is an interface for SurfaceTool objects.
        The [SurfaceTool] is used to construct a [Mesh] by specifying vertex attributes individually. It can be used to construct a [Mesh] from script. All properties except index need to be added before a call to [method add_vertex]. For example adding vertex colors and UVs looks like
		[codeblock]
		var st = SurfaceTool.new()
		st.begin(Mesh.PRIMITIVE_TRIANGLES)
		st.add_color(Color(1, 0, 0))
		st.add_uv(Vector2(0, 0))
		st.add_vertex(Vector3(0, 0, 0))
		[/codeblock]
		The [SurfaceTool] now contains one vertex of a triangle which has a UV coordinate and a specified [Color]. If another vertex were added without calls to [method add_uv] or [method add_color] then the last values would be used.
		It is very important that vertex attributes are passed [b]before[/b] the call to [method add_vertex], failure to do this will result in an error when committing the vertex information to a mesh.
*/
type SurfaceToolImplementer interface {
	ReferenceImplementer

	AddBones(bones *PoolIntArray)

	AddColor(color *Color)

	AddIndex(index int64)

	AddNormal(normal *Vector3)

	AddSmoothGroup(smooth *bool)

	AddTangent(tangent *Plane)

	AddToFormat(flags int64)

	AddTriangleFan(vertexes *PoolVector3Array, uvs *PoolVector2Array, colors *PoolColorArray, uv2S *PoolVector2Array, normals *PoolVector3Array, tangents *Array)

	AddUv(uv *Vector2)

	AddUv2(uv2 *Vector2)

	AddVertex(vertex *Vector3)

	AddWeights(weights *PoolRealArray)

	AppendFrom(existing *Mesh, surface int64, transform *Transform)

	Begin(primitive int64)

	Clear()

	Commit(existing *ArrayMesh) *ArrayMesh

	CreateFrom(existing *Mesh, surface int64)

	Deindex()

	GenerateNormals()

	GenerateTangents()

	Index()

	SetMaterial(material *Material)
}

/*
   TCP Server class. Listens to connections on a port and returns a [StreamPeerTCP] when got a connection.
*/
type TCP_Server struct {
	Reference
}

func (o *TCP_Server) baseClass() string {
	return "TCP_Server"
}

/*
   Return true if a connection is available for taking.
*/
func (o *TCP_Server) IsConnectionAvailable() *bool {
	log.Println("Calling TCP_Server.IsConnectionAvailable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_connection_available", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
                Listen on the "port" binding to "bind_address".
				If "bind_address" is set as "*" (default), the server will listen on all available addresses (both IPv4 and IPv6).
				If "bind_address" is set as "0.0.0.0" (for IPv4) or "::" (for IPv6), the server will listen on all available addresses matching that IP type.
				If "bind_address" is set to any valid address (e.g. "192.168.1.101", "::1", etc), the server will only listen on the interface with that addresses (or fail if no interface with the given address exists).
*/
func (o *TCP_Server) Listen(port int64, bindAddress string) int64 {
	log.Println("Calling TCP_Server.Listen()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(port)
	goArguments[1] = reflect.ValueOf(bindAddress)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "listen", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Stop listening.
*/
func (o *TCP_Server) Stop() {
	log.Println("Calling TCP_Server.Stop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "stop", goArguments, "")

	log.Println("Got return value!")

}

/*
   If a connection is available, return a StreamPeerTCP with the connection/
*/
func (o *TCP_Server) TakeConnection() *StreamPeerTCP {
	log.Println("Calling TCP_Server.TakeConnection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "take_connection", goArguments, "*StreamPeerTCP")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*StreamPeerTCP)

	return returnValue

}

/*
   TCP_ServerImplementer is an interface for TCP_Server objects.
   TCP Server class. Listens to connections on a port and returns a [StreamPeerTCP] when got a connection.
*/
type TCP_ServerImplementer interface {
	ReferenceImplementer

	IsConnectionAvailable() *bool

	Listen(port int64, bindAddress string) int64

	Stop()

	TakeConnection() *StreamPeerTCP
}

/*
        Tabbed Container. Contains several children controls, but shows only one at the same time. Clicking on the top tabs allows to change the currently visible one.
		Children controls of this one automatically.
*/
type TabContainer struct {
	Control
}

func (o *TabContainer) baseClass() string {
	return "TabContainer"
}

/*
   Return whether the tabs should be visible or hidden.
*/
func (o *TabContainer) AreTabsVisible() *bool {
	log.Println("Calling TabContainer.AreTabsVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "are_tabs_visible", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return the current tab index that is being shown.
*/
func (o *TabContainer) GetCurrentTab() int64 {
	log.Println("Calling TabContainer.GetCurrentTab()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_tab", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *TabContainer) GetCurrentTabControl() *Control {
	log.Println("Calling TabContainer.GetCurrentTabControl()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_tab_control", goArguments, "*Control")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Control)

	return returnValue

}

/*

 */
func (o *TabContainer) GetPopup() *Popup {
	log.Println("Calling TabContainer.GetPopup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_popup", goArguments, "*Popup")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Popup)

	return returnValue

}

/*
   Return the previous tab index that was being shown.
*/
func (o *TabContainer) GetPreviousTab() int64 {
	log.Println("Calling TabContainer.GetPreviousTab()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_previous_tab", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return tab alignment, from the ALIGN_* enum.
*/
func (o *TabContainer) GetTabAlign() int64 {
	log.Println("Calling TabContainer.GetTabAlign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tab_align", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the current tab control that is being shown.
*/
func (o *TabContainer) GetTabControl(idx int64) *Control {
	log.Println("Calling TabContainer.GetTabControl()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tab_control", goArguments, "*Control")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Control)

	return returnValue

}

/*
   Return the amount of tabs.
*/
func (o *TabContainer) GetTabCount() int64 {
	log.Println("Calling TabContainer.GetTabCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tab_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *TabContainer) GetTabDisabled(tabIdx int64) *bool {
	log.Println("Calling TabContainer.GetTabDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tabIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tab_disabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *TabContainer) GetTabIcon(tabIdx int64) *Texture {
	log.Println("Calling TabContainer.GetTabIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tabIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tab_icon", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   Return the title for the tab. Tab titles are by default the children node name, but this can be overridden.
*/
func (o *TabContainer) GetTabTitle(tabIdx int64) string {
	log.Println("Calling TabContainer.GetTabTitle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tabIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tab_title", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Bring a tab (and the Control it represents) to the front, and hide the rest.
*/
func (o *TabContainer) SetCurrentTab(tabIdx int64) {
	log.Println("Calling TabContainer.SetCurrentTab()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tabIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_current_tab", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TabContainer) SetPopup(popup *Node) {
	log.Println("Calling TabContainer.SetPopup()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(popup)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_popup", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set tab alignment, from the ALIGN_* enum. Moves tabs to the left, right or center.
*/
func (o *TabContainer) SetTabAlign(align int64) {
	log.Println("Calling TabContainer.SetTabAlign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(align)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tab_align", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TabContainer) SetTabDisabled(tabIdx int64, disabled *bool) {
	log.Println("Calling TabContainer.SetTabDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(tabIdx)
	goArguments[1] = reflect.ValueOf(disabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tab_disabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set an icon for a tab.
*/
func (o *TabContainer) SetTabIcon(tabIdx int64, icon *Texture) {
	log.Println("Calling TabContainer.SetTabIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(tabIdx)
	goArguments[1] = reflect.ValueOf(icon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tab_icon", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set a title for the tab. Tab titles are by default the children node name, but this can be overridden.
*/
func (o *TabContainer) SetTabTitle(tabIdx int64, title string) {
	log.Println("Calling TabContainer.SetTabTitle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(tabIdx)
	goArguments[1] = reflect.ValueOf(title)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tab_title", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether the tabs should be visible or hidden.
*/
func (o *TabContainer) SetTabsVisible(visible *bool) {
	log.Println("Calling TabContainer.SetTabsVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(visible)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tabs_visible", goArguments, "")

	log.Println("Got return value!")

}

/*
        TabContainerImplementer is an interface for TabContainer objects.
        Tabbed Container. Contains several children controls, but shows only one at the same time. Clicking on the top tabs allows to change the currently visible one.
		Children controls of this one automatically.
*/
type TabContainerImplementer interface {
	ControlImplementer

	AreTabsVisible() *bool

	GetCurrentTab() int64

	GetCurrentTabControl() *Control

	GetPopup() *Popup

	GetPreviousTab() int64

	GetTabAlign() int64

	GetTabControl(idx int64) *Control

	GetTabCount() int64

	GetTabDisabled(tabIdx int64) *bool

	GetTabIcon(tabIdx int64) *Texture

	GetTabTitle(tabIdx int64) string

	SetCurrentTab(tabIdx int64)

	SetPopup(popup *Node)

	SetTabAlign(align int64)

	SetTabDisabled(tabIdx int64, disabled *bool)

	SetTabIcon(tabIdx int64, icon *Texture)

	SetTabTitle(tabIdx int64, title string)

	SetTabsVisible(visible *bool)
}

/*
   Simple tabs control, similar to [TabContainer] but is only in charge of drawing tabs, not interact with children.
*/
type Tabs struct {
	Control
}

func (o *Tabs) baseClass() string {
	return "Tabs"
}

/*

 */
func (o *Tabs) AddTab(title string, icon *Texture) {
	log.Println("Calling Tabs.AddTab()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(title)
	goArguments[1] = reflect.ValueOf(icon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_tab", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Tabs) EnsureTabVisible(idx int64) {
	log.Println("Calling Tabs.EnsureTabVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "ensure_tab_visible", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Tabs) GetCurrentTab() int64 {
	log.Println("Calling Tabs.GetCurrentTab()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_tab", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Tabs) GetTabAlign() int64 {
	log.Println("Calling Tabs.GetTabAlign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tab_align", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Tabs) GetTabCloseDisplayPolicy() int64 {
	log.Println("Calling Tabs.GetTabCloseDisplayPolicy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tab_close_display_policy", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Tabs) GetTabCount() int64 {
	log.Println("Calling Tabs.GetTabCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tab_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Tabs) GetTabDisabled(tabIdx int64) *bool {
	log.Println("Calling Tabs.GetTabDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tabIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tab_disabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Tabs) GetTabIcon(tabIdx int64) *Texture {
	log.Println("Calling Tabs.GetTabIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tabIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tab_icon", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   Returns tab [Rect2] with local position and size.
*/
func (o *Tabs) GetTabRect(tabIdx int64) *Rect2 {
	log.Println("Calling Tabs.GetTabRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tabIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tab_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*

 */
func (o *Tabs) GetTabTitle(tabIdx int64) string {
	log.Println("Calling Tabs.GetTabTitle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tabIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tab_title", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Rearrange tab.
*/
func (o *Tabs) MoveTab(from int64, to int64) {
	log.Println("Calling Tabs.MoveTab()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(from)
	goArguments[1] = reflect.ValueOf(to)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "move_tab", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Tabs) RemoveTab(tabIdx int64) {
	log.Println("Calling Tabs.RemoveTab()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tabIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_tab", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Tabs) SetCurrentTab(tabIdx int64) {
	log.Println("Calling Tabs.SetCurrentTab()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tabIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_current_tab", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Tabs) SetTabAlign(align int64) {
	log.Println("Calling Tabs.SetTabAlign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(align)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tab_align", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Tabs) SetTabCloseDisplayPolicy(policy int64) {
	log.Println("Calling Tabs.SetTabCloseDisplayPolicy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(policy)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tab_close_display_policy", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Tabs) SetTabDisabled(tabIdx int64, disabled *bool) {
	log.Println("Calling Tabs.SetTabDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(tabIdx)
	goArguments[1] = reflect.ValueOf(disabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tab_disabled", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Tabs) SetTabIcon(tabIdx int64, icon *Texture) {
	log.Println("Calling Tabs.SetTabIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(tabIdx)
	goArguments[1] = reflect.ValueOf(icon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tab_icon", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Tabs) SetTabTitle(tabIdx int64, title string) {
	log.Println("Calling Tabs.SetTabTitle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(tabIdx)
	goArguments[1] = reflect.ValueOf(title)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tab_title", goArguments, "")

	log.Println("Got return value!")

}

/*
   TabsImplementer is an interface for Tabs objects.
   Simple tabs control, similar to [TabContainer] but is only in charge of drawing tabs, not interact with children.
*/
type TabsImplementer interface {
	ControlImplementer

	AddTab(title string, icon *Texture)

	EnsureTabVisible(idx int64)

	GetCurrentTab() int64

	GetTabAlign() int64

	GetTabCloseDisplayPolicy() int64

	GetTabCount() int64

	GetTabDisabled(tabIdx int64) *bool

	GetTabIcon(tabIdx int64) *Texture

	GetTabRect(tabIdx int64) *Rect2

	GetTabTitle(tabIdx int64) string

	MoveTab(from int64, to int64)

	RemoveTab(tabIdx int64)

	SetCurrentTab(tabIdx int64)

	SetTabAlign(align int64)

	SetTabCloseDisplayPolicy(policy int64)

	SetTabDisabled(tabIdx int64, disabled *bool)

	SetTabIcon(tabIdx int64, icon *Texture)

	SetTabTitle(tabIdx int64, title string)
}

/*
   TextEdit is meant for editing large, multiline text. It also has facilities for editing code, such as syntax highlighting support and multiple levels of undo/redo.
*/
type TextEdit struct {
	Control
}

func (o *TextEdit) baseClass() string {
	return "TextEdit"
}

/*
   Add color region (given the delimiters) and its colors.
*/
func (o *TextEdit) AddColorRegion(beginKey string, endKey string, color *Color, lineOnly *bool) {
	log.Println("Calling TextEdit.AddColorRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(beginKey)
	goArguments[1] = reflect.ValueOf(endKey)
	goArguments[2] = reflect.ValueOf(color)
	goArguments[3] = reflect.ValueOf(lineOnly)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_color_region", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a keyword and its color.
*/
func (o *TextEdit) AddKeywordColor(keyword string, color *Color) {
	log.Println("Calling TextEdit.AddKeywordColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(keyword)
	goArguments[1] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_keyword_color", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear all the syntax coloring information.
*/
func (o *TextEdit) ClearColors() {
	log.Println("Calling TextEdit.ClearColors()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_colors", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear the undo history.
*/
func (o *TextEdit) ClearUndoHistory() {
	log.Println("Calling TextEdit.ClearUndoHistory()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_undo_history", goArguments, "")

	log.Println("Got return value!")

}

/*
   Copy the current selection.
*/
func (o *TextEdit) Copy() {
	log.Println("Calling TextEdit.Copy()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "copy", goArguments, "")

	log.Println("Got return value!")

}

/*
   Gets whether the text editor caret is blinking.
*/
func (o *TextEdit) CursorGetBlinkEnabled() *bool {
	log.Println("Calling TextEdit.CursorGetBlinkEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "cursor_get_blink_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Gets the text editor caret blink speed.
*/
func (o *TextEdit) CursorGetBlinkSpeed() float64 {
	log.Println("Calling TextEdit.CursorGetBlinkSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "cursor_get_blink_speed", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the column the editing cursor is at.
*/
func (o *TextEdit) CursorGetColumn() int64 {
	log.Println("Calling TextEdit.CursorGetColumn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "cursor_get_column", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the line the editing cursor is at.
*/
func (o *TextEdit) CursorGetLine() int64 {
	log.Println("Calling TextEdit.CursorGetLine()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "cursor_get_line", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Gets whether the text editor caret is in block mode.
*/
func (o *TextEdit) CursorIsBlockMode() *bool {
	log.Println("Calling TextEdit.CursorIsBlockMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "cursor_is_block_mode", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Set the text editor caret to blink.
*/
func (o *TextEdit) CursorSetBlinkEnabled(enable *bool) {
	log.Println("Calling TextEdit.CursorSetBlinkEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "cursor_set_blink_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the text editor caret blink speed. Cannot be less then or equal to 0.
*/
func (o *TextEdit) CursorSetBlinkSpeed(blinkSpeed float64) {
	log.Println("Calling TextEdit.CursorSetBlinkSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(blinkSpeed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "cursor_set_blink_speed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the text editor caret to block mode.
*/
func (o *TextEdit) CursorSetBlockMode(enable *bool) {
	log.Println("Calling TextEdit.CursorSetBlockMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "cursor_set_block_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextEdit) CursorSetColumn(column int64, adjustViewport *bool) {
	log.Println("Calling TextEdit.CursorSetColumn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(adjustViewport)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "cursor_set_column", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextEdit) CursorSetLine(line int64, adjustViewport *bool) {
	log.Println("Calling TextEdit.CursorSetLine()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(line)
	goArguments[1] = reflect.ValueOf(adjustViewport)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "cursor_set_line", goArguments, "")

	log.Println("Got return value!")

}

/*
   Cut the current selection.
*/
func (o *TextEdit) Cut() {
	log.Println("Calling TextEdit.Cut()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "cut", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the text of a specific line.
*/
func (o *TextEdit) GetLine(line int64) string {
	log.Println("Calling TextEdit.GetLine()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(line)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_line", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the amount of total lines in the text.
*/
func (o *TextEdit) GetLineCount() int64 {
	log.Println("Calling TextEdit.GetLineCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_line_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *TextEdit) GetMenu() *PopupMenu {
	log.Println("Calling TextEdit.GetMenu()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_menu", goArguments, "*PopupMenu")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PopupMenu)

	return returnValue

}

/*
   Return the selection begin column.
*/
func (o *TextEdit) GetSelectionFromColumn() int64 {
	log.Println("Calling TextEdit.GetSelectionFromColumn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_selection_from_column", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the selection begin line.
*/
func (o *TextEdit) GetSelectionFromLine() int64 {
	log.Println("Calling TextEdit.GetSelectionFromLine()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_selection_from_line", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the text inside the selection.
*/
func (o *TextEdit) GetSelectionText() string {
	log.Println("Calling TextEdit.GetSelectionText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_selection_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the selection end column.
*/
func (o *TextEdit) GetSelectionToColumn() int64 {
	log.Println("Calling TextEdit.GetSelectionToColumn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_selection_to_column", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the selection end line.
*/
func (o *TextEdit) GetSelectionToLine() int64 {
	log.Println("Calling TextEdit.GetSelectionToLine()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_selection_to_line", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the whole text.
*/
func (o *TextEdit) GetText() string {
	log.Println("Calling TextEdit.GetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *TextEdit) GetVScrollSpeed() float64 {
	log.Println("Calling TextEdit.GetVScrollSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_v_scroll_speed", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *TextEdit) GetWordUnderCursor() string {
	log.Println("Calling TextEdit.GetWordUnderCursor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_word_under_cursor", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Insert a given text at the cursor position.
*/
func (o *TextEdit) InsertTextAtCursor(text string) {
	log.Println("Calling TextEdit.InsertTextAtCursor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "insert_text_at_cursor", goArguments, "")

	log.Println("Got return value!")

}

/*
   Returns true if highlight all occurrences is enabled.
*/
func (o *TextEdit) IsHighlightAllOccurrencesEnabled() *bool {
	log.Println("Calling TextEdit.IsHighlightAllOccurrencesEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_highlight_all_occurrences_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if the selection is active.
*/
func (o *TextEdit) IsSelectionActive() *bool {
	log.Println("Calling TextEdit.IsSelectionActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_selection_active", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns true if line numbers are enabled.
*/
func (o *TextEdit) IsShowLineNumbersEnabled() *bool {
	log.Println("Calling TextEdit.IsShowLineNumbersEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_show_line_numbers_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *TextEdit) IsSmoothScrollEnabled() *bool {
	log.Println("Calling TextEdit.IsSmoothScrollEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_smooth_scroll_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if the syntax coloring is enabled.
*/
func (o *TextEdit) IsSyntaxColoringEnabled() *bool {
	log.Println("Calling TextEdit.IsSyntaxColoringEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_syntax_coloring_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *TextEdit) MenuOption(option int64) {
	log.Println("Calling TextEdit.MenuOption()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(option)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "menu_option", goArguments, "")

	log.Println("Got return value!")

}

/*
   Paste the current selection.
*/
func (o *TextEdit) Paste() {
	log.Println("Calling TextEdit.Paste()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "paste", goArguments, "")

	log.Println("Got return value!")

}

/*
   Perform redo operation.
*/
func (o *TextEdit) Redo() {
	log.Println("Calling TextEdit.Redo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "redo", goArguments, "")

	log.Println("Got return value!")

}

/*
   Perform a search inside the text. Search flags can be specified in the SEARCH_* enum.
*/
func (o *TextEdit) Search(key string, flags int64, fromLine int64, fromColumn int64) *PoolIntArray {
	log.Println("Calling TextEdit.Search()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(key)
	goArguments[1] = reflect.ValueOf(flags)
	goArguments[2] = reflect.ValueOf(fromLine)
	goArguments[3] = reflect.ValueOf(fromColumn)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "search", goArguments, "*PoolIntArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolIntArray)

	return returnValue

}

/*
   Perform selection, from line/column to line/column.
*/
func (o *TextEdit) Select(fromLine int64, fromColumn int64, toLine int64, toColumn int64) {
	log.Println("Calling TextEdit.Select()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(fromLine)
	goArguments[1] = reflect.ValueOf(fromColumn)
	goArguments[2] = reflect.ValueOf(toLine)
	goArguments[3] = reflect.ValueOf(toColumn)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "select", goArguments, "")

	log.Println("Got return value!")

}

/*
   Select all the text.
*/
func (o *TextEdit) SelectAll() {
	log.Println("Calling TextEdit.SelectAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "select_all", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set to enable highlighting all occurrences of the current selection.
*/
func (o *TextEdit) SetHighlightAllOccurrences(enable *bool) {
	log.Println("Calling TextEdit.SetHighlightAllOccurrences()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_highlight_all_occurrences", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the maximum amount of characters editable.
*/
func (o *TextEdit) SetMaxChars(amount int64) {
	log.Println("Calling TextEdit.SetMaxChars()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_max_chars", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the text editor as read-only. Text can be displayed but not edited.
*/
func (o *TextEdit) SetReadonly(enable *bool) {
	log.Println("Calling TextEdit.SetReadonly()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_readonly", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set to enable showing line numbers.
*/
func (o *TextEdit) SetShowLineNumbers(enable *bool) {
	log.Println("Calling TextEdit.SetShowLineNumbers()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_show_line_numbers", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextEdit) SetSmoothScrollEnable(enable *bool) {
	log.Println("Calling TextEdit.SetSmoothScrollEnable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_smooth_scroll_enable", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set to enable the syntax coloring.
*/
func (o *TextEdit) SetSyntaxColoring(enable *bool) {
	log.Println("Calling TextEdit.SetSyntaxColoring()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_syntax_coloring", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the entire text.
*/
func (o *TextEdit) SetText(text string) {
	log.Println("Calling TextEdit.SetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_text", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextEdit) SetVScrollSpeed(speed float64) {
	log.Println("Calling TextEdit.SetVScrollSpeed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(speed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_v_scroll_speed", goArguments, "")

	log.Println("Got return value!")

}

/*
   Enable text wrapping when it goes beyond he edge of what is visible.
*/
func (o *TextEdit) SetWrap(enable *bool) {
	log.Println("Calling TextEdit.SetWrap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_wrap", goArguments, "")

	log.Println("Got return value!")

}

/*
   Perform undo operation.
*/
func (o *TextEdit) Undo() {
	log.Println("Calling TextEdit.Undo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "undo", goArguments, "")

	log.Println("Got return value!")

}

/*
   TextEditImplementer is an interface for TextEdit objects.
   TextEdit is meant for editing large, multiline text. It also has facilities for editing code, such as syntax highlighting support and multiple levels of undo/redo.
*/
type TextEditImplementer interface {
	ControlImplementer

	AddColorRegion(beginKey string, endKey string, color *Color, lineOnly *bool)

	AddKeywordColor(keyword string, color *Color)

	ClearColors()

	ClearUndoHistory()

	Copy()

	CursorGetBlinkEnabled() *bool

	CursorGetBlinkSpeed() float64

	CursorGetColumn() int64

	CursorGetLine() int64

	CursorIsBlockMode() *bool

	CursorSetBlinkEnabled(enable *bool)

	CursorSetBlinkSpeed(blinkSpeed float64)

	CursorSetBlockMode(enable *bool)

	CursorSetColumn(column int64, adjustViewport *bool)

	CursorSetLine(line int64, adjustViewport *bool)

	Cut()

	GetLine(line int64) string

	GetLineCount() int64

	GetMenu() *PopupMenu

	GetSelectionFromColumn() int64

	GetSelectionFromLine() int64

	GetSelectionText() string

	GetSelectionToColumn() int64

	GetSelectionToLine() int64

	GetText() string

	GetVScrollSpeed() float64

	GetWordUnderCursor() string

	InsertTextAtCursor(text string)

	IsHighlightAllOccurrencesEnabled() *bool

	IsSelectionActive() *bool

	IsShowLineNumbersEnabled() *bool

	IsSmoothScrollEnabled() *bool

	IsSyntaxColoringEnabled() *bool

	MenuOption(option int64)

	Paste()

	Redo()

	Search(key string, flags int64, fromLine int64, fromColumn int64) *PoolIntArray

	Select(fromLine int64, fromColumn int64, toLine int64, toColumn int64)

	SelectAll()

	SetHighlightAllOccurrences(enable *bool)

	SetMaxChars(amount int64)

	SetReadonly(enable *bool)

	SetShowLineNumbers(enable *bool)

	SetSmoothScrollEnable(enable *bool)

	SetSyntaxColoring(enable *bool)

	SetText(text string)

	SetVScrollSpeed(speed float64)

	SetWrap(enable *bool)

	Undo()
}

/*
   A texture works by registering an image in the video hardware, which then can be used in 3D models or 2D [Sprite] or GUI [Control].
*/
type Texture struct {
	Resource
}

func (o *Texture) baseClass() string {
	return "Texture"
}

/*

 */
func (o *Texture) Draw(canvasItem *RID, pos *Vector2, modulate *Color, transpose *bool, normalMap *Texture) {
	log.Println("Calling Texture.Draw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(canvasItem)
	goArguments[1] = reflect.ValueOf(pos)
	goArguments[2] = reflect.ValueOf(modulate)
	goArguments[3] = reflect.ValueOf(transpose)
	goArguments[4] = reflect.ValueOf(normalMap)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Texture) DrawRect(canvasItem *RID, rect *Rect2, tile *bool, modulate *Color, transpose *bool, normalMap *Texture) {
	log.Println("Calling Texture.DrawRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 6, 6)
	goArguments[0] = reflect.ValueOf(canvasItem)
	goArguments[1] = reflect.ValueOf(rect)
	goArguments[2] = reflect.ValueOf(tile)
	goArguments[3] = reflect.ValueOf(modulate)
	goArguments[4] = reflect.ValueOf(transpose)
	goArguments[5] = reflect.ValueOf(normalMap)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_rect", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Texture) DrawRectRegion(canvasItem *RID, rect *Rect2, srcRect *Rect2, modulate *Color, transpose *bool, normalMap *Texture, clipUv *bool) {
	log.Println("Calling Texture.DrawRectRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 7, 7)
	goArguments[0] = reflect.ValueOf(canvasItem)
	goArguments[1] = reflect.ValueOf(rect)
	goArguments[2] = reflect.ValueOf(srcRect)
	goArguments[3] = reflect.ValueOf(modulate)
	goArguments[4] = reflect.ValueOf(transpose)
	goArguments[5] = reflect.ValueOf(normalMap)
	goArguments[6] = reflect.ValueOf(clipUv)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "draw_rect_region", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Texture) GetData() *Image {
	log.Println("Calling Texture.GetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_data", goArguments, "*Image")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Image)

	return returnValue

}

/*
   Return the current texture flags.
*/
func (o *Texture) GetFlags() int64 {
	log.Println("Calling Texture.GetFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_flags", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the texture height.
*/
func (o *Texture) GetHeight() int64 {
	log.Println("Calling Texture.GetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_height", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the texture size.
*/
func (o *Texture) GetSize() *Vector2 {
	log.Println("Calling Texture.GetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the texture width.
*/
func (o *Texture) GetWidth() int64 {
	log.Println("Calling Texture.GetWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_width", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Texture) HasAlpha() *bool {
	log.Println("Calling Texture.HasAlpha()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_alpha", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Change the texture flags.
*/
func (o *Texture) SetFlags(flags int64) {
	log.Println("Calling Texture.SetFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flags)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_flags", goArguments, "")

	log.Println("Got return value!")

}

/*
   TextureImplementer is an interface for Texture objects.
   A texture works by registering an image in the video hardware, which then can be used in 3D models or 2D [Sprite] or GUI [Control].
*/
type TextureImplementer interface {
	ResourceImplementer

	Draw(canvasItem *RID, pos *Vector2, modulate *Color, transpose *bool, normalMap *Texture)

	DrawRect(canvasItem *RID, rect *Rect2, tile *bool, modulate *Color, transpose *bool, normalMap *Texture)

	DrawRectRegion(canvasItem *RID, rect *Rect2, srcRect *Rect2, modulate *Color, transpose *bool, normalMap *Texture, clipUv *bool)

	GetData() *Image

	GetFlags() int64

	GetHeight() int64

	GetSize() *Vector2

	GetWidth() int64

	HasAlpha() *bool

	SetFlags(flags int64)
}

/*
        Button that can be themed with textures. This is like a regular [Button] but can be themed by assigning textures to it. This button is intended to be easy to theme, however a regular button can expand (that uses styleboxes) and still be better if the interface is expect to have internationalization of texts.
		Only the normal texture is required, the others are optional.
*/
type TextureButton struct {
	BaseButton
}

func (o *TextureButton) baseClass() string {
	return "TextureButton"
}

/*

 */
func (o *TextureButton) GetClickMask() *BitMap {
	log.Println("Calling TextureButton.GetClickMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_click_mask", goArguments, "*BitMap")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*BitMap)

	return returnValue

}

/*

 */
func (o *TextureButton) GetDisabledTexture() *Texture {
	log.Println("Calling TextureButton.GetDisabledTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_disabled_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *TextureButton) GetExpand() *bool {
	log.Println("Calling TextureButton.GetExpand()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_expand", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *TextureButton) GetFocusedTexture() *Texture {
	log.Println("Calling TextureButton.GetFocusedTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_focused_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *TextureButton) GetHoverTexture() *Texture {
	log.Println("Calling TextureButton.GetHoverTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_hover_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *TextureButton) GetNormalTexture() *Texture {
	log.Println("Calling TextureButton.GetNormalTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_normal_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *TextureButton) GetPressedTexture() *Texture {
	log.Println("Calling TextureButton.GetPressedTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pressed_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *TextureButton) GetStretchMode() int64 {
	log.Println("Calling TextureButton.GetStretchMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stretch_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *TextureButton) SetClickMask(mask *BitMap) {
	log.Println("Calling TextureButton.SetClickMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_click_mask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureButton) SetDisabledTexture(texture *Texture) {
	log.Println("Calling TextureButton.SetDisabledTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_disabled_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureButton) SetExpand(pExpand *bool) {
	log.Println("Calling TextureButton.SetExpand()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pExpand)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_expand", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureButton) SetFocusedTexture(texture *Texture) {
	log.Println("Calling TextureButton.SetFocusedTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_focused_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureButton) SetHoverTexture(texture *Texture) {
	log.Println("Calling TextureButton.SetHoverTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_hover_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureButton) SetNormalTexture(texture *Texture) {
	log.Println("Calling TextureButton.SetNormalTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_normal_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureButton) SetPressedTexture(texture *Texture) {
	log.Println("Calling TextureButton.SetPressedTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_pressed_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureButton) SetStretchMode(pMode int64) {
	log.Println("Calling TextureButton.SetStretchMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_stretch_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
        TextureButtonImplementer is an interface for TextureButton objects.
        Button that can be themed with textures. This is like a regular [Button] but can be themed by assigning textures to it. This button is intended to be easy to theme, however a regular button can expand (that uses styleboxes) and still be better if the interface is expect to have internationalization of texts.
		Only the normal texture is required, the others are optional.
*/
type TextureButtonImplementer interface {
	BaseButtonImplementer

	GetClickMask() *BitMap

	GetDisabledTexture() *Texture

	GetExpand() *bool

	GetFocusedTexture() *Texture

	GetHoverTexture() *Texture

	GetNormalTexture() *Texture

	GetPressedTexture() *Texture

	GetStretchMode() int64

	SetClickMask(mask *BitMap)

	SetDisabledTexture(texture *Texture)

	SetExpand(pExpand *bool)

	SetFocusedTexture(texture *Texture)

	SetHoverTexture(texture *Texture)

	SetNormalTexture(texture *Texture)

	SetPressedTexture(texture *Texture)

	SetStretchMode(pMode int64)
}

/*
   [ProgressBar] implementation that is easier to theme (by just passing a few textures).
*/
type TextureProgress struct {
	Range
}

func (o *TextureProgress) baseClass() string {
	return "TextureProgress"
}

/*

 */
func (o *TextureProgress) GetFillDegrees() float64 {
	log.Println("Calling TextureProgress.GetFillDegrees()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fill_degrees", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *TextureProgress) GetFillMode() int64 {
	log.Println("Calling TextureProgress.GetFillMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fill_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Returns true if textures are stretched as nine-patches or false otherwise.
*/
func (o *TextureProgress) GetNinePatchStretch() *bool {
	log.Println("Calling TextureProgress.GetNinePatchStretch()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_nine_patch_stretch", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *TextureProgress) GetOverTexture() *Texture {
	log.Println("Calling TextureProgress.GetOverTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_over_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *TextureProgress) GetProgressTexture() *Texture {
	log.Println("Calling TextureProgress.GetProgressTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_progress_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *TextureProgress) GetRadialCenterOffset() *Vector2 {
	log.Println("Calling TextureProgress.GetRadialCenterOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_radial_center_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *TextureProgress) GetRadialInitialAngle() float64 {
	log.Println("Calling TextureProgress.GetRadialInitialAngle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_radial_initial_angle", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return nine-patch texture offset for a given margin (MARGIN_LEFT, MARGIN_TOP, MARGIN_RIGHT, MARGIN_BOTTOM).
*/
func (o *TextureProgress) GetStretchMargin(margin int64) int64 {
	log.Println("Calling TextureProgress.GetStretchMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stretch_margin", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *TextureProgress) GetUnderTexture() *Texture {
	log.Println("Calling TextureProgress.GetUnderTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_under_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *TextureProgress) SetFillDegrees(mode float64) {
	log.Println("Calling TextureProgress.SetFillDegrees()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fill_degrees", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureProgress) SetFillMode(mode int64) {
	log.Println("Calling TextureProgress.SetFillMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fill_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set if textures should be stretched as nine-patches.
*/
func (o *TextureProgress) SetNinePatchStretch(stretch *bool) {
	log.Println("Calling TextureProgress.SetNinePatchStretch()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(stretch)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_nine_patch_stretch", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureProgress) SetOverTexture(tex *Texture) {
	log.Println("Calling TextureProgress.SetOverTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tex)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_over_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureProgress) SetProgressTexture(tex *Texture) {
	log.Println("Calling TextureProgress.SetProgressTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tex)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_progress_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureProgress) SetRadialCenterOffset(mode *Vector2) {
	log.Println("Calling TextureProgress.SetRadialCenterOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_radial_center_offset", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureProgress) SetRadialInitialAngle(mode float64) {
	log.Println("Calling TextureProgress.SetRadialInitialAngle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_radial_initial_angle", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set nine-patch texture offset for a given margin (MARGIN_LEFT, MARGIN_TOP, MARGIN_RIGHT, MARGIN_BOTTOM).
*/
func (o *TextureProgress) SetStretchMargin(margin int64, value int64) {
	log.Println("Calling TextureProgress.SetStretchMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_stretch_margin", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureProgress) SetUnderTexture(tex *Texture) {
	log.Println("Calling TextureProgress.SetUnderTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tex)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_under_texture", goArguments, "")

	log.Println("Got return value!")

}

/*
   TextureProgressImplementer is an interface for TextureProgress objects.
   [ProgressBar] implementation that is easier to theme (by just passing a few textures).
*/
type TextureProgressImplementer interface {
	RangeImplementer

	GetFillDegrees() float64

	GetFillMode() int64

	GetNinePatchStretch() *bool

	GetOverTexture() *Texture

	GetProgressTexture() *Texture

	GetRadialCenterOffset() *Vector2

	GetRadialInitialAngle() float64

	GetStretchMargin(margin int64) int64

	GetUnderTexture() *Texture

	SetFillDegrees(mode float64)

	SetFillMode(mode int64)

	SetNinePatchStretch(stretch *bool)

	SetOverTexture(tex *Texture)

	SetProgressTexture(tex *Texture)

	SetRadialCenterOffset(mode *Vector2)

	SetRadialInitialAngle(mode float64)

	SetStretchMargin(margin int64, value int64)

	SetUnderTexture(tex *Texture)
}

/*
   Control frame that simply draws an assigned texture. It can stretch or not. It's a simple way to just show an image in a UI.
*/
type TextureRect struct {
	Control
}

func (o *TextureRect) baseClass() string {
	return "TextureRect"
}

/*

 */
func (o *TextureRect) GetStretchMode() int64 {
	log.Println("Calling TextureRect.GetStretchMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stretch_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *TextureRect) GetTexture() *Texture {
	log.Println("Calling TextureRect.GetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *TextureRect) HasExpand() *bool {
	log.Println("Calling TextureRect.HasExpand()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_expand", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *TextureRect) SetExpand(enable *bool) {
	log.Println("Calling TextureRect.SetExpand()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_expand", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureRect) SetStretchMode(stretchMode int64) {
	log.Println("Calling TextureRect.SetStretchMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(stretchMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_stretch_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TextureRect) SetTexture(texture *Texture) {
	log.Println("Calling TextureRect.SetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture", goArguments, "")

	log.Println("Got return value!")

}

/*
   TextureRectImplementer is an interface for TextureRect objects.
   Control frame that simply draws an assigned texture. It can stretch or not. It's a simple way to just show an image in a UI.
*/
type TextureRectImplementer interface {
	ControlImplementer

	GetStretchMode() int64

	GetTexture() *Texture

	HasExpand() *bool

	SetExpand(enable *bool)

	SetStretchMode(stretchMode int64)

	SetTexture(texture *Texture)
}

/*
        Theme for skinning controls. Controls can be skinned individually, but for complex applications it's more efficient to just create a global theme that defines everything. This theme can be applied to any [Control], and it and its children will automatically use it.
		Theme resources can be alternatively loaded by writing them in a .theme file, see docs for more info.
*/
type Theme struct {
	Resource
}

func (o *Theme) baseClass() string {
	return "Theme"
}

/*

 */
func (o *Theme) ClearColor(name string, aType string) {
	log.Println("Calling Theme.ClearColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Theme) ClearConstant(name string, aType string) {
	log.Println("Calling Theme.ClearConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_constant", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Theme) ClearFont(name string, aType string) {
	log.Println("Calling Theme.ClearFont()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_font", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Theme) ClearIcon(name string, aType string) {
	log.Println("Calling Theme.ClearIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_icon", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Theme) ClearStylebox(name string, aType string) {
	log.Println("Calling Theme.ClearStylebox()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_stylebox", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Theme) CopyDefaultTheme() {
	log.Println("Calling Theme.CopyDefaultTheme()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "copy_default_theme", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Theme) GetColor(name string, aType string) *Color {
	log.Println("Calling Theme.GetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *Theme) GetColorList(aType string) *PoolStringArray {
	log.Println("Calling Theme.GetColorList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_color_list", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*

 */
func (o *Theme) GetConstant(name string, aType string) int64 {
	log.Println("Calling Theme.GetConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_constant", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Theme) GetConstantList(aType string) *PoolStringArray {
	log.Println("Calling Theme.GetConstantList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_constant_list", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*

 */
func (o *Theme) GetDefaultFont() *Font {
	log.Println("Calling Theme.GetDefaultFont()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_default_font", goArguments, "*Font")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Font)

	return returnValue

}

/*

 */
func (o *Theme) GetFont(name string, aType string) *Font {
	log.Println("Calling Theme.GetFont()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_font", goArguments, "*Font")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Font)

	return returnValue

}

/*

 */
func (o *Theme) GetFontList(aType string) *PoolStringArray {
	log.Println("Calling Theme.GetFontList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_font_list", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*

 */
func (o *Theme) GetIcon(name string, aType string) *Texture {
	log.Println("Calling Theme.GetIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_icon", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *Theme) GetIconList(aType string) *PoolStringArray {
	log.Println("Calling Theme.GetIconList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_icon_list", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*

 */
func (o *Theme) GetStylebox(name string, aType string) *StyleBox {
	log.Println("Calling Theme.GetStylebox()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stylebox", goArguments, "*StyleBox")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*StyleBox)

	return returnValue

}

/*

 */
func (o *Theme) GetStyleboxList(aType string) *PoolStringArray {
	log.Println("Calling Theme.GetStyleboxList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stylebox_list", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*

 */
func (o *Theme) GetStyleboxTypes() *PoolStringArray {
	log.Println("Calling Theme.GetStyleboxTypes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stylebox_types", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*

 */
func (o *Theme) GetTypeList(aType string) *PoolStringArray {
	log.Println("Calling Theme.GetTypeList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_type_list", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*

 */
func (o *Theme) HasColor(name string, aType string) *bool {
	log.Println("Calling Theme.HasColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_color", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Theme) HasConstant(name string, aType string) *bool {
	log.Println("Calling Theme.HasConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_constant", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Theme) HasFont(name string, aType string) *bool {
	log.Println("Calling Theme.HasFont()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_font", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Theme) HasIcon(name string, aType string) *bool {
	log.Println("Calling Theme.HasIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_icon", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Theme) HasStylebox(name string, aType string) *bool {
	log.Println("Calling Theme.HasStylebox()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_stylebox", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Theme) SetColor(name string, aType string, color *Color) {
	log.Println("Calling Theme.SetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)
	goArguments[2] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Theme) SetConstant(name string, aType string, constant int64) {
	log.Println("Calling Theme.SetConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)
	goArguments[2] = reflect.ValueOf(constant)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_constant", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Theme) SetDefaultFont(font *Font) {
	log.Println("Calling Theme.SetDefaultFont()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(font)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_default_font", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Theme) SetFont(name string, aType string, font *Font) {
	log.Println("Calling Theme.SetFont()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)
	goArguments[2] = reflect.ValueOf(font)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_font", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Theme) SetIcon(name string, aType string, texture *Texture) {
	log.Println("Calling Theme.SetIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)
	goArguments[2] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_icon", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Theme) SetStylebox(name string, aType string, texture *StyleBox) {
	log.Println("Calling Theme.SetStylebox()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)
	goArguments[2] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_stylebox", goArguments, "")

	log.Println("Got return value!")

}

/*
        ThemeImplementer is an interface for Theme objects.
        Theme for skinning controls. Controls can be skinned individually, but for complex applications it's more efficient to just create a global theme that defines everything. This theme can be applied to any [Control], and it and its children will automatically use it.
		Theme resources can be alternatively loaded by writing them in a .theme file, see docs for more info.
*/
type ThemeImplementer interface {
	ResourceImplementer

	ClearColor(name string, aType string)

	ClearConstant(name string, aType string)

	ClearFont(name string, aType string)

	ClearIcon(name string, aType string)

	ClearStylebox(name string, aType string)

	CopyDefaultTheme()

	GetColor(name string, aType string) *Color

	GetColorList(aType string) *PoolStringArray

	GetConstant(name string, aType string) int64

	GetConstantList(aType string) *PoolStringArray

	GetDefaultFont() *Font

	GetFont(name string, aType string) *Font

	GetFontList(aType string) *PoolStringArray

	GetIcon(name string, aType string) *Texture

	GetIconList(aType string) *PoolStringArray

	GetStylebox(name string, aType string) *StyleBox

	GetStyleboxList(aType string) *PoolStringArray

	GetStyleboxTypes() *PoolStringArray

	GetTypeList(aType string) *PoolStringArray

	HasColor(name string, aType string) *bool

	HasConstant(name string, aType string) *bool

	HasFont(name string, aType string) *bool

	HasIcon(name string, aType string) *bool

	HasStylebox(name string, aType string) *bool

	SetColor(name string, aType string, color *Color)

	SetConstant(name string, aType string, constant int64)

	SetDefaultFont(font *Font)

	SetFont(name string, aType string, font *Font)

	SetIcon(name string, aType string, texture *Texture)

	SetStylebox(name string, aType string, texture *StyleBox)
}

/*
   A unit of execution in a process. Can run methods on [Object]\ s simultaneously. The use of synchronization via [Mutex], [Semaphore] is advised if working with shared objects.
*/
type Thread struct {
	Reference
}

func (o *Thread) baseClass() string {
	return "Thread"
}

/*
   Return the id of the thread, uniquely identifying it among all threads.
*/
func (o *Thread) GetId() string {
	log.Println("Calling Thread.GetId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_id", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Whether this thread is currently active, an active Thread cannot start work on a new method but can be joined with [method wait_to_finish].
*/
func (o *Thread) IsActive() *bool {
	log.Println("Calling Thread.IsActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_active", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
                Start a new [Thread], it will run "method" on object "instance" using "userdata" as an argument and running with "priority", one of PRIORITY_* enum.
				Returns OK on success, or ERR_CANT_CREATE on failure.
*/
func (o *Thread) Start(instance *Object, method string, userdata *Variant, priority int64) int64 {
	log.Println("Calling Thread.Start()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(instance)
	goArguments[1] = reflect.ValueOf(method)
	goArguments[2] = reflect.ValueOf(userdata)
	goArguments[3] = reflect.ValueOf(priority)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "start", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Joins the [Thread] and waits for it to finish. Returns what the method called returned.
*/
func (o *Thread) WaitToFinish() *Variant {
	log.Println("Calling Thread.WaitToFinish()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "wait_to_finish", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   ThreadImplementer is an interface for Thread objects.
   A unit of execution in a process. Can run methods on [Object]\ s simultaneously. The use of synchronization via [Mutex], [Semaphore] is advised if working with shared objects.
*/
type ThreadImplementer interface {
	ReferenceImplementer

	GetId() string

	IsActive() *bool

	Start(instance *Object, method string, userdata *Variant, priority int64) int64

	WaitToFinish() *Variant
}

/*
        Node for 2D tile-based games. Tilemaps use a [TileSet] which contain a list of tiles (textures, their rect and a collision) and are used to create complex grid-based maps.
		To optimize drawing and culling (sort of like [GridMap]), you can specify a quadrant size, so chunks of the map will be batched together at drawing time.
*/
type TileMap struct {
	Node2D
}

func (o *TileMap) baseClass() string {
	return "TileMap"
}

/*
   Clear all cells.
*/
func (o *TileMap) Clear() {
	log.Println("Calling TileMap.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the tile index of the referenced cell.
*/
func (o *TileMap) GetCell(x int64, y int64) int64 {
	log.Println("Calling TileMap.GetCell()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(x)
	goArguments[1] = reflect.ValueOf(y)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cell", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the cell size.
*/
func (o *TileMap) GetCellSize() *Vector2 {
	log.Println("Calling TileMap.GetCellSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cell_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the tile index of the cell referenced by a Vector2.
*/
func (o *TileMap) GetCellv(pos *Vector2) int64 {
	log.Println("Calling TileMap.GetCellv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pos)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cellv", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return true if tiles are to be centered in x coordinate (by default this is false and they are drawn from upper left cell corner).
*/
func (o *TileMap) GetCenterX() *bool {
	log.Println("Calling TileMap.GetCenterX()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_center_x", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if tiles are to be centered in y coordinate (by default this is false and they are drawn from upper left cell corner).
*/
func (o *TileMap) GetCenterY() *bool {
	log.Println("Calling TileMap.GetCenterY()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_center_y", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return the collision bounce parameter.
*/
func (o *TileMap) GetCollisionBounce() float64 {
	log.Println("Calling TileMap.GetCollisionBounce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_bounce", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the collision friction parameter.
*/
func (o *TileMap) GetCollisionFriction() float64 {
	log.Println("Calling TileMap.GetCollisionFriction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_friction", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the collision layer.
*/
func (o *TileMap) GetCollisionLayer() int64 {
	log.Println("Calling TileMap.GetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_layer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *TileMap) GetCollisionLayerBit(bit int64) *bool {
	log.Println("Calling TileMap.GetCollisionLayerBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bit)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_layer_bit", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return the collision mask.
*/
func (o *TileMap) GetCollisionMask() int64 {
	log.Println("Calling TileMap.GetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *TileMap) GetCollisionMaskBit(bit int64) *bool {
	log.Println("Calling TileMap.GetCollisionMaskBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bit)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_mask_bit", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether the tilemap handles collisions as a kinematic body.
*/
func (o *TileMap) GetCollisionUseKinematic() *bool {
	log.Println("Calling TileMap.GetCollisionUseKinematic()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_collision_use_kinematic", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return the custom transform matrix.
*/
func (o *TileMap) GetCustomTransform() *Transform2D {
	log.Println("Calling TileMap.GetCustomTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_custom_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Return the current half offset configuration.
*/
func (o *TileMap) GetHalfOffset() int64 {
	log.Println("Calling TileMap.GetHalfOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_half_offset", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the orientation mode.
*/
func (o *TileMap) GetMode() int64 {
	log.Println("Calling TileMap.GetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *TileMap) GetOccluderLightMask() int64 {
	log.Println("Calling TileMap.GetOccluderLightMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_occluder_light_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the quadrant size.
*/
func (o *TileMap) GetQuadrantSize() int64 {
	log.Println("Calling TileMap.GetQuadrantSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_quadrant_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the tile origin configuration.
*/
func (o *TileMap) GetTileOrigin() int64 {
	log.Println("Calling TileMap.GetTileOrigin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tile_origin", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the current tileset.
*/
func (o *TileMap) GetTileset() *TileSet {
	log.Println("Calling TileMap.GetTileset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tileset", goArguments, "*TileSet")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*TileSet)

	return returnValue

}

/*
   Return an array of all cells containing a tile from the tileset (i.e. a tile index different from -1).
*/
func (o *TileMap) GetUsedCells() *Array {
	log.Println("Calling TileMap.GetUsedCells()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_used_cells", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *TileMap) GetUsedCellsById(id int64) *Array {
	log.Println("Calling TileMap.GetUsedCellsById()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_used_cells_by_id", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*

 */
func (o *TileMap) GetUsedRect() *Rect2 {
	log.Println("Calling TileMap.GetUsedRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_used_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   Return whether the referenced cell is transposed, i.e. the X and Y axes are swapped (mirroring with regard to the (1,1) vector).
*/
func (o *TileMap) IsCellTransposed(x int64, y int64) *bool {
	log.Println("Calling TileMap.IsCellTransposed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(x)
	goArguments[1] = reflect.ValueOf(y)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_cell_transposed", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether the referenced cell is flipped over the X axis.
*/
func (o *TileMap) IsCellXFlipped(x int64, y int64) *bool {
	log.Println("Calling TileMap.IsCellXFlipped()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(x)
	goArguments[1] = reflect.ValueOf(y)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_cell_x_flipped", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether the referenced cell is flipped over the Y axis.
*/
func (o *TileMap) IsCellYFlipped(x int64, y int64) *bool {
	log.Println("Calling TileMap.IsCellYFlipped()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(x)
	goArguments[1] = reflect.ValueOf(y)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_cell_y_flipped", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return the Y sort mode.
*/
func (o *TileMap) IsYSortModeEnabled() *bool {
	log.Println("Calling TileMap.IsYSortModeEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_y_sort_mode_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
                Return the absolute world position corresponding to the tilemap (grid-based) coordinates given as an argument.
				Optionally, the tilemap's potential half offset can be ignored.
*/
func (o *TileMap) MapToWorld(mappos *Vector2, ignoreHalfOfs *bool) *Vector2 {
	log.Println("Calling TileMap.MapToWorld()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(mappos)
	goArguments[1] = reflect.ValueOf(ignoreHalfOfs)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "map_to_world", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
                Set the tile index for the cell referenced by its grid-based X and Y coordinates.
				A tile index of -1 clears the cell.
				Optionally, the tile can also be flipped over the X and Y coordinates or transposed.
*/
func (o *TileMap) SetCell(x int64, y int64, tile int64, flipX *bool, flipY *bool, transpose *bool) {
	log.Println("Calling TileMap.SetCell()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 6, 6)
	goArguments[0] = reflect.ValueOf(x)
	goArguments[1] = reflect.ValueOf(y)
	goArguments[2] = reflect.ValueOf(tile)
	goArguments[3] = reflect.ValueOf(flipX)
	goArguments[4] = reflect.ValueOf(flipY)
	goArguments[5] = reflect.ValueOf(transpose)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cell", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the cell size.
*/
func (o *TileMap) SetCellSize(size *Vector2) {
	log.Println("Calling TileMap.SetCellSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cell_size", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set the tile index for the cell referenced by a Vector2 of grid-based coordinates.
				A tile index of -1 clears the cell.
				Optionally, the tile can also be flipped over the X and Y axes or transposed.
*/
func (o *TileMap) SetCellv(pos *Vector2, tile int64, flipX *bool, flipY *bool, transpose *bool) {
	log.Println("Calling TileMap.SetCellv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(pos)
	goArguments[1] = reflect.ValueOf(tile)
	goArguments[2] = reflect.ValueOf(flipX)
	goArguments[3] = reflect.ValueOf(flipY)
	goArguments[4] = reflect.ValueOf(transpose)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cellv", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set tiles to be centered in x coordinate. (by default this is false and they are drawn from upper left cell corner).
*/
func (o *TileMap) SetCenterX(enable *bool) {
	log.Println("Calling TileMap.SetCenterX()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_center_x", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set tiles to be centered in y coordinate. (by default this is false and they are drawn from upper left cell corner).
*/
func (o *TileMap) SetCenterY(enable *bool) {
	log.Println("Calling TileMap.SetCenterY()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_center_y", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the collision bounce parameter. Allowable values range from 0 to 1.
*/
func (o *TileMap) SetCollisionBounce(value float64) {
	log.Println("Calling TileMap.SetCollisionBounce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_bounce", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the collision friction parameter. Allowable values range from 0 to 1.
*/
func (o *TileMap) SetCollisionFriction(value float64) {
	log.Println("Calling TileMap.SetCollisionFriction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_friction", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set the collision layer.
				Layers are referenced by binary indexes, so allowable values to describe the 20 available layers range from 0 to 2^20-1.
*/
func (o *TileMap) SetCollisionLayer(layer int64) {
	log.Println("Calling TileMap.SetCollisionLayer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(layer)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TileMap) SetCollisionLayerBit(bit int64, value *bool) {
	log.Println("Calling TileMap.SetCollisionLayerBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(bit)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_layer_bit", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set the collision masks.
				Masks are referenced by binary indexes, so allowable values to describe the 20 available masks range from 0 to 2^20-1.
*/
func (o *TileMap) SetCollisionMask(mask int64) {
	log.Println("Calling TileMap.SetCollisionMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_mask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TileMap) SetCollisionMaskBit(bit int64, value *bool) {
	log.Println("Calling TileMap.SetCollisionMaskBit()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(bit)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_mask_bit", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the tilemap to handle collisions as a kinematic body (enabled) or a static body (disabled).
*/
func (o *TileMap) SetCollisionUseKinematic(useKinematic *bool) {
	log.Println("Calling TileMap.SetCollisionUseKinematic()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(useKinematic)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collision_use_kinematic", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set custom transform matrix, to use in combination with the custom orientation mode.
*/
func (o *TileMap) SetCustomTransform(customTransform *Transform2D) {
	log.Println("Calling TileMap.SetCustomTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(customTransform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_custom_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set a half offset on the X coordinate, Y coordinate, or none (use HALF_OFFSET_* constants as argument).
				Half offset sets every other tile off by a half tile size in the specified direction.
*/
func (o *TileMap) SetHalfOffset(halfOffset int64) {
	log.Println("Calling TileMap.SetHalfOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(halfOffset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_half_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the orientation mode as square, isometric or custom (use MODE_* constants as argument).
*/
func (o *TileMap) SetMode(mode int64) {
	log.Println("Calling TileMap.SetMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TileMap) SetOccluderLightMask(mask int64) {
	log.Println("Calling TileMap.SetOccluderLightMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_occluder_light_mask", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set the quadrant size, this optimizes drawing by batching chunks of map at draw/cull time.
				Allowed values are integers ranging from 1 to 128.
*/
func (o *TileMap) SetQuadrantSize(size int64) {
	log.Println("Calling TileMap.SetQuadrantSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_quadrant_size", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the tile origin to the tile center or its top-left corner (use TILE_ORIGIN_* constants as argument).
*/
func (o *TileMap) SetTileOrigin(origin int64) {
	log.Println("Calling TileMap.SetTileOrigin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(origin)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tile_origin", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the current tileset.
*/
func (o *TileMap) SetTileset(tileset *TileSet) {
	log.Println("Calling TileMap.SetTileset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tileset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tileset", goArguments, "")

	log.Println("Got return value!")

}

/*
                Set the Y sort mode. Enabled Y sort mode means that children of the tilemap will be drawn in the order defined by their Y coordinate.
				A tile with a higher Y coordinate will therefore be drawn later, potentially covering up the tile(s) above it if its sprite is higher than its cell size.
*/
func (o *TileMap) SetYSortMode(enable *bool) {
	log.Println("Calling TileMap.SetYSortMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_y_sort_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the tilemap (grid-based) coordinates corresponding to the absolute world position given as an argument.
*/
func (o *TileMap) WorldToMap(worldpos *Vector2) *Vector2 {
	log.Println("Calling TileMap.WorldToMap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(worldpos)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "world_to_map", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
        TileMapImplementer is an interface for TileMap objects.
        Node for 2D tile-based games. Tilemaps use a [TileSet] which contain a list of tiles (textures, their rect and a collision) and are used to create complex grid-based maps.
		To optimize drawing and culling (sort of like [GridMap]), you can specify a quadrant size, so chunks of the map will be batched together at drawing time.
*/
type TileMapImplementer interface {
	Node2DImplementer

	Clear()

	GetCell(x int64, y int64) int64

	GetCellSize() *Vector2

	GetCellv(pos *Vector2) int64

	GetCenterX() *bool

	GetCenterY() *bool

	GetCollisionBounce() float64

	GetCollisionFriction() float64

	GetCollisionLayer() int64

	GetCollisionLayerBit(bit int64) *bool

	GetCollisionMask() int64

	GetCollisionMaskBit(bit int64) *bool

	GetCollisionUseKinematic() *bool

	GetCustomTransform() *Transform2D

	GetHalfOffset() int64

	GetMode() int64

	GetOccluderLightMask() int64

	GetQuadrantSize() int64

	GetTileOrigin() int64

	GetTileset() *TileSet

	GetUsedCells() *Array

	GetUsedCellsById(id int64) *Array

	GetUsedRect() *Rect2

	IsCellTransposed(x int64, y int64) *bool

	IsCellXFlipped(x int64, y int64) *bool

	IsCellYFlipped(x int64, y int64) *bool

	IsYSortModeEnabled() *bool

	MapToWorld(mappos *Vector2, ignoreHalfOfs *bool) *Vector2

	SetCell(x int64, y int64, tile int64, flipX *bool, flipY *bool, transpose *bool)

	SetCellSize(size *Vector2)

	SetCellv(pos *Vector2, tile int64, flipX *bool, flipY *bool, transpose *bool)

	SetCenterX(enable *bool)

	SetCenterY(enable *bool)

	SetCollisionBounce(value float64)

	SetCollisionFriction(value float64)

	SetCollisionLayer(layer int64)

	SetCollisionLayerBit(bit int64, value *bool)

	SetCollisionMask(mask int64)

	SetCollisionMaskBit(bit int64, value *bool)

	SetCollisionUseKinematic(useKinematic *bool)

	SetCustomTransform(customTransform *Transform2D)

	SetHalfOffset(halfOffset int64)

	SetMode(mode int64)

	SetOccluderLightMask(mask int64)

	SetQuadrantSize(size int64)

	SetTileOrigin(origin int64)

	SetTileset(tileset *TileSet)

	SetYSortMode(enable *bool)

	WorldToMap(worldpos *Vector2) *Vector2
}

/*
        A TileSet is a library of tiles for a [TileMap]. It contains a list of tiles, each consisting of a sprite and optional collision shapes.
		Tiles are referenced by a unique integer ID.
*/
type TileSet struct {
	Resource
}

func (o *TileSet) baseClass() string {
	return "TileSet"
}

/*
   Clear all tiles.
*/
func (o *TileSet) Clear() {
	log.Println("Calling TileSet.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Create a new tile which will be referenced by the given ID.
*/
func (o *TileSet) CreateTile(id int64) {
	log.Println("Calling TileSet.CreateTile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "create_tile", goArguments, "")

	log.Println("Got return value!")

}

/*
   Find the first tile matching the given name.
*/
func (o *TileSet) FindTileByName(name string) int64 {
	log.Println("Calling TileSet.FindTileByName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "find_tile_by_name", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the ID following the last currently used ID, useful when creating a new tile.
*/
func (o *TileSet) GetLastUnusedTileId() int64 {
	log.Println("Calling TileSet.GetLastUnusedTileId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_last_unused_tile_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return an array of all currently used tile IDs.
*/
func (o *TileSet) GetTilesIds() *Array {
	log.Println("Calling TileSet.GetTilesIds()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tiles_ids", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Remove the tile referenced by the given ID.
*/
func (o *TileSet) RemoveTile(id int64) {
	log.Println("Calling TileSet.RemoveTile()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_tile", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TileSet) TileAddShape(id int64, shape *Shape2D, shapeTransform *Transform2D, oneWay *bool) {
	log.Println("Calling TileSet.TileAddShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(shape)
	goArguments[2] = reflect.ValueOf(shapeTransform)
	goArguments[3] = reflect.ValueOf(oneWay)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_add_shape", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the light occluder of the tile.
*/
func (o *TileSet) TileGetLightOccluder(id int64) *OccluderPolygon2D {
	log.Println("Calling TileSet.TileGetLightOccluder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_light_occluder", goArguments, "*OccluderPolygon2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*OccluderPolygon2D)

	return returnValue

}

/*
   Return the material of the tile.
*/
func (o *TileSet) TileGetMaterial(id int64) *ShaderMaterial {
	log.Println("Calling TileSet.TileGetMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_material", goArguments, "*ShaderMaterial")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*ShaderMaterial)

	return returnValue

}

/*
   Return the name of the tile.
*/
func (o *TileSet) TileGetName(id int64) string {
	log.Println("Calling TileSet.TileGetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return the navigation polygon of the tile.
*/
func (o *TileSet) TileGetNavigationPolygon(id int64) *NavigationPolygon {
	log.Println("Calling TileSet.TileGetNavigationPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_navigation_polygon", goArguments, "*NavigationPolygon")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NavigationPolygon)

	return returnValue

}

/*
   Return the offset of the tile's navigation polygon.
*/
func (o *TileSet) TileGetNavigationPolygonOffset(id int64) *Vector2 {
	log.Println("Calling TileSet.TileGetNavigationPolygonOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_navigation_polygon_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *TileSet) TileGetNormalMap(id int64) *Texture {
	log.Println("Calling TileSet.TileGetNormalMap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_normal_map", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   Return the offset of the tile's light occluder.
*/
func (o *TileSet) TileGetOccluderOffset(id int64) *Vector2 {
	log.Println("Calling TileSet.TileGetOccluderOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_occluder_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Return the tile sub-region in the texture.
*/
func (o *TileSet) TileGetRegion(id int64) *Rect2 {
	log.Println("Calling TileSet.TileGetRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_region", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*

 */
func (o *TileSet) TileGetShape(id int64, shapeId int64) *Shape2D {
	log.Println("Calling TileSet.TileGetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(shapeId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_shape", goArguments, "*Shape2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Shape2D)

	return returnValue

}

/*

 */
func (o *TileSet) TileGetShapeCount(id int64) int64 {
	log.Println("Calling TileSet.TileGetShapeCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_shape_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *TileSet) TileGetShapeOneWay(id int64, shapeId int64) *bool {
	log.Println("Calling TileSet.TileGetShapeOneWay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(shapeId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_shape_one_way", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *TileSet) TileGetShapeTransform(id int64, shapeId int64) *Transform2D {
	log.Println("Calling TileSet.TileGetShapeTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(shapeId)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_shape_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Return the array of shapes of the tile.
*/
func (o *TileSet) TileGetShapes(id int64) *Array {
	log.Println("Calling TileSet.TileGetShapes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_shapes", goArguments, "*Array")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Array)

	return returnValue

}

/*
   Return the texture of the tile.
*/
func (o *TileSet) TileGetTexture(id int64) *Texture {
	log.Println("Calling TileSet.TileGetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   Return the texture offset of the tile.
*/
func (o *TileSet) TileGetTextureOffset(id int64) *Vector2 {
	log.Println("Calling TileSet.TileGetTextureOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tile_get_texture_offset", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Set a light occluder for the tile.
*/
func (o *TileSet) TileSetLightOccluder(id int64, lightOccluder *OccluderPolygon2D) {
	log.Println("Calling TileSet.TileSetLightOccluder()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(lightOccluder)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_set_light_occluder", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the material of the tile.
*/
func (o *TileSet) TileSetMaterial(id int64, material *ShaderMaterial) {
	log.Println("Calling TileSet.TileSetMaterial()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(material)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_set_material", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the name of the tile, for descriptive purposes.
*/
func (o *TileSet) TileSetName(id int64, name string) {
	log.Println("Calling TileSet.TileSetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_set_name", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set a navigation polygon for the tile.
*/
func (o *TileSet) TileSetNavigationPolygon(id int64, navigationPolygon *NavigationPolygon) {
	log.Println("Calling TileSet.TileSetNavigationPolygon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(navigationPolygon)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_set_navigation_polygon", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set an offset for the tile's navigation polygon.
*/
func (o *TileSet) TileSetNavigationPolygonOffset(id int64, navigationPolygonOffset *Vector2) {
	log.Println("Calling TileSet.TileSetNavigationPolygonOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(navigationPolygonOffset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_set_navigation_polygon_offset", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TileSet) TileSetNormalMap(id int64, normalMap *Texture) {
	log.Println("Calling TileSet.TileSetNormalMap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(normalMap)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_set_normal_map", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set an offset for the tile's light occluder.
*/
func (o *TileSet) TileSetOccluderOffset(id int64, occluderOffset *Vector2) {
	log.Println("Calling TileSet.TileSetOccluderOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(occluderOffset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_set_occluder_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the tile sub-region in the texture. This is common in texture atlases.
*/
func (o *TileSet) TileSetRegion(id int64, region *Rect2) {
	log.Println("Calling TileSet.TileSetRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(region)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_set_region", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TileSet) TileSetShape(id int64, shapeId int64, shape *Shape2D) {
	log.Println("Calling TileSet.TileSetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(shapeId)
	goArguments[2] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_set_shape", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TileSet) TileSetShapeOneWay(id int64, shapeId int64, oneWay *bool) {
	log.Println("Calling TileSet.TileSetShapeOneWay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(shapeId)
	goArguments[2] = reflect.ValueOf(oneWay)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_set_shape_one_way", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TileSet) TileSetShapeTransform(id int64, shapeId int64, shapeTransform *Transform2D) {
	log.Println("Calling TileSet.TileSetShapeTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(shapeId)
	goArguments[2] = reflect.ValueOf(shapeTransform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_set_shape_transform", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set an array of shapes for the tile, enabling physics to collide with it.
*/
func (o *TileSet) TileSetShapes(id int64, shapes *Array) {
	log.Println("Calling TileSet.TileSetShapes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(shapes)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_set_shapes", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the texture of the tile.
*/
func (o *TileSet) TileSetTexture(id int64, texture *Texture) {
	log.Println("Calling TileSet.TileSetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_set_texture", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the texture offset of the tile.
*/
func (o *TileSet) TileSetTextureOffset(id int64, textureOffset *Vector2) {
	log.Println("Calling TileSet.TileSetTextureOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(id)
	goArguments[1] = reflect.ValueOf(textureOffset)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "tile_set_texture_offset", goArguments, "")

	log.Println("Got return value!")

}

/*
        TileSetImplementer is an interface for TileSet objects.
        A TileSet is a library of tiles for a [TileMap]. It contains a list of tiles, each consisting of a sprite and optional collision shapes.
		Tiles are referenced by a unique integer ID.
*/
type TileSetImplementer interface {
	ResourceImplementer

	Clear()

	CreateTile(id int64)

	FindTileByName(name string) int64

	GetLastUnusedTileId() int64

	GetTilesIds() *Array

	RemoveTile(id int64)

	TileAddShape(id int64, shape *Shape2D, shapeTransform *Transform2D, oneWay *bool)

	TileGetLightOccluder(id int64) *OccluderPolygon2D

	TileGetMaterial(id int64) *ShaderMaterial

	TileGetName(id int64) string

	TileGetNavigationPolygon(id int64) *NavigationPolygon

	TileGetNavigationPolygonOffset(id int64) *Vector2

	TileGetNormalMap(id int64) *Texture

	TileGetOccluderOffset(id int64) *Vector2

	TileGetRegion(id int64) *Rect2

	TileGetShape(id int64, shapeId int64) *Shape2D

	TileGetShapeCount(id int64) int64

	TileGetShapeOneWay(id int64, shapeId int64) *bool

	TileGetShapeTransform(id int64, shapeId int64) *Transform2D

	TileGetShapes(id int64) *Array

	TileGetTexture(id int64) *Texture

	TileGetTextureOffset(id int64) *Vector2

	TileSetLightOccluder(id int64, lightOccluder *OccluderPolygon2D)

	TileSetMaterial(id int64, material *ShaderMaterial)

	TileSetName(id int64, name string)

	TileSetNavigationPolygon(id int64, navigationPolygon *NavigationPolygon)

	TileSetNavigationPolygonOffset(id int64, navigationPolygonOffset *Vector2)

	TileSetNormalMap(id int64, normalMap *Texture)

	TileSetOccluderOffset(id int64, occluderOffset *Vector2)

	TileSetRegion(id int64, region *Rect2)

	TileSetShape(id int64, shapeId int64, shape *Shape2D)

	TileSetShapeOneWay(id int64, shapeId int64, oneWay *bool)

	TileSetShapeTransform(id int64, shapeId int64, shapeTransform *Transform2D)

	TileSetShapes(id int64, shapes *Array)

	TileSetTexture(id int64, texture *Texture)

	TileSetTextureOffset(id int64, textureOffset *Vector2)
}

/*
   Timer node. This is a simple node that will emit a timeout callback when the timer runs out. It can optionally be set to loop.
*/
type Timer struct {
	Node
}

func (o *Timer) baseClass() string {
	return "Timer"
}

/*
   Return the time left for timeout in seconds if the timer is active, 0 otherwise.
*/
func (o *Timer) GetTimeLeft() float64 {
	log.Println("Calling Timer.GetTimeLeft()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_time_left", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the timer's processing mode.
*/
func (o *Timer) GetTimerProcessMode() int64 {
	log.Println("Calling Timer.GetTimerProcessMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_timer_process_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the wait time in seconds.
*/
func (o *Timer) GetWaitTime() float64 {
	log.Println("Calling Timer.GetWaitTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_wait_time", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return true if set to automatically start when entering the scene.
*/
func (o *Timer) HasAutostart() *bool {
	log.Println("Calling Timer.HasAutostart()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_autostart", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return true if configured as one-shot.
*/
func (o *Timer) IsOneShot() *bool {
	log.Println("Calling Timer.IsOneShot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_one_shot", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return if the timer is paused or not.
*/
func (o *Timer) IsPaused() *bool {
	log.Println("Calling Timer.IsPaused()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_paused", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Timer) IsStopped() *bool {
	log.Println("Calling Timer.IsStopped()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_stopped", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Set to automatically start when entering the scene.
*/
func (o *Timer) SetAutostart(enable *bool) {
	log.Println("Calling Timer.SetAutostart()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_autostart", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set as one-shot. If enabled, the timer will stop after timeout, otherwise it will automatically restart.
*/
func (o *Timer) SetOneShot(enable *bool) {
	log.Println("Calling Timer.SetOneShot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_one_shot", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether the timer is paused or not. A paused timer will be inactive until it is unpaused again.
*/
func (o *Timer) SetPaused(paused *bool) {
	log.Println("Calling Timer.SetPaused()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(paused)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_paused", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the timer's processing mode (fixed or idle, use TIMER_PROCESS_* constants as argument).
*/
func (o *Timer) SetTimerProcessMode(mode int64) {
	log.Println("Calling Timer.SetTimerProcessMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_timer_process_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set wait time in seconds. When the time is over, it will emit the timeout signal.
*/
func (o *Timer) SetWaitTime(timeSec float64) {
	log.Println("Calling Timer.SetWaitTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(timeSec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_wait_time", goArguments, "")

	log.Println("Got return value!")

}

/*
   Start the timer.
*/
func (o *Timer) Start() {
	log.Println("Calling Timer.Start()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "start", goArguments, "")

	log.Println("Got return value!")

}

/*
   Stop (cancel) the timer.
*/
func (o *Timer) Stop() {
	log.Println("Calling Timer.Stop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "stop", goArguments, "")

	log.Println("Got return value!")

}

/*
   TimerImplementer is an interface for Timer objects.
   Timer node. This is a simple node that will emit a timeout callback when the timer runs out. It can optionally be set to loop.
*/
type TimerImplementer interface {
	NodeImplementer

	GetTimeLeft() float64

	GetTimerProcessMode() int64

	GetWaitTime() float64

	HasAutostart() *bool

	IsOneShot() *bool

	IsPaused() *bool

	IsStopped() *bool

	SetAutostart(enable *bool)

	SetOneShot(enable *bool)

	SetPaused(paused *bool)

	SetTimerProcessMode(mode int64)

	SetWaitTime(timeSec float64)

	Start()

	Stop()
}

/*

 */
type ToolButton struct {
	Button
}

func (o *ToolButton) baseClass() string {
	return "ToolButton"
}

/*
   ToolButtonImplementer is an interface for ToolButton objects.

*/
type ToolButtonImplementer interface {
	ButtonImplementer
}

/*

 */
type TouchScreenButton struct {
	Node2D
}

func (o *TouchScreenButton) baseClass() string {
	return "TouchScreenButton"
}

/*

 */
func (o *TouchScreenButton) GetAction() string {
	log.Println("Calling TouchScreenButton.GetAction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_action", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *TouchScreenButton) GetBitmask() *BitMap {
	log.Println("Calling TouchScreenButton.GetBitmask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_bitmask", goArguments, "*BitMap")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*BitMap)

	return returnValue

}

/*

 */
func (o *TouchScreenButton) GetShape() *Shape2D {
	log.Println("Calling TouchScreenButton.GetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shape", goArguments, "*Shape2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Shape2D)

	return returnValue

}

/*

 */
func (o *TouchScreenButton) GetTexture() *Texture {
	log.Println("Calling TouchScreenButton.GetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *TouchScreenButton) GetTexturePressed() *Texture {
	log.Println("Calling TouchScreenButton.GetTexturePressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture_pressed", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *TouchScreenButton) GetVisibilityMode() int64 {
	log.Println("Calling TouchScreenButton.GetVisibilityMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_visibility_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *TouchScreenButton) IsPassbyPressEnabled() *bool {
	log.Println("Calling TouchScreenButton.IsPassbyPressEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_passby_press_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *TouchScreenButton) IsPressed() *bool {
	log.Println("Calling TouchScreenButton.IsPressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_pressed", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *TouchScreenButton) IsShapeCentered() *bool {
	log.Println("Calling TouchScreenButton.IsShapeCentered()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_shape_centered", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *TouchScreenButton) IsShapeVisible() *bool {
	log.Println("Calling TouchScreenButton.IsShapeVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_shape_visible", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *TouchScreenButton) SetAction(action string) {
	log.Println("Calling TouchScreenButton.SetAction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(action)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_action", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TouchScreenButton) SetBitmask(bitmask *BitMap) {
	log.Println("Calling TouchScreenButton.SetBitmask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bitmask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_bitmask", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TouchScreenButton) SetPassbyPress(enabled *bool) {
	log.Println("Calling TouchScreenButton.SetPassbyPress()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_passby_press", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TouchScreenButton) SetShape(shape *Shape2D) {
	log.Println("Calling TouchScreenButton.SetShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shape", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TouchScreenButton) SetShapeCentered(bool *bool) {
	log.Println("Calling TouchScreenButton.SetShapeCentered()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bool)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shape_centered", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TouchScreenButton) SetShapeVisible(bool *bool) {
	log.Println("Calling TouchScreenButton.SetShapeVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bool)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shape_visible", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TouchScreenButton) SetTexture(texture *Texture) {
	log.Println("Calling TouchScreenButton.SetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TouchScreenButton) SetTexturePressed(texturePressed *Texture) {
	log.Println("Calling TouchScreenButton.SetTexturePressed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texturePressed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_texture_pressed", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TouchScreenButton) SetVisibilityMode(mode int64) {
	log.Println("Calling TouchScreenButton.SetVisibilityMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_visibility_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   TouchScreenButtonImplementer is an interface for TouchScreenButton objects.

*/
type TouchScreenButtonImplementer interface {
	Node2DImplementer

	GetAction() string

	GetBitmask() *BitMap

	GetShape() *Shape2D

	GetTexture() *Texture

	GetTexturePressed() *Texture

	GetVisibilityMode() int64

	IsPassbyPressEnabled() *bool

	IsPressed() *bool

	IsShapeCentered() *bool

	IsShapeVisible() *bool

	SetAction(action string)

	SetBitmask(bitmask *BitMap)

	SetPassbyPress(enabled *bool)

	SetShape(shape *Shape2D)

	SetShapeCentered(bool *bool)

	SetShapeVisible(bool *bool)

	SetTexture(texture *Texture)

	SetTexturePressed(texturePressed *Texture)

	SetVisibilityMode(mode int64)
}

/*
   Translations are resources that can be loaded/unloaded on demand. They map a string to another string.
*/
type Translation struct {
	Resource
}

func (o *Translation) baseClass() string {
	return "Translation"
}

/*
   Add a message for translation.
*/
func (o *Translation) AddMessage(srcMessage string, xlatedMessage string) {
	log.Println("Calling Translation.AddMessage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(srcMessage)
	goArguments[1] = reflect.ValueOf(xlatedMessage)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_message", goArguments, "")

	log.Println("Got return value!")

}

/*
   Erase a message.
*/
func (o *Translation) EraseMessage(srcMessage string) {
	log.Println("Calling Translation.EraseMessage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(srcMessage)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "erase_message", goArguments, "")

	log.Println("Got return value!")

}

/*
   Return the locale of the translation.
*/
func (o *Translation) GetLocale() string {
	log.Println("Calling Translation.GetLocale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_locale", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Return a message for translation.
*/
func (o *Translation) GetMessage(srcMessage string) string {
	log.Println("Calling Translation.GetMessage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(srcMessage)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_message", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *Translation) GetMessageCount() int64 {
	log.Println("Calling Translation.GetMessageCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_message_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return all the messages (keys).
*/
func (o *Translation) GetMessageList() *PoolStringArray {
	log.Println("Calling Translation.GetMessageList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_message_list", goArguments, "*PoolStringArray")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PoolStringArray)

	return returnValue

}

/*
   Set the locale of the translation.
*/
func (o *Translation) SetLocale(locale string) {
	log.Println("Calling Translation.SetLocale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(locale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_locale", goArguments, "")

	log.Println("Got return value!")

}

/*
   TranslationImplementer is an interface for Translation objects.
   Translations are resources that can be loaded/unloaded on demand. They map a string to another string.
*/
type TranslationImplementer interface {
	ResourceImplementer

	AddMessage(srcMessage string, xlatedMessage string)

	EraseMessage(srcMessage string)

	GetLocale() string

	GetMessage(srcMessage string) string

	GetMessageCount() int64

	GetMessageList() *PoolStringArray

	SetLocale(locale string)
}

/*

 */
type TranslationServer struct {
	Object
}

func (o *TranslationServer) baseClass() string {
	return "TranslationServer"
}

/*

 */
func (o *TranslationServer) AddTranslation(translation *Translation) {
	log.Println("Calling TranslationServer.AddTranslation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(translation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_translation", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TranslationServer) Clear() {
	log.Println("Calling TranslationServer.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TranslationServer) GetLocale() string {
	log.Println("Calling TranslationServer.GetLocale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_locale", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *TranslationServer) RemoveTranslation(translation *Translation) {
	log.Println("Calling TranslationServer.RemoveTranslation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(translation)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_translation", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TranslationServer) SetLocale(locale string) {
	log.Println("Calling TranslationServer.SetLocale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(locale)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_locale", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TranslationServer) Translate(message string) string {
	log.Println("Calling TranslationServer.Translate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(message)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "translate", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   TranslationServerImplementer is an interface for TranslationServer objects.

*/
type TranslationServerImplementer interface {
	ObjectImplementer

	AddTranslation(translation *Translation)

	Clear()

	GetLocale() string

	RemoveTranslation(translation *Translation)

	SetLocale(locale string)

	Translate(message string) string
}

/*
        This shows a tree of items that can be selected, expanded and collapsed. The tree can have multiple columns with custom controls like text editing, buttons and popups. It can be useful for structural displaying and interactions.
		Trees are built via code, using [TreeItem] objects to create the structure. They have a single root but multiple root can be simulated if a dummy hidden root is added.
		[codeblock]
		func _ready():
		    var tree = Tree.new()
		    var root = tree.create_item()
		    tree.set_hide_root(true)
		    var child1 = tree.create_item(root)
		    var child2 = tree.create_item(root)
		    var subchild1 = tree.create_item(child1)
		    subchild1.set_text(0, "Subchild1")
		[/codeblock]
*/
type Tree struct {
	Control
}

func (o *Tree) baseClass() string {
	return "Tree"
}

/*
   Get whether the column titles are being shown.
*/
func (o *Tree) AreColumnTitlesVisible() *bool {
	log.Println("Calling Tree.AreColumnTitlesVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "are_column_titles_visible", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Clear the tree. This erases all of the items.
*/
func (o *Tree) Clear() {
	log.Println("Calling Tree.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear", goArguments, "")

	log.Println("Got return value!")

}

/*
   Create an item in the tree and add it as the last child of [code]parent[/code]. If parent is not given, it will be added as the last child of the root, or it'll the be the root itself if the tree is empty.
*/
func (o *Tree) CreateItem(parent *Object) *Object {
	log.Println("Calling Tree.CreateItem()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(parent)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "create_item", goArguments, "*Object")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Object)

	return returnValue

}

/*
   Make the current selected item visible. This will scroll the tree to make sure the selected item is in sight.
*/
func (o *Tree) EnsureCursorIsVisible() {
	log.Println("Calling Tree.EnsureCursorIsVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "ensure_cursor_is_visible", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Tree) GetAllowReselect() *bool {
	log.Println("Calling Tree.GetAllowReselect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_allow_reselect", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Get whether a right click can select items.
*/
func (o *Tree) GetAllowRmbSelect() *bool {
	log.Println("Calling Tree.GetAllowRmbSelect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_allow_rmb_select", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Get the column index under the given point.
*/
func (o *Tree) GetColumnAtPos(pos *Vector2) int64 {
	log.Println("Calling Tree.GetColumnAtPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pos)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_column_at_pos", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the title of the given column.
*/
func (o *Tree) GetColumnTitle(column int64) string {
	log.Println("Calling Tree.GetColumnTitle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_column_title", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the width of the given column in pixels.
*/
func (o *Tree) GetColumnWidth(column int64) int64 {
	log.Println("Calling Tree.GetColumnWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_column_width", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the amount of columns.
*/
func (o *Tree) GetColumns() int64 {
	log.Println("Calling Tree.GetColumns()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_columns", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the rectangle for custom popups. Helper to create custom cell controls that display a popup. See [method TreeItem.set_cell_mode].
*/
func (o *Tree) GetCustomPopupRect() *Rect2 {
	log.Println("Calling Tree.GetCustomPopupRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_custom_popup_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   Get the flags of the current drop mode.
*/
func (o *Tree) GetDropModeFlags() int64 {
	log.Println("Calling Tree.GetDropModeFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_drop_mode_flags", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the current edited item. This is only available for custom cell mode.
*/
func (o *Tree) GetEdited() *TreeItem {
	log.Println("Calling Tree.GetEdited()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_edited", goArguments, "*TreeItem")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*TreeItem)

	return returnValue

}

/*
   Get the column of the cell for the current edited icon. This is only available for custom cell mode.
*/
func (o *Tree) GetEditedColumn() int64 {
	log.Println("Calling Tree.GetEditedColumn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_edited_column", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the rectangle area of the the specified item. If column is specified, only get the position and size of that column, otherwise get the rectangle containing all columns.
*/
func (o *Tree) GetItemAreaRect(item *Object, column int64) *Rect2 {
	log.Println("Calling Tree.GetItemAreaRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(item)
	goArguments[1] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_area_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   Get the tree item at the specified position (relative to the tree origin position).
*/
func (o *Tree) GetItemAtPos(pos *Vector2) *TreeItem {
	log.Println("Calling Tree.GetItemAtPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pos)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_item_at_pos", goArguments, "*TreeItem")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*TreeItem)

	return returnValue

}

/*
   Get the next selected item after the given one.
*/
func (o *Tree) GetNextSelected(from *Object) *TreeItem {
	log.Println("Calling Tree.GetNextSelected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(from)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_next_selected", goArguments, "*TreeItem")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*TreeItem)

	return returnValue

}

/*
   Get the index of the last pressed button.
*/
func (o *Tree) GetPressedButton() int64 {
	log.Println("Calling Tree.GetPressedButton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_pressed_button", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the root item of the tree.
*/
func (o *Tree) GetRoot() *TreeItem {
	log.Println("Calling Tree.GetRoot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_root", goArguments, "*TreeItem")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*TreeItem)

	return returnValue

}

/*
   Get the current scrolling position.
*/
func (o *Tree) GetScroll() *Vector2 {
	log.Println("Calling Tree.GetScroll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scroll", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Get the currently selected item.
*/
func (o *Tree) GetSelected() *TreeItem {
	log.Println("Calling Tree.GetSelected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_selected", goArguments, "*TreeItem")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*TreeItem)

	return returnValue

}

/*
   Get the column number of the current selection.
*/
func (o *Tree) GetSelectedColumn() int64 {
	log.Println("Calling Tree.GetSelectedColumn()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_selected_column", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get whether the folding arrow is hidden.
*/
func (o *Tree) IsFoldingHidden() *bool {
	log.Println("Calling Tree.IsFoldingHidden()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_folding_hidden", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Tree) SetAllowReselect(allow *bool) {
	log.Println("Calling Tree.SetAllowReselect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(allow)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_allow_reselect", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether or not a right mouse button click can select items.
*/
func (o *Tree) SetAllowRmbSelect(allow *bool) {
	log.Println("Calling Tree.SetAllowRmbSelect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(allow)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_allow_rmb_select", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether a column will have the "Expand" flag of [Control].
*/
func (o *Tree) SetColumnExpand(column int64, expand *bool) {
	log.Println("Calling Tree.SetColumnExpand()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(expand)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_column_expand", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the minimum width of a column.
*/
func (o *Tree) SetColumnMinWidth(column int64, minWidth int64) {
	log.Println("Calling Tree.SetColumnMinWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(minWidth)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_column_min_width", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the title of a column.
*/
func (o *Tree) SetColumnTitle(column int64, title string) {
	log.Println("Calling Tree.SetColumnTitle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(title)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_column_title", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether the column titles visibility.
*/
func (o *Tree) SetColumnTitlesVisible(visible *bool) {
	log.Println("Calling Tree.SetColumnTitlesVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(visible)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_column_titles_visible", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the amount of columns.
*/
func (o *Tree) SetColumns(amount int64) {
	log.Println("Calling Tree.SetColumns()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_columns", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the drop mode as an OR combination of flags. See [code]DROP_MODE_*[/code] constants.
*/
func (o *Tree) SetDropModeFlags(flags int64) {
	log.Println("Calling Tree.SetDropModeFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flags)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_drop_mode_flags", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether the folding arrow should be hidden.
*/
func (o *Tree) SetHideFolding(hide *bool) {
	log.Println("Calling Tree.SetHideFolding()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(hide)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_hide_folding", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether the root of the tree should be hidden.
*/
func (o *Tree) SetHideRoot(enable *bool) {
	log.Println("Calling Tree.SetHideRoot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_hide_root", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the selection mode. Use one of the [code]SELECT_*[/code] constants.
*/
func (o *Tree) SetSelectMode(mode int64) {
	log.Println("Calling Tree.SetSelectMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_select_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
        TreeImplementer is an interface for Tree objects.
        This shows a tree of items that can be selected, expanded and collapsed. The tree can have multiple columns with custom controls like text editing, buttons and popups. It can be useful for structural displaying and interactions.
		Trees are built via code, using [TreeItem] objects to create the structure. They have a single root but multiple root can be simulated if a dummy hidden root is added.
		[codeblock]
		func _ready():
		    var tree = Tree.new()
		    var root = tree.create_item()
		    tree.set_hide_root(true)
		    var child1 = tree.create_item(root)
		    var child2 = tree.create_item(root)
		    var subchild1 = tree.create_item(child1)
		    subchild1.set_text(0, "Subchild1")
		[/codeblock]
*/
type TreeImplementer interface {
	ControlImplementer

	AreColumnTitlesVisible() *bool

	Clear()

	CreateItem(parent *Object) *Object

	EnsureCursorIsVisible()

	GetAllowReselect() *bool

	GetAllowRmbSelect() *bool

	GetColumnAtPos(pos *Vector2) int64

	GetColumnTitle(column int64) string

	GetColumnWidth(column int64) int64

	GetColumns() int64

	GetCustomPopupRect() *Rect2

	GetDropModeFlags() int64

	GetEdited() *TreeItem

	GetEditedColumn() int64

	GetItemAreaRect(item *Object, column int64) *Rect2

	GetItemAtPos(pos *Vector2) *TreeItem

	GetNextSelected(from *Object) *TreeItem

	GetPressedButton() int64

	GetRoot() *TreeItem

	GetScroll() *Vector2

	GetSelected() *TreeItem

	GetSelectedColumn() int64

	IsFoldingHidden() *bool

	SetAllowReselect(allow *bool)

	SetAllowRmbSelect(allow *bool)

	SetColumnExpand(column int64, expand *bool)

	SetColumnMinWidth(column int64, minWidth int64)

	SetColumnTitle(column int64, title string)

	SetColumnTitlesVisible(visible *bool)

	SetColumns(amount int64)

	SetDropModeFlags(flags int64)

	SetHideFolding(hide *bool)

	SetHideRoot(enable *bool)

	SetSelectMode(mode int64)
}

/*

 */
type TreeItem struct {
	Object
}

func (o *TreeItem) baseClass() string {
	return "TreeItem"
}

/*

 */
func (o *TreeItem) AddButton(column int64, button *Texture, buttonIdx int64, disabled *bool, tooltip string) {
	log.Println("Calling TreeItem.AddButton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(button)
	goArguments[2] = reflect.ValueOf(buttonIdx)
	goArguments[3] = reflect.ValueOf(disabled)
	goArguments[4] = reflect.ValueOf(tooltip)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_button", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) ClearCustomBgColor(column int64) {
	log.Println("Calling TreeItem.ClearCustomBgColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_custom_bg_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) ClearCustomColor(column int64) {
	log.Println("Calling TreeItem.ClearCustomColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_custom_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) Deselect(column int64) {
	log.Println("Calling TreeItem.Deselect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "deselect", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) EraseButton(column int64, buttonIdx int64) {
	log.Println("Calling TreeItem.EraseButton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(buttonIdx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "erase_button", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) GetButton(column int64, buttonIdx int64) *Texture {
	log.Println("Calling TreeItem.GetButton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(buttonIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_button", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *TreeItem) GetButtonCount(column int64) int64 {
	log.Println("Calling TreeItem.GetButtonCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_button_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *TreeItem) GetCellMode(column int64) int64 {
	log.Println("Calling TreeItem.GetCellMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_cell_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *TreeItem) GetChildren() *TreeItem {
	log.Println("Calling TreeItem.GetChildren()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_children", goArguments, "*TreeItem")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*TreeItem)

	return returnValue

}

/*

 */
func (o *TreeItem) GetCustomBgColor(column int64) *Color {
	log.Println("Calling TreeItem.GetCustomBgColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_custom_bg_color", goArguments, "*Color")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Color)

	return returnValue

}

/*

 */
func (o *TreeItem) GetExpandRight(column int64) *bool {
	log.Println("Calling TreeItem.GetExpandRight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_expand_right", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *TreeItem) GetIcon(column int64) *Texture {
	log.Println("Calling TreeItem.GetIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_icon", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*

 */
func (o *TreeItem) GetIconMaxWidth(column int64) int64 {
	log.Println("Calling TreeItem.GetIconMaxWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_icon_max_width", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *TreeItem) GetIconRegion(column int64) *Rect2 {
	log.Println("Calling TreeItem.GetIconRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_icon_region", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*

 */
func (o *TreeItem) GetMetadata(column int64) *Variant {
	log.Println("Calling TreeItem.GetMetadata()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_metadata", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *TreeItem) GetNext() *TreeItem {
	log.Println("Calling TreeItem.GetNext()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_next", goArguments, "*TreeItem")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*TreeItem)

	return returnValue

}

/*

 */
func (o *TreeItem) GetNextVisible() *TreeItem {
	log.Println("Calling TreeItem.GetNextVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_next_visible", goArguments, "*TreeItem")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*TreeItem)

	return returnValue

}

/*

 */
func (o *TreeItem) GetParent() *TreeItem {
	log.Println("Calling TreeItem.GetParent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_parent", goArguments, "*TreeItem")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*TreeItem)

	return returnValue

}

/*

 */
func (o *TreeItem) GetPrev() *TreeItem {
	log.Println("Calling TreeItem.GetPrev()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_prev", goArguments, "*TreeItem")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*TreeItem)

	return returnValue

}

/*

 */
func (o *TreeItem) GetPrevVisible() *TreeItem {
	log.Println("Calling TreeItem.GetPrevVisible()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_prev_visible", goArguments, "*TreeItem")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*TreeItem)

	return returnValue

}

/*

 */
func (o *TreeItem) GetRange(column int64) float64 {
	log.Println("Calling TreeItem.GetRange()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_range", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *TreeItem) GetRangeConfig(column int64) *Dictionary {
	log.Println("Calling TreeItem.GetRangeConfig()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_range_config", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*

 */
func (o *TreeItem) GetText(column int64) string {
	log.Println("Calling TreeItem.GetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *TreeItem) GetTextAlign(column int64) int64 {
	log.Println("Calling TreeItem.GetTextAlign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_text_align", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *TreeItem) GetTooltip(column int64) string {
	log.Println("Calling TreeItem.GetTooltip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tooltip", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *TreeItem) IsButtonDisabled(column int64, buttonIdx int64) *bool {
	log.Println("Calling TreeItem.IsButtonDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(buttonIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_button_disabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *TreeItem) IsChecked(column int64) *bool {
	log.Println("Calling TreeItem.IsChecked()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_checked", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *TreeItem) IsCollapsed() *bool {
	log.Println("Calling TreeItem.IsCollapsed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_collapsed", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *TreeItem) IsCustomSetAsButton(column int64) *bool {
	log.Println("Calling TreeItem.IsCustomSetAsButton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_custom_set_as_button", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *TreeItem) IsEditable(column int64) *bool {
	log.Println("Calling TreeItem.IsEditable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_editable", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *TreeItem) IsFoldingDisabled() *bool {
	log.Println("Calling TreeItem.IsFoldingDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_folding_disabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *TreeItem) IsSelectable(column int64) *bool {
	log.Println("Calling TreeItem.IsSelectable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_selectable", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *TreeItem) IsSelected(column int64) *bool {
	log.Println("Calling TreeItem.IsSelected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_selected", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *TreeItem) MoveToBottom() {
	log.Println("Calling TreeItem.MoveToBottom()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "move_to_bottom", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) MoveToTop() {
	log.Println("Calling TreeItem.MoveToTop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "move_to_top", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) RemoveChild(child *Object) {
	log.Println("Calling TreeItem.RemoveChild()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(child)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_child", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) Select(column int64) {
	log.Println("Calling TreeItem.Select()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(column)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "select", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) SetButton(column int64, buttonIdx int64, button *Texture) {
	log.Println("Calling TreeItem.SetButton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(buttonIdx)
	goArguments[2] = reflect.ValueOf(button)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_button", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) SetCellMode(column int64, mode int64) {
	log.Println("Calling TreeItem.SetCellMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_cell_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) SetChecked(column int64, checked *bool) {
	log.Println("Calling TreeItem.SetChecked()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(checked)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_checked", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) SetCollapsed(enable *bool) {
	log.Println("Calling TreeItem.SetCollapsed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_collapsed", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) SetCustomAsButton(column int64, enable *bool) {
	log.Println("Calling TreeItem.SetCustomAsButton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_custom_as_button", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) SetCustomBgColor(column int64, color *Color, justOutline *bool) {
	log.Println("Calling TreeItem.SetCustomBgColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(color)
	goArguments[2] = reflect.ValueOf(justOutline)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_custom_bg_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) SetCustomColor(column int64, color *Color) {
	log.Println("Calling TreeItem.SetCustomColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_custom_color", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) SetCustomDraw(column int64, object *Object, callback string) {
	log.Println("Calling TreeItem.SetCustomDraw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(object)
	goArguments[2] = reflect.ValueOf(callback)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_custom_draw", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) SetDisableFolding(disable *bool) {
	log.Println("Calling TreeItem.SetDisableFolding()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(disable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_disable_folding", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) SetEditable(column int64, enabled *bool) {
	log.Println("Calling TreeItem.SetEditable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_editable", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) SetExpandRight(column int64, enable *bool) {
	log.Println("Calling TreeItem.SetExpandRight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_expand_right", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) SetIcon(column int64, texture *Texture) {
	log.Println("Calling TreeItem.SetIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_icon", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) SetIconMaxWidth(column int64, width int64) {
	log.Println("Calling TreeItem.SetIconMaxWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(width)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_icon_max_width", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) SetIconRegion(column int64, region *Rect2) {
	log.Println("Calling TreeItem.SetIconRegion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(region)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_icon_region", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) SetMetadata(column int64, meta *Variant) {
	log.Println("Calling TreeItem.SetMetadata()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(meta)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_metadata", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) SetRange(column int64, value float64) {
	log.Println("Calling TreeItem.SetRange()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_range", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) SetRangeConfig(column int64, min float64, max float64, step float64, expr *bool) {
	log.Println("Calling TreeItem.SetRangeConfig()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(min)
	goArguments[2] = reflect.ValueOf(max)
	goArguments[3] = reflect.ValueOf(step)
	goArguments[4] = reflect.ValueOf(expr)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_range_config", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) SetSelectable(column int64, selectable *bool) {
	log.Println("Calling TreeItem.SetSelectable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(selectable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_selectable", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) SetText(column int64, text string) {
	log.Println("Calling TreeItem.SetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(text)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_text", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) SetTextAlign(column int64, textAlign int64) {
	log.Println("Calling TreeItem.SetTextAlign()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(textAlign)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_text_align", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *TreeItem) SetTooltip(column int64, tooltip string) {
	log.Println("Calling TreeItem.SetTooltip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(column)
	goArguments[1] = reflect.ValueOf(tooltip)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tooltip", goArguments, "")

	log.Println("Got return value!")

}

/*
   TreeItemImplementer is an interface for TreeItem objects.

*/
type TreeItemImplementer interface {
	ObjectImplementer

	AddButton(column int64, button *Texture, buttonIdx int64, disabled *bool, tooltip string)

	ClearCustomBgColor(column int64)

	ClearCustomColor(column int64)

	Deselect(column int64)

	EraseButton(column int64, buttonIdx int64)

	GetButton(column int64, buttonIdx int64) *Texture

	GetButtonCount(column int64) int64

	GetCellMode(column int64) int64

	GetChildren() *TreeItem

	GetCustomBgColor(column int64) *Color

	GetExpandRight(column int64) *bool

	GetIcon(column int64) *Texture

	GetIconMaxWidth(column int64) int64

	GetIconRegion(column int64) *Rect2

	GetMetadata(column int64) *Variant

	GetNext() *TreeItem

	GetNextVisible() *TreeItem

	GetParent() *TreeItem

	GetPrev() *TreeItem

	GetPrevVisible() *TreeItem

	GetRange(column int64) float64

	GetRangeConfig(column int64) *Dictionary

	GetText(column int64) string

	GetTextAlign(column int64) int64

	GetTooltip(column int64) string

	IsButtonDisabled(column int64, buttonIdx int64) *bool

	IsChecked(column int64) *bool

	IsCollapsed() *bool

	IsCustomSetAsButton(column int64) *bool

	IsEditable(column int64) *bool

	IsFoldingDisabled() *bool

	IsSelectable(column int64) *bool

	IsSelected(column int64) *bool

	MoveToBottom()

	MoveToTop()

	RemoveChild(child *Object)

	Select(column int64)

	SetButton(column int64, buttonIdx int64, button *Texture)

	SetCellMode(column int64, mode int64)

	SetChecked(column int64, checked *bool)

	SetCollapsed(enable *bool)

	SetCustomAsButton(column int64, enable *bool)

	SetCustomBgColor(column int64, color *Color, justOutline *bool)

	SetCustomColor(column int64, color *Color)

	SetCustomDraw(column int64, object *Object, callback string)

	SetDisableFolding(disable *bool)

	SetEditable(column int64, enabled *bool)

	SetExpandRight(column int64, enable *bool)

	SetIcon(column int64, texture *Texture)

	SetIconMaxWidth(column int64, width int64)

	SetIconRegion(column int64, region *Rect2)

	SetMetadata(column int64, meta *Variant)

	SetRange(column int64, value float64)

	SetRangeConfig(column int64, min float64, max float64, step float64, expr *bool)

	SetSelectable(column int64, selectable *bool)

	SetText(column int64, text string)

	SetTextAlign(column int64, textAlign int64)

	SetTooltip(column int64, tooltip string)
}

/*

 */
type TriangleMesh struct {
	Reference
}

func (o *TriangleMesh) baseClass() string {
	return "TriangleMesh"
}

/*
   TriangleMeshImplementer is an interface for TriangleMesh objects.

*/
type TriangleMeshImplementer interface {
	ReferenceImplementer
}

/*
        Node useful for animations with unknown start and end points, procedural animations, making one node follow another, and other simple behavior.
		Because it is easy to get it wrong, here is a quick usage example:
		[codeblock]
		var tween = get_node("Tween")
		tween.interpolate_property(get_node("Node2D_to_move"), "transform/pos", Vector2(0,0), Vector2(100,100), 1, Tween.TRANS_LINEAR, Tween.EASE_IN_OUT)
		tween.start()
		[/codeblock]
		Some of the methods of this class require a property name. You can get the property name by hovering over the property in the inspector of the editor.
		Many of the methods accept [code]trans_type[/code] and [code]ease_type[/code]. The first accepts an TRANS_* constant, and refers to the way the timing of the animation is handled (you might want to see [code]http://easings.net/[/code] for some examples). The second accepts an EASE_* constant, and controls the where [code]trans_type[/code] is applied to the interpolation (in the beginning, the end, or both). If you don't know which transision and easing to pick, you can try different TRANS_* constants with EASE_IN_OUT, and use the one that looks best.
*/
type Tween struct {
	Node
}

func (o *Tween) baseClass() string {
	return "Tween"
}

/*
                Follow [code]method[/code] of [code]object[/code] and apply the returned value on [code]target_method[/code] of [code]target[/code], beginning from [code]initial_val[/code] for [code]duration[/code] seconds, [code]delay[/code] later. Methods are animated by calling them with consequitive values.
				[code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) FollowMethod(object *Object, method string, initialVal *Variant, target *Object, targetMethod string, duration float64, transType int64, easeType int64, delay float64) *bool {
	log.Println("Calling Tween.FollowMethod()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 9, 9)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(method)
	goArguments[2] = reflect.ValueOf(initialVal)
	goArguments[3] = reflect.ValueOf(target)
	goArguments[4] = reflect.ValueOf(targetMethod)
	goArguments[5] = reflect.ValueOf(duration)
	goArguments[6] = reflect.ValueOf(transType)
	goArguments[7] = reflect.ValueOf(easeType)
	goArguments[8] = reflect.ValueOf(delay)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "follow_method", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
                Follow [code]property[/code] of [code]object[/code] and apply it on [code]target_property[/code] of [code]target[/code], beginning from [code]initial_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. Note that [code]target:target_property[/code] would equal [code]object:property[/code] at the end of the tween.
				[code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) FollowProperty(object *Object, property string, initialVal *Variant, target *Object, targetProperty string, duration float64, transType int64, easeType int64, delay float64) *bool {
	log.Println("Calling Tween.FollowProperty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 9, 9)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(property)
	goArguments[2] = reflect.ValueOf(initialVal)
	goArguments[3] = reflect.ValueOf(target)
	goArguments[4] = reflect.ValueOf(targetProperty)
	goArguments[5] = reflect.ValueOf(duration)
	goArguments[6] = reflect.ValueOf(transType)
	goArguments[7] = reflect.ValueOf(easeType)
	goArguments[8] = reflect.ValueOf(delay)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "follow_property", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns the time needed for all tweens to end in seconds, measured from the start. Thus, if you have two tweens, one ending 10 seconds after the start and the other - 20 seconds, it would return 20 seconds, as by that time all tweens would have finished.
*/
func (o *Tween) GetRuntime() float64 {
	log.Println("Calling Tween.GetRuntime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_runtime", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns the speed that has been set from editor GUI or [method set_repeat].
*/
func (o *Tween) GetSpeedScale() float64 {
	log.Println("Calling Tween.GetSpeedScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_speed_scale", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Returns the process mode that has been set from editor GUI or [method set_tween_process_mode]
*/
func (o *Tween) GetTweenProcessMode() int64 {
	log.Println("Calling Tween.GetTweenProcessMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_tween_process_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Call [code]callback[/code] of [code]object[/code] after [code]duration[/code]. [code]arg1[/code]-[code]arg5[/code] are arguments to be passed to the callback.
*/
func (o *Tween) InterpolateCallback(object *Object, duration float64, callback string, arg1 *Variant, arg2 *Variant, arg3 *Variant, arg4 *Variant, arg5 *Variant) *bool {
	log.Println("Calling Tween.InterpolateCallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 8, 8)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(duration)
	goArguments[2] = reflect.ValueOf(callback)
	goArguments[3] = reflect.ValueOf(arg1)
	goArguments[4] = reflect.ValueOf(arg2)
	goArguments[5] = reflect.ValueOf(arg3)
	goArguments[6] = reflect.ValueOf(arg4)
	goArguments[7] = reflect.ValueOf(arg5)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "interpolate_callback", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Call [code]callback[/code] of [code]object[/code] after [code]duration[/code] on the main thread (similar to [methog Object.call_deferred). [code]arg1[/code]-[code]arg5[/code] are arguments to be passed to the callback.
*/
func (o *Tween) InterpolateDeferredCallback(object *Object, duration float64, callback string, arg1 *Variant, arg2 *Variant, arg3 *Variant, arg4 *Variant, arg5 *Variant) *bool {
	log.Println("Calling Tween.InterpolateDeferredCallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 8, 8)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(duration)
	goArguments[2] = reflect.ValueOf(callback)
	goArguments[3] = reflect.ValueOf(arg1)
	goArguments[4] = reflect.ValueOf(arg2)
	goArguments[5] = reflect.ValueOf(arg3)
	goArguments[6] = reflect.ValueOf(arg4)
	goArguments[7] = reflect.ValueOf(arg5)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "interpolate_deferred_callback", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
                Animate [code]method[/code] of [code]object[/code] from [code]initial_val[/code] to [code]final_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. Methods are animated by calling them with consecuitive values.
				[code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) InterpolateMethod(object *Object, method string, initialVal *Variant, finalVal *Variant, duration float64, transType int64, easeType int64, delay float64) *bool {
	log.Println("Calling Tween.InterpolateMethod()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 8, 8)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(method)
	goArguments[2] = reflect.ValueOf(initialVal)
	goArguments[3] = reflect.ValueOf(finalVal)
	goArguments[4] = reflect.ValueOf(duration)
	goArguments[5] = reflect.ValueOf(transType)
	goArguments[6] = reflect.ValueOf(easeType)
	goArguments[7] = reflect.ValueOf(delay)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "interpolate_method", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
                Animate [code]property[/code] of [code]object[/code] from [code]initial_val[/code] to [code]final_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later.
				[code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) InterpolateProperty(object *Object, property string, initialVal *Variant, finalVal *Variant, duration float64, transType int64, easeType int64, delay float64) *bool {
	log.Println("Calling Tween.InterpolateProperty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 8, 8)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(property)
	goArguments[2] = reflect.ValueOf(initialVal)
	goArguments[3] = reflect.ValueOf(finalVal)
	goArguments[4] = reflect.ValueOf(duration)
	goArguments[5] = reflect.ValueOf(transType)
	goArguments[6] = reflect.ValueOf(easeType)
	goArguments[7] = reflect.ValueOf(delay)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "interpolate_property", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns true if any tweens are currently running, and false otherwise. Note that this method doesn't consider tweens that have ended.
*/
func (o *Tween) IsActive() *bool {
	log.Println("Calling Tween.IsActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_active", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns true if repeat has been set from editor GUI or [method set_repeat].
*/
func (o *Tween) IsRepeat() *bool {
	log.Println("Calling Tween.IsRepeat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_repeat", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Stop animating and completely remove a tween, given its object and property/method pair. Passing empty String as key will remove all tweens for given object.
*/
func (o *Tween) Remove(object *Object, key string) *bool {
	log.Println("Calling Tween.Remove()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(key)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "remove", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Stop animating and completely remove all tweens.
*/
func (o *Tween) RemoveAll() *bool {
	log.Println("Calling Tween.RemoveAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "remove_all", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Resets a tween to the initial value (the one given, not the one before the tween), given its object and property/method pair. Passing empty String as key will reset all tweens for given object.
*/
func (o *Tween) Reset(object *Object, key string) *bool {
	log.Println("Calling Tween.Reset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(key)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "reset", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Resets all tweens to their initial values (the ones given, not those before the tween).
*/
func (o *Tween) ResetAll() *bool {
	log.Println("Calling Tween.ResetAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "reset_all", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Continue animating a stopped tween, given its object and property/method pair. Passing empty String as key will resume all tweens for given object.
*/
func (o *Tween) Resume(object *Object, key string) *bool {
	log.Println("Calling Tween.Resume()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(key)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "resume", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Continue animating all stopped tweens.
*/
func (o *Tween) ResumeAll() *bool {
	log.Println("Calling Tween.ResumeAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "resume_all", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Seek the animation to the given [code]time[/code] in seconds.
*/
func (o *Tween) Seek(time float64) *bool {
	log.Println("Calling Tween.Seek()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(time)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "seek", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Activate/deactivate the tween. You can use this for pausing animations, though [method stop_all] and [method resume_all] might be more fit for this.
*/
func (o *Tween) SetActive(active *bool) {
	log.Println("Calling Tween.SetActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(active)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_active", goArguments, "")

	log.Println("Got return value!")

}

/*
   Make the tween repeat after all tweens have finished.
*/
func (o *Tween) SetRepeat(repeat *bool) {
	log.Println("Calling Tween.SetRepeat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(repeat)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_repeat", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the speed multiplier of the tween. Set it to 1 for normal speed, 2 for two times nromal speed, and 0.5 for half of the normal speed. Setting it to 0 would pause the animation, but you might consider using [method set_active] or [method stop_all] and [method resume_all] for this.
*/
func (o *Tween) SetSpeedScale(speed float64) {
	log.Println("Calling Tween.SetSpeedScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(speed)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_speed_scale", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether the Tween uses [code]_process[/code] or [code]_fixed_process[/code] (accepts TWEEN_PROCESS_IDLE and TWEEN_PROCESS_FIXED constants, respectively).
*/
func (o *Tween) SetTweenProcessMode(mode int64) {
	log.Println("Calling Tween.SetTweenProcessMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_tween_process_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   Start the tween node. You can define tweens both before and after this.
*/
func (o *Tween) Start() *bool {
	log.Println("Calling Tween.Start()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "start", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Stop animating a tween, given its object and property/method pair. Passing empty String as key will stop all tweens for given object.
*/
func (o *Tween) Stop(object *Object, key string) *bool {
	log.Println("Calling Tween.Stop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(key)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "stop", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Stop animating all tweens.
*/
func (o *Tween) StopAll() *bool {
	log.Println("Calling Tween.StopAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "stop_all", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
                Animate [code]method[/code] of [code]object[/code] from the value returned by [code]initial.initial_method[/code] to [code]final_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. Methods are animated by calling them with consecuitive values.
				[code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) TargetingMethod(object *Object, method string, initial *Object, initialMethod string, finalVal *Variant, duration float64, transType int64, easeType int64, delay float64) *bool {
	log.Println("Calling Tween.TargetingMethod()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 9, 9)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(method)
	goArguments[2] = reflect.ValueOf(initial)
	goArguments[3] = reflect.ValueOf(initialMethod)
	goArguments[4] = reflect.ValueOf(finalVal)
	goArguments[5] = reflect.ValueOf(duration)
	goArguments[6] = reflect.ValueOf(transType)
	goArguments[7] = reflect.ValueOf(easeType)
	goArguments[8] = reflect.ValueOf(delay)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "targeting_method", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
                Animate [code]property[/code] of [code]object[/code] from the current value of the [code]initial_val[/code] property of [code]initial[/code] to [code]final_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later.
				[code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) TargetingProperty(object *Object, property string, initial *Object, initialVal string, finalVal *Variant, duration float64, transType int64, easeType int64, delay float64) *bool {
	log.Println("Calling Tween.TargetingProperty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 9, 9)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(property)
	goArguments[2] = reflect.ValueOf(initial)
	goArguments[3] = reflect.ValueOf(initialVal)
	goArguments[4] = reflect.ValueOf(finalVal)
	goArguments[5] = reflect.ValueOf(duration)
	goArguments[6] = reflect.ValueOf(transType)
	goArguments[7] = reflect.ValueOf(easeType)
	goArguments[8] = reflect.ValueOf(delay)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "targeting_property", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns the current time of the tween.
*/
func (o *Tween) Tell() float64 {
	log.Println("Calling Tween.Tell()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "tell", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
        TweenImplementer is an interface for Tween objects.
        Node useful for animations with unknown start and end points, procedural animations, making one node follow another, and other simple behavior.
		Because it is easy to get it wrong, here is a quick usage example:
		[codeblock]
		var tween = get_node("Tween")
		tween.interpolate_property(get_node("Node2D_to_move"), "transform/pos", Vector2(0,0), Vector2(100,100), 1, Tween.TRANS_LINEAR, Tween.EASE_IN_OUT)
		tween.start()
		[/codeblock]
		Some of the methods of this class require a property name. You can get the property name by hovering over the property in the inspector of the editor.
		Many of the methods accept [code]trans_type[/code] and [code]ease_type[/code]. The first accepts an TRANS_* constant, and refers to the way the timing of the animation is handled (you might want to see [code]http://easings.net/[/code] for some examples). The second accepts an EASE_* constant, and controls the where [code]trans_type[/code] is applied to the interpolation (in the beginning, the end, or both). If you don't know which transision and easing to pick, you can try different TRANS_* constants with EASE_IN_OUT, and use the one that looks best.
*/
type TweenImplementer interface {
	NodeImplementer

	FollowMethod(object *Object, method string, initialVal *Variant, target *Object, targetMethod string, duration float64, transType int64, easeType int64, delay float64) *bool

	FollowProperty(object *Object, property string, initialVal *Variant, target *Object, targetProperty string, duration float64, transType int64, easeType int64, delay float64) *bool

	GetRuntime() float64

	GetSpeedScale() float64

	GetTweenProcessMode() int64

	InterpolateCallback(object *Object, duration float64, callback string, arg1 *Variant, arg2 *Variant, arg3 *Variant, arg4 *Variant, arg5 *Variant) *bool

	InterpolateDeferredCallback(object *Object, duration float64, callback string, arg1 *Variant, arg2 *Variant, arg3 *Variant, arg4 *Variant, arg5 *Variant) *bool

	InterpolateMethod(object *Object, method string, initialVal *Variant, finalVal *Variant, duration float64, transType int64, easeType int64, delay float64) *bool

	InterpolateProperty(object *Object, property string, initialVal *Variant, finalVal *Variant, duration float64, transType int64, easeType int64, delay float64) *bool

	IsActive() *bool

	IsRepeat() *bool

	Remove(object *Object, key string) *bool

	RemoveAll() *bool

	Reset(object *Object, key string) *bool

	ResetAll() *bool

	Resume(object *Object, key string) *bool

	ResumeAll() *bool

	Seek(time float64) *bool

	SetActive(active *bool)

	SetRepeat(repeat *bool)

	SetSpeedScale(speed float64)

	SetTweenProcessMode(mode int64)

	Start() *bool

	Stop(object *Object, key string) *bool

	StopAll() *bool

	TargetingMethod(object *Object, method string, initial *Object, initialMethod string, finalVal *Variant, duration float64, transType int64, easeType int64, delay float64) *bool

	TargetingProperty(object *Object, property string, initial *Object, initialVal string, finalVal *Variant, duration float64, transType int64, easeType int64, delay float64) *bool

	Tell() float64
}

/*
        Helper to manage UndoRedo in the editor or custom tools. It works by storing calls to functions in both 'do' an 'undo' lists.
		Common behavior is to create an action, then add do/undo calls to functions or property changes, then committing the action.
*/
type UndoRedo struct {
	Object
}

func (o *UndoRedo) baseClass() string {
	return "UndoRedo"
}

/*

 */
func (o *UndoRedo) AddDoMethod(object *Object, method string) *Variant {
	log.Println("Calling UndoRedo.AddDoMethod()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "add_do_method", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Set a property with a custom value.
*/
func (o *UndoRedo) AddDoProperty(object *Object, property string, value *Variant) {
	log.Println("Calling UndoRedo.AddDoProperty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(property)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_do_property", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add a 'do' reference that will be erased if the 'do' history is lost. This is useful mostly for new nodes created for the 'do' call. Do not use for resources.
*/
func (o *UndoRedo) AddDoReference(object *Object) {
	log.Println("Calling UndoRedo.AddDoReference()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(object)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_do_reference", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *UndoRedo) AddUndoMethod(object *Object, method string) *Variant {
	log.Println("Calling UndoRedo.AddUndoMethod()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "add_undo_method", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Undo setting of a property with a custom value.
*/
func (o *UndoRedo) AddUndoProperty(object *Object, property string, value *Variant) {
	log.Println("Calling UndoRedo.AddUndoProperty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(property)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_undo_property", goArguments, "")

	log.Println("Got return value!")

}

/*
   Add an 'undo' reference that will be erased if the 'undo' history is lost. This is useful mostly for nodes removed with the 'do' call (not the 'undo' call!).
*/
func (o *UndoRedo) AddUndoReference(object *Object) {
	log.Println("Calling UndoRedo.AddUndoReference()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(object)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_undo_reference", goArguments, "")

	log.Println("Got return value!")

}

/*
   Clear the undo/redo history and associated references.
*/
func (o *UndoRedo) ClearHistory() {
	log.Println("Calling UndoRedo.ClearHistory()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "clear_history", goArguments, "")

	log.Println("Got return value!")

}

/*
   Commit the action. All 'do' methods/properties are called/set when this function is called.
*/
func (o *UndoRedo) CommitAction() {
	log.Println("Calling UndoRedo.CommitAction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "commit_action", goArguments, "")

	log.Println("Got return value!")

}

/*
   Create a new action. After this is called, do all your calls to [method add_do_method], [method add_undo_method], [method add_do_property] and [method add_undo_property].
*/
func (o *UndoRedo) CreateAction(name string, mergeMode int64) {
	log.Println("Calling UndoRedo.CreateAction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(mergeMode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "create_action", goArguments, "")

	log.Println("Got return value!")

}

/*
   Get the name of the current action.
*/
func (o *UndoRedo) GetCurrentActionName() string {
	log.Println("Calling UndoRedo.GetCurrentActionName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_action_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
                Get the version, each time a new action is committed, the version number of the UndoRedo is increased automatically.
				This is useful mostly to check if something changed from a saved version.
*/
func (o *UndoRedo) GetVersion() int64 {
	log.Println("Calling UndoRedo.GetVersion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_version", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
        UndoRedoImplementer is an interface for UndoRedo objects.
        Helper to manage UndoRedo in the editor or custom tools. It works by storing calls to functions in both 'do' an 'undo' lists.
		Common behavior is to create an action, then add do/undo calls to functions or property changes, then committing the action.
*/
type UndoRedoImplementer interface {
	ObjectImplementer

	AddDoMethod(object *Object, method string) *Variant

	AddDoProperty(object *Object, property string, value *Variant)

	AddDoReference(object *Object)

	AddUndoMethod(object *Object, method string) *Variant

	AddUndoProperty(object *Object, property string, value *Variant)

	AddUndoReference(object *Object)

	ClearHistory()

	CommitAction()

	CreateAction(name string, mergeMode int64)

	GetCurrentActionName() string

	GetVersion() int64
}

/*
   Vertical box container. See [BoxContainer].
*/
type VBoxContainer struct {
	BoxContainer
}

func (o *VBoxContainer) baseClass() string {
	return "VBoxContainer"
}

/*
   VBoxContainerImplementer is an interface for VBoxContainer objects.
   Vertical box container. See [BoxContainer].
*/
type VBoxContainerImplementer interface {
	BoxContainerImplementer
}

/*

 */
type VScrollBar struct {
	ScrollBar
}

func (o *VScrollBar) baseClass() string {
	return "VScrollBar"
}

/*
   VScrollBarImplementer is an interface for VScrollBar objects.

*/
type VScrollBarImplementer interface {
	ScrollBarImplementer
}

/*
   Vertical version of [Separator]. It is used to separate objects horizontally, though (but it looks vertical!).
*/
type VSeparator struct {
	Separator
}

func (o *VSeparator) baseClass() string {
	return "VSeparator"
}

/*
   VSeparatorImplementer is an interface for VSeparator objects.
   Vertical version of [Separator]. It is used to separate objects horizontally, though (but it looks vertical!).
*/
type VSeparatorImplementer interface {
	SeparatorImplementer
}

/*
   Vertical slider. See [Slider]. This one goes from left (min) to right (max).
*/
type VSlider struct {
	Slider
}

func (o *VSlider) baseClass() string {
	return "VSlider"
}

/*
   VSliderImplementer is an interface for VSlider objects.
   Vertical slider. See [Slider]. This one goes from left (min) to right (max).
*/
type VSliderImplementer interface {
	SliderImplementer
}

/*
   Vertical split container. See [SplitContainer]. This goes from left to right.
*/
type VSplitContainer struct {
	SplitContainer
}

func (o *VSplitContainer) baseClass() string {
	return "VSplitContainer"
}

/*
   VSplitContainerImplementer is an interface for VSplitContainer objects.
   Vertical split container. See [SplitContainer]. This goes from left to right.
*/
type VSplitContainerImplementer interface {
	SplitContainerImplementer
}

/*

 */
type VehicleBody struct {
	PhysicsBody
}

func (o *VehicleBody) baseClass() string {
	return "VehicleBody"
}

/*

 */
func (o *VehicleBody) GetBrake() float64 {
	log.Println("Calling VehicleBody.GetBrake()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_brake", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *VehicleBody) GetEngineForce() float64 {
	log.Println("Calling VehicleBody.GetEngineForce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_engine_force", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *VehicleBody) GetFriction() float64 {
	log.Println("Calling VehicleBody.GetFriction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_friction", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
                Returns the VehicleBody's velocity vector. To get the absolute speed in scalar value, get the length of the return vector in pixels/second. Example:
				[codeblock]
				# vehicle is an instance of VehicleBody
				var speed = vehicle.get_linear_velocity().length()
				[/codeblock]
*/
func (o *VehicleBody) GetLinearVelocity() *Vector3 {
	log.Println("Calling VehicleBody.GetLinearVelocity()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_linear_velocity", goArguments, "*Vector3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector3)

	return returnValue

}

/*

 */
func (o *VehicleBody) GetMass() float64 {
	log.Println("Calling VehicleBody.GetMass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mass", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Return the steering angle (in radians).
*/
func (o *VehicleBody) GetSteering() float64 {
	log.Println("Calling VehicleBody.GetSteering()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_steering", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *VehicleBody) SetBrake(brake float64) {
	log.Println("Calling VehicleBody.SetBrake()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(brake)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_brake", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VehicleBody) SetEngineForce(engineForce float64) {
	log.Println("Calling VehicleBody.SetEngineForce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(engineForce)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_engine_force", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VehicleBody) SetFriction(friction float64) {
	log.Println("Calling VehicleBody.SetFriction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(friction)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_friction", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VehicleBody) SetMass(mass float64) {
	log.Println("Calling VehicleBody.SetMass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mass)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_mass", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the steering angle (in radians).
*/
func (o *VehicleBody) SetSteering(steering float64) {
	log.Println("Calling VehicleBody.SetSteering()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(steering)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_steering", goArguments, "")

	log.Println("Got return value!")

}

/*
   VehicleBodyImplementer is an interface for VehicleBody objects.

*/
type VehicleBodyImplementer interface {
	PhysicsBodyImplementer

	GetBrake() float64

	GetEngineForce() float64

	GetFriction() float64

	GetLinearVelocity() *Vector3

	GetMass() float64

	GetSteering() float64

	SetBrake(brake float64)

	SetEngineForce(engineForce float64)

	SetFriction(friction float64)

	SetMass(mass float64)

	SetSteering(steering float64)
}

/*

 */
type VehicleWheel struct {
	Spatial
}

func (o *VehicleWheel) baseClass() string {
	return "VehicleWheel"
}

/*

 */
func (o *VehicleWheel) GetDampingCompression() float64 {
	log.Println("Calling VehicleWheel.GetDampingCompression()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_damping_compression", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *VehicleWheel) GetDampingRelaxation() float64 {
	log.Println("Calling VehicleWheel.GetDampingRelaxation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_damping_relaxation", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *VehicleWheel) GetFrictionSlip() float64 {
	log.Println("Calling VehicleWheel.GetFrictionSlip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_friction_slip", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *VehicleWheel) GetRadius() float64 {
	log.Println("Calling VehicleWheel.GetRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_radius", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *VehicleWheel) GetRollInfluence() float64 {
	log.Println("Calling VehicleWheel.GetRollInfluence()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_roll_influence", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *VehicleWheel) GetSuspensionMaxForce() float64 {
	log.Println("Calling VehicleWheel.GetSuspensionMaxForce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_suspension_max_force", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *VehicleWheel) GetSuspensionRestLength() float64 {
	log.Println("Calling VehicleWheel.GetSuspensionRestLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_suspension_rest_length", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *VehicleWheel) GetSuspensionStiffness() float64 {
	log.Println("Calling VehicleWheel.GetSuspensionStiffness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_suspension_stiffness", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *VehicleWheel) GetSuspensionTravel() float64 {
	log.Println("Calling VehicleWheel.GetSuspensionTravel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_suspension_travel", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *VehicleWheel) IsInContact() *bool {
	log.Println("Calling VehicleWheel.IsInContact()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_in_contact", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *VehicleWheel) IsUsedAsSteering() *bool {
	log.Println("Calling VehicleWheel.IsUsedAsSteering()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_used_as_steering", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *VehicleWheel) IsUsedAsTraction() *bool {
	log.Println("Calling VehicleWheel.IsUsedAsTraction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_used_as_traction", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *VehicleWheel) SetDampingCompression(length float64) {
	log.Println("Calling VehicleWheel.SetDampingCompression()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(length)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_damping_compression", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VehicleWheel) SetDampingRelaxation(length float64) {
	log.Println("Calling VehicleWheel.SetDampingRelaxation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(length)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_damping_relaxation", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VehicleWheel) SetFrictionSlip(length float64) {
	log.Println("Calling VehicleWheel.SetFrictionSlip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(length)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_friction_slip", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VehicleWheel) SetRadius(length float64) {
	log.Println("Calling VehicleWheel.SetRadius()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(length)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_radius", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VehicleWheel) SetRollInfluence(rollInfluence float64) {
	log.Println("Calling VehicleWheel.SetRollInfluence()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rollInfluence)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_roll_influence", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VehicleWheel) SetSuspensionMaxForce(length float64) {
	log.Println("Calling VehicleWheel.SetSuspensionMaxForce()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(length)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_suspension_max_force", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VehicleWheel) SetSuspensionRestLength(length float64) {
	log.Println("Calling VehicleWheel.SetSuspensionRestLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(length)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_suspension_rest_length", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VehicleWheel) SetSuspensionStiffness(length float64) {
	log.Println("Calling VehicleWheel.SetSuspensionStiffness()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(length)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_suspension_stiffness", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VehicleWheel) SetSuspensionTravel(length float64) {
	log.Println("Calling VehicleWheel.SetSuspensionTravel()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(length)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_suspension_travel", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VehicleWheel) SetUseAsSteering(enable *bool) {
	log.Println("Calling VehicleWheel.SetUseAsSteering()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_as_steering", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VehicleWheel) SetUseAsTraction(enable *bool) {
	log.Println("Calling VehicleWheel.SetUseAsTraction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_as_traction", goArguments, "")

	log.Println("Got return value!")

}

/*
   VehicleWheelImplementer is an interface for VehicleWheel objects.

*/
type VehicleWheelImplementer interface {
	SpatialImplementer

	GetDampingCompression() float64

	GetDampingRelaxation() float64

	GetFrictionSlip() float64

	GetRadius() float64

	GetRollInfluence() float64

	GetSuspensionMaxForce() float64

	GetSuspensionRestLength() float64

	GetSuspensionStiffness() float64

	GetSuspensionTravel() float64

	IsInContact() *bool

	IsUsedAsSteering() *bool

	IsUsedAsTraction() *bool

	SetDampingCompression(length float64)

	SetDampingRelaxation(length float64)

	SetFrictionSlip(length float64)

	SetRadius(length float64)

	SetRollInfluence(rollInfluence float64)

	SetSuspensionMaxForce(length float64)

	SetSuspensionRestLength(length float64)

	SetSuspensionStiffness(length float64)

	SetSuspensionTravel(length float64)

	SetUseAsSteering(enable *bool)

	SetUseAsTraction(enable *bool)
}

/*
   This control has the ability to play video streams. The only format accepted is the OGV Theora, so any other format must be converted before using in a project.
*/
type VideoPlayer struct {
	Control
}

func (o *VideoPlayer) baseClass() string {
	return "VideoPlayer"
}

/*
   Get the selected audio track (for multitrack videos).
*/
func (o *VideoPlayer) GetAudioTrack() int64 {
	log.Println("Calling VideoPlayer.GetAudioTrack()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_audio_track", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the amount of miliseconds to store in buffer while playing.
*/
func (o *VideoPlayer) GetBufferingMsec() int64 {
	log.Println("Calling VideoPlayer.GetBufferingMsec()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_buffering_msec", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the video stream.
*/
func (o *VideoPlayer) GetStream() *VideoStream {
	log.Println("Calling VideoPlayer.GetStream()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stream", goArguments, "*VideoStream")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*VideoStream)

	return returnValue

}

/*
   Get the name of the video stream.
*/
func (o *VideoPlayer) GetStreamName() string {
	log.Println("Calling VideoPlayer.GetStreamName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stream_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the current position of the stream, in seconds.
*/
func (o *VideoPlayer) GetStreamPos() float64 {
	log.Println("Calling VideoPlayer.GetStreamPos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_stream_pos", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Get the current frame of the video as a [Texture].
*/
func (o *VideoPlayer) GetVideoTexture() *Texture {
	log.Println("Calling VideoPlayer.GetVideoTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_video_texture", goArguments, "*Texture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Texture)

	return returnValue

}

/*
   Get the volume of the audio track as a linear value.
*/
func (o *VideoPlayer) GetVolume() float64 {
	log.Println("Calling VideoPlayer.GetVolume()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_volume", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Get the volume of the audio track in decibels.
*/
func (o *VideoPlayer) GetVolumeDb() float64 {
	log.Println("Calling VideoPlayer.GetVolumeDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_volume_db", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*
   Get whether or not the video is set as autoplay.
*/
func (o *VideoPlayer) HasAutoplay() *bool {
	log.Println("Calling VideoPlayer.HasAutoplay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_autoplay", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Get whether or not the expand property is set.
*/
func (o *VideoPlayer) HasExpand() *bool {
	log.Println("Calling VideoPlayer.HasExpand()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_expand", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Get whether or not the video is paused.
*/
func (o *VideoPlayer) IsPaused() *bool {
	log.Println("Calling VideoPlayer.IsPaused()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_paused", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Get whether or not the video is playing.
*/
func (o *VideoPlayer) IsPlaying() *bool {
	log.Println("Calling VideoPlayer.IsPlaying()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_playing", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Start the video playback.
*/
func (o *VideoPlayer) Play() {
	log.Println("Calling VideoPlayer.Play()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "play", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the audio track (for multitrack videos).
*/
func (o *VideoPlayer) SetAudioTrack(track int64) {
	log.Println("Calling VideoPlayer.SetAudioTrack()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(track)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_audio_track", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether this node should start playing automatically.
*/
func (o *VideoPlayer) SetAutoplay(enabled *bool) {
	log.Println("Calling VideoPlayer.SetAutoplay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_autoplay", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the amount of miliseconds to buffer during playback.
*/
func (o *VideoPlayer) SetBufferingMsec(msec int64) {
	log.Println("Calling VideoPlayer.SetBufferingMsec()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(msec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_buffering_msec", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the expand property. If enabled, the video will grow or shrink to fit the player size, otherwise it will play at the stream resolution.
*/
func (o *VideoPlayer) SetExpand(enable *bool) {
	log.Println("Calling VideoPlayer.SetExpand()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_expand", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether the video should pause the playback.
*/
func (o *VideoPlayer) SetPaused(paused *bool) {
	log.Println("Calling VideoPlayer.SetPaused()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(paused)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_paused", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the video stream for this player.
*/
func (o *VideoPlayer) SetStream(stream *VideoStream) {
	log.Println("Calling VideoPlayer.SetStream()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(stream)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_stream", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the audio volume as a linear value.
*/
func (o *VideoPlayer) SetVolume(volume float64) {
	log.Println("Calling VideoPlayer.SetVolume()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(volume)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_volume", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the audio volume in decibels.
*/
func (o *VideoPlayer) SetVolumeDb(db float64) {
	log.Println("Calling VideoPlayer.SetVolumeDb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(db)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_volume_db", goArguments, "")

	log.Println("Got return value!")

}

/*
   Stop the video playback.
*/
func (o *VideoPlayer) Stop() {
	log.Println("Calling VideoPlayer.Stop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "stop", goArguments, "")

	log.Println("Got return value!")

}

/*
   VideoPlayerImplementer is an interface for VideoPlayer objects.
   This control has the ability to play video streams. The only format accepted is the OGV Theora, so any other format must be converted before using in a project.
*/
type VideoPlayerImplementer interface {
	ControlImplementer

	GetAudioTrack() int64

	GetBufferingMsec() int64

	GetStream() *VideoStream

	GetStreamName() string

	GetStreamPos() float64

	GetVideoTexture() *Texture

	GetVolume() float64

	GetVolumeDb() float64

	HasAutoplay() *bool

	HasExpand() *bool

	IsPaused() *bool

	IsPlaying() *bool

	Play()

	SetAudioTrack(track int64)

	SetAutoplay(enabled *bool)

	SetBufferingMsec(msec int64)

	SetExpand(enable *bool)

	SetPaused(paused *bool)

	SetStream(stream *VideoStream)

	SetVolume(volume float64)

	SetVolumeDb(db float64)

	Stop()
}

/*

 */
type VideoStream struct {
	Resource
}

func (o *VideoStream) baseClass() string {
	return "VideoStream"
}

/*
   VideoStreamImplementer is an interface for VideoStream objects.

*/
type VideoStreamImplementer interface {
	ResourceImplementer
}

/*
        A Viewport creates a different view into the screen, or a sub-view inside another viewport. Children 2D Nodes will display on it, and children Camera 3D nodes will render on it too.
		Optionally, a viewport can have its own 2D or 3D world, so they don't share what they draw with other viewports.
		If a viewport is a child of a [Control], it will automatically take up its same rect and position, otherwise they must be set manually.
		Viewports can also choose to be audio listeners, so they generate positional audio depending on a 2D or 3D camera child of it.
		Also, viewports can be assigned to different screens in case the devices have multiple screens.
		Finally, viewports can also behave as render targets, in which case they will not be visible unless the associated texture is used to draw.
*/
type Viewport struct {
	Node
}

func (o *Viewport) baseClass() string {
	return "Viewport"
}

/*
   Return the 3D world of the viewport, or if no such present, the one of the parent viewport.
*/
func (o *Viewport) FindWorld() *World {
	log.Println("Calling Viewport.FindWorld()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "find_world", goArguments, "*World")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*World)

	return returnValue

}

/*
   Return the 2D world of the viewport.
*/
func (o *Viewport) FindWorld2D() *World2D {
	log.Println("Calling Viewport.FindWorld2D()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "find_world_2d", goArguments, "*World2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*World2D)

	return returnValue

}

/*
   Return the active 3D camera.
*/
func (o *Viewport) GetCamera() *Camera {
	log.Println("Calling Viewport.GetCamera()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_camera", goArguments, "*Camera")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Camera)

	return returnValue

}

/*
   Get the canvas transform of the viewport.
*/
func (o *Viewport) GetCanvasTransform() *Transform2D {
	log.Println("Calling Viewport.GetCanvasTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_canvas_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*

 */
func (o *Viewport) GetClearMode() int64 {
	log.Println("Calling Viewport.GetClearMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_clear_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Viewport) GetDebugDraw() int64 {
	log.Println("Calling Viewport.GetDebugDraw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_debug_draw", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the total transform of the viewport.
*/
func (o *Viewport) GetFinalTransform() *Transform2D {
	log.Println("Calling Viewport.GetFinalTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_final_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Get the global canvas transform of the viewport.
*/
func (o *Viewport) GetGlobalCanvasTransform() *Transform2D {
	log.Println("Calling Viewport.GetGlobalCanvasTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_global_canvas_transform", goArguments, "*Transform2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Transform2D)

	return returnValue

}

/*
   Get whether the rendered texture has filters enabled.
*/
func (o *Viewport) GetHdr() *bool {
	log.Println("Calling Viewport.GetHdr()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_hdr", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Get the mouse position, relative to the viewport.
*/
func (o *Viewport) GetMousePosition() *Vector2 {
	log.Println("Calling Viewport.GetMousePosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_mouse_position", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *Viewport) GetMsaa() int64 {
	log.Println("Calling Viewport.GetMsaa()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_msaa", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get whether picking for all physics objects inside the viewport is enabled.
*/
func (o *Viewport) GetPhysicsObjectPicking() *bool {
	log.Println("Calling Viewport.GetPhysicsObjectPicking()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_physics_object_picking", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Viewport) GetRenderInfo(info int64) int64 {
	log.Println("Calling Viewport.GetRenderInfo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(info)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_render_info", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Viewport) GetShadowAtlasQuadrantSubdiv(quadrant int64) int64 {
	log.Println("Calling Viewport.GetShadowAtlasQuadrantSubdiv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(quadrant)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shadow_atlas_quadrant_subdiv", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Viewport) GetShadowAtlasSize() int64 {
	log.Println("Calling Viewport.GetShadowAtlasSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_shadow_atlas_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Return the viewport rect. If the viewport is child of a control, it will use the same rect as the parent. Otherwise, if the rect is empty, the viewport will use all the allowed space.
*/
func (o *Viewport) GetSize() *Vector2 {
	log.Println("Calling Viewport.GetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Get the size override set with [method set_size_override].
*/
func (o *Viewport) GetSizeOverride() *Vector2 {
	log.Println("Calling Viewport.GetSizeOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_size_override", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*
   Get the viewport's texture, for use with various objects that you want to texture with the viewport.
*/
func (o *Viewport) GetTexture() *ViewportTexture {
	log.Println("Calling Viewport.GetTexture()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_texture", goArguments, "*ViewportTexture")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*ViewportTexture)

	return returnValue

}

/*
   Get when the viewport would be updated, will be one of the [code]UPDATE_*[/code] constants.
*/
func (o *Viewport) GetUpdateMode() int64 {
	log.Println("Calling Viewport.GetUpdateMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_update_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *Viewport) GetUsage() int64 {
	log.Println("Calling Viewport.GetUsage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_usage", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Set whether the render target is flipped on the Y axis.
*/
func (o *Viewport) GetVflip() *bool {
	log.Println("Calling Viewport.GetVflip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_vflip", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Get the viewport RID from the [VisualServer].
*/
func (o *Viewport) GetViewportRid() *RID {
	log.Println("Calling Viewport.GetViewportRid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_viewport_rid", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Return the final, visible rect in global screen coordinates.
*/
func (o *Viewport) GetVisibleRect() *Rect2 {
	log.Println("Calling Viewport.GetVisibleRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_visible_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   Return the 3D world of the viewport.
*/
func (o *Viewport) GetWorld() *World {
	log.Println("Calling Viewport.GetWorld()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_world", goArguments, "*World")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*World)

	return returnValue

}

/*
   Return the 2D world of the viewport.
*/
func (o *Viewport) GetWorld2D() *World2D {
	log.Println("Calling Viewport.GetWorld2D()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_world_2d", goArguments, "*World2D")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*World2D)

	return returnValue

}

/*
   Returs the drag data from the GUI, that was previously returned by [method Control.get_drag_data].
*/
func (o *Viewport) GuiGetDragData() *Variant {
	log.Println("Calling Viewport.GuiGetDragData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "gui_get_drag_data", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   Returs whether there are shown modals on-screen.
*/
func (o *Viewport) GuiHasModalStack() *bool {
	log.Println("Calling Viewport.GuiHasModalStack()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "gui_has_modal_stack", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether the viewport lets whatever is behind it to show.
*/
func (o *Viewport) HasTransparentBackground() *bool {
	log.Println("Calling Viewport.HasTransparentBackground()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_transparent_background", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *Viewport) Input(localEvent *InputEvent) {
	log.Println("Calling Viewport.Input()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(localEvent)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "input", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Viewport) Is3DDisabled() *bool {
	log.Println("Calling Viewport.Is3DDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_3d_disabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns whether the viewport sends sounds to the speakers.
*/
func (o *Viewport) IsAudioListener() *bool {
	log.Println("Calling Viewport.IsAudioListener()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_audio_listener", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Returns whether the viewport sends soundsfrom 2D emitters to the speakers.
*/
func (o *Viewport) IsAudioListener2D() *bool {
	log.Println("Calling Viewport.IsAudioListener2D()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_audio_listener_2d", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether input to the viewport is disabled.
*/
func (o *Viewport) IsInputDisabled() *bool {
	log.Println("Calling Viewport.IsInputDisabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_input_disabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Get the enabled status of the size override set with [method set_size_override].
*/
func (o *Viewport) IsSizeOverrideEnabled() *bool {
	log.Println("Calling Viewport.IsSizeOverrideEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_size_override_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Get the enabled status of the size strech override set with [method set_size_override_stretch].
*/
func (o *Viewport) IsSizeOverrideStretchEnabled() *bool {
	log.Println("Calling Viewport.IsSizeOverrideStretchEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_size_override_stretch_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return whether the viewport is using a world separate from the parent viewport's world.
*/
func (o *Viewport) IsUsingOwnWorld() *bool {
	log.Println("Calling Viewport.IsUsingOwnWorld()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_using_own_world", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Makes the viewport send sounds to the speakers.
*/
func (o *Viewport) SetAsAudioListener(enable *bool) {
	log.Println("Calling Viewport.SetAsAudioListener()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_as_audio_listener", goArguments, "")

	log.Println("Got return value!")

}

/*
   Makes the viewport send sounds from 2D emitters to the speakers.
*/
func (o *Viewport) SetAsAudioListener2D(enable *bool) {
	log.Println("Calling Viewport.SetAsAudioListener2D()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_as_audio_listener_2d", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Viewport) SetAttachToScreenRect(rect *Rect2) {
	log.Println("Calling Viewport.SetAttachToScreenRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rect)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_attach_to_screen_rect", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the canvas transform of the viewport, useful for changing the on-screen positions of all child [CanvasItem]\ s. This is relative to the global canvas transform of the viewport.
*/
func (o *Viewport) SetCanvasTransform(xform *Transform2D) {
	log.Println("Calling Viewport.SetCanvasTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(xform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_canvas_transform", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Viewport) SetClearMode(mode int64) {
	log.Println("Calling Viewport.SetClearMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_clear_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Viewport) SetDebugDraw(debugDraw int64) {
	log.Println("Calling Viewport.SetDebugDraw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(debugDraw)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_debug_draw", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Viewport) SetDisable3D(disable *bool) {
	log.Println("Calling Viewport.SetDisable3D()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(disable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_disable_3d", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether input to the viewport is disabled.
*/
func (o *Viewport) SetDisableInput(disable *bool) {
	log.Println("Calling Viewport.SetDisableInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(disable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_disable_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the global canvas transform of the viewport. The canvas transform is relative to this.
*/
func (o *Viewport) SetGlobalCanvasTransform(xform *Transform2D) {
	log.Println("Calling Viewport.SetGlobalCanvasTransform()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(xform)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_global_canvas_transform", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Viewport) SetHdr(enable *bool) {
	log.Println("Calling Viewport.SetHdr()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_hdr", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Viewport) SetMsaa(msaa int64) {
	log.Println("Calling Viewport.SetMsaa()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(msaa)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_msaa", goArguments, "")

	log.Println("Got return value!")

}

/*
   Enable/disable picking for all physics objects inside the viewport.
*/
func (o *Viewport) SetPhysicsObjectPicking(enable *bool) {
	log.Println("Calling Viewport.SetPhysicsObjectPicking()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_physics_object_picking", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Viewport) SetShadowAtlasQuadrantSubdiv(quadrant int64, subdiv int64) {
	log.Println("Calling Viewport.SetShadowAtlasQuadrantSubdiv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(quadrant)
	goArguments[1] = reflect.ValueOf(subdiv)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_atlas_quadrant_subdiv", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Viewport) SetShadowAtlasSize(size int64) {
	log.Println("Calling Viewport.SetShadowAtlasSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_shadow_atlas_size", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the size of the viewport.
*/
func (o *Viewport) SetSize(size *Vector2) {
	log.Println("Calling Viewport.SetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_size", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the size override of the viewport. If the enable parameter is true, it would use the override, otherwise it would use the default size. If the size parameter is equal to [code](-1, -1)[/code], it won't update the size.
*/
func (o *Viewport) SetSizeOverride(enable *bool, size *Vector2, margin *Vector2) {
	log.Println("Calling Viewport.SetSizeOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(enable)
	goArguments[1] = reflect.ValueOf(size)
	goArguments[2] = reflect.ValueOf(margin)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_size_override", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether the size override affects stretch as well.
*/
func (o *Viewport) SetSizeOverrideStretch(enabled *bool) {
	log.Println("Calling Viewport.SetSizeOverrideStretch()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_size_override_stretch", goArguments, "")

	log.Println("Got return value!")

}

/*
   If this viewport is a child of another viewport, keep the previously drawn background visible.
*/
func (o *Viewport) SetTransparentBackground(enable *bool) {
	log.Println("Calling Viewport.SetTransparentBackground()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_transparent_background", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set when the render target would be updated, using the [code]UPDATE_*[/code] constants
*/
func (o *Viewport) SetUpdateMode(mode int64) {
	log.Println("Calling Viewport.SetUpdateMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_update_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Viewport) SetUsage(usage int64) {
	log.Println("Calling Viewport.SetUsage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(usage)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_usage", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Viewport) SetUseArvr(use *bool) {
	log.Println("Calling Viewport.SetUseArvr()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(use)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_arvr", goArguments, "")

	log.Println("Got return value!")

}

/*
   Make the viewport use a world separate from the parent viewport's world.
*/
func (o *Viewport) SetUseOwnWorld(enable *bool) {
	log.Println("Calling Viewport.SetUseOwnWorld()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_own_world", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set whether the viewport is flipped on the Y axis.
*/
func (o *Viewport) SetVflip(enable *bool) {
	log.Println("Calling Viewport.SetVflip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_vflip", goArguments, "")

	log.Println("Got return value!")

}

/*
   Change the 3D world of the viewport.
*/
func (o *Viewport) SetWorld(world *World) {
	log.Println("Calling Viewport.SetWorld()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(world)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_world", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Viewport) SetWorld2D(world2D *World2D) {
	log.Println("Calling Viewport.SetWorld2D()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(world2D)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_world_2d", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Viewport) UnhandledInput(localEvent *InputEvent) {
	log.Println("Calling Viewport.UnhandledInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(localEvent)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "unhandled_input", goArguments, "")

	log.Println("Got return value!")

}

/*
   Force update of the 2D and 3D worlds.
*/
func (o *Viewport) UpdateWorlds() {
	log.Println("Calling Viewport.UpdateWorlds()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "update_worlds", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *Viewport) UseArvr() *bool {
	log.Println("Calling Viewport.UseArvr()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "use_arvr", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Warp the mouse to a position, relative to the viewport.
*/
func (o *Viewport) WarpMouse(toPos *Vector2) {
	log.Println("Calling Viewport.WarpMouse()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(toPos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "warp_mouse", goArguments, "")

	log.Println("Got return value!")

}

/*
        ViewportImplementer is an interface for Viewport objects.
        A Viewport creates a different view into the screen, or a sub-view inside another viewport. Children 2D Nodes will display on it, and children Camera 3D nodes will render on it too.
		Optionally, a viewport can have its own 2D or 3D world, so they don't share what they draw with other viewports.
		If a viewport is a child of a [Control], it will automatically take up its same rect and position, otherwise they must be set manually.
		Viewports can also choose to be audio listeners, so they generate positional audio depending on a 2D or 3D camera child of it.
		Also, viewports can be assigned to different screens in case the devices have multiple screens.
		Finally, viewports can also behave as render targets, in which case they will not be visible unless the associated texture is used to draw.
*/
type ViewportImplementer interface {
	NodeImplementer

	FindWorld() *World

	FindWorld2D() *World2D

	GetCamera() *Camera

	GetCanvasTransform() *Transform2D

	GetClearMode() int64

	GetDebugDraw() int64

	GetFinalTransform() *Transform2D

	GetGlobalCanvasTransform() *Transform2D

	GetHdr() *bool

	GetMousePosition() *Vector2

	GetMsaa() int64

	GetPhysicsObjectPicking() *bool

	GetRenderInfo(info int64) int64

	GetShadowAtlasQuadrantSubdiv(quadrant int64) int64

	GetShadowAtlasSize() int64

	GetSize() *Vector2

	GetSizeOverride() *Vector2

	GetTexture() *ViewportTexture

	GetUpdateMode() int64

	GetUsage() int64

	GetVflip() *bool

	GetViewportRid() *RID

	GetVisibleRect() *Rect2

	GetWorld() *World

	GetWorld2D() *World2D

	GuiGetDragData() *Variant

	GuiHasModalStack() *bool

	HasTransparentBackground() *bool

	Input(localEvent *InputEvent)

	Is3DDisabled() *bool

	IsAudioListener() *bool

	IsAudioListener2D() *bool

	IsInputDisabled() *bool

	IsSizeOverrideEnabled() *bool

	IsSizeOverrideStretchEnabled() *bool

	IsUsingOwnWorld() *bool

	SetAsAudioListener(enable *bool)

	SetAsAudioListener2D(enable *bool)

	SetAttachToScreenRect(rect *Rect2)

	SetCanvasTransform(xform *Transform2D)

	SetClearMode(mode int64)

	SetDebugDraw(debugDraw int64)

	SetDisable3D(disable *bool)

	SetDisableInput(disable *bool)

	SetGlobalCanvasTransform(xform *Transform2D)

	SetHdr(enable *bool)

	SetMsaa(msaa int64)

	SetPhysicsObjectPicking(enable *bool)

	SetShadowAtlasQuadrantSubdiv(quadrant int64, subdiv int64)

	SetShadowAtlasSize(size int64)

	SetSize(size *Vector2)

	SetSizeOverride(enable *bool, size *Vector2, margin *Vector2)

	SetSizeOverrideStretch(enabled *bool)

	SetTransparentBackground(enable *bool)

	SetUpdateMode(mode int64)

	SetUsage(usage int64)

	SetUseArvr(use *bool)

	SetUseOwnWorld(enable *bool)

	SetVflip(enable *bool)

	SetWorld(world *World)

	SetWorld2D(world2D *World2D)

	UnhandledInput(localEvent *InputEvent)

	UpdateWorlds()

	UseArvr() *bool

	WarpMouse(toPos *Vector2)
}

/*

 */
type ViewportContainer struct {
	Container
}

func (o *ViewportContainer) baseClass() string {
	return "ViewportContainer"
}

/*

 */
func (o *ViewportContainer) IsStretchEnabled() *bool {
	log.Println("Calling ViewportContainer.IsStretchEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_stretch_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *ViewportContainer) SetStretch(enable *bool) {
	log.Println("Calling ViewportContainer.SetStretch()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_stretch", goArguments, "")

	log.Println("Got return value!")

}

/*
   ViewportContainerImplementer is an interface for ViewportContainer objects.

*/
type ViewportContainerImplementer interface {
	ContainerImplementer

	IsStretchEnabled() *bool

	SetStretch(enable *bool)
}

/*

 */
type ViewportTexture struct {
	Texture
}

func (o *ViewportTexture) baseClass() string {
	return "ViewportTexture"
}

/*

 */
func (o *ViewportTexture) GetViewportPathInScene() *NodePath {
	log.Println("Calling ViewportTexture.GetViewportPathInScene()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_viewport_path_in_scene", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *ViewportTexture) SetViewportPathInScene(path *NodePath) {
	log.Println("Calling ViewportTexture.SetViewportPathInScene()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_viewport_path_in_scene", goArguments, "")

	log.Println("Got return value!")

}

/*
   ViewportTextureImplementer is an interface for ViewportTexture objects.

*/
type ViewportTextureImplementer interface {
	TextureImplementer

	GetViewportPathInScene() *NodePath

	SetViewportPathInScene(path *NodePath)
}

/*
   The VisibilityEnabler will disable [RigidBody] and [AnimationPlayer] nodes when they are not visible. It will only affect other nodes within the same scene as the VisibilityEnabler itself.
*/
type VisibilityEnabler struct {
	VisibilityNotifier
}

func (o *VisibilityEnabler) baseClass() string {
	return "VisibilityEnabler"
}

/*
   Returns whether the specified enabler was set to true or not.
*/
func (o *VisibilityEnabler) IsEnablerEnabled(enabler int64) *bool {
	log.Println("Calling VisibilityEnabler.IsEnablerEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabler)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_enabler_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Set an enabler to true for all nodes of its type to be disabled when the VisibilityEnabler is not in view. See the constants for enablers and what they affect.
*/
func (o *VisibilityEnabler) SetEnabler(enabler int64, enabled *bool) {
	log.Println("Calling VisibilityEnabler.SetEnabler()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(enabler)
	goArguments[1] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_enabler", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisibilityEnablerImplementer is an interface for VisibilityEnabler objects.
   The VisibilityEnabler will disable [RigidBody] and [AnimationPlayer] nodes when they are not visible. It will only affect other nodes within the same scene as the VisibilityEnabler itself.
*/
type VisibilityEnablerImplementer interface {
	VisibilityNotifierImplementer

	IsEnablerEnabled(enabler int64) *bool

	SetEnabler(enabler int64, enabled *bool)
}

/*
   The VisibilityEnabler2D will disable [RigidBody2D], [AnimationPlayer], and other nodes when they are not visible. It will only affect other nodes within the same scene as the VisibilityEnabler2D itself.
*/
type VisibilityEnabler2D struct {
	VisibilityNotifier2D
}

func (o *VisibilityEnabler2D) baseClass() string {
	return "VisibilityEnabler2D"
}

/*
   Returns whether the specified enabler was set to true or not.
*/
func (o *VisibilityEnabler2D) IsEnablerEnabled(enabler int64) *bool {
	log.Println("Calling VisibilityEnabler2D.IsEnablerEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabler)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_enabler_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Set an enabler to true for all nodes of its type to be disabled when the VisibilityEnabler2D is not in view. See the constants for enablers and what they affect.
*/
func (o *VisibilityEnabler2D) SetEnabler(enabler int64, enabled *bool) {
	log.Println("Calling VisibilityEnabler2D.SetEnabler()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(enabler)
	goArguments[1] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_enabler", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisibilityEnabler2DImplementer is an interface for VisibilityEnabler2D objects.
   The VisibilityEnabler2D will disable [RigidBody2D], [AnimationPlayer], and other nodes when they are not visible. It will only affect other nodes within the same scene as the VisibilityEnabler2D itself.
*/
type VisibilityEnabler2DImplementer interface {
	VisibilityNotifier2DImplementer

	IsEnablerEnabled(enabler int64) *bool

	SetEnabler(enabler int64, enabled *bool)
}

/*
   The VisibilityNotifier is used to notify when its bounding box enters the screen, is visible on the screen, or when it exits the screen.
*/
type VisibilityNotifier struct {
	Spatial
}

func (o *VisibilityNotifier) baseClass() string {
	return "VisibilityNotifier"
}

/*
   Return the visibility bounding box of the VisibilityNotifier.
*/
func (o *VisibilityNotifier) GetAabb() *Rect3 {
	log.Println("Calling VisibilityNotifier.GetAabb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_aabb", goArguments, "*Rect3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect3)

	return returnValue

}

/*
   Return true if any part of the bounding box is on the screen.
*/
func (o *VisibilityNotifier) IsOnScreen() *bool {
	log.Println("Calling VisibilityNotifier.IsOnScreen()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_on_screen", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Set the visibility bounding box of the VisibilityNotifier.
*/
func (o *VisibilityNotifier) SetAabb(rect *Rect3) {
	log.Println("Calling VisibilityNotifier.SetAabb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rect)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_aabb", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisibilityNotifierImplementer is an interface for VisibilityNotifier objects.
   The VisibilityNotifier is used to notify when its bounding box enters the screen, is visible on the screen, or when it exits the screen.
*/
type VisibilityNotifierImplementer interface {
	SpatialImplementer

	GetAabb() *Rect3

	IsOnScreen() *bool

	SetAabb(rect *Rect3)
}

/*
   The VisibilityNotifier2D is used to notify when its bounding rectangle enters the screen, is visible on the screen, or when it exits the screen.
*/
type VisibilityNotifier2D struct {
	Node2D
}

func (o *VisibilityNotifier2D) baseClass() string {
	return "VisibilityNotifier2D"
}

/*
   Return the visibility bounding rectangle of the VisibilityNotifier2D.
*/
func (o *VisibilityNotifier2D) GetRect() *Rect2 {
	log.Println("Calling VisibilityNotifier2D.GetRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rect", goArguments, "*Rect2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect2)

	return returnValue

}

/*
   Return true if any part of the bounding rectangle is on the screen.
*/
func (o *VisibilityNotifier2D) IsOnScreen() *bool {
	log.Println("Calling VisibilityNotifier2D.IsOnScreen()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_on_screen", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Set the visibility bounding rectangle of the VisibilityNotifier2D.
*/
func (o *VisibilityNotifier2D) SetRect(rect *Rect2) {
	log.Println("Calling VisibilityNotifier2D.SetRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(rect)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rect", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisibilityNotifier2DImplementer is an interface for VisibilityNotifier2D objects.
   The VisibilityNotifier2D is used to notify when its bounding rectangle enters the screen, is visible on the screen, or when it exits the screen.
*/
type VisibilityNotifier2DImplementer interface {
	Node2DImplementer

	GetRect() *Rect2

	IsOnScreen() *bool

	SetRect(rect *Rect2)
}

/*

 */
type VisualInstance struct {
	Spatial
}

func (o *VisualInstance) baseClass() string {
	return "VisualInstance"
}

/*

 */
func (o *VisualInstance) GetAabb() *Rect3 {
	log.Println("Calling VisualInstance.GetAabb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_aabb", goArguments, "*Rect3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect3)

	return returnValue

}

/*

 */
func (o *VisualInstance) GetLayerMask() int64 {
	log.Println("Calling VisualInstance.GetLayerMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_layer_mask", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualInstance) GetTransformedAabb() *Rect3 {
	log.Println("Calling VisualInstance.GetTransformedAabb()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_transformed_aabb", goArguments, "*Rect3")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Rect3)

	return returnValue

}

/*

 */
func (o *VisualInstance) SetBase(base *RID) {
	log.Println("Calling VisualInstance.SetBase()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(base)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualInstance) SetLayerMask(mask int64) {
	log.Println("Calling VisualInstance.SetLayerMask()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mask)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_layer_mask", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualInstanceImplementer is an interface for VisualInstance objects.

*/
type VisualInstanceImplementer interface {
	SpatialImplementer

	GetAabb() *Rect3

	GetLayerMask() int64

	GetTransformedAabb() *Rect3

	SetBase(base *RID)

	SetLayerMask(mask int64)
}

/*

 */
type VisualScript struct {
	Script
}

func (o *VisualScript) baseClass() string {
	return "VisualScript"
}

/*

 */
func (o *VisualScript) AddCustomSignal(name string) {
	log.Println("Calling VisualScript.AddCustomSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_custom_signal", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) AddFunction(name string) {
	log.Println("Calling VisualScript.AddFunction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_function", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) AddNode(function string, id int64, node *VisualScriptNode, pos *Vector2) {
	log.Println("Calling VisualScript.AddNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(function)
	goArguments[1] = reflect.ValueOf(id)
	goArguments[2] = reflect.ValueOf(node)
	goArguments[3] = reflect.ValueOf(pos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_node", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) AddVariable(name string, defaultValue *Variant, export *bool) {
	log.Println("Calling VisualScript.AddVariable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(defaultValue)
	goArguments[2] = reflect.ValueOf(export)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "add_variable", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) CustomSignalAddArgument(name string, aType int64, argname string, index int64) {
	log.Println("Calling VisualScript.CustomSignalAddArgument()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)
	goArguments[2] = reflect.ValueOf(argname)
	goArguments[3] = reflect.ValueOf(index)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "custom_signal_add_argument", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) CustomSignalGetArgumentCount(name string) int64 {
	log.Println("Calling VisualScript.CustomSignalGetArgumentCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "custom_signal_get_argument_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScript) CustomSignalGetArgumentName(name string, argidx int64) string {
	log.Println("Calling VisualScript.CustomSignalGetArgumentName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(argidx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "custom_signal_get_argument_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScript) CustomSignalGetArgumentType(name string, argidx int64) int64 {
	log.Println("Calling VisualScript.CustomSignalGetArgumentType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(argidx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "custom_signal_get_argument_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScript) CustomSignalRemoveArgument(name string, argidx int64) {
	log.Println("Calling VisualScript.CustomSignalRemoveArgument()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(argidx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "custom_signal_remove_argument", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) CustomSignalSetArgumentName(name string, argidx int64, argname string) {
	log.Println("Calling VisualScript.CustomSignalSetArgumentName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(argidx)
	goArguments[2] = reflect.ValueOf(argname)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "custom_signal_set_argument_name", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) CustomSignalSetArgumentType(name string, argidx int64, aType int64) {
	log.Println("Calling VisualScript.CustomSignalSetArgumentType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(argidx)
	goArguments[2] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "custom_signal_set_argument_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) CustomSignalSwapArgument(name string, argidx int64, withidx int64) {
	log.Println("Calling VisualScript.CustomSignalSwapArgument()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(argidx)
	goArguments[2] = reflect.ValueOf(withidx)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "custom_signal_swap_argument", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) DataConnect(function string, fromNode int64, fromPort int64, toNode int64, toPort int64) {
	log.Println("Calling VisualScript.DataConnect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(function)
	goArguments[1] = reflect.ValueOf(fromNode)
	goArguments[2] = reflect.ValueOf(fromPort)
	goArguments[3] = reflect.ValueOf(toNode)
	goArguments[4] = reflect.ValueOf(toPort)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "data_connect", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) DataDisconnect(function string, fromNode int64, fromPort int64, toNode int64, toPort int64) {
	log.Println("Calling VisualScript.DataDisconnect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(function)
	goArguments[1] = reflect.ValueOf(fromNode)
	goArguments[2] = reflect.ValueOf(fromPort)
	goArguments[3] = reflect.ValueOf(toNode)
	goArguments[4] = reflect.ValueOf(toPort)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "data_disconnect", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) GetFunctionNodeId(name string) int64 {
	log.Println("Calling VisualScript.GetFunctionNodeId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_function_node_id", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScript) GetFunctionScroll(name string) *Vector2 {
	log.Println("Calling VisualScript.GetFunctionScroll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_function_scroll", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *VisualScript) GetNode(function string, id int64) *VisualScriptNode {
	log.Println("Calling VisualScript.GetNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(function)
	goArguments[1] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node", goArguments, "*VisualScriptNode")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*VisualScriptNode)

	return returnValue

}

/*

 */
func (o *VisualScript) GetNodePos(function string, id int64) *Vector2 {
	log.Println("Calling VisualScript.GetNodePos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(function)
	goArguments[1] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_pos", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *VisualScript) GetVariableDefaultValue(name string) *Variant {
	log.Println("Calling VisualScript.GetVariableDefaultValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_variable_default_value", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *VisualScript) GetVariableExport(name string) *bool {
	log.Println("Calling VisualScript.GetVariableExport()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_variable_export", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *VisualScript) GetVariableInfo(name string) *Dictionary {
	log.Println("Calling VisualScript.GetVariableInfo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_variable_info", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*

 */
func (o *VisualScript) HasCustomSignal(name string) *bool {
	log.Println("Calling VisualScript.HasCustomSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_custom_signal", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *VisualScript) HasDataConnection(function string, fromNode int64, fromPort int64, toNode int64, toPort int64) *bool {
	log.Println("Calling VisualScript.HasDataConnection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(function)
	goArguments[1] = reflect.ValueOf(fromNode)
	goArguments[2] = reflect.ValueOf(fromPort)
	goArguments[3] = reflect.ValueOf(toNode)
	goArguments[4] = reflect.ValueOf(toPort)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_data_connection", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *VisualScript) HasFunction(name string) *bool {
	log.Println("Calling VisualScript.HasFunction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_function", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *VisualScript) HasNode(function string, id int64) *bool {
	log.Println("Calling VisualScript.HasNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(function)
	goArguments[1] = reflect.ValueOf(id)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_node", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *VisualScript) HasSequenceConnection(function string, fromNode int64, fromOutput int64, toNode int64) *bool {
	log.Println("Calling VisualScript.HasSequenceConnection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(function)
	goArguments[1] = reflect.ValueOf(fromNode)
	goArguments[2] = reflect.ValueOf(fromOutput)
	goArguments[3] = reflect.ValueOf(toNode)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_sequence_connection", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *VisualScript) HasVariable(name string) *bool {
	log.Println("Calling VisualScript.HasVariable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_variable", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *VisualScript) RemoveCustomSignal(name string) {
	log.Println("Calling VisualScript.RemoveCustomSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_custom_signal", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) RemoveFunction(name string) {
	log.Println("Calling VisualScript.RemoveFunction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_function", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) RemoveNode(function string, id int64) {
	log.Println("Calling VisualScript.RemoveNode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(function)
	goArguments[1] = reflect.ValueOf(id)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_node", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) RemoveVariable(name string) {
	log.Println("Calling VisualScript.RemoveVariable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "remove_variable", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) RenameCustomSignal(name string, newName string) {
	log.Println("Calling VisualScript.RenameCustomSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(newName)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rename_custom_signal", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) RenameFunction(name string, newName string) {
	log.Println("Calling VisualScript.RenameFunction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(newName)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rename_function", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) RenameVariable(name string, newName string) {
	log.Println("Calling VisualScript.RenameVariable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(newName)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "rename_variable", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) SequenceConnect(function string, fromNode int64, fromOutput int64, toNode int64) {
	log.Println("Calling VisualScript.SequenceConnect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(function)
	goArguments[1] = reflect.ValueOf(fromNode)
	goArguments[2] = reflect.ValueOf(fromOutput)
	goArguments[3] = reflect.ValueOf(toNode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "sequence_connect", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) SequenceDisconnect(function string, fromNode int64, fromOutput int64, toNode int64) {
	log.Println("Calling VisualScript.SequenceDisconnect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(function)
	goArguments[1] = reflect.ValueOf(fromNode)
	goArguments[2] = reflect.ValueOf(fromOutput)
	goArguments[3] = reflect.ValueOf(toNode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "sequence_disconnect", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) SetFunctionScroll(name string, ofs *Vector2) {
	log.Println("Calling VisualScript.SetFunctionScroll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(ofs)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_function_scroll", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) SetInstanceBaseType(aType string) {
	log.Println("Calling VisualScript.SetInstanceBaseType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_instance_base_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) SetNodePos(function string, id int64, pos *Vector2) {
	log.Println("Calling VisualScript.SetNodePos()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(function)
	goArguments[1] = reflect.ValueOf(id)
	goArguments[2] = reflect.ValueOf(pos)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_node_pos", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) SetVariableDefaultValue(name string, value *Variant) {
	log.Println("Calling VisualScript.SetVariableDefaultValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_variable_default_value", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) SetVariableExport(name string, enable *bool) {
	log.Println("Calling VisualScript.SetVariableExport()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_variable_export", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScript) SetVariableInfo(name string, value *Dictionary) {
	log.Println("Calling VisualScript.SetVariableInfo()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_variable_info", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptImplementer is an interface for VisualScript objects.

*/
type VisualScriptImplementer interface {
	ScriptImplementer

	AddCustomSignal(name string)

	AddFunction(name string)

	AddNode(function string, id int64, node *VisualScriptNode, pos *Vector2)

	AddVariable(name string, defaultValue *Variant, export *bool)

	CustomSignalAddArgument(name string, aType int64, argname string, index int64)

	CustomSignalGetArgumentCount(name string) int64

	CustomSignalGetArgumentName(name string, argidx int64) string

	CustomSignalGetArgumentType(name string, argidx int64) int64

	CustomSignalRemoveArgument(name string, argidx int64)

	CustomSignalSetArgumentName(name string, argidx int64, argname string)

	CustomSignalSetArgumentType(name string, argidx int64, aType int64)

	CustomSignalSwapArgument(name string, argidx int64, withidx int64)

	DataConnect(function string, fromNode int64, fromPort int64, toNode int64, toPort int64)

	DataDisconnect(function string, fromNode int64, fromPort int64, toNode int64, toPort int64)

	GetFunctionNodeId(name string) int64

	GetFunctionScroll(name string) *Vector2

	GetNode(function string, id int64) *VisualScriptNode

	GetNodePos(function string, id int64) *Vector2

	GetVariableDefaultValue(name string) *Variant

	GetVariableExport(name string) *bool

	GetVariableInfo(name string) *Dictionary

	HasCustomSignal(name string) *bool

	HasDataConnection(function string, fromNode int64, fromPort int64, toNode int64, toPort int64) *bool

	HasFunction(name string) *bool

	HasNode(function string, id int64) *bool

	HasSequenceConnection(function string, fromNode int64, fromOutput int64, toNode int64) *bool

	HasVariable(name string) *bool

	RemoveCustomSignal(name string)

	RemoveFunction(name string)

	RemoveNode(function string, id int64)

	RemoveVariable(name string)

	RenameCustomSignal(name string, newName string)

	RenameFunction(name string, newName string)

	RenameVariable(name string, newName string)

	SequenceConnect(function string, fromNode int64, fromOutput int64, toNode int64)

	SequenceDisconnect(function string, fromNode int64, fromOutput int64, toNode int64)

	SetFunctionScroll(name string, ofs *Vector2)

	SetInstanceBaseType(aType string)

	SetNodePos(function string, id int64, pos *Vector2)

	SetVariableDefaultValue(name string, value *Variant)

	SetVariableExport(name string, enable *bool)

	SetVariableInfo(name string, value *Dictionary)
}

/*

 */
type VisualScriptBasicTypeConstant struct {
	VisualScriptNode
}

func (o *VisualScriptBasicTypeConstant) baseClass() string {
	return "VisualScriptBasicTypeConstant"
}

/*

 */
func (o *VisualScriptBasicTypeConstant) GetBasicType() int64 {
	log.Println("Calling VisualScriptBasicTypeConstant.GetBasicType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_basic_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptBasicTypeConstant) GetBasicTypeConstant() string {
	log.Println("Calling VisualScriptBasicTypeConstant.GetBasicTypeConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_basic_type_constant", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptBasicTypeConstant) SetBasicType(name int64) {
	log.Println("Calling VisualScriptBasicTypeConstant.SetBasicType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_basic_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptBasicTypeConstant) SetBasicTypeConstant(name string) {
	log.Println("Calling VisualScriptBasicTypeConstant.SetBasicTypeConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_basic_type_constant", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptBasicTypeConstantImplementer is an interface for VisualScriptBasicTypeConstant objects.

*/
type VisualScriptBasicTypeConstantImplementer interface {
	VisualScriptNodeImplementer

	GetBasicType() int64

	GetBasicTypeConstant() string

	SetBasicType(name int64)

	SetBasicTypeConstant(name string)
}

/*

 */
type VisualScriptBuiltinFunc struct {
	VisualScriptNode
}

func (o *VisualScriptBuiltinFunc) baseClass() string {
	return "VisualScriptBuiltinFunc"
}

/*

 */
func (o *VisualScriptBuiltinFunc) GetFunc() int64 {
	log.Println("Calling VisualScriptBuiltinFunc.GetFunc()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_func", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptBuiltinFunc) SetFunc(which int64) {
	log.Println("Calling VisualScriptBuiltinFunc.SetFunc()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(which)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_func", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptBuiltinFuncImplementer is an interface for VisualScriptBuiltinFunc objects.

*/
type VisualScriptBuiltinFuncImplementer interface {
	VisualScriptNodeImplementer

	GetFunc() int64

	SetFunc(which int64)
}

/*

 */
type VisualScriptClassConstant struct {
	VisualScriptNode
}

func (o *VisualScriptClassConstant) baseClass() string {
	return "VisualScriptClassConstant"
}

/*

 */
func (o *VisualScriptClassConstant) GetBaseType() string {
	log.Println("Calling VisualScriptClassConstant.GetBaseType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_type", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptClassConstant) GetClassConstant() string {
	log.Println("Calling VisualScriptClassConstant.GetClassConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_class_constant", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptClassConstant) SetBaseType(name string) {
	log.Println("Calling VisualScriptClassConstant.SetBaseType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptClassConstant) SetClassConstant(name string) {
	log.Println("Calling VisualScriptClassConstant.SetClassConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_class_constant", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptClassConstantImplementer is an interface for VisualScriptClassConstant objects.

*/
type VisualScriptClassConstantImplementer interface {
	VisualScriptNodeImplementer

	GetBaseType() string

	GetClassConstant() string

	SetBaseType(name string)

	SetClassConstant(name string)
}

/*

 */
type VisualScriptComment struct {
	VisualScriptNode
}

func (o *VisualScriptComment) baseClass() string {
	return "VisualScriptComment"
}

/*

 */
func (o *VisualScriptComment) GetDescription() string {
	log.Println("Calling VisualScriptComment.GetDescription()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_description", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptComment) GetSize() *Vector2 {
	log.Println("Calling VisualScriptComment.GetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_size", goArguments, "*Vector2")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Vector2)

	return returnValue

}

/*

 */
func (o *VisualScriptComment) GetTitle() string {
	log.Println("Calling VisualScriptComment.GetTitle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_title", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptComment) SetDescription(description string) {
	log.Println("Calling VisualScriptComment.SetDescription()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(description)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_description", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptComment) SetSize(size *Vector2) {
	log.Println("Calling VisualScriptComment.SetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_size", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptComment) SetTitle(title string) {
	log.Println("Calling VisualScriptComment.SetTitle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(title)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_title", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptCommentImplementer is an interface for VisualScriptComment objects.

*/
type VisualScriptCommentImplementer interface {
	VisualScriptNodeImplementer

	GetDescription() string

	GetSize() *Vector2

	GetTitle() string

	SetDescription(description string)

	SetSize(size *Vector2)

	SetTitle(title string)
}

/*

 */
type VisualScriptCondition struct {
	VisualScriptNode
}

func (o *VisualScriptCondition) baseClass() string {
	return "VisualScriptCondition"
}

/*
   VisualScriptConditionImplementer is an interface for VisualScriptCondition objects.

*/
type VisualScriptConditionImplementer interface {
	VisualScriptNodeImplementer
}

/*

 */
type VisualScriptConstant struct {
	VisualScriptNode
}

func (o *VisualScriptConstant) baseClass() string {
	return "VisualScriptConstant"
}

/*

 */
func (o *VisualScriptConstant) GetConstantType() int64 {
	log.Println("Calling VisualScriptConstant.GetConstantType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_constant_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptConstant) GetConstantValue() *Variant {
	log.Println("Calling VisualScriptConstant.GetConstantValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_constant_value", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *VisualScriptConstant) SetConstantType(aType int64) {
	log.Println("Calling VisualScriptConstant.SetConstantType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_constant_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptConstant) SetConstantValue(value *Variant) {
	log.Println("Calling VisualScriptConstant.SetConstantValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_constant_value", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptConstantImplementer is an interface for VisualScriptConstant objects.

*/
type VisualScriptConstantImplementer interface {
	VisualScriptNodeImplementer

	GetConstantType() int64

	GetConstantValue() *Variant

	SetConstantType(aType int64)

	SetConstantValue(value *Variant)
}

/*

 */
type VisualScriptConstructor struct {
	VisualScriptNode
}

func (o *VisualScriptConstructor) baseClass() string {
	return "VisualScriptConstructor"
}

/*

 */
func (o *VisualScriptConstructor) GetConstructor() *Dictionary {
	log.Println("Calling VisualScriptConstructor.GetConstructor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_constructor", goArguments, "*Dictionary")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Dictionary)

	return returnValue

}

/*

 */
func (o *VisualScriptConstructor) GetConstructorType() int64 {
	log.Println("Calling VisualScriptConstructor.GetConstructorType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_constructor_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptConstructor) SetConstructor(constructor *Dictionary) {
	log.Println("Calling VisualScriptConstructor.SetConstructor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(constructor)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_constructor", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptConstructor) SetConstructorType(aType int64) {
	log.Println("Calling VisualScriptConstructor.SetConstructorType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_constructor_type", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptConstructorImplementer is an interface for VisualScriptConstructor objects.

*/
type VisualScriptConstructorImplementer interface {
	VisualScriptNodeImplementer

	GetConstructor() *Dictionary

	GetConstructorType() int64

	SetConstructor(constructor *Dictionary)

	SetConstructorType(aType int64)
}

/*

 */
type VisualScriptCustomNode struct {
	VisualScriptNode
}

func (o *VisualScriptCustomNode) baseClass() string {
	return "VisualScriptCustomNode"
}

/*

 */
func (o *VisualScriptCustomNode) X_GetCaption() string {
	log.Println("Calling VisualScriptCustomNode.X_GetCaption()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_caption", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptCustomNode) X_GetCategory() string {
	log.Println("Calling VisualScriptCustomNode.X_GetCategory()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_category", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptCustomNode) X_GetInputValuePortCount() int64 {
	log.Println("Calling VisualScriptCustomNode.X_GetInputValuePortCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_input_value_port_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptCustomNode) X_GetInputValuePortName(idx int64) string {
	log.Println("Calling VisualScriptCustomNode.X_GetInputValuePortName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_input_value_port_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptCustomNode) X_GetInputValuePortType(idx int64) int64 {
	log.Println("Calling VisualScriptCustomNode.X_GetInputValuePortType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_input_value_port_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptCustomNode) X_GetOutputSequencePortCount() int64 {
	log.Println("Calling VisualScriptCustomNode.X_GetOutputSequencePortCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_output_sequence_port_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptCustomNode) X_GetOutputSequencePortText(idx int64) string {
	log.Println("Calling VisualScriptCustomNode.X_GetOutputSequencePortText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_output_sequence_port_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptCustomNode) X_GetOutputValuePortCount() int64 {
	log.Println("Calling VisualScriptCustomNode.X_GetOutputValuePortCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_output_value_port_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptCustomNode) X_GetOutputValuePortName(idx int64) string {
	log.Println("Calling VisualScriptCustomNode.X_GetOutputValuePortName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_output_value_port_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptCustomNode) X_GetOutputValuePortType(idx int64) int64 {
	log.Println("Calling VisualScriptCustomNode.X_GetOutputValuePortType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_output_value_port_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptCustomNode) X_GetText() string {
	log.Println("Calling VisualScriptCustomNode.X_GetText()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_text", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptCustomNode) X_GetWorkingMemorySize() int64 {
	log.Println("Calling VisualScriptCustomNode.X_GetWorkingMemorySize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_get_working_memory_size", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptCustomNode) X_HasInputSequencePort() *bool {
	log.Println("Calling VisualScriptCustomNode.X_HasInputSequencePort()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_has_input_sequence_port", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *VisualScriptCustomNode) X_Step(inputs *Array, outputs *Array, startMode int64, workingMem *Array) *Variant {
	log.Println("Calling VisualScriptCustomNode.X_Step()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(inputs)
	goArguments[1] = reflect.ValueOf(outputs)
	goArguments[2] = reflect.ValueOf(startMode)
	goArguments[3] = reflect.ValueOf(workingMem)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_step", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   VisualScriptCustomNodeImplementer is an interface for VisualScriptCustomNode objects.

*/
type VisualScriptCustomNodeImplementer interface {
	VisualScriptNodeImplementer

	X_GetCaption() string

	X_GetCategory() string

	X_GetInputValuePortCount() int64

	X_GetInputValuePortName(idx int64) string

	X_GetInputValuePortType(idx int64) int64

	X_GetOutputSequencePortCount() int64

	X_GetOutputSequencePortText(idx int64) string

	X_GetOutputValuePortCount() int64

	X_GetOutputValuePortName(idx int64) string

	X_GetOutputValuePortType(idx int64) int64

	X_GetText() string

	X_GetWorkingMemorySize() int64

	X_HasInputSequencePort() *bool

	X_Step(inputs *Array, outputs *Array, startMode int64, workingMem *Array) *Variant
}

/*

 */
type VisualScriptDeconstruct struct {
	VisualScriptNode
}

func (o *VisualScriptDeconstruct) baseClass() string {
	return "VisualScriptDeconstruct"
}

/*

 */
func (o *VisualScriptDeconstruct) GetDeconstructType() int64 {
	log.Println("Calling VisualScriptDeconstruct.GetDeconstructType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_deconstruct_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptDeconstruct) SetDeconstructType(aType int64) {
	log.Println("Calling VisualScriptDeconstruct.SetDeconstructType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_deconstruct_type", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptDeconstructImplementer is an interface for VisualScriptDeconstruct objects.

*/
type VisualScriptDeconstructImplementer interface {
	VisualScriptNodeImplementer

	GetDeconstructType() int64

	SetDeconstructType(aType int64)
}

/*

 */
type VisualScriptEmitSignal struct {
	VisualScriptNode
}

func (o *VisualScriptEmitSignal) baseClass() string {
	return "VisualScriptEmitSignal"
}

/*

 */
func (o *VisualScriptEmitSignal) GetSignal() string {
	log.Println("Calling VisualScriptEmitSignal.GetSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_signal", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptEmitSignal) SetSignal(name string) {
	log.Println("Calling VisualScriptEmitSignal.SetSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_signal", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptEmitSignalImplementer is an interface for VisualScriptEmitSignal objects.

*/
type VisualScriptEmitSignalImplementer interface {
	VisualScriptNodeImplementer

	GetSignal() string

	SetSignal(name string)
}

/*

 */
type VisualScriptEngineSingleton struct {
	VisualScriptNode
}

func (o *VisualScriptEngineSingleton) baseClass() string {
	return "VisualScriptEngineSingleton"
}

/*

 */
func (o *VisualScriptEngineSingleton) GetSingleton() string {
	log.Println("Calling VisualScriptEngineSingleton.GetSingleton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_singleton", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptEngineSingleton) SetSingleton(name string) {
	log.Println("Calling VisualScriptEngineSingleton.SetSingleton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_singleton", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptEngineSingletonImplementer is an interface for VisualScriptEngineSingleton objects.

*/
type VisualScriptEngineSingletonImplementer interface {
	VisualScriptNodeImplementer

	GetSingleton() string

	SetSingleton(name string)
}

/*

 */
type VisualScriptExpression struct {
	VisualScriptNode
}

func (o *VisualScriptExpression) baseClass() string {
	return "VisualScriptExpression"
}

/*
   VisualScriptExpressionImplementer is an interface for VisualScriptExpression objects.

*/
type VisualScriptExpressionImplementer interface {
	VisualScriptNodeImplementer
}

/*

 */
type VisualScriptFunction struct {
	VisualScriptNode
}

func (o *VisualScriptFunction) baseClass() string {
	return "VisualScriptFunction"
}

/*
   VisualScriptFunctionImplementer is an interface for VisualScriptFunction objects.

*/
type VisualScriptFunctionImplementer interface {
	VisualScriptNodeImplementer
}

/*

 */
type VisualScriptFunctionCall struct {
	VisualScriptNode
}

func (o *VisualScriptFunctionCall) baseClass() string {
	return "VisualScriptFunctionCall"
}

/*

 */
func (o *VisualScriptFunctionCall) GetBasePath() *NodePath {
	log.Println("Calling VisualScriptFunctionCall.GetBasePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_path", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *VisualScriptFunctionCall) GetBaseScript() string {
	log.Println("Calling VisualScriptFunctionCall.GetBaseScript()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_script", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptFunctionCall) GetBaseType() string {
	log.Println("Calling VisualScriptFunctionCall.GetBaseType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_type", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptFunctionCall) GetBasicType() int64 {
	log.Println("Calling VisualScriptFunctionCall.GetBasicType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_basic_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptFunctionCall) GetCallMode() int64 {
	log.Println("Calling VisualScriptFunctionCall.GetCallMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_call_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptFunctionCall) GetFunction() string {
	log.Println("Calling VisualScriptFunctionCall.GetFunction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_function", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptFunctionCall) GetRpcCallMode() int64 {
	log.Println("Calling VisualScriptFunctionCall.GetRpcCallMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_rpc_call_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptFunctionCall) GetSingleton() string {
	log.Println("Calling VisualScriptFunctionCall.GetSingleton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_singleton", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptFunctionCall) GetUseDefaultArgs() int64 {
	log.Println("Calling VisualScriptFunctionCall.GetUseDefaultArgs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_use_default_args", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptFunctionCall) GetValidate() *bool {
	log.Println("Calling VisualScriptFunctionCall.GetValidate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_validate", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *VisualScriptFunctionCall) SetBasePath(basePath *NodePath) {
	log.Println("Calling VisualScriptFunctionCall.SetBasePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(basePath)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_path", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptFunctionCall) SetBaseScript(baseScript string) {
	log.Println("Calling VisualScriptFunctionCall.SetBaseScript()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(baseScript)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_script", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptFunctionCall) SetBaseType(baseType string) {
	log.Println("Calling VisualScriptFunctionCall.SetBaseType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(baseType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptFunctionCall) SetBasicType(basicType int64) {
	log.Println("Calling VisualScriptFunctionCall.SetBasicType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(basicType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_basic_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptFunctionCall) SetCallMode(mode int64) {
	log.Println("Calling VisualScriptFunctionCall.SetCallMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_call_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptFunctionCall) SetFunction(function string) {
	log.Println("Calling VisualScriptFunctionCall.SetFunction()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(function)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_function", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptFunctionCall) SetRpcCallMode(mode int64) {
	log.Println("Calling VisualScriptFunctionCall.SetRpcCallMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_rpc_call_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptFunctionCall) SetSingleton(singleton string) {
	log.Println("Calling VisualScriptFunctionCall.SetSingleton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(singleton)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_singleton", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptFunctionCall) SetUseDefaultArgs(amount int64) {
	log.Println("Calling VisualScriptFunctionCall.SetUseDefaultArgs()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(amount)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_use_default_args", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptFunctionCall) SetValidate(enable *bool) {
	log.Println("Calling VisualScriptFunctionCall.SetValidate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_validate", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptFunctionCallImplementer is an interface for VisualScriptFunctionCall objects.

*/
type VisualScriptFunctionCallImplementer interface {
	VisualScriptNodeImplementer

	GetBasePath() *NodePath

	GetBaseScript() string

	GetBaseType() string

	GetBasicType() int64

	GetCallMode() int64

	GetFunction() string

	GetRpcCallMode() int64

	GetSingleton() string

	GetUseDefaultArgs() int64

	GetValidate() *bool

	SetBasePath(basePath *NodePath)

	SetBaseScript(baseScript string)

	SetBaseType(baseType string)

	SetBasicType(basicType int64)

	SetCallMode(mode int64)

	SetFunction(function string)

	SetRpcCallMode(mode int64)

	SetSingleton(singleton string)

	SetUseDefaultArgs(amount int64)

	SetValidate(enable *bool)
}

/*

 */
type VisualScriptFunctionState struct {
	Reference
}

func (o *VisualScriptFunctionState) baseClass() string {
	return "VisualScriptFunctionState"
}

/*

 */
func (o *VisualScriptFunctionState) ConnectToSignal(obj *Object, signals string, args *Array) {
	log.Println("Calling VisualScriptFunctionState.ConnectToSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(obj)
	goArguments[1] = reflect.ValueOf(signals)
	goArguments[2] = reflect.ValueOf(args)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "connect_to_signal", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptFunctionState) IsValid() *bool {
	log.Println("Calling VisualScriptFunctionState.IsValid()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_valid", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *VisualScriptFunctionState) Resume(args *Array) *Variant {
	log.Println("Calling VisualScriptFunctionState.Resume()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(args)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "resume", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   VisualScriptFunctionStateImplementer is an interface for VisualScriptFunctionState objects.

*/
type VisualScriptFunctionStateImplementer interface {
	ReferenceImplementer

	ConnectToSignal(obj *Object, signals string, args *Array)

	IsValid() *bool

	Resume(args *Array) *Variant
}

/*

 */
type VisualScriptGlobalConstant struct {
	VisualScriptNode
}

func (o *VisualScriptGlobalConstant) baseClass() string {
	return "VisualScriptGlobalConstant"
}

/*

 */
func (o *VisualScriptGlobalConstant) GetGlobalConstant() int64 {
	log.Println("Calling VisualScriptGlobalConstant.GetGlobalConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_global_constant", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptGlobalConstant) SetGlobalConstant(index int64) {
	log.Println("Calling VisualScriptGlobalConstant.SetGlobalConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_global_constant", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptGlobalConstantImplementer is an interface for VisualScriptGlobalConstant objects.

*/
type VisualScriptGlobalConstantImplementer interface {
	VisualScriptNodeImplementer

	GetGlobalConstant() int64

	SetGlobalConstant(index int64)
}

/*

 */
type VisualScriptIndexGet struct {
	VisualScriptNode
}

func (o *VisualScriptIndexGet) baseClass() string {
	return "VisualScriptIndexGet"
}

/*
   VisualScriptIndexGetImplementer is an interface for VisualScriptIndexGet objects.

*/
type VisualScriptIndexGetImplementer interface {
	VisualScriptNodeImplementer
}

/*

 */
type VisualScriptIndexSet struct {
	VisualScriptNode
}

func (o *VisualScriptIndexSet) baseClass() string {
	return "VisualScriptIndexSet"
}

/*
   VisualScriptIndexSetImplementer is an interface for VisualScriptIndexSet objects.

*/
type VisualScriptIndexSetImplementer interface {
	VisualScriptNodeImplementer
}

/*

 */
type VisualScriptInputAction struct {
	VisualScriptNode
}

func (o *VisualScriptInputAction) baseClass() string {
	return "VisualScriptInputAction"
}

/*

 */
func (o *VisualScriptInputAction) GetActionMode() int64 {
	log.Println("Calling VisualScriptInputAction.GetActionMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_action_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptInputAction) GetActionName() string {
	log.Println("Calling VisualScriptInputAction.GetActionName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_action_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptInputAction) SetActionMode(mode int64) {
	log.Println("Calling VisualScriptInputAction.SetActionMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_action_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptInputAction) SetActionName(name string) {
	log.Println("Calling VisualScriptInputAction.SetActionName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_action_name", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptInputActionImplementer is an interface for VisualScriptInputAction objects.

*/
type VisualScriptInputActionImplementer interface {
	VisualScriptNodeImplementer

	GetActionMode() int64

	GetActionName() string

	SetActionMode(mode int64)

	SetActionName(name string)
}

/*

 */
type VisualScriptIterator struct {
	VisualScriptNode
}

func (o *VisualScriptIterator) baseClass() string {
	return "VisualScriptIterator"
}

/*
   VisualScriptIteratorImplementer is an interface for VisualScriptIterator objects.

*/
type VisualScriptIteratorImplementer interface {
	VisualScriptNodeImplementer
}

/*

 */
type VisualScriptLocalVar struct {
	VisualScriptNode
}

func (o *VisualScriptLocalVar) baseClass() string {
	return "VisualScriptLocalVar"
}

/*

 */
func (o *VisualScriptLocalVar) GetVarName() string {
	log.Println("Calling VisualScriptLocalVar.GetVarName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_var_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptLocalVar) GetVarType() int64 {
	log.Println("Calling VisualScriptLocalVar.GetVarType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_var_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptLocalVar) SetVarName(name string) {
	log.Println("Calling VisualScriptLocalVar.SetVarName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_var_name", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptLocalVar) SetVarType(aType int64) {
	log.Println("Calling VisualScriptLocalVar.SetVarType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_var_type", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptLocalVarImplementer is an interface for VisualScriptLocalVar objects.

*/
type VisualScriptLocalVarImplementer interface {
	VisualScriptNodeImplementer

	GetVarName() string

	GetVarType() int64

	SetVarName(name string)

	SetVarType(aType int64)
}

/*

 */
type VisualScriptLocalVarSet struct {
	VisualScriptNode
}

func (o *VisualScriptLocalVarSet) baseClass() string {
	return "VisualScriptLocalVarSet"
}

/*

 */
func (o *VisualScriptLocalVarSet) GetVarName() string {
	log.Println("Calling VisualScriptLocalVarSet.GetVarName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_var_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptLocalVarSet) GetVarType() int64 {
	log.Println("Calling VisualScriptLocalVarSet.GetVarType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_var_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptLocalVarSet) SetVarName(name string) {
	log.Println("Calling VisualScriptLocalVarSet.SetVarName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_var_name", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptLocalVarSet) SetVarType(aType int64) {
	log.Println("Calling VisualScriptLocalVarSet.SetVarType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_var_type", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptLocalVarSetImplementer is an interface for VisualScriptLocalVarSet objects.

*/
type VisualScriptLocalVarSetImplementer interface {
	VisualScriptNodeImplementer

	GetVarName() string

	GetVarType() int64

	SetVarName(name string)

	SetVarType(aType int64)
}

/*

 */
type VisualScriptMathConstant struct {
	VisualScriptNode
}

func (o *VisualScriptMathConstant) baseClass() string {
	return "VisualScriptMathConstant"
}

/*

 */
func (o *VisualScriptMathConstant) GetMathConstant() int64 {
	log.Println("Calling VisualScriptMathConstant.GetMathConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_math_constant", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptMathConstant) SetMathConstant(which int64) {
	log.Println("Calling VisualScriptMathConstant.SetMathConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(which)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_math_constant", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptMathConstantImplementer is an interface for VisualScriptMathConstant objects.

*/
type VisualScriptMathConstantImplementer interface {
	VisualScriptNodeImplementer

	GetMathConstant() int64

	SetMathConstant(which int64)
}

/*

 */
type VisualScriptNode struct {
	Resource
}

func (o *VisualScriptNode) baseClass() string {
	return "VisualScriptNode"
}

/*

 */
func (o *VisualScriptNode) GetDefaultInputValue(portIdx int64) *Variant {
	log.Println("Calling VisualScriptNode.GetDefaultInputValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(portIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_default_input_value", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*

 */
func (o *VisualScriptNode) GetVisualScript() *VisualScript {
	log.Println("Calling VisualScriptNode.GetVisualScript()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_visual_script", goArguments, "*VisualScript")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*VisualScript)

	return returnValue

}

/*

 */
func (o *VisualScriptNode) SetDefaultInputValue(portIdx int64, value *Variant) {
	log.Println("Calling VisualScriptNode.SetDefaultInputValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(portIdx)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_default_input_value", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptNodeImplementer is an interface for VisualScriptNode objects.

*/
type VisualScriptNodeImplementer interface {
	ResourceImplementer

	GetDefaultInputValue(portIdx int64) *Variant

	GetVisualScript() *VisualScript

	SetDefaultInputValue(portIdx int64, value *Variant)
}

/*

 */
type VisualScriptOperator struct {
	VisualScriptNode
}

func (o *VisualScriptOperator) baseClass() string {
	return "VisualScriptOperator"
}

/*

 */
func (o *VisualScriptOperator) GetOperator() int64 {
	log.Println("Calling VisualScriptOperator.GetOperator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_operator", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptOperator) GetTyped() int64 {
	log.Println("Calling VisualScriptOperator.GetTyped()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_typed", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptOperator) SetOperator(op int64) {
	log.Println("Calling VisualScriptOperator.SetOperator()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(op)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_operator", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptOperator) SetTyped(aType int64) {
	log.Println("Calling VisualScriptOperator.SetTyped()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_typed", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptOperatorImplementer is an interface for VisualScriptOperator objects.

*/
type VisualScriptOperatorImplementer interface {
	VisualScriptNodeImplementer

	GetOperator() int64

	GetTyped() int64

	SetOperator(op int64)

	SetTyped(aType int64)
}

/*

 */
type VisualScriptPreload struct {
	VisualScriptNode
}

func (o *VisualScriptPreload) baseClass() string {
	return "VisualScriptPreload"
}

/*

 */
func (o *VisualScriptPreload) GetPreload() *Resource {
	log.Println("Calling VisualScriptPreload.GetPreload()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_preload", goArguments, "*Resource")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Resource)

	return returnValue

}

/*

 */
func (o *VisualScriptPreload) SetPreload(resource *Resource) {
	log.Println("Calling VisualScriptPreload.SetPreload()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(resource)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_preload", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptPreloadImplementer is an interface for VisualScriptPreload objects.

*/
type VisualScriptPreloadImplementer interface {
	VisualScriptNodeImplementer

	GetPreload() *Resource

	SetPreload(resource *Resource)
}

/*

 */
type VisualScriptPropertyGet struct {
	VisualScriptNode
}

func (o *VisualScriptPropertyGet) baseClass() string {
	return "VisualScriptPropertyGet"
}

/*

 */
func (o *VisualScriptPropertyGet) GetBasePath() *NodePath {
	log.Println("Calling VisualScriptPropertyGet.GetBasePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_path", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *VisualScriptPropertyGet) GetBaseScript() string {
	log.Println("Calling VisualScriptPropertyGet.GetBaseScript()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_script", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptPropertyGet) GetBaseType() string {
	log.Println("Calling VisualScriptPropertyGet.GetBaseType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_type", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptPropertyGet) GetBasicType() int64 {
	log.Println("Calling VisualScriptPropertyGet.GetBasicType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_basic_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptPropertyGet) GetCallMode() int64 {
	log.Println("Calling VisualScriptPropertyGet.GetCallMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_call_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptPropertyGet) GetIndex() string {
	log.Println("Calling VisualScriptPropertyGet.GetIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_index", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptPropertyGet) GetProperty() string {
	log.Println("Calling VisualScriptPropertyGet.GetProperty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_property", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptPropertyGet) SetBasePath(basePath *NodePath) {
	log.Println("Calling VisualScriptPropertyGet.SetBasePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(basePath)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_path", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptPropertyGet) SetBaseScript(baseScript string) {
	log.Println("Calling VisualScriptPropertyGet.SetBaseScript()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(baseScript)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_script", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptPropertyGet) SetBaseType(baseType string) {
	log.Println("Calling VisualScriptPropertyGet.SetBaseType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(baseType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptPropertyGet) SetBasicType(basicType int64) {
	log.Println("Calling VisualScriptPropertyGet.SetBasicType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(basicType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_basic_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptPropertyGet) SetCallMode(mode int64) {
	log.Println("Calling VisualScriptPropertyGet.SetCallMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_call_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptPropertyGet) SetIndex(index string) {
	log.Println("Calling VisualScriptPropertyGet.SetIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_index", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptPropertyGet) SetProperty(property string) {
	log.Println("Calling VisualScriptPropertyGet.SetProperty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(property)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_property", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptPropertyGetImplementer is an interface for VisualScriptPropertyGet objects.

*/
type VisualScriptPropertyGetImplementer interface {
	VisualScriptNodeImplementer

	GetBasePath() *NodePath

	GetBaseScript() string

	GetBaseType() string

	GetBasicType() int64

	GetCallMode() int64

	GetIndex() string

	GetProperty() string

	SetBasePath(basePath *NodePath)

	SetBaseScript(baseScript string)

	SetBaseType(baseType string)

	SetBasicType(basicType int64)

	SetCallMode(mode int64)

	SetIndex(index string)

	SetProperty(property string)
}

/*

 */
type VisualScriptPropertySet struct {
	VisualScriptNode
}

func (o *VisualScriptPropertySet) baseClass() string {
	return "VisualScriptPropertySet"
}

/*

 */
func (o *VisualScriptPropertySet) GetAssignOp() int64 {
	log.Println("Calling VisualScriptPropertySet.GetAssignOp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_assign_op", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptPropertySet) GetBasePath() *NodePath {
	log.Println("Calling VisualScriptPropertySet.GetBasePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_path", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *VisualScriptPropertySet) GetBaseScript() string {
	log.Println("Calling VisualScriptPropertySet.GetBaseScript()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_script", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptPropertySet) GetBaseType() string {
	log.Println("Calling VisualScriptPropertySet.GetBaseType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_type", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptPropertySet) GetBasicType() int64 {
	log.Println("Calling VisualScriptPropertySet.GetBasicType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_basic_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptPropertySet) GetCallMode() int64 {
	log.Println("Calling VisualScriptPropertySet.GetCallMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_call_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptPropertySet) GetIndex() string {
	log.Println("Calling VisualScriptPropertySet.GetIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_index", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptPropertySet) GetProperty() string {
	log.Println("Calling VisualScriptPropertySet.GetProperty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_property", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptPropertySet) SetAssignOp(assignOp int64) {
	log.Println("Calling VisualScriptPropertySet.SetAssignOp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(assignOp)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_assign_op", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptPropertySet) SetBasePath(basePath *NodePath) {
	log.Println("Calling VisualScriptPropertySet.SetBasePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(basePath)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_path", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptPropertySet) SetBaseScript(baseScript string) {
	log.Println("Calling VisualScriptPropertySet.SetBaseScript()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(baseScript)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_script", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptPropertySet) SetBaseType(baseType string) {
	log.Println("Calling VisualScriptPropertySet.SetBaseType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(baseType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptPropertySet) SetBasicType(basicType int64) {
	log.Println("Calling VisualScriptPropertySet.SetBasicType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(basicType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_basic_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptPropertySet) SetCallMode(mode int64) {
	log.Println("Calling VisualScriptPropertySet.SetCallMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_call_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptPropertySet) SetIndex(index string) {
	log.Println("Calling VisualScriptPropertySet.SetIndex()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_index", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptPropertySet) SetProperty(property string) {
	log.Println("Calling VisualScriptPropertySet.SetProperty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(property)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_property", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptPropertySetImplementer is an interface for VisualScriptPropertySet objects.

*/
type VisualScriptPropertySetImplementer interface {
	VisualScriptNodeImplementer

	GetAssignOp() int64

	GetBasePath() *NodePath

	GetBaseScript() string

	GetBaseType() string

	GetBasicType() int64

	GetCallMode() int64

	GetIndex() string

	GetProperty() string

	SetAssignOp(assignOp int64)

	SetBasePath(basePath *NodePath)

	SetBaseScript(baseScript string)

	SetBaseType(baseType string)

	SetBasicType(basicType int64)

	SetCallMode(mode int64)

	SetIndex(index string)

	SetProperty(property string)
}

/*

 */
type VisualScriptResourcePath struct {
	VisualScriptNode
}

func (o *VisualScriptResourcePath) baseClass() string {
	return "VisualScriptResourcePath"
}

/*

 */
func (o *VisualScriptResourcePath) GetResourcePath() string {
	log.Println("Calling VisualScriptResourcePath.GetResourcePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_resource_path", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptResourcePath) SetResourcePath(path string) {
	log.Println("Calling VisualScriptResourcePath.SetResourcePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_resource_path", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptResourcePathImplementer is an interface for VisualScriptResourcePath objects.

*/
type VisualScriptResourcePathImplementer interface {
	VisualScriptNodeImplementer

	GetResourcePath() string

	SetResourcePath(path string)
}

/*

 */
type VisualScriptReturn struct {
	VisualScriptNode
}

func (o *VisualScriptReturn) baseClass() string {
	return "VisualScriptReturn"
}

/*

 */
func (o *VisualScriptReturn) GetReturnType() int64 {
	log.Println("Calling VisualScriptReturn.GetReturnType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_return_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptReturn) IsReturnValueEnabled() *bool {
	log.Println("Calling VisualScriptReturn.IsReturnValueEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_return_value_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*

 */
func (o *VisualScriptReturn) SetEnableReturnValue(enable *bool) {
	log.Println("Calling VisualScriptReturn.SetEnableReturnValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_enable_return_value", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptReturn) SetReturnType(aType int64) {
	log.Println("Calling VisualScriptReturn.SetReturnType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_return_type", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptReturnImplementer is an interface for VisualScriptReturn objects.

*/
type VisualScriptReturnImplementer interface {
	VisualScriptNodeImplementer

	GetReturnType() int64

	IsReturnValueEnabled() *bool

	SetEnableReturnValue(enable *bool)

	SetReturnType(aType int64)
}

/*

 */
type VisualScriptSceneNode struct {
	VisualScriptNode
}

func (o *VisualScriptSceneNode) baseClass() string {
	return "VisualScriptSceneNode"
}

/*

 */
func (o *VisualScriptSceneNode) GetNodePath() *NodePath {
	log.Println("Calling VisualScriptSceneNode.GetNodePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_path", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *VisualScriptSceneNode) SetNodePath(path *NodePath) {
	log.Println("Calling VisualScriptSceneNode.SetNodePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_node_path", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptSceneNodeImplementer is an interface for VisualScriptSceneNode objects.

*/
type VisualScriptSceneNodeImplementer interface {
	VisualScriptNodeImplementer

	GetNodePath() *NodePath

	SetNodePath(path *NodePath)
}

/*

 */
type VisualScriptSceneTree struct {
	VisualScriptNode
}

func (o *VisualScriptSceneTree) baseClass() string {
	return "VisualScriptSceneTree"
}

/*
   VisualScriptSceneTreeImplementer is an interface for VisualScriptSceneTree objects.

*/
type VisualScriptSceneTreeImplementer interface {
	VisualScriptNodeImplementer
}

/*

 */
type VisualScriptSelect struct {
	VisualScriptNode
}

func (o *VisualScriptSelect) baseClass() string {
	return "VisualScriptSelect"
}

/*

 */
func (o *VisualScriptSelect) GetTyped() int64 {
	log.Println("Calling VisualScriptSelect.GetTyped()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_typed", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptSelect) SetTyped(aType int64) {
	log.Println("Calling VisualScriptSelect.SetTyped()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_typed", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptSelectImplementer is an interface for VisualScriptSelect objects.

*/
type VisualScriptSelectImplementer interface {
	VisualScriptNodeImplementer

	GetTyped() int64

	SetTyped(aType int64)
}

/*

 */
type VisualScriptSelf struct {
	VisualScriptNode
}

func (o *VisualScriptSelf) baseClass() string {
	return "VisualScriptSelf"
}

/*
   VisualScriptSelfImplementer is an interface for VisualScriptSelf objects.

*/
type VisualScriptSelfImplementer interface {
	VisualScriptNodeImplementer
}

/*

 */
type VisualScriptSequence struct {
	VisualScriptNode
}

func (o *VisualScriptSequence) baseClass() string {
	return "VisualScriptSequence"
}

/*

 */
func (o *VisualScriptSequence) GetSteps() int64 {
	log.Println("Calling VisualScriptSequence.GetSteps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_steps", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptSequence) SetSteps(steps int64) {
	log.Println("Calling VisualScriptSequence.SetSteps()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(steps)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_steps", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptSequenceImplementer is an interface for VisualScriptSequence objects.

*/
type VisualScriptSequenceImplementer interface {
	VisualScriptNodeImplementer

	GetSteps() int64

	SetSteps(steps int64)
}

/*

 */
type VisualScriptSubCall struct {
	VisualScriptNode
}

func (o *VisualScriptSubCall) baseClass() string {
	return "VisualScriptSubCall"
}

/*

 */
func (o *VisualScriptSubCall) X_Subcall(arguments *Variant) *Variant {
	log.Println("Calling VisualScriptSubCall.X_Subcall()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arguments)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "_subcall", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   VisualScriptSubCallImplementer is an interface for VisualScriptSubCall objects.

*/
type VisualScriptSubCallImplementer interface {
	VisualScriptNodeImplementer

	X_Subcall(arguments *Variant) *Variant
}

/*

 */
type VisualScriptSwitch struct {
	VisualScriptNode
}

func (o *VisualScriptSwitch) baseClass() string {
	return "VisualScriptSwitch"
}

/*
   VisualScriptSwitchImplementer is an interface for VisualScriptSwitch objects.

*/
type VisualScriptSwitchImplementer interface {
	VisualScriptNodeImplementer
}

/*

 */
type VisualScriptTypeCast struct {
	VisualScriptNode
}

func (o *VisualScriptTypeCast) baseClass() string {
	return "VisualScriptTypeCast"
}

/*

 */
func (o *VisualScriptTypeCast) GetBaseScript() string {
	log.Println("Calling VisualScriptTypeCast.GetBaseScript()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_script", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptTypeCast) GetBaseType() string {
	log.Println("Calling VisualScriptTypeCast.GetBaseType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_type", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptTypeCast) SetBaseScript(path string) {
	log.Println("Calling VisualScriptTypeCast.SetBaseScript()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_script", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptTypeCast) SetBaseType(aType string) {
	log.Println("Calling VisualScriptTypeCast.SetBaseType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_type", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptTypeCastImplementer is an interface for VisualScriptTypeCast objects.

*/
type VisualScriptTypeCastImplementer interface {
	VisualScriptNodeImplementer

	GetBaseScript() string

	GetBaseType() string

	SetBaseScript(path string)

	SetBaseType(aType string)
}

/*

 */
type VisualScriptVariableGet struct {
	VisualScriptNode
}

func (o *VisualScriptVariableGet) baseClass() string {
	return "VisualScriptVariableGet"
}

/*

 */
func (o *VisualScriptVariableGet) GetVariable() string {
	log.Println("Calling VisualScriptVariableGet.GetVariable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_variable", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptVariableGet) SetVariable(name string) {
	log.Println("Calling VisualScriptVariableGet.SetVariable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_variable", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptVariableGetImplementer is an interface for VisualScriptVariableGet objects.

*/
type VisualScriptVariableGetImplementer interface {
	VisualScriptNodeImplementer

	GetVariable() string

	SetVariable(name string)
}

/*

 */
type VisualScriptVariableSet struct {
	VisualScriptNode
}

func (o *VisualScriptVariableSet) baseClass() string {
	return "VisualScriptVariableSet"
}

/*

 */
func (o *VisualScriptVariableSet) GetVariable() string {
	log.Println("Calling VisualScriptVariableSet.GetVariable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_variable", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptVariableSet) SetVariable(name string) {
	log.Println("Calling VisualScriptVariableSet.SetVariable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_variable", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptVariableSetImplementer is an interface for VisualScriptVariableSet objects.

*/
type VisualScriptVariableSetImplementer interface {
	VisualScriptNodeImplementer

	GetVariable() string

	SetVariable(name string)
}

/*

 */
type VisualScriptWhile struct {
	VisualScriptNode
}

func (o *VisualScriptWhile) baseClass() string {
	return "VisualScriptWhile"
}

/*
   VisualScriptWhileImplementer is an interface for VisualScriptWhile objects.

*/
type VisualScriptWhileImplementer interface {
	VisualScriptNodeImplementer
}

/*

 */
type VisualScriptYield struct {
	VisualScriptNode
}

func (o *VisualScriptYield) baseClass() string {
	return "VisualScriptYield"
}

/*

 */
func (o *VisualScriptYield) GetWaitTime() float64 {
	log.Println("Calling VisualScriptYield.GetWaitTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_wait_time", goArguments, "float64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(float64)

	return returnValue

}

/*

 */
func (o *VisualScriptYield) GetYieldMode() int64 {
	log.Println("Calling VisualScriptYield.GetYieldMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_yield_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptYield) SetWaitTime(sec float64) {
	log.Println("Calling VisualScriptYield.SetWaitTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(sec)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_wait_time", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptYield) SetYieldMode(mode int64) {
	log.Println("Calling VisualScriptYield.SetYieldMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_yield_mode", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptYieldImplementer is an interface for VisualScriptYield objects.

*/
type VisualScriptYieldImplementer interface {
	VisualScriptNodeImplementer

	GetWaitTime() float64

	GetYieldMode() int64

	SetWaitTime(sec float64)

	SetYieldMode(mode int64)
}

/*

 */
type VisualScriptYieldSignal struct {
	VisualScriptNode
}

func (o *VisualScriptYieldSignal) baseClass() string {
	return "VisualScriptYieldSignal"
}

/*

 */
func (o *VisualScriptYieldSignal) GetBasePath() *NodePath {
	log.Println("Calling VisualScriptYieldSignal.GetBasePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_path", goArguments, "*NodePath")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*NodePath)

	return returnValue

}

/*

 */
func (o *VisualScriptYieldSignal) GetBaseType() string {
	log.Println("Calling VisualScriptYieldSignal.GetBaseType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_base_type", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptYieldSignal) GetCallMode() int64 {
	log.Println("Calling VisualScriptYieldSignal.GetCallMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_call_mode", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualScriptYieldSignal) GetSignal() string {
	log.Println("Calling VisualScriptYieldSignal.GetSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_signal", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *VisualScriptYieldSignal) SetBasePath(basePath *NodePath) {
	log.Println("Calling VisualScriptYieldSignal.SetBasePath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(basePath)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_path", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptYieldSignal) SetBaseType(baseType string) {
	log.Println("Calling VisualScriptYieldSignal.SetBaseType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(baseType)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_base_type", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptYieldSignal) SetCallMode(mode int64) {
	log.Println("Calling VisualScriptYieldSignal.SetCallMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_call_mode", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualScriptYieldSignal) SetSignal(signal string) {
	log.Println("Calling VisualScriptYieldSignal.SetSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(signal)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_signal", goArguments, "")

	log.Println("Got return value!")

}

/*
   VisualScriptYieldSignalImplementer is an interface for VisualScriptYieldSignal objects.

*/
type VisualScriptYieldSignalImplementer interface {
	VisualScriptNodeImplementer

	GetBasePath() *NodePath

	GetBaseType() string

	GetCallMode() int64

	GetSignal() string

	SetBasePath(basePath *NodePath)

	SetBaseType(baseType string)

	SetCallMode(mode int64)

	SetSignal(signal string)
}

/*
        Server for anything visible. The visual server is the API backend for everything visible. The whole scene system mounts on it to display.
		The visual server is completely opaque, the internals are entirely implementation specific and cannot be accessed.
*/
type VisualServer struct {
	Object
}

func (o *VisualServer) baseClass() string {
	return "VisualServer"
}

/*

 */
func (o *VisualServer) ForceDraw() {
	log.Println("Calling VisualServer.ForceDraw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "force_draw", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualServer) TextureCreate() *RID {
	log.Println("Calling VisualServer.TextureCreate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "texture_create", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *VisualServer) TextureCreateFromImage(image *Image, flags int64) *RID {
	log.Println("Calling VisualServer.TextureCreateFromImage()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(image)
	goArguments[1] = reflect.ValueOf(flags)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "texture_create_from_image", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *VisualServer) TextureGetFlags(texture *RID) int64 {
	log.Println("Calling VisualServer.TextureGetFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "texture_get_flags", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualServer) TextureGetHeight(texture *RID) int64 {
	log.Println("Calling VisualServer.TextureGetHeight()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "texture_get_height", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualServer) TextureGetWidth(texture *RID) int64 {
	log.Println("Calling VisualServer.TextureGetWidth()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(texture)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "texture_get_width", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*

 */
func (o *VisualServer) TextureSetFlags(texture *RID, flags int64) {
	log.Println("Calling VisualServer.TextureSetFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(texture)
	goArguments[1] = reflect.ValueOf(flags)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "texture_set_flags", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *VisualServer) TextureSetShrinkAllX2OnSetData(shrink *bool) {
	log.Println("Calling VisualServer.TextureSetShrinkAllX2OnSetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shrink)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "texture_set_shrink_all_x2_on_set_data", goArguments, "")

	log.Println("Got return value!")

}

/*
        VisualServerImplementer is an interface for VisualServer objects.
        Server for anything visible. The visual server is the API backend for everything visible. The whole scene system mounts on it to display.
		The visual server is completely opaque, the internals are entirely implementation specific and cannot be accessed.
*/
type VisualServerImplementer interface {
	ObjectImplementer

	ForceDraw()

	TextureCreate() *RID

	TextureCreateFromImage(image *Image, flags int64) *RID

	TextureGetFlags(texture *RID) int64

	TextureGetHeight(texture *RID) int64

	TextureGetWidth(texture *RID) int64

	TextureSetFlags(texture *RID, flags int64)

	TextureSetShrinkAllX2OnSetData(shrink *bool)
}

/*
   A weakref can hold a [Reference], without contributing to the reference counter. A weakref can be created from an [Object] using [method @GDScript.weakref]. If this object is not a reference, weakref still works, however, it does not have any effect on the object. Weakrefs are useful in cases where multiple classes have variables that refer to eachother. Without weakrefs, using these classes could lead to memory leaks, since both references keep eachother from being released. Making part of the variables a weakref can prevent this cyclic dependency, and allows the references to be released.
*/
type WeakRef struct {
	Reference
}

func (o *WeakRef) baseClass() string {
	return "WeakRef"
}

/*
   Returns the [Object] this weakref is referring to.
*/
func (o *WeakRef) GetRef() *Variant {
	log.Println("Calling WeakRef.GetRef()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_ref", goArguments, "*Variant")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Variant)

	return returnValue

}

/*
   WeakRefImplementer is an interface for WeakRef objects.
   A weakref can hold a [Reference], without contributing to the reference counter. A weakref can be created from an [Object] using [method @GDScript.weakref]. If this object is not a reference, weakref still works, however, it does not have any effect on the object. Weakrefs are useful in cases where multiple classes have variables that refer to eachother. Without weakrefs, using these classes could lead to memory leaks, since both references keep eachother from being released. Making part of the variables a weakref can prevent this cyclic dependency, and allows the references to be released.
*/
type WeakRefImplementer interface {
	ReferenceImplementer

	GetRef() *Variant
}

/*
   Windowdialog is the base class for all window-based dialogs. It's a by-default toplevel [Control] that draws a window decoration and allows motion and resizing.
*/
type WindowDialog struct {
	Popup
}

func (o *WindowDialog) baseClass() string {
	return "WindowDialog"
}

/*
   Return the close [TextureButton].
*/
func (o *WindowDialog) GetCloseButton() *TextureButton {
	log.Println("Calling WindowDialog.GetCloseButton()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_close_button", goArguments, "*TextureButton")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*TextureButton)

	return returnValue

}

/*

 */
func (o *WindowDialog) GetResizable() *bool {
	log.Println("Calling WindowDialog.GetResizable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_resizable", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Return the title of the window.
*/
func (o *WindowDialog) GetTitle() string {
	log.Println("Calling WindowDialog.GetTitle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_title", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*

 */
func (o *WindowDialog) SetResizable(resizable *bool) {
	log.Println("Calling WindowDialog.SetResizable()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(resizable)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_resizable", goArguments, "")

	log.Println("Got return value!")

}

/*
   Set the title of the window.
*/
func (o *WindowDialog) SetTitle(title string) {
	log.Println("Calling WindowDialog.SetTitle()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(title)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_title", goArguments, "")

	log.Println("Got return value!")

}

/*
   WindowDialogImplementer is an interface for WindowDialog objects.
   Windowdialog is the base class for all window-based dialogs. It's a by-default toplevel [Control] that draws a window decoration and allows motion and resizing.
*/
type WindowDialogImplementer interface {
	PopupImplementer

	GetCloseButton() *TextureButton

	GetResizable() *bool

	GetTitle() string

	SetResizable(resizable *bool)

	SetTitle(title string)
}

/*
   Class that has everything pertaining to a world. A physics space, a visual scenario and a sound space. Spatial nodes register their resources into the current world.
*/
type World struct {
	Resource
}

func (o *World) baseClass() string {
	return "World"
}

/*

 */
func (o *World) GetDirectSpaceState() *PhysicsDirectSpaceState {
	log.Println("Calling World.GetDirectSpaceState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_direct_space_state", goArguments, "*PhysicsDirectSpaceState")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*PhysicsDirectSpaceState)

	return returnValue

}

/*

 */
func (o *World) GetEnvironment() *Environment {
	log.Println("Calling World.GetEnvironment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_environment", goArguments, "*Environment")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Environment)

	return returnValue

}

/*

 */
func (o *World) GetFallbackEnvironment() *Environment {
	log.Println("Calling World.GetFallbackEnvironment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_fallback_environment", goArguments, "*Environment")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Environment)

	return returnValue

}

/*

 */
func (o *World) GetScenario() *RID {
	log.Println("Calling World.GetScenario()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_scenario", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *World) GetSpace() *RID {
	log.Println("Calling World.GetSpace()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_space", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*

 */
func (o *World) SetEnvironment(env *Environment) {
	log.Println("Calling World.SetEnvironment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(env)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_environment", goArguments, "")

	log.Println("Got return value!")

}

/*

 */
func (o *World) SetFallbackEnvironment(env *Environment) {
	log.Println("Calling World.SetFallbackEnvironment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(env)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_fallback_environment", goArguments, "")

	log.Println("Got return value!")

}

/*
   WorldImplementer is an interface for World objects.
   Class that has everything pertaining to a world. A physics space, a visual scenario and a sound space. Spatial nodes register their resources into the current world.
*/
type WorldImplementer interface {
	ResourceImplementer

	GetDirectSpaceState() *PhysicsDirectSpaceState

	GetEnvironment() *Environment

	GetFallbackEnvironment() *Environment

	GetScenario() *RID

	GetSpace() *RID

	SetEnvironment(env *Environment)

	SetFallbackEnvironment(env *Environment)
}

/*
   Class that has everything pertaining to a 2D world. A physics space, a visual scenario and a sound space. 2D nodes register their resources into the current 2D world.
*/
type World2D struct {
	Resource
}

func (o *World2D) baseClass() string {
	return "World2D"
}

/*
   Retrieve the [RID] of this world's canvas resource. Used by the [VisualServer] for 2D drawing.
*/
func (o *World2D) GetCanvas() *RID {
	log.Println("Calling World2D.GetCanvas()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_canvas", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   Retrieve the state of this world's physics space. This allows arbitrary querying for collision.
*/
func (o *World2D) GetDirectSpaceState() *Physics2DDirectSpaceState {
	log.Println("Calling World2D.GetDirectSpaceState()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_direct_space_state", goArguments, "*Physics2DDirectSpaceState")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Physics2DDirectSpaceState)

	return returnValue

}

/*
   Retrieve the [RID] of this world's physics space resource. Used by the [Physics2DServer] for 2D physics, treating it as both a space and an area.
*/
func (o *World2D) GetSpace() *RID {
	log.Println("Calling World2D.GetSpace()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_space", goArguments, "*RID")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*RID)

	return returnValue

}

/*
   World2DImplementer is an interface for World2D objects.
   Class that has everything pertaining to a 2D world. A physics space, a visual scenario and a sound space. 2D nodes register their resources into the current 2D world.
*/
type World2DImplementer interface {
	ResourceImplementer

	GetCanvas() *RID

	GetDirectSpaceState() *Physics2DDirectSpaceState

	GetSpace() *RID
}

/*
   The [WorldEnvironment] node can be added to a scene in order to set default [Environment] variables for the scene. The [WorldEnvironment] can be overridden by an [Environment] node set on the current [Camera]. Additionally, only one [WorldEnvironment] may be instanced in a given scene at a time. The [WorldEnvironment] allows the user to specify default lighting parameters (e.g. ambient lighting), various post-processing effects (e.g. SSAO, DOF, Tonemapping), and how to draw the background (e.g. solid color, skybox).
*/
type WorldEnvironment struct {
	Node
}

func (o *WorldEnvironment) baseClass() string {
	return "WorldEnvironment"
}

/*
   Return the [Environment] currently bound.
*/
func (o *WorldEnvironment) GetEnvironment() *Environment {
	log.Println("Calling WorldEnvironment.GetEnvironment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_environment", goArguments, "*Environment")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*Environment)

	return returnValue

}

/*
   Set the currently bound [Environment] to the one specified.
*/
func (o *WorldEnvironment) SetEnvironment(env *Environment) {
	log.Println("Calling WorldEnvironment.SetEnvironment()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(env)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_environment", goArguments, "")

	log.Println("Got return value!")

}

/*
   WorldEnvironmentImplementer is an interface for WorldEnvironment objects.
   The [WorldEnvironment] node can be added to a scene in order to set default [Environment] variables for the scene. The [WorldEnvironment] can be overridden by an [Environment] node set on the current [Camera]. Additionally, only one [WorldEnvironment] may be instanced in a given scene at a time. The [WorldEnvironment] allows the user to specify default lighting parameters (e.g. ambient lighting), various post-processing effects (e.g. SSAO, DOF, Tonemapping), and how to draw the background (e.g. solid color, skybox).
*/
type WorldEnvironmentImplementer interface {
	NodeImplementer

	GetEnvironment() *Environment

	SetEnvironment(env *Environment)
}

/*
   This class can serve as base to make custom XML parsers. Since XML is a very flexible standard, this interface is low level so it can be applied to any possible schema.
*/
type XMLParser struct {
	Reference
}

func (o *XMLParser) baseClass() string {
	return "XMLParser"
}

/*
   Get the amount of attributes in the current element.
*/
func (o *XMLParser) GetAttributeCount() int64 {
	log.Println("Calling XMLParser.GetAttributeCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_attribute_count", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the name of the attribute specified by the index in [code]idx[/code] argument.
*/
func (o *XMLParser) GetAttributeName(idx int64) string {
	log.Println("Calling XMLParser.GetAttributeName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_attribute_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the value of the attribute specified by the index in [code]idx[/code] argument.
*/
func (o *XMLParser) GetAttributeValue(idx int64) string {
	log.Println("Calling XMLParser.GetAttributeValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_attribute_value", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the current line in the parsed file (currently not implemented).
*/
func (o *XMLParser) GetCurrentLine() int64 {
	log.Println("Calling XMLParser.GetCurrentLine()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_current_line", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the value of a certain attribute of the current element by name. This will raise an error if the element has no such attribute.
*/
func (o *XMLParser) GetNamedAttributeValue(name string) string {
	log.Println("Calling XMLParser.GetNamedAttributeValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_named_attribute_value", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the value of a certain attribute of the current element by name. This will return an empty [String] if the attribute is not found.
*/
func (o *XMLParser) GetNamedAttributeValueSafe(name string) string {
	log.Println("Calling XMLParser.GetNamedAttributeValueSafe()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_named_attribute_value_safe", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the contents of a text node. This will raise an error in any other type of node.
*/
func (o *XMLParser) GetNodeData() string {
	log.Println("Calling XMLParser.GetNodeData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_data", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the name of the current element node. This will raise an error if the current node type is not [code]NODE_ELEMENT[/code] nor [code]NODE_ELEMENT_END[/code]
*/
func (o *XMLParser) GetNodeName() string {
	log.Println("Calling XMLParser.GetNodeName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_name", goArguments, "string")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(string)

	return returnValue

}

/*
   Get the byte offset of the current node since the beginning of the file or buffer.
*/
func (o *XMLParser) GetNodeOffset() int64 {
	log.Println("Calling XMLParser.GetNodeOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_offset", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Get the type of the current node. Compare with [code]NODE_*[/code] constants.
*/
func (o *XMLParser) GetNodeType() int64 {
	log.Println("Calling XMLParser.GetNodeType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "get_node_type", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Check whether or not the current element has a certain attribute.
*/
func (o *XMLParser) HasAttribute(name string) *bool {
	log.Println("Calling XMLParser.HasAttribute()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "has_attribute", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Check whether the current element is empty (this only works for completely empty tags, e.g. <element \>).
*/
func (o *XMLParser) IsEmpty() *bool {
	log.Println("Calling XMLParser.IsEmpty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_empty", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Open a XML file for parsing. This returns an error code.
*/
func (o *XMLParser) Open(file string) int64 {
	log.Println("Calling XMLParser.Open()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(file)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "open", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Open a XML raw buffer for parsing. This returns an error code.
*/
func (o *XMLParser) OpenBuffer(buffer *PoolByteArray) int64 {
	log.Println("Calling XMLParser.OpenBuffer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(buffer)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "open_buffer", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Read the next node of the file. This returns an error code.
*/
func (o *XMLParser) Read() int64 {
	log.Println("Calling XMLParser.Read()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "read", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Move the buffer cursor to a certain offset (since the beginning) and read the next node there. This returns an error code.
*/
func (o *XMLParser) Seek(pos int64) int64 {
	log.Println("Calling XMLParser.Seek()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pos)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "seek", goArguments, "int64")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(int64)

	return returnValue

}

/*
   Skips the current section. If the node contains other elements, they will be ignored and the cursor will go to the closing of the current element.
*/
func (o *XMLParser) SkipSection() {
	log.Println("Calling XMLParser.SkipSection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "skip_section", goArguments, "")

	log.Println("Got return value!")

}

/*
   XMLParserImplementer is an interface for XMLParser objects.
   This class can serve as base to make custom XML parsers. Since XML is a very flexible standard, this interface is low level so it can be applied to any possible schema.
*/
type XMLParserImplementer interface {
	ReferenceImplementer

	GetAttributeCount() int64

	GetAttributeName(idx int64) string

	GetAttributeValue(idx int64) string

	GetCurrentLine() int64

	GetNamedAttributeValue(name string) string

	GetNamedAttributeValueSafe(name string) string

	GetNodeData() string

	GetNodeName() string

	GetNodeOffset() int64

	GetNodeType() int64

	HasAttribute(name string) *bool

	IsEmpty() *bool

	Open(file string) int64

	OpenBuffer(buffer *PoolByteArray) int64

	Read() int64

	Seek(pos int64) int64

	SkipSection()
}

/*
   Sort all child nodes based on their Y positions. The child node must inherit from [CanvasItem] for it to be sorted. Nodes that have a higher Y position will be drawn later, so they will appear on top of nodes that have a lower Y position.
*/
type YSort struct {
	Node2D
}

func (o *YSort) baseClass() string {
	return "YSort"
}

/*
   Returns true if the children nodes are being sorted.
*/
func (o *YSort) IsSortEnabled() *bool {
	log.Println("Calling YSort.IsSortEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.baseClass(), "is_sort_enabled", goArguments, "*bool")

	log.Println("Got return value!")

	returnValue := goRet.Interface().(*bool)

	return returnValue

}

/*
   Set whether the children nodes are sorted or not. (default true)
*/
func (o *YSort) SetSortEnabled(enabled *bool) {
	log.Println("Calling YSort.SetSortEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.baseClass(), "set_sort_enabled", goArguments, "")

	log.Println("Got return value!")

}

/*
   YSortImplementer is an interface for YSort objects.
   Sort all child nodes based on their Y positions. The child node must inherit from [CanvasItem] for it to be sorted. Nodes that have a higher Y position will be drawn later, so they will appear on top of nodes that have a lower Y position.
*/
type YSortImplementer interface {
	Node2DImplementer

	IsSortEnabled() *bool

	SetSortEnabled(enabled *bool)
}
