package godot

import (
	"github.com/shadowapex/godot-go/gdnative"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

// TweenEaseType is an enum for EaseType values.
type TweenEaseType int

const (
	TweenEaseIn    TweenEaseType = 0
	TweenEaseInOut TweenEaseType = 2
	TweenEaseOut   TweenEaseType = 1
	TweenEaseOutIn TweenEaseType = 3
)

// TweenTransitionType is an enum for TransitionType values.
type TweenTransitionType int

const (
	TweenTransBack    TweenTransitionType = 10
	TweenTransBounce  TweenTransitionType = 9
	TweenTransCirc    TweenTransitionType = 8
	TweenTransCubic   TweenTransitionType = 7
	TweenTransElastic TweenTransitionType = 6
	TweenTransExpo    TweenTransitionType = 5
	TweenTransLinear  TweenTransitionType = 0
	TweenTransQuad    TweenTransitionType = 4
	TweenTransQuart   TweenTransitionType = 3
	TweenTransQuint   TweenTransitionType = 2
	TweenTransSine    TweenTransitionType = 1
)

// TweenTweenProcessMode is an enum for TweenProcessMode values.
type TweenTweenProcessMode int

const (
	TweenTweenProcessIdle    TweenTweenProcessMode = 1
	TweenTweenProcessPhysics TweenTweenProcessMode = 0
)

//func NewTweenFromPointer(ptr gdnative.Pointer) Tween {
func newTweenFromPointer(ptr gdnative.Pointer) Tween {
	owner := gdnative.NewObjectFromPointer(ptr)
	obj := Tween{}
	obj.SetBaseObject(owner)

	return obj
}

/*
Node useful for animations with unknown start and end points, procedural animations, making one node follow another, and other simple behavior. Because it is easy to get it wrong, here is a quick usage example: [codeblock] var tween = get_node("Tween") tween.interpolate_property(get_node("Node2D_to_move"), "transform/origin", Vector2(0,0), Vector2(100,100), 1, Tween.TRANS_LINEAR, Tween.EASE_IN_OUT) tween.start() [/codeblock] Some of the methods of this class require a property name. You can get the property name by hovering over the property in the inspector of the editor. Many of the methods accept [code]trans_type[/code] and [code]ease_type[/code]. The first accepts an TRANS_* constant, and refers to the way the timing of the animation is handled (you might want to see [code]http://easings.net/[/code] for some examples). The second accepts an EASE_* constant, and controls the where [code]trans_type[/code] is applied to the interpolation (in the beginning, the end, or both). If you don't know which transition and easing to pick, you can try different TRANS_* constants with EASE_IN_OUT, and use the one that looks best.
*/
type Tween struct {
	Node
	owner gdnative.Object
}

func (o *Tween) BaseClass() string {
	return "Tween"
}

/*
        Undocumented
	Args: [{ false object Object} { false key String} { false first_only bool}], Returns: void
*/
func (o *Tween) X_Remove(object ObjectImplementer, key gdnative.String, firstOnly gdnative.Bool) {
	//log.Println("Calling Tween.X_Remove()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromString(key)
	ptrArguments[2] = gdnative.NewPointerFromBool(firstOnly)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "_remove")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Follow [code]method[/code] of [code]object[/code] and apply the returned value on [code]target_method[/code] of [code]target[/code], beginning from [code]initial_val[/code] for [code]duration[/code] seconds, [code]delay[/code] later. Methods are animated by calling them with consequitive values. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
	Args: [{ false object Object} { false method String} { false initial_val Variant} { false target Object} { false target_method String} { false duration float} { false trans_type int} { false ease_type int} {0 true delay float}], Returns: bool
*/
func (o *Tween) FollowMethod(object ObjectImplementer, method gdnative.String, initialVal gdnative.Variant, target ObjectImplementer, targetMethod gdnative.String, duration gdnative.Real, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Real) gdnative.Bool {
	//log.Println("Calling Tween.FollowMethod()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 9, 9)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromString(method)
	ptrArguments[2] = gdnative.NewPointerFromVariant(initialVal)
	ptrArguments[3] = gdnative.NewPointerFromObject(target.GetBaseObject())
	ptrArguments[4] = gdnative.NewPointerFromString(targetMethod)
	ptrArguments[5] = gdnative.NewPointerFromReal(duration)
	ptrArguments[6] = gdnative.NewPointerFromInt(transType)
	ptrArguments[7] = gdnative.NewPointerFromInt(easeType)
	ptrArguments[8] = gdnative.NewPointerFromReal(delay)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "follow_method")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Follow [code]property[/code] of [code]object[/code] and apply it on [code]target_property[/code] of [code]target[/code], beginning from [code]initial_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. Note that [code]target:target_property[/code] would equal [code]object:property[/code] at the end of the tween. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
	Args: [{ false object Object} { false property NodePath} { false initial_val Variant} { false target Object} { false target_property NodePath} { false duration float} { false trans_type int} { false ease_type int} {0 true delay float}], Returns: bool
*/
func (o *Tween) FollowProperty(object ObjectImplementer, property gdnative.NodePath, initialVal gdnative.Variant, target ObjectImplementer, targetProperty gdnative.NodePath, duration gdnative.Real, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Real) gdnative.Bool {
	//log.Println("Calling Tween.FollowProperty()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 9, 9)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromNodePath(property)
	ptrArguments[2] = gdnative.NewPointerFromVariant(initialVal)
	ptrArguments[3] = gdnative.NewPointerFromObject(target.GetBaseObject())
	ptrArguments[4] = gdnative.NewPointerFromNodePath(targetProperty)
	ptrArguments[5] = gdnative.NewPointerFromReal(duration)
	ptrArguments[6] = gdnative.NewPointerFromInt(transType)
	ptrArguments[7] = gdnative.NewPointerFromInt(easeType)
	ptrArguments[8] = gdnative.NewPointerFromReal(delay)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "follow_property")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns the time needed for all tweens to end in seconds, measured from the start. Thus, if you have two tweens, one ending 10 seconds after the start and the other - 20 seconds, it would return 20 seconds, as by that time all tweens would have finished.
	Args: [], Returns: float
*/
func (o *Tween) GetRuntime() gdnative.Real {
	//log.Println("Calling Tween.GetRuntime()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "get_runtime")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: float
*/
func (o *Tween) GetSpeedScale() gdnative.Real {
	//log.Println("Calling Tween.GetSpeedScale()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "get_speed_scale")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: enum.Tween::TweenProcessMode
*/
func (o *Tween) GetTweenProcessMode() TweenTweenProcessMode {
	//log.Println("Calling Tween.GetTweenProcessMode()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "get_tween_process_mode")

	// Call the parent method.
	// enum.Tween::TweenProcessMode
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	return TweenTweenProcessMode(ret)
}

/*
        Call [code]callback[/code] of [code]object[/code] after [code]duration[/code]. [code]arg1[/code]-[code]arg5[/code] are arguments to be passed to the callback.
	Args: [{ false object Object} { false duration float} { false callback String} {Null true arg1 Variant} {Null true arg2 Variant} {Null true arg3 Variant} {Null true arg4 Variant} {Null true arg5 Variant}], Returns: bool
*/
func (o *Tween) InterpolateCallback(object ObjectImplementer, duration gdnative.Real, callback gdnative.String, arg1 gdnative.Variant, arg2 gdnative.Variant, arg3 gdnative.Variant, arg4 gdnative.Variant, arg5 gdnative.Variant) gdnative.Bool {
	//log.Println("Calling Tween.InterpolateCallback()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 8, 8)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromReal(duration)
	ptrArguments[2] = gdnative.NewPointerFromString(callback)
	ptrArguments[3] = gdnative.NewPointerFromVariant(arg1)
	ptrArguments[4] = gdnative.NewPointerFromVariant(arg2)
	ptrArguments[5] = gdnative.NewPointerFromVariant(arg3)
	ptrArguments[6] = gdnative.NewPointerFromVariant(arg4)
	ptrArguments[7] = gdnative.NewPointerFromVariant(arg5)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "interpolate_callback")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Call [code]callback[/code] of [code]object[/code] after [code]duration[/code] on the main thread (similar to [method Object.call_deferred]). [code]arg1[/code]-[code]arg5[/code] are arguments to be passed to the callback.
	Args: [{ false object Object} { false duration float} { false callback String} {Null true arg1 Variant} {Null true arg2 Variant} {Null true arg3 Variant} {Null true arg4 Variant} {Null true arg5 Variant}], Returns: bool
*/
func (o *Tween) InterpolateDeferredCallback(object ObjectImplementer, duration gdnative.Real, callback gdnative.String, arg1 gdnative.Variant, arg2 gdnative.Variant, arg3 gdnative.Variant, arg4 gdnative.Variant, arg5 gdnative.Variant) gdnative.Bool {
	//log.Println("Calling Tween.InterpolateDeferredCallback()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 8, 8)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromReal(duration)
	ptrArguments[2] = gdnative.NewPointerFromString(callback)
	ptrArguments[3] = gdnative.NewPointerFromVariant(arg1)
	ptrArguments[4] = gdnative.NewPointerFromVariant(arg2)
	ptrArguments[5] = gdnative.NewPointerFromVariant(arg3)
	ptrArguments[6] = gdnative.NewPointerFromVariant(arg4)
	ptrArguments[7] = gdnative.NewPointerFromVariant(arg5)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "interpolate_deferred_callback")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Animate [code]method[/code] of [code]object[/code] from [code]initial_val[/code] to [code]final_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. Methods are animated by calling them with consecutive values. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
	Args: [{ false object Object} { false method String} { false initial_val Variant} { false final_val Variant} { false duration float} { false trans_type int} { false ease_type int} {0 true delay float}], Returns: bool
*/
func (o *Tween) InterpolateMethod(object ObjectImplementer, method gdnative.String, initialVal gdnative.Variant, finalVal gdnative.Variant, duration gdnative.Real, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Real) gdnative.Bool {
	//log.Println("Calling Tween.InterpolateMethod()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 8, 8)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromString(method)
	ptrArguments[2] = gdnative.NewPointerFromVariant(initialVal)
	ptrArguments[3] = gdnative.NewPointerFromVariant(finalVal)
	ptrArguments[4] = gdnative.NewPointerFromReal(duration)
	ptrArguments[5] = gdnative.NewPointerFromInt(transType)
	ptrArguments[6] = gdnative.NewPointerFromInt(easeType)
	ptrArguments[7] = gdnative.NewPointerFromReal(delay)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "interpolate_method")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Animate [code]property[/code] of [code]object[/code] from [code]initial_val[/code] to [code]final_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
	Args: [{ false object Object} { false property NodePath} { false initial_val Variant} { false final_val Variant} { false duration float} { false trans_type int} { false ease_type int} {0 true delay float}], Returns: bool
*/
func (o *Tween) InterpolateProperty(object ObjectImplementer, property gdnative.NodePath, initialVal gdnative.Variant, finalVal gdnative.Variant, duration gdnative.Real, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Real) gdnative.Bool {
	//log.Println("Calling Tween.InterpolateProperty()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 8, 8)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromNodePath(property)
	ptrArguments[2] = gdnative.NewPointerFromVariant(initialVal)
	ptrArguments[3] = gdnative.NewPointerFromVariant(finalVal)
	ptrArguments[4] = gdnative.NewPointerFromReal(duration)
	ptrArguments[5] = gdnative.NewPointerFromInt(transType)
	ptrArguments[6] = gdnative.NewPointerFromInt(easeType)
	ptrArguments[7] = gdnative.NewPointerFromReal(delay)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "interpolate_property")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns true if any tweens are currently running, and false otherwise. Note that this method doesn't consider tweens that have ended.
	Args: [], Returns: bool
*/
func (o *Tween) IsActive() gdnative.Bool {
	//log.Println("Calling Tween.IsActive()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "is_active")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Undocumented
	Args: [], Returns: bool
*/
func (o *Tween) IsRepeat() gdnative.Bool {
	//log.Println("Calling Tween.IsRepeat()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "is_repeat")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Stop animating and completely remove a tween, given its object and property/method pair. Passing empty String as key will remove all tweens for given object.
	Args: [{ false object Object} { true key String}], Returns: bool
*/
func (o *Tween) Remove(object ObjectImplementer, key gdnative.String) gdnative.Bool {
	//log.Println("Calling Tween.Remove()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromString(key)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "remove")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Stop animating and completely remove all tweens.
	Args: [], Returns: bool
*/
func (o *Tween) RemoveAll() gdnative.Bool {
	//log.Println("Calling Tween.RemoveAll()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "remove_all")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Resets a tween to the initial value (the one given, not the one before the tween), given its object and property/method pair. Passing empty String as key will reset all tweens for given object.
	Args: [{ false object Object} { true key String}], Returns: bool
*/
func (o *Tween) Reset(object ObjectImplementer, key gdnative.String) gdnative.Bool {
	//log.Println("Calling Tween.Reset()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromString(key)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "reset")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Resets all tweens to their initial values (the ones given, not those before the tween).
	Args: [], Returns: bool
*/
func (o *Tween) ResetAll() gdnative.Bool {
	//log.Println("Calling Tween.ResetAll()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "reset_all")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Continue animating a stopped tween, given its object and property/method pair. Passing empty String as key will resume all tweens for given object.
	Args: [{ false object Object} { true key String}], Returns: bool
*/
func (o *Tween) Resume(object ObjectImplementer, key gdnative.String) gdnative.Bool {
	//log.Println("Calling Tween.Resume()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromString(key)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "resume")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Continue animating all stopped tweens.
	Args: [], Returns: bool
*/
func (o *Tween) ResumeAll() gdnative.Bool {
	//log.Println("Calling Tween.ResumeAll()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "resume_all")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Seek the animation to the given [code]time[/code] in seconds.
	Args: [{ false time float}], Returns: bool
*/
func (o *Tween) Seek(time gdnative.Real) gdnative.Bool {
	//log.Println("Calling Tween.Seek()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromReal(time)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "seek")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Activate/deactivate the tween. You can use this for pausing animations, though [method stop_all] and [method resume_all] might be more fit for this.
	Args: [{ false active bool}], Returns: void
*/
func (o *Tween) SetActive(active gdnative.Bool) {
	//log.Println("Calling Tween.SetActive()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(active)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "set_active")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false repeat bool}], Returns: void
*/
func (o *Tween) SetRepeat(repeat gdnative.Bool) {
	//log.Println("Calling Tween.SetRepeat()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromBool(repeat)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "set_repeat")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false speed float}], Returns: void
*/
func (o *Tween) SetSpeedScale(speed gdnative.Real) {
	//log.Println("Calling Tween.SetSpeedScale()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromReal(speed)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "set_speed_scale")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Undocumented
	Args: [{ false mode int}], Returns: void
*/
func (o *Tween) SetTweenProcessMode(mode gdnative.Int) {
	//log.Println("Calling Tween.SetTweenProcessMode()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(mode)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "set_tween_process_mode")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Start the tween node. You can define tweens both before and after this.
	Args: [], Returns: bool
*/
func (o *Tween) Start() gdnative.Bool {
	//log.Println("Calling Tween.Start()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "start")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Stop animating a tween, given its object and property/method pair. Passing empty String as key will stop all tweens for given object.
	Args: [{ false object Object} { true key String}], Returns: bool
*/
func (o *Tween) Stop(object ObjectImplementer, key gdnative.String) gdnative.Bool {
	//log.Println("Calling Tween.Stop()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromString(key)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "stop")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Stop animating all tweens.
	Args: [], Returns: bool
*/
func (o *Tween) StopAll() gdnative.Bool {
	//log.Println("Calling Tween.StopAll()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "stop_all")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Animate [code]method[/code] of [code]object[/code] from the value returned by [code]initial.initial_method[/code] to [code]final_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. Methods are animated by calling them with consecutive values. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
	Args: [{ false object Object} { false method String} { false initial Object} { false initial_method String} { false final_val Variant} { false duration float} { false trans_type int} { false ease_type int} {0 true delay float}], Returns: bool
*/
func (o *Tween) TargetingMethod(object ObjectImplementer, method gdnative.String, initial ObjectImplementer, initialMethod gdnative.String, finalVal gdnative.Variant, duration gdnative.Real, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Real) gdnative.Bool {
	//log.Println("Calling Tween.TargetingMethod()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 9, 9)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromString(method)
	ptrArguments[2] = gdnative.NewPointerFromObject(initial.GetBaseObject())
	ptrArguments[3] = gdnative.NewPointerFromString(initialMethod)
	ptrArguments[4] = gdnative.NewPointerFromVariant(finalVal)
	ptrArguments[5] = gdnative.NewPointerFromReal(duration)
	ptrArguments[6] = gdnative.NewPointerFromInt(transType)
	ptrArguments[7] = gdnative.NewPointerFromInt(easeType)
	ptrArguments[8] = gdnative.NewPointerFromReal(delay)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "targeting_method")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Animate [code]property[/code] of [code]object[/code] from the current value of the [code]initial_val[/code] property of [code]initial[/code] to [code]final_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
	Args: [{ false object Object} { false property NodePath} { false initial Object} { false initial_val NodePath} { false final_val Variant} { false duration float} { false trans_type int} { false ease_type int} {0 true delay float}], Returns: bool
*/
func (o *Tween) TargetingProperty(object ObjectImplementer, property gdnative.NodePath, initial ObjectImplementer, initialVal gdnative.NodePath, finalVal gdnative.Variant, duration gdnative.Real, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Real) gdnative.Bool {
	//log.Println("Calling Tween.TargetingProperty()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 9, 9)
	ptrArguments[0] = gdnative.NewPointerFromObject(object.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromNodePath(property)
	ptrArguments[2] = gdnative.NewPointerFromObject(initial.GetBaseObject())
	ptrArguments[3] = gdnative.NewPointerFromNodePath(initialVal)
	ptrArguments[4] = gdnative.NewPointerFromVariant(finalVal)
	ptrArguments[5] = gdnative.NewPointerFromReal(duration)
	ptrArguments[6] = gdnative.NewPointerFromInt(transType)
	ptrArguments[7] = gdnative.NewPointerFromInt(easeType)
	ptrArguments[8] = gdnative.NewPointerFromReal(delay)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "targeting_property")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	return ret
}

/*
        Returns the current time of the tween.
	Args: [], Returns: float
*/
func (o *Tween) Tell() gdnative.Real {
	//log.Println("Calling Tween.Tell()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Tween", "tell")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyReal()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewRealFromPointer(retPtr)
	return ret
}

// TweenImplementer is an interface that implements the methods
// of the Tween class.
type TweenImplementer interface {
	NodeImplementer
	X_Remove(object ObjectImplementer, key gdnative.String, firstOnly gdnative.Bool)
	FollowMethod(object ObjectImplementer, method gdnative.String, initialVal gdnative.Variant, target ObjectImplementer, targetMethod gdnative.String, duration gdnative.Real, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Real) gdnative.Bool
	FollowProperty(object ObjectImplementer, property gdnative.NodePath, initialVal gdnative.Variant, target ObjectImplementer, targetProperty gdnative.NodePath, duration gdnative.Real, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Real) gdnative.Bool
	GetRuntime() gdnative.Real
	GetSpeedScale() gdnative.Real
	InterpolateCallback(object ObjectImplementer, duration gdnative.Real, callback gdnative.String, arg1 gdnative.Variant, arg2 gdnative.Variant, arg3 gdnative.Variant, arg4 gdnative.Variant, arg5 gdnative.Variant) gdnative.Bool
	InterpolateDeferredCallback(object ObjectImplementer, duration gdnative.Real, callback gdnative.String, arg1 gdnative.Variant, arg2 gdnative.Variant, arg3 gdnative.Variant, arg4 gdnative.Variant, arg5 gdnative.Variant) gdnative.Bool
	InterpolateMethod(object ObjectImplementer, method gdnative.String, initialVal gdnative.Variant, finalVal gdnative.Variant, duration gdnative.Real, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Real) gdnative.Bool
	InterpolateProperty(object ObjectImplementer, property gdnative.NodePath, initialVal gdnative.Variant, finalVal gdnative.Variant, duration gdnative.Real, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Real) gdnative.Bool
	IsActive() gdnative.Bool
	IsRepeat() gdnative.Bool
	Remove(object ObjectImplementer, key gdnative.String) gdnative.Bool
	RemoveAll() gdnative.Bool
	Reset(object ObjectImplementer, key gdnative.String) gdnative.Bool
	ResetAll() gdnative.Bool
	Resume(object ObjectImplementer, key gdnative.String) gdnative.Bool
	ResumeAll() gdnative.Bool
	Seek(time gdnative.Real) gdnative.Bool
	SetActive(active gdnative.Bool)
	SetRepeat(repeat gdnative.Bool)
	SetSpeedScale(speed gdnative.Real)
	SetTweenProcessMode(mode gdnative.Int)
	Start() gdnative.Bool
	Stop(object ObjectImplementer, key gdnative.String) gdnative.Bool
	StopAll() gdnative.Bool
	TargetingMethod(object ObjectImplementer, method gdnative.String, initial ObjectImplementer, initialMethod gdnative.String, finalVal gdnative.Variant, duration gdnative.Real, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Real) gdnative.Bool
	TargetingProperty(object ObjectImplementer, property gdnative.NodePath, initial ObjectImplementer, initialVal gdnative.NodePath, finalVal gdnative.Variant, duration gdnative.Real, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Real) gdnative.Bool
	Tell() gdnative.Real
}
