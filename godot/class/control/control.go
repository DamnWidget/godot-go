package control

import (
	"log"
	"reflect"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

/*
Base class for all User Interface or [i]UI[/i] related nodes. [code]Control[/code] features a bounding rectangle that defines its extents, an anchor position relative to its parent and margins that represent an offset to the anchor. The margins update automatically when the node, any of its parents, or the screen size change. For more information on Godot's UI system, anchors, margins, and containers, see the related tutorials in the manual. To build flexible UIs, you'll need a mix of UI elements that inherit from [code]Control[/code] and [Container] nodes. [b]User Interface nodes and input[/b] Godot sends input events to the scene's root node first, by calling [method Node._input]. [method Node._input] forwards the event down the node tree to the nodes under the mouse cursor, or on keyboard focus. To do so, it calls [method MainLoop._input_event]. Call [method accept_event] so no other node receives the event. Once you accepted an input, it becomes handled so [method Node._unhandled_input] will not process it. Only one [code]Control[/code] node can be in keyboard focus. Only the node in focus will receive keyboard events. To get the focus, call [method grab_focus]. [code]Control[/code] nodes lose focus when another node grabs it, or if you hide the node in focus. Set [member mouse_filter] to MOUSE_FILTER_IGNORE to tell a [code]Control[/code] node to ignore mouse or touch events. You'll need it if you place an icon on top of a button. [Theme] resources change the Control's appearance. If you change the [Theme] on a [code]Control[/code] node, it affects all of its children. To override some of the theme's parameters, call one of the [code]add_*_override[/code] methods, like [method add_font_override]. You can override the theme with the inspector.
*/
type Control struct {
	CanvasItem
}

func (o *Control) BaseClass() string {
	return "Control"
}

/*
   Undocumented
*/
func (o *Control) X_FontChanged() {
	log.Println("Calling Control.X_FontChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "_font_changed", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Returns the minimum size this Control can shrink to. The node can never be smaller than this minimum size.
*/
func (o *Control) X_GetMinimumSize() *Vector2 {
	log.Println("Calling Control.X_GetMinimumSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "_get_minimum_size", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Control) X_GetTooltip() gdnative.String {
	log.Println("Calling Control.X_GetTooltip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "_get_tooltip", goArguments, "gdnative.String")

	returnValue := goRet.Interface().(gdnative.String)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   The node's parent forwards input events to this method. Use it to process and accept inputs on UI elements. See [method accept_event]. Replaces Godot 2's [code]_input_event[/code].
*/
func (o *Control) X_GuiInput(event *InputEvent) {
	log.Println("Calling Control.X_GuiInput()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(event)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "_gui_input", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) X_SetAnchor(margin gdnative.Int, anchor gdnative.Float) {
	log.Println("Calling Control.X_SetAnchor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(anchor)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "_set_anchor", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) X_SizeChanged() {
	log.Println("Calling Control.X_SizeChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "_size_changed", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) X_ThemeChanged() {
	log.Println("Calling Control.X_ThemeChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "_theme_changed", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) X_UpdateMinimumSize() {
	log.Println("Calling Control.X_UpdateMinimumSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "_update_minimum_size", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Marks an input event as handled. Once you accept an input event, it stops propagating, even to nodes listening to [method Node._unhandled_input] or [method Node._unhandled_key_input].
*/
func (o *Control) AcceptEvent() {
	log.Println("Calling Control.AcceptEvent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "accept_event", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Overrides the color in the [theme] resource the node uses.
*/
func (o *Control) AddColorOverride(name gdnative.String, color *Color) {
	log.Println("Calling Control.AddColorOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(color)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "add_color_override", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Overrides an integer constant in the [Theme] resource the node uses. If the [code]constant[/code] is invalid, Godot clears the override. See [member Theme.INVALID_CONSTANT] for more information.
*/
func (o *Control) AddConstantOverride(name gdnative.String, constant gdnative.Int) {
	log.Println("Calling Control.AddConstantOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(constant)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "add_constant_override", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Overrides the [code]name[/code] font in the [theme] resource the node uses. If [code]font[/code] is empty, Godot clears the override.
*/
func (o *Control) AddFontOverride(name gdnative.String, font *Font) {
	log.Println("Calling Control.AddFontOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(font)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "add_font_override", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Overrides the [code]name[/code] icon in the [theme] resource the node uses. If [code]icon[/code] is empty, Godot clears the override.
*/
func (o *Control) AddIconOverride(name gdnative.String, texture *Texture) {
	log.Println("Calling Control.AddIconOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(texture)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "add_icon_override", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Overrides the [code]name[/code] shader in the [theme] resource the node uses. If [code]shader[/code] is empty, Godot clears the override.
*/
func (o *Control) AddShaderOverride(name gdnative.String, shader *Shader) {
	log.Println("Calling Control.AddShaderOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(shader)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "add_shader_override", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Overrides the [code]name[/code] [Stylebox] in the [theme] resource the node uses. If [code]stylebox[/code] is empty, Godot clears the override.
*/
func (o *Control) AddStyleboxOverride(name gdnative.String, stylebox *StyleBox) {
	log.Println("Calling Control.AddStyleboxOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(stylebox)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "add_stylebox_override", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Godot calls this method to test if [code]data[/code] from a control's [method get_drag_data] can be dropped at [code]position[/code]. [code]position[/code] is local to this control. This method should only be used to test the data. Process the data in [method drop_data]. [codeblock] extends Control func can_drop_data(position, data): # check position if it is relevant to you # otherwise just check data return typeof(data) == TYPE_DICTIONARY and data.has('expected') [/codeblock]
*/
func (o *Control) CanDropData(position *Vector2, data *Variant) gdnative.Bool {
	log.Println("Calling Control.CanDropData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(position)
	goArguments[1] = reflect.ValueOf(data)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "can_drop_data", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Godot calls this method to pass you the [code]data[/code] from a control's [method get_drag_data] result. Godot first calls [method can_drop_data] to test if [code]data[/code] is allowed to drop at [code]position[/code] where [code]position[/code] is local to this control. [codeblock] extends ColorRect func can_drop_data(position, data): return typeof(data) == TYPE_DICTIONARY and data.has('color') func drop_data(position, data): color = data['color'] [/codeblock]
*/
func (o *Control) DropData(position *Vector2, data *Variant) {
	log.Println("Calling Control.DropData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(position)
	goArguments[1] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "drop_data", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Forces drag and bypasses [method get_drag_data] and [method set_drag_preview] by passing [code]data[/code] and [code]preview[/code]. Drag will start even if the mouse is neither over nor pressed on this control. The methods [method can_drop_data] and [method drop_data] must be implemented on controls that want to recieve drop data.
*/
func (o *Control) ForceDrag(data *Variant, preview *Object) {
	log.Println("Calling Control.ForceDrag()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(data)
	goArguments[1] = reflect.ValueOf(preview)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "force_drag", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) GetAnchor(margin gdnative.Int) gdnative.Float {
	log.Println("Calling Control.GetAnchor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_anchor", goArguments, "gdnative.Float")

	returnValue := goRet.Interface().(gdnative.Float)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) GetBegin() *Vector2 {
	log.Println("Calling Control.GetBegin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_begin", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) GetColor(name gdnative.String, aType gdnative.String) *Color {
	log.Println("Calling Control.GetColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_color", goArguments, "*Color")

	returnValue := goRet.Interface().(*Color)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) GetCombinedMinimumSize() *Vector2 {
	log.Println("Calling Control.GetCombinedMinimumSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_combined_minimum_size", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) GetConstant(name gdnative.String, aType gdnative.String) gdnative.Int {
	log.Println("Calling Control.GetConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_constant", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the mouse cursor shape the control displays on mouse hover, one of the [code]CURSOR_*[/code] constants.
*/
func (o *Control) GetCursorShape(position *Vector2) gdnative.Int {
	log.Println("Calling Control.GetCursorShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_cursor_shape", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetCustomMinimumSize() *Vector2 {
	log.Println("Calling Control.GetCustomMinimumSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_custom_minimum_size", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetDefaultCursorShape() gdnative.Int {
	log.Println("Calling Control.GetDefaultCursorShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_default_cursor_shape", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Godot calls this method to get data that can be dragged and dropped onto controls that expect drop data. Return null if there is no data to drag. Controls that want to recieve drop data should implement [method can_drop_data] and [method drop_data]. [code]position[/code] is local to this control. Drag may be forced with [method force_drag]. A preview that will follow the mouse that should represent the data can be set with [method set_drag_preview]. A good time to set the preview is in this method. [codeblock] extends Control func get_drag_data(position): var mydata = make_data() set_drag_preview(make_preview(mydata)) return mydata [/codeblock]
*/
func (o *Control) GetDragData(position *Vector2) *Object {
	log.Println("Calling Control.GetDragData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_drag_data", goArguments, "*Object")

	returnValue := goRet.Interface().(*Object)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns MARGIN_LEFT and MARGIN_TOP at the same time. This is a helper (see [method set_margin]).
*/
func (o *Control) GetEnd() *Vector2 {
	log.Println("Calling Control.GetEnd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_end", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetFocusMode() gdnative.Int {
	log.Println("Calling Control.GetFocusMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_focus_mode", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetFocusNeighbour(margin gdnative.Int) *NodePath {
	log.Println("Calling Control.GetFocusNeighbour()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_focus_neighbour", goArguments, "*NodePath")

	returnValue := goRet.Interface().(*NodePath)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetFocusNext() *NodePath {
	log.Println("Calling Control.GetFocusNext()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_focus_next", goArguments, "*NodePath")

	returnValue := goRet.Interface().(*NodePath)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return which control is owning the keyboard focus, or null if no one.
*/
func (o *Control) GetFocusOwner() *Control {
	log.Println("Calling Control.GetFocusOwner()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_focus_owner", goArguments, "*Control")

	returnValue := goRet.Interface().(*Control)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetFocusPrevious() *NodePath {
	log.Println("Calling Control.GetFocusPrevious()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_focus_previous", goArguments, "*NodePath")

	returnValue := goRet.Interface().(*NodePath)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) GetFont(name gdnative.String, aType gdnative.String) *Font {
	log.Println("Calling Control.GetFont()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_font", goArguments, "*Font")

	returnValue := goRet.Interface().(*Font)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetGlobalPosition() *Vector2 {
	log.Println("Calling Control.GetGlobalPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_global_position", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return position and size of the Control, relative to the top-left corner of the [i]window[/i] Control. This is a helper (see [method get_global_position], [method get_size]).
*/
func (o *Control) GetGlobalRect() *Rect2 {
	log.Println("Calling Control.GetGlobalRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_global_rect", goArguments, "*Rect2")

	returnValue := goRet.Interface().(*Rect2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetHGrowDirection() gdnative.Int {
	log.Println("Calling Control.GetHGrowDirection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_h_grow_direction", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetHSizeFlags() gdnative.Int {
	log.Println("Calling Control.GetHSizeFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_h_size_flags", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) GetIcon(name gdnative.String, aType gdnative.String) *Texture {
	log.Println("Calling Control.GetIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_icon", goArguments, "*Texture")

	returnValue := goRet.Interface().(*Texture)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetMargin(margin gdnative.Int) gdnative.Float {
	log.Println("Calling Control.GetMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_margin", goArguments, "gdnative.Float")

	returnValue := goRet.Interface().(gdnative.Float)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the minimum size this Control can shrink to. A control will never be displayed or resized smaller than its minimum size.
*/
func (o *Control) GetMinimumSize() *Vector2 {
	log.Println("Calling Control.GetMinimumSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_minimum_size", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetMouseFilter() gdnative.Int {
	log.Println("Calling Control.GetMouseFilter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_mouse_filter", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) GetParentAreaSize() *Vector2 {
	log.Println("Calling Control.GetParentAreaSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_parent_area_size", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) GetParentControl() *Control {
	log.Println("Calling Control.GetParentControl()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_parent_control", goArguments, "*Control")

	returnValue := goRet.Interface().(*Control)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetPivotOffset() *Vector2 {
	log.Println("Calling Control.GetPivotOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_pivot_offset", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetPosition() *Vector2 {
	log.Println("Calling Control.GetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_position", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return position and size of the Control, relative to the top-left corner of the parent Control. This is a helper (see [method get_position], [method get_size]).
*/
func (o *Control) GetRect() *Rect2 {
	log.Println("Calling Control.GetRect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_rect", goArguments, "*Rect2")

	returnValue := goRet.Interface().(*Rect2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the rotation (in radians)
*/
func (o *Control) GetRotation() gdnative.Float {
	log.Println("Calling Control.GetRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_rotation", goArguments, "gdnative.Float")

	returnValue := goRet.Interface().(gdnative.Float)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetRotationDegrees() gdnative.Float {
	log.Println("Calling Control.GetRotationDegrees()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_rotation_degrees", goArguments, "gdnative.Float")

	returnValue := goRet.Interface().(gdnative.Float)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetScale() *Vector2 {
	log.Println("Calling Control.GetScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_scale", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetSize() *Vector2 {
	log.Println("Calling Control.GetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_size", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetStretchRatio() gdnative.Float {
	log.Println("Calling Control.GetStretchRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_stretch_ratio", goArguments, "gdnative.Float")

	returnValue := goRet.Interface().(gdnative.Float)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) GetStylebox(name gdnative.String, aType gdnative.String) *StyleBox {
	log.Println("Calling Control.GetStylebox()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_stylebox", goArguments, "*StyleBox")

	returnValue := goRet.Interface().(*StyleBox)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetTheme() *Theme {
	log.Println("Calling Control.GetTheme()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_theme", goArguments, "*Theme")

	returnValue := goRet.Interface().(*Theme)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the tooltip, which will appear when the cursor is resting over this control.
*/
func (o *Control) GetTooltip(atPosition *Vector2) gdnative.String {
	log.Println("Calling Control.GetTooltip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(atPosition)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_tooltip", goArguments, "gdnative.String")

	returnValue := goRet.Interface().(gdnative.String)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetVGrowDirection() gdnative.Int {
	log.Println("Calling Control.GetVGrowDirection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_v_grow_direction", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Control) GetVSizeFlags() gdnative.Int {
	log.Println("Calling Control.GetVSizeFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_v_size_flags", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) GrabClickFocus() {
	log.Println("Calling Control.GrabClickFocus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "grab_click_focus", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Steal the focus from another control and become the focused control (see [method set_focus_mode]).
*/
func (o *Control) GrabFocus() {
	log.Println("Calling Control.GrabFocus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "grab_focus", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) HasColor(name gdnative.String, aType gdnative.String) gdnative.Bool {
	log.Println("Calling Control.HasColor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "has_color", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) HasColorOverride(name gdnative.String) gdnative.Bool {
	log.Println("Calling Control.HasColorOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "has_color_override", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) HasConstant(name gdnative.String, aType gdnative.String) gdnative.Bool {
	log.Println("Calling Control.HasConstant()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "has_constant", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) HasConstantOverride(name gdnative.String) gdnative.Bool {
	log.Println("Calling Control.HasConstantOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "has_constant_override", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return whether the Control is the current focused control (see [method set_focus_mode]).
*/
func (o *Control) HasFocus() gdnative.Bool {
	log.Println("Calling Control.HasFocus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "has_focus", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) HasFont(name gdnative.String, aType gdnative.String) gdnative.Bool {
	log.Println("Calling Control.HasFont()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "has_font", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) HasFontOverride(name gdnative.String) gdnative.Bool {
	log.Println("Calling Control.HasFontOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "has_font_override", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) HasIcon(name gdnative.String, aType gdnative.String) gdnative.Bool {
	log.Println("Calling Control.HasIcon()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "has_icon", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) HasIconOverride(name gdnative.String) gdnative.Bool {
	log.Println("Calling Control.HasIconOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "has_icon_override", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) HasPoint(point *Vector2) gdnative.Bool {
	log.Println("Calling Control.HasPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(point)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "has_point", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) HasShaderOverride(name gdnative.String) gdnative.Bool {
	log.Println("Calling Control.HasShaderOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "has_shader_override", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) HasStylebox(name gdnative.String, aType gdnative.String) gdnative.Bool {
	log.Println("Calling Control.HasStylebox()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "has_stylebox", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) HasStyleboxOverride(name gdnative.String) gdnative.Bool {
	log.Println("Calling Control.HasStyleboxOverride()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "has_stylebox_override", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Control) IsClippingContents() gdnative.Bool {
	log.Println("Calling Control.IsClippingContents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "is_clipping_contents", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Control) MinimumSizeChanged() {
	log.Println("Calling Control.MinimumSizeChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "minimum_size_changed", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Give up the focus, no other control will be able to receive keyboard input.
*/
func (o *Control) ReleaseFocus() {
	log.Println("Calling Control.ReleaseFocus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "release_focus", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) SetAnchor(margin gdnative.Int, anchor gdnative.Float, keepMargin gdnative.Bool, pushOppositeAnchor gdnative.Bool) {
	log.Println("Calling Control.SetAnchor()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(anchor)
	goArguments[2] = reflect.ValueOf(keepMargin)
	goArguments[3] = reflect.ValueOf(pushOppositeAnchor)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_anchor", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) SetAnchorAndMargin(margin gdnative.Int, anchor gdnative.Float, offset gdnative.Float, pushOppositeAnchor gdnative.Bool) {
	log.Println("Calling Control.SetAnchorAndMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(anchor)
	goArguments[2] = reflect.ValueOf(offset)
	goArguments[3] = reflect.ValueOf(pushOppositeAnchor)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_anchor_and_margin", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) SetAnchorsAndMarginsPreset(preset gdnative.Int, resizeMode gdnative.Int, margin gdnative.Int) {
	log.Println("Calling Control.SetAnchorsAndMarginsPreset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(preset)
	goArguments[1] = reflect.ValueOf(resizeMode)
	goArguments[2] = reflect.ValueOf(margin)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_anchors_and_margins_preset", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) SetAnchorsPreset(preset gdnative.Int, keepMargin gdnative.Bool) {
	log.Println("Calling Control.SetAnchorsPreset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(preset)
	goArguments[1] = reflect.ValueOf(keepMargin)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_anchors_preset", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Sets MARGIN_LEFT and MARGIN_TOP at the same time. This is a helper (see [method set_margin]).
*/
func (o *Control) SetBegin(position *Vector2) {
	log.Println("Calling Control.SetBegin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_begin", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetClipContents(enable gdnative.Bool) {
	log.Println("Calling Control.SetClipContents()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_clip_contents", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetCustomMinimumSize(size *Vector2) {
	log.Println("Calling Control.SetCustomMinimumSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_custom_minimum_size", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetDefaultCursorShape(shape gdnative.Int) {
	log.Println("Calling Control.SetDefaultCursorShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(shape)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_default_cursor_shape", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Forwards the handling of this control's drag and drop to [code]target[/code] control. Forwarding can be implemented in the target control similar to the methods [method get_drag_data], [method can_drop_data], and [method drop_data] but with two differences: 1. The function name must be suffixed with [b]_fw[/b] 2. The function must take an extra argument that is the control doing the forwarding [codeblock] # ThisControl.gd extends Control func _ready(): set_drag_forwarding(target_control) # TargetControl.gd extends Control func can_drop_data_fw(position, data, from_control): return true func drop_data_fw(position, data, from_control): my_handle_data(data) func get_drag_data_fw(position, from_control): set_drag_preview(my_preview) return my_data() [/codeblock]
*/
func (o *Control) SetDragForwarding(target *Object) {
	log.Println("Calling Control.SetDragForwarding()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(target)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_drag_forwarding", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Shows the given control at the mouse pointer. A good time to call this method is in [method get_drag_data].
*/
func (o *Control) SetDragPreview(control *Object) {
	log.Println("Calling Control.SetDragPreview()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(control)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_drag_preview", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Sets MARGIN_RIGHT and MARGIN_BOTTOM at the same time. This is a helper (see [method set_margin]).
*/
func (o *Control) SetEnd(position *Vector2) {
	log.Println("Calling Control.SetEnd()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_end", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetFocusMode(mode gdnative.Int) {
	log.Println("Calling Control.SetFocusMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_focus_mode", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetFocusNeighbour(margin gdnative.Int, neighbour *NodePath) {
	log.Println("Calling Control.SetFocusNeighbour()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(neighbour)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_focus_neighbour", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetFocusNext(next *NodePath) {
	log.Println("Calling Control.SetFocusNext()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(next)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_focus_next", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetFocusPrevious(previous *NodePath) {
	log.Println("Calling Control.SetFocusPrevious()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(previous)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_focus_previous", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetGlobalPosition(position *Vector2) {
	log.Println("Calling Control.SetGlobalPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_global_position", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetHGrowDirection(direction gdnative.Int) {
	log.Println("Calling Control.SetHGrowDirection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(direction)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_h_grow_direction", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetHSizeFlags(flags gdnative.Int) {
	log.Println("Calling Control.SetHSizeFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flags)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_h_size_flags", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetMargin(margin gdnative.Int, offset gdnative.Float) {
	log.Println("Calling Control.SetMargin()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(margin)
	goArguments[1] = reflect.ValueOf(offset)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_margin", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) SetMarginsPreset(preset gdnative.Int, resizeMode gdnative.Int, margin gdnative.Int) {
	log.Println("Calling Control.SetMarginsPreset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(preset)
	goArguments[1] = reflect.ValueOf(resizeMode)
	goArguments[2] = reflect.ValueOf(margin)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_margins_preset", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetMouseFilter(filter gdnative.Int) {
	log.Println("Calling Control.SetMouseFilter()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(filter)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_mouse_filter", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetPivotOffset(pivotOffset *Vector2) {
	log.Println("Calling Control.SetPivotOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(pivotOffset)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_pivot_offset", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetPosition(position *Vector2) {
	log.Println("Calling Control.SetPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_position", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the rotation (in radians).
*/
func (o *Control) SetRotation(radians gdnative.Float) {
	log.Println("Calling Control.SetRotation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(radians)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_rotation", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetRotationDegrees(degrees gdnative.Float) {
	log.Println("Calling Control.SetRotationDegrees()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(degrees)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_rotation_degrees", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetScale(scale *Vector2) {
	log.Println("Calling Control.SetScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(scale)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_scale", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetSize(size *Vector2) {
	log.Println("Calling Control.SetSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_size", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetStretchRatio(ratio gdnative.Float) {
	log.Println("Calling Control.SetStretchRatio()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(ratio)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_stretch_ratio", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetTheme(theme *Theme) {
	log.Println("Calling Control.SetTheme()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(theme)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_theme", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetTooltip(tooltip gdnative.String) {
	log.Println("Calling Control.SetTooltip()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(tooltip)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_tooltip", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetVGrowDirection(direction gdnative.Int) {
	log.Println("Calling Control.SetVGrowDirection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(direction)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_v_grow_direction", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Control) SetVSizeFlags(flags gdnative.Int) {
	log.Println("Calling Control.SetVSizeFlags()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(flags)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_v_size_flags", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Display a Control as modal. Control must be a subwindow. Modal controls capture the input signals until closed or the area outside them is accessed. When a modal control loses focus, or the ESC key is pressed, they automatically hide. Modal controls are used extensively for popup dialogs and menus.
*/
func (o *Control) ShowModal(exclusive gdnative.Bool) {
	log.Println("Calling Control.ShowModal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(exclusive)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "show_modal", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Control) WarpMouse(toPosition *Vector2) {
	log.Println("Calling Control.WarpMouse()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(toPosition)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "warp_mouse", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   ControlImplementer is an interface for Control objects.
*/
type ControlImplementer interface {
	Class
}
