package httpclient

import (
	"log"
	"reflect"

	"github.com/shadowapex/godot-go/gdnative"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

/*
Hyper-text transfer protocol client (sometimes called "User Agent"). Used to make HTTP requests to download web content, upload files and other data or to communicate with various services, among other use cases. Note that this client only needs to connect to a host once (see [method connect_to_host]) to send multiple requests. Because of this, methods that take URLs usually take just the part after the host instead of the full URL, as the client is already connected to a host. See [method request] for a full example and to get started. A [code]HTTPClient[/code] should be reused between multiple requests or to connect to different hosts instead of creating one client per request. Supports SSL and SSL server certificate verification. HTTP status codes in the 2xx range indicate success, 3xx redirection (i.e. "try again, but over here"), 4xx something was wrong with the request, and 5xx something went wrong on the server's side. For more information on HTTP, see https://developer.mozilla.org/en-US/docs/Web/HTTP (or read RFC 2616 to get it straight from the source: https://tools.ietf.org/html/rfc2616).
*/
type HTTPClient struct {
	Reference
}

func (o *HTTPClient) BaseClass() string {
	return "HTTPClient"
}

/*
   Closes the current connection, allowing reuse of this [code]HTTPClient[/code].
*/
func (o *HTTPClient) Close() {
	log.Println("Calling HTTPClient.Close()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "close", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Connect to a host. This needs to be done before any requests are sent. The host should not have http:// prepended but will strip the protocol identifier if provided. If no [code]port[/code] is specified (or [code]-1[/code] is used), it is automatically set to 80 for HTTP and 443 for HTTPS (if [code]use_ssl[/code] is enabled). [code]verify_host[/code] will check the SSL identity of the host if set to [code]true[/code].
*/
func (o *HTTPClient) ConnectToHost(host gdnative.String, port gdnative.Int, useSsl gdnative.Bool, verifyHost gdnative.Bool) gdnative.Int {
	log.Println("Calling HTTPClient.ConnectToHost()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(host)
	goArguments[1] = reflect.ValueOf(port)
	goArguments[2] = reflect.ValueOf(useSsl)
	goArguments[3] = reflect.ValueOf(verifyHost)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "connect_to_host", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *HTTPClient) GetConnection() *StreamPeer {
	log.Println("Calling HTTPClient.GetConnection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_connection", goArguments, "*StreamPeer")

	returnValue := goRet.Interface().(*StreamPeer)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the response's body length.
*/
func (o *HTTPClient) GetResponseBodyLength() gdnative.Int {
	log.Println("Calling HTTPClient.GetResponseBodyLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_response_body_length", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the response's HTTP status code.
*/
func (o *HTTPClient) GetResponseCode() gdnative.Int {
	log.Println("Calling HTTPClient.GetResponseCode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_response_code", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the response headers.
*/
func (o *HTTPClient) GetResponseHeaders() *PoolStringArray {
	log.Println("Calling HTTPClient.GetResponseHeaders()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_response_headers", goArguments, "*PoolStringArray")

	returnValue := goRet.Interface().(*PoolStringArray)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns all response headers as dictionary where the case-sensitivity of the keys and values is kept like the server delivers it. A value is a simple String, this string can have more than one value where "; " is used as separator. Structure: ("key":"value1; value2") Example: (content-length:12), (Content-Type:application/json; charset=UTF-8)
*/
func (o *HTTPClient) GetResponseHeadersAsDictionary() *Dictionary {
	log.Println("Calling HTTPClient.GetResponseHeadersAsDictionary()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_response_headers_as_dictionary", goArguments, "*Dictionary")

	returnValue := goRet.Interface().(*Dictionary)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns a STATUS_* enum constant. Need to call [method poll] in order to get status updates.
*/
func (o *HTTPClient) GetStatus() gdnative.Int {
	log.Println("Calling HTTPClient.GetStatus()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_status", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   If [code]true[/code] this [code]HTTPClient[/code] has a response available.
*/
func (o *HTTPClient) HasResponse() gdnative.Bool {
	log.Println("Calling HTTPClient.HasResponse()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "has_response", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *HTTPClient) IsBlockingModeEnabled() gdnative.Bool {
	log.Println("Calling HTTPClient.IsBlockingModeEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "is_blocking_mode_enabled", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   If [code]true[/code] this [code]HTTPClient[/code] has a response that is chunked.
*/
func (o *HTTPClient) IsResponseChunked() gdnative.Bool {
	log.Println("Calling HTTPClient.IsResponseChunked()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "is_response_chunked", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   This needs to be called in order to have any request processed. Check results with [method get_status]
*/
func (o *HTTPClient) Poll() gdnative.Int {
	log.Println("Calling HTTPClient.Poll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "poll", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Generates a GET/POST application/x-www-form-urlencoded style query string from a provided dictionary, e.g.: [codeblock] var fields = {"username": "user", "password": "pass"} String queryString = httpClient.query_string_from_dict(fields) returns:= "username=user&password=pass" [/codeblock]
*/
func (o *HTTPClient) QueryStringFromDict(fields *Dictionary) gdnative.String {
	log.Println("Calling HTTPClient.QueryStringFromDict()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(fields)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "query_string_from_dict", goArguments, "gdnative.String")

	returnValue := goRet.Interface().(gdnative.String)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Reads one chunk from the response.
*/
func (o *HTTPClient) ReadResponseBodyChunk() *PoolByteArray {
	log.Println("Calling HTTPClient.ReadResponseBodyChunk()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "read_response_body_chunk", goArguments, "*PoolByteArray")

	returnValue := goRet.Interface().(*PoolByteArray)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Sends a request to the connected host. The URL parameter is just the part after the host, so for [code]http://somehost.com/index.php[/code], it is [code]index.php[/code]. Headers are HTTP request headers. For available HTTP methods, see [code]METHOD_*[/code]. To create a POST request with query strings to push to the server, do: [codeblock] var fields = {"username" : "user", "password" : "pass"} var queryString = httpClient.query_string_from_dict(fields) var headers = ["Content-Type: application/x-www-form-urlencoded", "Content-Length: " + str(queryString.length())] var result = httpClient.request(httpClient.METHOD_POST, "index.php", headers, queryString) [/codeblock]
*/
func (o *HTTPClient) Request(method gdnative.Int, url gdnative.String, headers *PoolStringArray, body gdnative.String) gdnative.Int {
	log.Println("Calling HTTPClient.Request()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(method)
	goArguments[1] = reflect.ValueOf(url)
	goArguments[2] = reflect.ValueOf(headers)
	goArguments[3] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "request", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Sends a raw request to the connected host. The URL parameter is just the part after the host, so for [code]http://somehost.com/index.php[/code], it is [code]index.php[/code]. Headers are HTTP request headers. For available HTTP methods, see [code]METHOD_*[/code]. Sends the body data raw, as a byte array and does not encode it in any way.
*/
func (o *HTTPClient) RequestRaw(method gdnative.Int, url gdnative.String, headers *PoolStringArray, body *PoolByteArray) gdnative.Int {
	log.Println("Calling HTTPClient.RequestRaw()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(method)
	goArguments[1] = reflect.ValueOf(url)
	goArguments[2] = reflect.ValueOf(headers)
	goArguments[3] = reflect.ValueOf(body)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "request_raw", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *HTTPClient) SetBlockingMode(enabled gdnative.Bool) {
	log.Println("Calling HTTPClient.SetBlockingMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_blocking_mode", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *HTTPClient) SetConnection(connection *StreamPeer) {
	log.Println("Calling HTTPClient.SetConnection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(connection)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_connection", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Sets the size of the buffer used and maximum bytes to read per iteration. see [method read_response_body_chunk]
*/
func (o *HTTPClient) SetReadChunkSize(bytes gdnative.Int) {
	log.Println("Calling HTTPClient.SetReadChunkSize()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(bytes)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_read_chunk_size", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   HTTPClientImplementer is an interface for HTTPClient objects.
*/
type HTTPClientImplementer interface {
	Class
}
