package configfile

import (
	"log"
	"reflect"

	"github.com/shadowapex/godot-go/gdnative"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

/*
This helper class can be used to store [Variant] values on the filesystem using INI-style formatting. The stored values are identified by a section and a key: [codeblock] [section] some_key=42 string_example="Hello World!" a_vector=Vector3( 1, 0, 2 ) [/codeblock] The stored data can be saved to or parsed from a file, though ConfigFile objects can also be used directly without accessing the filesystem. The following example shows how to parse an INI-style file from the system, read its contents and store new values in it: [codeblock] var config = ConfigFile.new() var err = config.load("user://settings.cfg") if err == OK: # if not, something went wrong with the file loading # Look for the display/width pair, and default to 1024 if missing var screen_width = get_value("display", "width", 1024) # Store a variable if and only if it hasn't been defined yet if not config.has_section_key("audio", "mute"): config.set_value("audio", "mute", false) # Save the changes by overwriting the previous file config.save("user://settings.cfg") [/codeblock]
*/
type ConfigFile struct {
	Reference
}

func (o *ConfigFile) BaseClass() string {
	return "ConfigFile"
}

/*
   Deletes the specified section along with all the key-value pairs inside.
*/
func (o *ConfigFile) EraseSection(section gdnative.String) {
	log.Println("Calling ConfigFile.EraseSection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(section)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "erase_section", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Returns an array of all defined key identifiers in the specified section.
*/
func (o *ConfigFile) GetSectionKeys(section gdnative.String) *PoolStringArray {
	log.Println("Calling ConfigFile.GetSectionKeys()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(section)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_section_keys", goArguments, "*PoolStringArray")

	returnValue := goRet.Interface().(*PoolStringArray)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns an array of all defined section identifiers.
*/
func (o *ConfigFile) GetSections() *PoolStringArray {
	log.Println("Calling ConfigFile.GetSections()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_sections", goArguments, "*PoolStringArray")

	returnValue := goRet.Interface().(*PoolStringArray)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the current value for the specified section and key. If the section and/or the key do not exist, the method returns the value of the optional [code]default[/code] argument, or [code]null[/code] if it is omitted.
*/
func (o *ConfigFile) GetValue(section gdnative.String, key gdnative.String, aDefault *Variant) *Variant {
	log.Println("Calling ConfigFile.GetValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(section)
	goArguments[1] = reflect.ValueOf(key)
	goArguments[2] = reflect.ValueOf(aDefault)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_value", goArguments, "*Variant")

	returnValue := goRet.Interface().(*Variant)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns [code]true[/code] if the specified section exists.
*/
func (o *ConfigFile) HasSection(section gdnative.String) gdnative.Bool {
	log.Println("Calling ConfigFile.HasSection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(section)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "has_section", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns [code]true[/code] if the specified section-key pair exists.
*/
func (o *ConfigFile) HasSectionKey(section gdnative.String, key gdnative.String) gdnative.Bool {
	log.Println("Calling ConfigFile.HasSectionKey()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(section)
	goArguments[1] = reflect.ValueOf(key)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "has_section_key", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Loads the config file specified as a parameter. The file's contents are parsed and loaded in the ConfigFile object which the method was called on. Returns one of the [code]OK[/code], [code]FAILED[/code] or [code]ERR_*[/code] constants listed in [@GlobalScope]. If the load was successful, the return value is [code]OK[/code].
*/
func (o *ConfigFile) Load(path gdnative.String) gdnative.Int {
	log.Println("Calling ConfigFile.Load()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "load", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Saves the contents of the ConfigFile object to the file specified as a parameter. The output file uses an INI-style structure. Returns one of the [code]OK[/code], [code]FAILED[/code] or [code]ERR_*[/code] constants listed in [@GlobalScope]. If the load was successful, the return value is [code]OK[/code].
*/
func (o *ConfigFile) Save(path gdnative.String) gdnative.Int {
	log.Println("Calling ConfigFile.Save()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "save", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Assigns a value to the specified key of the the specified section. If the section and/or the key do not exist, they are created. Passing a [code]null[/code] value deletes the specified key if it exists, and deletes the section if it ends up empty once the key has been removed.
*/
func (o *ConfigFile) SetValue(section gdnative.String, key gdnative.String, value *Variant) {
	log.Println("Calling ConfigFile.SetValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(section)
	goArguments[1] = reflect.ValueOf(key)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_value", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   ConfigFileImplementer is an interface for ConfigFile objects.
*/
type ConfigFileImplementer interface {
	Class
}
