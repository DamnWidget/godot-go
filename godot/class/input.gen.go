package class

import (
	"log"

	"github.com/shadowapex/godot-go/gdnative"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

//func NewinputFromPointer(ptr gdnative.Pointer) input {
func NewInputFromPointer(ptr gdnative.Pointer) input {
	owner := gdnative.NewObjectFromPointer(ptr)
	obj := input{}
	obj.SetBaseObject(owner)

	return obj
}

func newSingletonInput() *input {
	return &input{}
}

/*
   A Singleton that deals with inputs. This includes key presses, mouse buttons and movement, joypads, and input actions. Actions and their events can be set in the Project Settings / Input Map tab. Or be set with [InputMap].
*/
var Input = newSingletonInput()

/*
A Singleton that deals with inputs. This includes key presses, mouse buttons and movement, joypads, and input actions. Actions and their events can be set in the Project Settings / Input Map tab. Or be set with [InputMap].
*/
type input struct {
	Object
	owner       gdnative.Object
	initialized bool
}

// EnsureSingleton will check to see if we have an object for it. If not, it will fetch its
// GDNative object and set it.
func (o *input) ensureSingleton() {
	log.Println("ObjectID:", o.GetBaseObject().ID())
	if o.initialized == true {
		return
	}
	log.Println("Singleton not found. Fetching from GDNative...")
	base := gdnative.GetSingleton("Input")
	o.SetBaseObject(base)
	o.initialized = true
}

func (o *input) BaseClass() string {
	return "Input"
}

// SetBaseObject will internally set the Godot object inside the struct.
// This is used to call parent methods.
func (o *input) SetBaseObject(object gdnative.Object) {
	o.owner = object
}

func (o *input) GetBaseObject() gdnative.Object {
	return o.owner
}

/*
        This will simulate pressing the specified action.
	Args: [{ false action String}], Returns: void
*/
func (o *input) ActionPress(action gdnative.String) {
	o.ensureSingleton()
	log.Println("Calling Input.ActionPress()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(action)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "action_press")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        If the specified action is already pressed, this will release it.
	Args: [{ false action String}], Returns: void
*/
func (o *input) ActionRelease(action gdnative.String) {
	o.ensureSingleton()
	log.Println("Calling Input.ActionRelease()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(action)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "action_release")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Add a new mapping entry (in SDL2 format) to the mapping database. Optionally update already connected devices.
	Args: [{ false mapping String} {False true update_existing bool}], Returns: void
*/
func (o *input) AddJoyMapping(mapping gdnative.String, updateExisting gdnative.Bool) {
	o.ensureSingleton()
	log.Println("Calling Input.AddJoyMapping()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromString(mapping)
	ptrArguments[1] = gdnative.NewPointerFromBool(updateExisting)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "add_joy_mapping")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        If the device has an accelerometer, this will return the movement.
	Args: [], Returns: Vector3
*/
func (o *input) GetAccelerometer() gdnative.Vector3 {
	o.ensureSingleton()
	log.Println("Calling Input.GetAccelerometer()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "get_accelerometer")

	// Call the parent method.
	// Vector3
	retPtr := gdnative.NewEmptyVector3()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector3FromPointer(retPtr)
	log.Println("  Got return value: ", ret)
	return ret
}

/*
        Returns an [Array] containing the device IDs of all currently connected joypads.
	Args: [], Returns: Array
*/
func (o *input) GetConnectedJoypads() gdnative.Array {
	o.ensureSingleton()
	log.Println("Calling Input.GetConnectedJoypads()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "get_connected_joypads")

	// Call the parent method.
	// Array
	retPtr := gdnative.NewEmptyArray()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewArrayFromPointer(retPtr)
	log.Println("  Got return value: ", ret)
	return ret
}

/*

	Args: [], Returns: Vector3
*/
func (o *input) GetGravity() gdnative.Vector3 {
	o.ensureSingleton()
	log.Println("Calling Input.GetGravity()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "get_gravity")

	// Call the parent method.
	// Vector3
	retPtr := gdnative.NewEmptyVector3()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector3FromPointer(retPtr)
	log.Println("  Got return value: ", ret)
	return ret
}

/*
        If the device has a gyroscope, this will return the rate of rotation in rad/s around a device's x, y, and z axis.
	Args: [], Returns: Vector3
*/
func (o *input) GetGyroscope() gdnative.Vector3 {
	o.ensureSingleton()
	log.Println("Calling Input.GetGyroscope()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "get_gyroscope")

	// Call the parent method.
	// Vector3
	retPtr := gdnative.NewEmptyVector3()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector3FromPointer(retPtr)
	log.Println("  Got return value: ", ret)
	return ret
}

/*
        Returns the current value of the joypad axis at given index (see [code]JOY_*[/code] constants in [@GlobalScope])
	Args: [{ false device int} { false axis int}], Returns: float
*/
func (o *input) GetJoyAxis(device gdnative.Int, axis gdnative.Int) gdnative.Float {
	o.ensureSingleton()
	log.Println("Calling Input.GetJoyAxis()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(device)
	ptrArguments[1] = gdnative.NewPointerFromInt(axis)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "get_joy_axis")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyFloat()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewFloatFromPointer(retPtr)
	log.Println("  Got return value: ", ret)
	return ret
}

/*

	Args: [{ false axis String}], Returns: int
*/
func (o *input) GetJoyAxisIndexFromString(axis gdnative.String) gdnative.Int {
	o.ensureSingleton()
	log.Println("Calling Input.GetJoyAxisIndexFromString()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(axis)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "get_joy_axis_index_from_string")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	log.Println("  Got return value: ", ret)
	return ret
}

/*

	Args: [{ false axis_index int}], Returns: String
*/
func (o *input) GetJoyAxisString(axisIndex gdnative.Int) gdnative.String {
	o.ensureSingleton()
	log.Println("Calling Input.GetJoyAxisString()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(axisIndex)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "get_joy_axis_string")

	// Call the parent method.
	// String
	retPtr := gdnative.NewEmptyString()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewStringFromPointer(retPtr)
	log.Println("  Got return value: ", ret)
	return ret
}

/*

	Args: [{ false button String}], Returns: int
*/
func (o *input) GetJoyButtonIndexFromString(button gdnative.String) gdnative.Int {
	o.ensureSingleton()
	log.Println("Calling Input.GetJoyButtonIndexFromString()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(button)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "get_joy_button_index_from_string")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	log.Println("  Got return value: ", ret)
	return ret
}

/*

	Args: [{ false button_index int}], Returns: String
*/
func (o *input) GetJoyButtonString(buttonIndex gdnative.Int) gdnative.String {
	o.ensureSingleton()
	log.Println("Calling Input.GetJoyButtonString()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(buttonIndex)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "get_joy_button_string")

	// Call the parent method.
	// String
	retPtr := gdnative.NewEmptyString()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewStringFromPointer(retPtr)
	log.Println("  Got return value: ", ret)
	return ret
}

/*
        Returns a SDL2 compatible device guid on platforms that use gamepad remapping. Returns "Default Gamepad" otherwise.
	Args: [{ false device int}], Returns: String
*/
func (o *input) GetJoyGuid(device gdnative.Int) gdnative.String {
	o.ensureSingleton()
	log.Println("Calling Input.GetJoyGuid()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(device)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "get_joy_guid")

	// Call the parent method.
	// String
	retPtr := gdnative.NewEmptyString()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewStringFromPointer(retPtr)
	log.Println("  Got return value: ", ret)
	return ret
}

/*
        Returns the name of the joypad at the specified device index
	Args: [{ false device int}], Returns: String
*/
func (o *input) GetJoyName(device gdnative.Int) gdnative.String {
	o.ensureSingleton()
	log.Println("Calling Input.GetJoyName()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(device)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "get_joy_name")

	// Call the parent method.
	// String
	retPtr := gdnative.NewEmptyString()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewStringFromPointer(retPtr)
	log.Println("  Got return value: ", ret)
	return ret
}

/*
        Returns the duration of the current vibration effect in seconds.
	Args: [{ false device int}], Returns: float
*/
func (o *input) GetJoyVibrationDuration(device gdnative.Int) gdnative.Float {
	o.ensureSingleton()
	log.Println("Calling Input.GetJoyVibrationDuration()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(device)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "get_joy_vibration_duration")

	// Call the parent method.
	// float
	retPtr := gdnative.NewEmptyFloat()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewFloatFromPointer(retPtr)
	log.Println("  Got return value: ", ret)
	return ret
}

/*
        Returns the strength of the joypad vibration: x is the strength of the weak motor, and y is the strength of the strong motor.
	Args: [{ false device int}], Returns: Vector2
*/
func (o *input) GetJoyVibrationStrength(device gdnative.Int) gdnative.Vector2 {
	o.ensureSingleton()
	log.Println("Calling Input.GetJoyVibrationStrength()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(device)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "get_joy_vibration_strength")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	log.Println("  Got return value: ", ret)
	return ret
}

/*
        Returns the mouse speed for the last time the cursor was moved, and this until the next frame where the mouse moves. This means that even if the mouse is not moving, this function will still return the value of the last motion.
	Args: [], Returns: Vector2
*/
func (o *input) GetLastMouseSpeed() gdnative.Vector2 {
	o.ensureSingleton()
	log.Println("Calling Input.GetLastMouseSpeed()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "get_last_mouse_speed")

	// Call the parent method.
	// Vector2
	retPtr := gdnative.NewEmptyVector2()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector2FromPointer(retPtr)
	log.Println("  Got return value: ", ret)
	return ret
}

/*
        If the device has a magnetometer, this will return the magnetic field strength in micro-Tesla for all axes.
	Args: [], Returns: Vector3
*/
func (o *input) GetMagnetometer() gdnative.Vector3 {
	o.ensureSingleton()
	log.Println("Calling Input.GetMagnetometer()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "get_magnetometer")

	// Call the parent method.
	// Vector3
	retPtr := gdnative.NewEmptyVector3()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewVector3FromPointer(retPtr)
	log.Println("  Got return value: ", ret)
	return ret
}

/*
        Returns mouse buttons as a bitmask. If multiple mouse buttons are pressed at the same time the bits are added together.
	Args: [], Returns: int
*/
func (o *input) GetMouseButtonMask() gdnative.Int {
	o.ensureSingleton()
	log.Println("Calling Input.GetMouseButtonMask()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 0, 0)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "get_mouse_button_mask")

	// Call the parent method.
	// int
	retPtr := gdnative.NewEmptyInt()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewIntFromPointer(retPtr)
	log.Println("  Got return value: ", ret)
	return ret
}

/*
        Return the mouse mode. See the constants for more information.
	Args: [], Returns: enum.Input::MouseMode
*/

/*
        Returns [code]true[/code] when you start pressing the action event.
	Args: [{ false action String}], Returns: bool
*/
func (o *input) IsActionJustPressed(action gdnative.String) gdnative.Bool {
	o.ensureSingleton()
	log.Println("Calling Input.IsActionJustPressed()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(action)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "is_action_just_pressed")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	log.Println("  Got return value: ", ret)
	return ret
}

/*
        Returns [code]true[/code] when you stop pressing the action event.
	Args: [{ false action String}], Returns: bool
*/
func (o *input) IsActionJustReleased(action gdnative.String) gdnative.Bool {
	o.ensureSingleton()
	log.Println("Calling Input.IsActionJustReleased()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(action)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "is_action_just_released")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	log.Println("  Got return value: ", ret)
	return ret
}

/*
        Returns [code]true[/code] if you are pressing the action event.
	Args: [{ false action String}], Returns: bool
*/
func (o *input) IsActionPressed(action gdnative.String) gdnative.Bool {
	o.ensureSingleton()
	log.Println("Calling Input.IsActionPressed()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(action)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "is_action_pressed")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	log.Println("ObjectID:", o.GetBaseObject().ID())
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	log.Println("  Got return value: ", ret)
	return ret
}

/*
        Returns [code]true[/code] if you are pressing the joypad button. (see [code]JOY_*[/code] constants in [@GlobalScope])
	Args: [{ false device int} { false button int}], Returns: bool
*/
func (o *input) IsJoyButtonPressed(device gdnative.Int, button gdnative.Int) gdnative.Bool {
	o.ensureSingleton()
	log.Println("Calling Input.IsJoyButtonPressed()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 2, 2)
	ptrArguments[0] = gdnative.NewPointerFromInt(device)
	ptrArguments[1] = gdnative.NewPointerFromInt(button)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "is_joy_button_pressed")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	log.Println("  Got return value: ", ret)
	return ret
}

/*
        Returns [code]true[/code] if the system knows the specified device. This means that it sets all button and axis indices exactly as defined in the [code]JOY_*[/code] constants (see [@GlobalScope]). Unknown joypads are not expected to match these constants, but you can still retrieve events from them.
	Args: [{ false device int}], Returns: bool
*/
func (o *input) IsJoyKnown(device gdnative.Int) gdnative.Bool {
	o.ensureSingleton()
	log.Println("Calling Input.IsJoyKnown()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(device)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "is_joy_known")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	log.Println("  Got return value: ", ret)
	return ret
}

/*
        Returns [code]true[/code] if you are pressing the key. You can pass [code]KEY_*[/code], which are pre-defined constants listed in [@GlobalScope].
	Args: [{ false scancode int}], Returns: bool
*/
func (o *input) IsKeyPressed(scancode gdnative.Int) gdnative.Bool {
	o.ensureSingleton()
	log.Println("Calling Input.IsKeyPressed()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(scancode)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "is_key_pressed")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	log.Println("  Got return value: ", ret)
	return ret
}

/*
        Returns [code]true[/code] if you are pressing the mouse button. You can pass [code]BUTTON_*[/code], which are pre-defined constants listed in [@GlobalScope].
	Args: [{ false button int}], Returns: bool
*/
func (o *input) IsMouseButtonPressed(button gdnative.Int) gdnative.Bool {
	o.ensureSingleton()
	log.Println("Calling Input.IsMouseButtonPressed()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(button)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "is_mouse_button_pressed")

	// Call the parent method.
	// bool
	retPtr := gdnative.NewEmptyBool()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

	// If we have a return type, convert it from a pointer into its actual object.
	ret := gdnative.NewBoolFromPointer(retPtr)
	log.Println("  Got return value: ", ret)
	return ret
}

/*

	Args: [{ false device int} { false connected bool} { false name String} { false guid String}], Returns: void
*/
func (o *input) JoyConnectionChanged(device gdnative.Int, connected gdnative.Bool, name gdnative.String, guid gdnative.String) {
	o.ensureSingleton()
	log.Println("Calling Input.JoyConnectionChanged()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 4, 4)
	ptrArguments[0] = gdnative.NewPointerFromInt(device)
	ptrArguments[1] = gdnative.NewPointerFromBool(connected)
	ptrArguments[2] = gdnative.NewPointerFromString(name)
	ptrArguments[3] = gdnative.NewPointerFromString(guid)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "joy_connection_changed")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*

	Args: [{ false event InputEvent}], Returns: void
*/
func (o *input) ParseInputEvent(event InputEvent) {
	o.ensureSingleton()
	log.Println("Calling Input.ParseInputEvent()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromObject(event.GetBaseObject())

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "parse_input_event")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Removes all mappings from the internal db that match the given uid.
	Args: [{ false guid String}], Returns: void
*/
func (o *input) RemoveJoyMapping(guid gdnative.String) {
	o.ensureSingleton()
	log.Println("Calling Input.RemoveJoyMapping()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromString(guid)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "remove_joy_mapping")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Set a custom mouse cursor image, which is only visible inside the game window. The hotspot can also be specified. See enum [code]CURSOR_*[/code] for the list of shapes.
	Args: [{ false image Resource} {0 true shape int} {(0, 0) true hotspot Vector2}], Returns: void
*/
func (o *input) SetCustomMouseCursor(image Resource, shape gdnative.Int, hotspot gdnative.Vector2) {
	o.ensureSingleton()
	log.Println("Calling Input.SetCustomMouseCursor()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 3, 3)
	ptrArguments[0] = gdnative.NewPointerFromObject(image.GetBaseObject())
	ptrArguments[1] = gdnative.NewPointerFromInt(shape)
	ptrArguments[2] = gdnative.NewPointerFromVector2(hotspot)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "set_custom_mouse_cursor")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Set the mouse mode. See the constants for more information.
	Args: [{ false mode int}], Returns: void
*/
func (o *input) SetMouseMode(mode gdnative.Int) {
	o.ensureSingleton()
	log.Println("Calling Input.SetMouseMode()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(mode)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "set_mouse_mode")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Starts to vibrate the joypad. Joypads usually come with two rumble motors, a strong and a weak one. weak_magnitude is the strength of the weak motor (between 0 and 1) and strong_magnitude is the strength of the strong motor (between 0 and 1). duration is the duration of the effect in seconds (a duration of 0 will try to play the vibration indefinitely). Note that not every hardware is compatible with long effect durations, it is recommended to restart an effect if in need to play it for more than a few seconds.
	Args: [{ false device int} { false weak_magnitude float} { false strong_magnitude float} {0 true duration float}], Returns: void
*/
func (o *input) StartJoyVibration(device gdnative.Int, weakMagnitude gdnative.Float, strongMagnitude gdnative.Float, duration gdnative.Float) {
	o.ensureSingleton()
	log.Println("Calling Input.StartJoyVibration()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 4, 4)
	ptrArguments[0] = gdnative.NewPointerFromInt(device)
	ptrArguments[1] = gdnative.NewPointerFromFloat(weakMagnitude)
	ptrArguments[2] = gdnative.NewPointerFromFloat(strongMagnitude)
	ptrArguments[3] = gdnative.NewPointerFromFloat(duration)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "start_joy_vibration")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Stops the vibration of the joypad.
	Args: [{ false device int}], Returns: void
*/
func (o *input) StopJoyVibration(device gdnative.Int) {
	o.ensureSingleton()
	log.Println("Calling Input.StopJoyVibration()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromInt(device)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "stop_joy_vibration")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}

/*
        Sets the mouse position to the specified vector.
	Args: [{ false to Vector2}], Returns: void
*/
func (o *input) WarpMousePosition(to gdnative.Vector2) {
	o.ensureSingleton()
	log.Println("Calling Input.WarpMousePosition()")

	// Build out the method's arguments
	ptrArguments := make([]gdnative.Pointer, 1, 1)
	ptrArguments[0] = gdnative.NewPointerFromVector2(to)

	// Get the method bind
	methodBind := gdnative.NewMethodBind("Input", "warp_mouse_position")

	// Call the parent method.
	// void
	retPtr := gdnative.NewEmptyVoid()
	gdnative.MethodBindPtrCall(methodBind, o.GetBaseObject(), ptrArguments, retPtr)

}
