package object

import (
	"log"
	"reflect"
	"unsafe"

	"github.com/shadowapex/godot-go/gdnative"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

/*
Base class for all non built-in types. Everything not a built-in type starts the inheritance chain from this class. Objects do not manage memory, if inheriting from one the object will most likely have to be deleted manually (call the [method free] function from the script or delete from C++). Some derivatives add memory management, such as [Reference] (which keeps a reference count and deletes itself automatically when no longer referenced) and [Node], which deletes the children tree when deleted. Objects export properties, which are mainly useful for storage and editing, but not really so much in programming. Properties are exported in [method _get_property_list] and handled in [method _get] and [method _set]. However, scripting languages and C++ have simpler means to export them. Objects also receive notifications ([method _notification]). Notifications are a simple way to notify the object about simple events, so they can all be handled together.
*/
type Object struct {
	owner gdnative.Object
}

func (o *Object) BaseClass() string {
	return "Object"
}

/*
   Returns the given property. Returns [code]null[/code] if the [code]property[/code] does not exist.
*/
func (o *Object) X_Get(property gdnative.String) {
	log.Println("Calling Object.X_Get()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(property)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "_get", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Returns the object's property list as an [Array] of dictionaries. Dictionaries must contain: name:String, type:int (see TYPE_* enum in [@GlobalScope]) and optionally: hint:int (see PROPERTY_HINT_* in [@GlobalScope]), hint_string:String, usage:int (see PROPERTY_USAGE_* in [@GlobalScope]).
*/
func (o *Object) X_GetPropertyList() *Array {
	log.Println("Calling Object.X_GetPropertyList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "_get_property_list", goArguments, "*Array")

	returnValue := goRet.Interface().(*Array)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   The virtual method called upon initialization.
*/
func (o *Object) X_Init() {
	log.Println("Calling Object.X_Init()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "_init", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Notify the object internally using an ID.
*/
func (o *Object) X_Notification(what gdnative.Int) {
	log.Println("Calling Object.X_Notification()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(what)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "_notification", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Sets a property. Returns [code]true[/code] if the [code]property[/code] exists.
*/
func (o *Object) X_Set(property gdnative.String, value *Variant) gdnative.Bool {
	log.Println("Calling Object.X_Set()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(property)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "_set", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Adds a user-defined [code]signal[/code]. Arguments are optional, but can be added as an [Array] of dictionaries, each containing "name" and "type" (from [@GlobalScope] TYPE_*).
*/
func (o *Object) AddUserSignal(signal gdnative.String, arguments *Array) {
	log.Println("Calling Object.AddUserSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(signal)
	goArguments[1] = reflect.ValueOf(arguments)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "add_user_signal", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Calls the [code]method[/code] on the object and returns a result. Pass parameters as a comma separated list.
*/
func (o *Object) Call(method gdnative.String) *Variant {
	log.Println("Calling Object.Call()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "call", goArguments, "*Variant")

	returnValue := goRet.Interface().(*Variant)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Calls the [code]method[/code] on the object during idle time and returns a result. Pass parameters as a comma separated list.
*/
func (o *Object) CallDeferred(method gdnative.String) *Variant {
	log.Println("Calling Object.CallDeferred()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "call_deferred", goArguments, "*Variant")

	returnValue := goRet.Interface().(*Variant)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Calls the [code]method[/code] on the object and returns a result. Pass parameters as an [Array].
*/
func (o *Object) Callv(method gdnative.String, argArray *Array) *Variant {
	log.Println("Calling Object.Callv()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(method)
	goArguments[1] = reflect.ValueOf(argArray)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "callv", goArguments, "*Variant")

	returnValue := goRet.Interface().(*Variant)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns [code]true[/code] if the object can translate strings.
*/
func (o *Object) CanTranslateMessages() gdnative.Bool {
	log.Println("Calling Object.CanTranslateMessages()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "can_translate_messages", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Connects a [code]signal[/code] to a [code]method[/code] on a [code]target[/code] object. Pass optional [code]binds[/code] to the call. Use [code]flags[/code] to set deferred or one shot connections. See [code]CONNECT_*[/code] constants. A [code]signal[/code] can only be connected once to a [code]method[/code]. It will throw an error if already connected. To avoid this, first use [method is_connected] to check for existing connections.
*/
func (o *Object) Connect(signal gdnative.String, target *Object, method gdnative.String, binds *Array, flags gdnative.Int) gdnative.Int {
	log.Println("Calling Object.Connect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(signal)
	goArguments[1] = reflect.ValueOf(target)
	goArguments[2] = reflect.ValueOf(method)
	goArguments[3] = reflect.ValueOf(binds)
	goArguments[4] = reflect.ValueOf(flags)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "connect", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Disconnects a [code]signal[/code] from a [code]method[/code] on the given [code]target[/code].
*/
func (o *Object) Disconnect(signal gdnative.String, target *Object, method gdnative.String) {
	log.Println("Calling Object.Disconnect()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(signal)
	goArguments[1] = reflect.ValueOf(target)
	goArguments[2] = reflect.ValueOf(method)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "disconnect", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Emits the given [code]signal[/code].
*/
func (o *Object) EmitSignal(signal gdnative.String) *Variant {
	log.Println("Calling Object.EmitSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(signal)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "emit_signal", goArguments, "*Variant")

	returnValue := goRet.Interface().(*Variant)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Deletes the object from memory.
*/
func (o *Object) Free() {
	log.Println("Calling Object.Free()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "free", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Returns a [Variant] for a [code]property[/code].
*/
func (o *Object) Get(property gdnative.String) *Variant {
	log.Println("Calling Object.Get()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(property)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get", goArguments, "*Variant")

	returnValue := goRet.Interface().(*Variant)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the object's class as a [String].
*/
func (o *Object) GetClass() gdnative.String {
	log.Println("Calling Object.GetClass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_class", goArguments, "gdnative.String")

	returnValue := goRet.Interface().(gdnative.String)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns an [Array] of dictionaries with information about signals that are connected to the object. Inside each [Dictionary] there are 3 fields: - "source" is a reference to signal emitter. - "signal_name" is name of connected signal. - "method_name" is a name of method to which signal is connected.
*/
func (o *Object) GetIncomingConnections() *Array {
	log.Println("Calling Object.GetIncomingConnections()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_incoming_connections", goArguments, "*Array")

	returnValue := goRet.Interface().(*Array)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*

 */
func (o *Object) GetIndexed(property *NodePath) *Variant {
	log.Println("Calling Object.GetIndexed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(property)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_indexed", goArguments, "*Variant")

	returnValue := goRet.Interface().(*Variant)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the object's unique instance ID.
*/
func (o *Object) GetInstanceId() gdnative.Int {
	log.Println("Calling Object.GetInstanceId()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_instance_id", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the object's metadata for the given [code]name[/code].
*/
func (o *Object) GetMeta(name gdnative.String) *Variant {
	log.Println("Calling Object.GetMeta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_meta", goArguments, "*Variant")

	returnValue := goRet.Interface().(*Variant)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the object's metadata as a [PoolStringArray].
*/
func (o *Object) GetMetaList() *PoolStringArray {
	log.Println("Calling Object.GetMetaList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_meta_list", goArguments, "*PoolStringArray")

	returnValue := goRet.Interface().(*PoolStringArray)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the object's methods and their signatures as an [Array].
*/
func (o *Object) GetMethodList() *Array {
	log.Println("Calling Object.GetMethodList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_method_list", goArguments, "*Array")

	returnValue := goRet.Interface().(*Array)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the list of properties as an [Array] of dictionaries. Dictionaries contain: name:String, type:int (see TYPE_* enum in [@GlobalScope]) and optionally: hint:int (see PROPERTY_HINT_* in [@GlobalScope]), hint_string:String, usage:int (see PROPERTY_USAGE_* in [@GlobalScope]).
*/
func (o *Object) GetPropertyList() *Array {
	log.Println("Calling Object.GetPropertyList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_property_list", goArguments, "*Array")

	returnValue := goRet.Interface().(*Array)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the object's [Script] or [code]null[/code] if one doesn't exist.
*/
func (o *Object) GetScript() *Reference {
	log.Println("Calling Object.GetScript()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_script", goArguments, "*Reference")

	returnValue := goRet.Interface().(*Reference)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns an [Array] of connections for the given [code]signal[/code].
*/
func (o *Object) GetSignalConnectionList(signal gdnative.String) *Array {
	log.Println("Calling Object.GetSignalConnectionList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(signal)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_signal_connection_list", goArguments, "*Array")

	returnValue := goRet.Interface().(*Array)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the list of signals as an [Array] of dictionaries.
*/
func (o *Object) GetSignalList() *Array {
	log.Println("Calling Object.GetSignalList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_signal_list", goArguments, "*Array")

	returnValue := goRet.Interface().(*Array)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns [code]true[/code] if a metadata is found with the given [code]name[/code].
*/
func (o *Object) HasMeta(name gdnative.String) gdnative.Bool {
	log.Println("Calling Object.HasMeta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "has_meta", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns [code]true[/code] if the object contains the given [code]method[/code].
*/
func (o *Object) HasMethod(method gdnative.String) gdnative.Bool {
	log.Println("Calling Object.HasMethod()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "has_method", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns [code]true[/code] if the given user-defined [code]signal[/code] exists.
*/
func (o *Object) HasUserSignal(signal gdnative.String) gdnative.Bool {
	log.Println("Calling Object.HasUserSignal()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(signal)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "has_user_signal", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns [code]true[/code] if signal emission blocking is enabled.
*/
func (o *Object) IsBlockingSignals() gdnative.Bool {
	log.Println("Calling Object.IsBlockingSignals()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "is_blocking_signals", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns [code]true[/code] if the object inherits from the given [code]type[/code].
*/
func (o *Object) IsClass(aType gdnative.String) gdnative.Bool {
	log.Println("Calling Object.IsClass()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(aType)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "is_class", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns [code]true[/code] if a connection exists for a given [code]signal[/code], [code]target[/code], and [code]method[/code].
*/
func (o *Object) IsConnected(signal gdnative.String, target *Object, method gdnative.String) gdnative.Bool {
	log.Println("Calling Object.IsConnected()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(signal)
	goArguments[1] = reflect.ValueOf(target)
	goArguments[2] = reflect.ValueOf(method)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "is_connected", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns [code]true[/code] if the [code]queue_free[/code] method was called for the object.
*/
func (o *Object) IsQueuedForDeletion() gdnative.Bool {
	log.Println("Calling Object.IsQueuedForDeletion()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "is_queued_for_deletion", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Notify the object of something.
*/
func (o *Object) Notification(what gdnative.Int, reversed gdnative.Bool) {
	log.Println("Calling Object.Notification()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(what)
	goArguments[1] = reflect.ValueOf(reversed)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "notification", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Object) PropertyListChangedNotify() {
	log.Println("Calling Object.PropertyListChangedNotify()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "property_list_changed_notify", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set property into the object.
*/
func (o *Object) Set(property gdnative.String, value *Variant) {
	log.Println("Calling Object.Set()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(property)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   If set to true, signal emission is blocked.
*/
func (o *Object) SetBlockSignals(enable gdnative.Bool) {
	log.Println("Calling Object.SetBlockSignals()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_block_signals", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*

 */
func (o *Object) SetIndexed(property *NodePath, value *Variant) {
	log.Println("Calling Object.SetIndexed()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(property)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_indexed", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Define whether the object can translate strings (with calls to [method tr]). Default is true.
*/
func (o *Object) SetMessageTranslation(enable gdnative.Bool) {
	log.Println("Calling Object.SetMessageTranslation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enable)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_message_translation", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set a metadata into the object. Metadata is serialized. Metadata can be [i]anything[/i].
*/
func (o *Object) SetMeta(name gdnative.String, value *Variant) {
	log.Println("Calling Object.SetMeta()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_meta", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set a script into the object, scripts extend the object functionality.
*/
func (o *Object) SetScript(script *Reference) {
	log.Println("Calling Object.SetScript()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(script)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_script", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Translate a message. Only works if message translation is enabled (which it is by default). See [method set_message_translation].
*/
func (o *Object) Tr(message gdnative.String) gdnative.String {
	log.Println("Calling Object.Tr()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(message)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "tr", goArguments, "gdnative.String")

	returnValue := goRet.Interface().(gdnative.String)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

// SetOwner will internally set the Godot object inside the struct.
// This is used to call parent methods.
func (o *Object) SetOwner(object gdnative.Object) {
	o.owner = object
}

func (o *Object) GetOwner() gdnative.Object {
	return o.owner
}

// callParentMethod will call this object's method with the given method name.
func (o *Object) callParentMethod(baseClass, methodName string, args []reflect.Value, returns string) reflect.Value {
	log.Println("Calling parent method!")

	// Convert the base class and method names to C strings.
	log.Println("  Using base class: ", baseClass)
	classCString := C.CString(baseClass)
	log.Println("  Using method name: ", methodName)
	methodCString := C.CString(methodName)

	// Get the Godot objects owner so we can pass it to godot_method_bind_ptrcall.
	log.Println("  Using godot object owner:", o.getOwner())
	objectOwner := unsafe.Pointer(o.getOwner())

	// Get the Godot method bind pointer so we can pass it to godot_method_bind_ptrcall.
	var methodBind *C.godot_method_bind
	methodBind = C.godot_method_bind_get_method(classCString, methodCString)
	log.Println("  Using method bind pointer: ", methodBind)

	// Loop through the given arguments and see what type they are. When we know what
	// type it is, we need to convert them to the correct godot objects.
	// TODO: Probably pull this out into its own function?
	variantArgs := []unsafe.Pointer{}
	for _, arg := range args {
		log.Println("  Argument type: ", arg.Type().String())

		// Look up our conversion function in our map of conversion functions
		// based on the Go type. This is essentially a more optimal case/switch
		// statement on the type of Go object, so we can know how to convert it
		// to a Godot object.
		if convert, ok := goToGodotConversionMap[arg.Type().String()]; ok {
			argValue := convert(arg.Interface())
			variantArgs = append(variantArgs, argValue)
		} else {
			err := "Unknown type of argument value when calling parent method: " + arg.Type().String()
			Log.Error(err)
			panic(err)
		}
	}
	log.Println("  Built variant arguments: ", variantArgs)

	// Construct a C array that will contain pointers to our arguments.
	log.Println("  Allocating argument array in C.")
	cArgsArray := C.build_array(C.int(len(variantArgs)))
	log.Println("    C Array: ", cArgsArray)

	// Loop through and add each argument to our C args array.
	for i, arg := range variantArgs {
		C.add_element(cArgsArray, arg, C.int(i))
	}
	log.Println("  Built argument array from variant arguments: ", cArgsArray)

	// Construct our return object that will be populated by the method call.
	// Here we're just using a CString
	log.Println("  Building return value.")
	ret := unsafe.Pointer(C.CString(""))

	// Call the parent method. "ret" will be populated with the return value.
	log.Println("  Calling bind_ptrcall...")
	C.godot_method_bind_ptrcall(
		methodBind,
		objectOwner,
		cArgsArray, // void**
		ret,        // void*
	)
	log.Println("  Finished calling method")

	// Convert the return value based on the type.
	var retValue reflect.Value
	if _, ok := godotToGoConversionMap[returns]; ok {
		retValue = godotToGoConversionMap[returns](ret)
	} else {
		panic("Return type not found when calling parent method: " + returns)
	}

	// Return the converted variant.
	return retValue
}

/*
   ObjectImplementer is an interface for Object objects.
*/
type ObjectImplementer interface {
	Class
}
