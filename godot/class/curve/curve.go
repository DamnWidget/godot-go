package curve

import (
	"log"
	"reflect"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

/*
A curve that can be saved and re-used for other objects. By default it ranges between [code]0[/code] and [code]1[/code] on the y-axis and positions points relative to the [code]0.5[/code] y-position.
*/
type Curve struct {
	Resource
}

func (o *Curve) BaseClass() string {
	return "Curve"
}

/*
   Undocumented
*/
func (o *Curve) X_GetData() *Array {
	log.Println("Calling Curve.X_GetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "_get_data", goArguments, "*Array")

	returnValue := goRet.Interface().(*Array)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Curve) X_SetData(data *Array) {
	log.Println("Calling Curve.X_SetData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(data)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "_set_data", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Adds a point to the curve. For each side, if the [code]*_mode[/code] is [code]TANGENT_LINEAR[/code], the [code]*_tangent[/code] angle (in degrees) uses the slope of the curve halfway to the adjacent point. Allows custom assignments to the [code]*_tangent[/code] angle if [code]*_mode[/code] is set to [code]TANGENT_FREE[/code].
*/
func (o *Curve) AddPoint(position *Vector2, leftTangent gdnative.Float, rightTangent gdnative.Float, leftMode gdnative.Int, rightMode gdnative.Int) gdnative.Int {
	log.Println("Calling Curve.AddPoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(position)
	goArguments[1] = reflect.ValueOf(leftTangent)
	goArguments[2] = reflect.ValueOf(rightTangent)
	goArguments[3] = reflect.ValueOf(leftMode)
	goArguments[4] = reflect.ValueOf(rightMode)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "add_point", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Recomputes the baked cache of points for the curve.
*/
func (o *Curve) Bake() {
	log.Println("Calling Curve.Bake()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "bake", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Removes points that are closer than [code]CMP_EPSILON[/code] (0.00001) units to their neighbor on the curve.
*/
func (o *Curve) CleanDupes() {
	log.Println("Calling Curve.CleanDupes()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "clean_dupes", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Removes all points from the curve.
*/
func (o *Curve) ClearPoints() {
	log.Println("Calling Curve.ClearPoints()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "clear_points", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Curve) GetBakeResolution() gdnative.Int {
	log.Println("Calling Curve.GetBakeResolution()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_bake_resolution", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Curve) GetMaxValue() gdnative.Float {
	log.Println("Calling Curve.GetMaxValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_max_value", goArguments, "gdnative.Float")

	returnValue := goRet.Interface().(gdnative.Float)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Curve) GetMinValue() gdnative.Float {
	log.Println("Calling Curve.GetMinValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_min_value", goArguments, "gdnative.Float")

	returnValue := goRet.Interface().(gdnative.Float)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the left [code]TangentMode[/code] for the point at [code]index[/code].
*/
func (o *Curve) GetPointLeftMode(index gdnative.Int) gdnative.Int {
	log.Println("Calling Curve.GetPointLeftMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_point_left_mode", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the left tangent angle (in degrees) for the point at [code]index[/code].
*/
func (o *Curve) GetPointLeftTangent(index gdnative.Int) gdnative.Float {
	log.Println("Calling Curve.GetPointLeftTangent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_point_left_tangent", goArguments, "gdnative.Float")

	returnValue := goRet.Interface().(gdnative.Float)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the curve coordinates for the point at [code]index[/code].
*/
func (o *Curve) GetPointPosition(index gdnative.Int) *Vector2 {
	log.Println("Calling Curve.GetPointPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_point_position", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the right [code]TangentMode[/code] for the point at [code]index[/code].
*/
func (o *Curve) GetPointRightMode(index gdnative.Int) gdnative.Int {
	log.Println("Calling Curve.GetPointRightMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_point_right_mode", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the right tangent angle (in degrees) for the point at [code]index[/code].
*/
func (o *Curve) GetPointRightTangent(index gdnative.Int) gdnative.Float {
	log.Println("Calling Curve.GetPointRightTangent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_point_right_tangent", goArguments, "gdnative.Float")

	returnValue := goRet.Interface().(gdnative.Float)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the y value for the point that would exist at x-position [code]offset[/code] along the curve.
*/
func (o *Curve) Interpolate(offset gdnative.Float) gdnative.Float {
	log.Println("Calling Curve.Interpolate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "interpolate", goArguments, "gdnative.Float")

	returnValue := goRet.Interface().(gdnative.Float)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the y value for the point that would exist at x-position [code]offset[/code] along the curve using the baked cache. Bakes the curve's points if not already baked.
*/
func (o *Curve) InterpolateBaked(offset gdnative.Float) gdnative.Float {
	log.Println("Calling Curve.InterpolateBaked()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(offset)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "interpolate_baked", goArguments, "gdnative.Float")

	returnValue := goRet.Interface().(gdnative.Float)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Removes the point at [code]index[/code] from the curve.
*/
func (o *Curve) RemovePoint(index gdnative.Int) {
	log.Println("Calling Curve.RemovePoint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(index)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "remove_point", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Curve) SetBakeResolution(resolution gdnative.Int) {
	log.Println("Calling Curve.SetBakeResolution()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(resolution)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_bake_resolution", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Curve) SetMaxValue(max gdnative.Float) {
	log.Println("Calling Curve.SetMaxValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(max)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_max_value", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Curve) SetMinValue(min gdnative.Float) {
	log.Println("Calling Curve.SetMinValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(min)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_min_value", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Sets the left [code]TangentMode[/code] for the point at [code]index[/code] to [code]mode[/code].
*/
func (o *Curve) SetPointLeftMode(index gdnative.Int, mode gdnative.Int) {
	log.Println("Calling Curve.SetPointLeftMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(index)
	goArguments[1] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_point_left_mode", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Sets the left tangent angle for the point at [code]index[/code] to [code]tangent[/code].
*/
func (o *Curve) SetPointLeftTangent(index gdnative.Int, tangent gdnative.Float) {
	log.Println("Calling Curve.SetPointLeftTangent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(index)
	goArguments[1] = reflect.ValueOf(tangent)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_point_left_tangent", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Sets the offset from [code]0.5[/code]
*/
func (o *Curve) SetPointOffset(index gdnative.Int, offset gdnative.Float) gdnative.Int {
	log.Println("Calling Curve.SetPointOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(index)
	goArguments[1] = reflect.ValueOf(offset)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "set_point_offset", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Sets the right [code]TangentMode[/code] for the point at [code]index[/code] to [code]mode[/code].
*/
func (o *Curve) SetPointRightMode(index gdnative.Int, mode gdnative.Int) {
	log.Println("Calling Curve.SetPointRightMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(index)
	goArguments[1] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_point_right_mode", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Sets the right tangent angle for the point at [code]index[/code] to [code]tangent[/code].
*/
func (o *Curve) SetPointRightTangent(index gdnative.Int, tangent gdnative.Float) {
	log.Println("Calling Curve.SetPointRightTangent()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(index)
	goArguments[1] = reflect.ValueOf(tangent)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_point_right_tangent", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Assigns the vertical position [code]y[/code] to the point at [code]index[/code].
*/
func (o *Curve) SetPointValue(index gdnative.Int, y gdnative.Float) {
	log.Println("Calling Curve.SetPointValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(index)
	goArguments[1] = reflect.ValueOf(y)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_point_value", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   CurveImplementer is an interface for Curve objects.
*/
type CurveImplementer interface {
	Class
}
