package xmlparser

import (
	"log"
	"reflect"

	"github.com/shadowapex/godot-go/gdnative"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

/*
This class can serve as base to make custom XML parsers. Since XML is a very flexible standard, this interface is low level so it can be applied to any possible schema.
*/
type XMLParser struct {
	Reference
}

func (o *XMLParser) BaseClass() string {
	return "XMLParser"
}

/*
   Get the amount of attributes in the current element.
*/
func (o *XMLParser) GetAttributeCount() gdnative.Int {
	log.Println("Calling XMLParser.GetAttributeCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_attribute_count", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Get the name of the attribute specified by the index in [code]idx[/code] argument.
*/
func (o *XMLParser) GetAttributeName(idx gdnative.Int) gdnative.String {
	log.Println("Calling XMLParser.GetAttributeName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_attribute_name", goArguments, "gdnative.String")

	returnValue := goRet.Interface().(gdnative.String)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Get the value of the attribute specified by the index in [code]idx[/code] argument.
*/
func (o *XMLParser) GetAttributeValue(idx gdnative.Int) gdnative.String {
	log.Println("Calling XMLParser.GetAttributeValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_attribute_value", goArguments, "gdnative.String")

	returnValue := goRet.Interface().(gdnative.String)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Get the current line in the parsed file (currently not implemented).
*/
func (o *XMLParser) GetCurrentLine() gdnative.Int {
	log.Println("Calling XMLParser.GetCurrentLine()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_current_line", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Get the value of a certain attribute of the current element by name. This will raise an error if the element has no such attribute.
*/
func (o *XMLParser) GetNamedAttributeValue(name gdnative.String) gdnative.String {
	log.Println("Calling XMLParser.GetNamedAttributeValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_named_attribute_value", goArguments, "gdnative.String")

	returnValue := goRet.Interface().(gdnative.String)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Get the value of a certain attribute of the current element by name. This will return an empty [String] if the attribute is not found.
*/
func (o *XMLParser) GetNamedAttributeValueSafe(name gdnative.String) gdnative.String {
	log.Println("Calling XMLParser.GetNamedAttributeValueSafe()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_named_attribute_value_safe", goArguments, "gdnative.String")

	returnValue := goRet.Interface().(gdnative.String)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Get the contents of a text node. This will raise an error in any other type of node.
*/
func (o *XMLParser) GetNodeData() gdnative.String {
	log.Println("Calling XMLParser.GetNodeData()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_node_data", goArguments, "gdnative.String")

	returnValue := goRet.Interface().(gdnative.String)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Get the name of the current element node. This will raise an error if the current node type is not [code]NODE_ELEMENT[/code] nor [code]NODE_ELEMENT_END[/code]
*/
func (o *XMLParser) GetNodeName() gdnative.String {
	log.Println("Calling XMLParser.GetNodeName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_node_name", goArguments, "gdnative.String")

	returnValue := goRet.Interface().(gdnative.String)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Get the byte offset of the current node since the beginning of the file or buffer.
*/
func (o *XMLParser) GetNodeOffset() gdnative.Int {
	log.Println("Calling XMLParser.GetNodeOffset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_node_offset", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Get the type of the current node. Compare with [code]NODE_*[/code] constants.
*/
func (o *XMLParser) GetNodeType() gdnative.Int {
	log.Println("Calling XMLParser.GetNodeType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_node_type", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Check whether or not the current element has a certain attribute.
*/
func (o *XMLParser) HasAttribute(name gdnative.String) gdnative.Bool {
	log.Println("Calling XMLParser.HasAttribute()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "has_attribute", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Check whether the current element is empty (this only works for completely empty tags, e.g. <element \>).
*/
func (o *XMLParser) IsEmpty() gdnative.Bool {
	log.Println("Calling XMLParser.IsEmpty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "is_empty", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Open a XML file for parsing. This returns an error code.
*/
func (o *XMLParser) Open(file gdnative.String) gdnative.Int {
	log.Println("Calling XMLParser.Open()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(file)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "open", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Open a XML raw buffer for parsing. This returns an error code.
*/
func (o *XMLParser) OpenBuffer(buffer *PoolByteArray) gdnative.Int {
	log.Println("Calling XMLParser.OpenBuffer()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(buffer)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "open_buffer", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Read the next node of the file. This returns an error code.
*/
func (o *XMLParser) Read() gdnative.Int {
	log.Println("Calling XMLParser.Read()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "read", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Move the buffer cursor to a certain offset (since the beginning) and read the next node there. This returns an error code.
*/
func (o *XMLParser) Seek(position gdnative.Int) gdnative.Int {
	log.Println("Calling XMLParser.Seek()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(position)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "seek", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Skips the current section. If the node contains other elements, they will be ignored and the cursor will go to the closing of the current element.
*/
func (o *XMLParser) SkipSection() {
	log.Println("Calling XMLParser.SkipSection()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "skip_section", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   XMLParserImplementer is an interface for XMLParser objects.
*/
type XMLParserImplementer interface {
	Class
}
