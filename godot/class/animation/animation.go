package animation

import (
	"log"
	"reflect"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

/*
An Animation resource contains data used to animate everything in the engine. Animations are divided into tracks, and each track must be linked to a node. The state of that node can be changed through time, by adding timed keys (events) to the track. Animations are just data containers, and must be added to odes such as an [AnimationPlayer] or [AnimationTreePlayer] to be played back.
*/
type Animation struct {
	Resource
}

func (o *Animation) BaseClass() string {
	return "Animation"
}

/*
   Add a track to the Animation. The track type must be specified as any of the values in the TYPE_* enumeration.
*/
func (o *Animation) AddTrack(aType gdnative.Int, atPosition gdnative.Int) gdnative.Int {
	log.Println("Calling Animation.AddTrack()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(aType)
	goArguments[1] = reflect.ValueOf(atPosition)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "add_track", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Clear the animation (clear all tracks and reset all).
*/
func (o *Animation) Clear() {
	log.Println("Calling Animation.Clear()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "clear", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Adds a new track that is a copy of the given track from [code]to_animation[/code].
*/
func (o *Animation) CopyTrack(track gdnative.Int, toAnimation *Animation) {
	log.Println("Calling Animation.CopyTrack()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(track)
	goArguments[1] = reflect.ValueOf(toAnimation)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "copy_track", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Return the index of the specified track. If the track is not found, return -1.
*/
func (o *Animation) FindTrack(path *NodePath) gdnative.Int {
	log.Println("Calling Animation.FindTrack()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "find_track", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Animation) GetLength() gdnative.Float {
	log.Println("Calling Animation.GetLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_length", goArguments, "gdnative.Float")

	returnValue := goRet.Interface().(gdnative.Float)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Animation) GetStep() gdnative.Float {
	log.Println("Calling Animation.GetStep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_step", goArguments, "gdnative.Float")

	returnValue := goRet.Interface().(gdnative.Float)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the amount of tracks in the animation.
*/
func (o *Animation) GetTrackCount() gdnative.Int {
	log.Println("Calling Animation.GetTrackCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_track_count", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Animation) HasLoop() gdnative.Bool {
	log.Println("Calling Animation.HasLoop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "has_loop", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return all the key indices of a method track, given a position and delta time.
*/
func (o *Animation) MethodTrackGetKeyIndices(idx gdnative.Int, timeSec gdnative.Float, delta gdnative.Float) *PoolIntArray {
	log.Println("Calling Animation.MethodTrackGetKeyIndices()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(timeSec)
	goArguments[2] = reflect.ValueOf(delta)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "method_track_get_key_indices", goArguments, "*PoolIntArray")

	returnValue := goRet.Interface().(*PoolIntArray)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the method name of a method track.
*/
func (o *Animation) MethodTrackGetName(idx gdnative.Int, keyIdx gdnative.Int) gdnative.String {
	log.Println("Calling Animation.MethodTrackGetName()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(keyIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "method_track_get_name", goArguments, "gdnative.String")

	returnValue := goRet.Interface().(gdnative.String)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the arguments values to be called on a method track for a given key in a given track.
*/
func (o *Animation) MethodTrackGetParams(idx gdnative.Int, keyIdx gdnative.Int) *Array {
	log.Println("Calling Animation.MethodTrackGetParams()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(keyIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "method_track_get_params", goArguments, "*Array")

	returnValue := goRet.Interface().(*Array)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Remove a track by specifying the track index.
*/
func (o *Animation) RemoveTrack(idx gdnative.Int) {
	log.Println("Calling Animation.RemoveTrack()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "remove_track", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Animation) SetLength(timeSec gdnative.Float) {
	log.Println("Calling Animation.SetLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(timeSec)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_length", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Animation) SetLoop(enabled gdnative.Bool) {
	log.Println("Calling Animation.SetLoop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_loop", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Animation) SetStep(sizeSec gdnative.Float) {
	log.Println("Calling Animation.SetStep()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(sizeSec)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_step", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Find the key index by time in a given track. Optionally, only find it if the exact time is given.
*/
func (o *Animation) TrackFindKey(idx gdnative.Int, time gdnative.Float, exact gdnative.Bool) gdnative.Int {
	log.Println("Calling Animation.TrackFindKey()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(time)
	goArguments[2] = reflect.ValueOf(exact)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "track_find_key", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns [code]true[/code] if the track at [code]idx[/code] wraps the interpolation loop. Default value: [code]true[/code].
*/
func (o *Animation) TrackGetInterpolationLoopWrap(idx gdnative.Int) gdnative.Bool {
	log.Println("Calling Animation.TrackGetInterpolationLoopWrap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "track_get_interpolation_loop_wrap", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the interpolation type of a given track, from the INTERPOLATION_* enum.
*/
func (o *Animation) TrackGetInterpolationType(idx gdnative.Int) gdnative.Int {
	log.Println("Calling Animation.TrackGetInterpolationType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "track_get_interpolation_type", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the amount of keys in a given track.
*/
func (o *Animation) TrackGetKeyCount(idx gdnative.Int) gdnative.Int {
	log.Println("Calling Animation.TrackGetKeyCount()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "track_get_key_count", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the time at which the key is located.
*/
func (o *Animation) TrackGetKeyTime(idx gdnative.Int, keyIdx gdnative.Int) gdnative.Float {
	log.Println("Calling Animation.TrackGetKeyTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(keyIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "track_get_key_time", goArguments, "gdnative.Float")

	returnValue := goRet.Interface().(gdnative.Float)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the transition curve (easing) for a specific key (see built-in math function "ease").
*/
func (o *Animation) TrackGetKeyTransition(idx gdnative.Int, keyIdx gdnative.Int) gdnative.Float {
	log.Println("Calling Animation.TrackGetKeyTransition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(keyIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "track_get_key_transition", goArguments, "gdnative.Float")

	returnValue := goRet.Interface().(gdnative.Float)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the value of a given key in a given track.
*/
func (o *Animation) TrackGetKeyValue(idx gdnative.Int, keyIdx gdnative.Int) *Variant {
	log.Println("Calling Animation.TrackGetKeyValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(keyIdx)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "track_get_key_value", goArguments, "*Variant")

	returnValue := goRet.Interface().(*Variant)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Get the path of a track. for more information on the path format, see [method track_set_path]
*/
func (o *Animation) TrackGetPath(idx gdnative.Int) *NodePath {
	log.Println("Calling Animation.TrackGetPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "track_get_path", goArguments, "*NodePath")

	returnValue := goRet.Interface().(*NodePath)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Get the type of a track.
*/
func (o *Animation) TrackGetType(idx gdnative.Int) gdnative.Int {
	log.Println("Calling Animation.TrackGetType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "track_get_type", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Insert a generic key in a given track.
*/
func (o *Animation) TrackInsertKey(idx gdnative.Int, time gdnative.Float, key *Variant, transition gdnative.Float) {
	log.Println("Calling Animation.TrackInsertKey()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(time)
	goArguments[2] = reflect.ValueOf(key)
	goArguments[3] = reflect.ValueOf(transition)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "track_insert_key", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Returns [code]true[/code] if the track at index [code]idx[/code] is enabled.
*/
func (o *Animation) TrackIsEnabled(idx gdnative.Int) gdnative.Bool {
	log.Println("Calling Animation.TrackIsEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "track_is_enabled", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return true if the given track is imported. Else, return false.
*/
func (o *Animation) TrackIsImported(idx gdnative.Int) gdnative.Bool {
	log.Println("Calling Animation.TrackIsImported()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "track_is_imported", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Move a track down.
*/
func (o *Animation) TrackMoveDown(idx gdnative.Int) {
	log.Println("Calling Animation.TrackMoveDown()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "track_move_down", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Move a track up.
*/
func (o *Animation) TrackMoveUp(idx gdnative.Int) {
	log.Println("Calling Animation.TrackMoveUp()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "track_move_up", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Remove a key by index in a given track.
*/
func (o *Animation) TrackRemoveKey(idx gdnative.Int, keyIdx gdnative.Int) {
	log.Println("Calling Animation.TrackRemoveKey()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(keyIdx)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "track_remove_key", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Remove a key by position (seconds) in a given track.
*/
func (o *Animation) TrackRemoveKeyAtPosition(idx gdnative.Int, position gdnative.Float) {
	log.Println("Calling Animation.TrackRemoveKeyAtPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(position)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "track_remove_key_at_position", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Enables/disables the given track. Tracks are enabled by default.
*/
func (o *Animation) TrackSetEnabled(idx gdnative.Int, enabled gdnative.Bool) {
	log.Println("Calling Animation.TrackSetEnabled()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(enabled)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "track_set_enabled", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the given track as imported or not.
*/
func (o *Animation) TrackSetImported(idx gdnative.Int, imported gdnative.Bool) {
	log.Println("Calling Animation.TrackSetImported()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(imported)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "track_set_imported", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   If [code]true[/code] the track at [code]idx[/code] wraps the interpolation loop.
*/
func (o *Animation) TrackSetInterpolationLoopWrap(idx gdnative.Int, interpolation gdnative.Bool) {
	log.Println("Calling Animation.TrackSetInterpolationLoopWrap()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(interpolation)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "track_set_interpolation_loop_wrap", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the interpolation type of a given track, from the INTERPOLATION_* enum.
*/
func (o *Animation) TrackSetInterpolationType(idx gdnative.Int, interpolation gdnative.Int) {
	log.Println("Calling Animation.TrackSetInterpolationType()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(interpolation)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "track_set_interpolation_type", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the transition curve (easing) for a specific key (see built-in math function "ease").
*/
func (o *Animation) TrackSetKeyTransition(idx gdnative.Int, keyIdx gdnative.Int, transition gdnative.Float) {
	log.Println("Calling Animation.TrackSetKeyTransition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(keyIdx)
	goArguments[2] = reflect.ValueOf(transition)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "track_set_key_transition", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the value of an existing key.
*/
func (o *Animation) TrackSetKeyValue(idx gdnative.Int, key gdnative.Int, value *Variant) {
	log.Println("Calling Animation.TrackSetKeyValue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(key)
	goArguments[2] = reflect.ValueOf(value)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "track_set_key_value", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Set the path of a track. Paths must be valid scene-tree paths to a node, and must be specified starting from the parent node of the node that will reproduce the animation. Tracks that control properties or bones must append their name after the path, separated by ":". Example: "character/skeleton:ankle" or "character/mesh:transform/local"
*/
func (o *Animation) TrackSetPath(idx gdnative.Int, path *NodePath) {
	log.Println("Calling Animation.TrackSetPath()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "track_set_path", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Insert a transform key for a transform track.
*/
func (o *Animation) TransformTrackInsertKey(idx gdnative.Int, time gdnative.Float, location *Vector3, rotation *Quat, scale *Vector3) gdnative.Int {
	log.Println("Calling Animation.TransformTrackInsertKey()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 5, 5)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(time)
	goArguments[2] = reflect.ValueOf(location)
	goArguments[3] = reflect.ValueOf(rotation)
	goArguments[4] = reflect.ValueOf(scale)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "transform_track_insert_key", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the interpolated value of a transform track at a given time (in seconds). An array consisting of 3 elements: position ([Vector3]), rotation ([Quat]) and scale ([Vector3]).
*/
func (o *Animation) TransformTrackInterpolate(idx gdnative.Int, timeSec gdnative.Float) *Array {
	log.Println("Calling Animation.TransformTrackInterpolate()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(timeSec)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "transform_track_interpolate", goArguments, "*Array")

	returnValue := goRet.Interface().(*Array)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return all the key indices of a value track, given a position and delta time.
*/
func (o *Animation) ValueTrackGetKeyIndices(idx gdnative.Int, timeSec gdnative.Float, delta gdnative.Float) *PoolIntArray {
	log.Println("Calling Animation.ValueTrackGetKeyIndices()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(timeSec)
	goArguments[2] = reflect.ValueOf(delta)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "value_track_get_key_indices", goArguments, "*PoolIntArray")

	returnValue := goRet.Interface().(*PoolIntArray)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Return the update mode of a value track.
*/
func (o *Animation) ValueTrackGetUpdateMode(idx gdnative.Int) gdnative.Int {
	log.Println("Calling Animation.ValueTrackGetUpdateMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(idx)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "value_track_get_update_mode", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Set the update mode (UPDATE_*) of a value track.
*/
func (o *Animation) ValueTrackSetUpdateMode(idx gdnative.Int, mode gdnative.Int) {
	log.Println("Calling Animation.ValueTrackSetUpdateMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(idx)
	goArguments[1] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "value_track_set_update_mode", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   AnimationImplementer is an interface for Animation objects.
*/
type AnimationImplementer interface {
	Class
}
