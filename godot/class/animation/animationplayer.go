package animation

import (
	"log"
	"reflect"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

/*
An animation player is used for general purpose playback of [Animation] resources. It contains a dictionary of animations (referenced by name) and custom blend times between their transitions. Additionally, animations can be played and blended in different channels.
*/
type AnimationPlayer struct {
	Node
}

func (o *AnimationPlayer) BaseClass() string {
	return "AnimationPlayer"
}

/*
   Undocumented
*/
func (o *AnimationPlayer) X_AnimationChanged() {
	log.Println("Calling AnimationPlayer.X_AnimationChanged()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "_animation_changed", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimationPlayer) X_NodeRemoved(arg0 *Object) {
	log.Println("Calling AnimationPlayer.X_NodeRemoved()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(arg0)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "_node_removed", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Adds [code]animation[/code] to the player accessible with the key [code]name[/code].
*/
func (o *AnimationPlayer) AddAnimation(name gdnative.String, animation *Animation) gdnative.Int {
	log.Println("Calling AnimationPlayer.AddAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(animation)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "add_animation", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Shifts position in the animation timeline. Delta is the time in seconds to shift.
*/
func (o *AnimationPlayer) Advance(delta gdnative.Float) {
	log.Println("Calling AnimationPlayer.Advance()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(delta)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "advance", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Returns the name of the next animation in the queue.
*/
func (o *AnimationPlayer) AnimationGetNext(animFrom gdnative.String) gdnative.String {
	log.Println("Calling AnimationPlayer.AnimationGetNext()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(animFrom)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "animation_get_next", goArguments, "gdnative.String")

	returnValue := goRet.Interface().(gdnative.String)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Triggers the [code]anim_to[/code] animation when the [code]anim_from[/code] animation completes.
*/
func (o *AnimationPlayer) AnimationSetNext(animFrom gdnative.String, animTo gdnative.String) {
	log.Println("Calling AnimationPlayer.AnimationSetNext()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(animFrom)
	goArguments[1] = reflect.ValueOf(animTo)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "animation_set_next", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   [code]AnimationPlayer[/code] caches animated nodes. It may not notice if a node disappears, so clear_caches forces it to update the cache again.
*/
func (o *AnimationPlayer) ClearCaches() {
	log.Println("Calling AnimationPlayer.ClearCaches()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "clear_caches", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Clears all queued, unplayed animations.
*/
func (o *AnimationPlayer) ClearQueue() {
	log.Println("Calling AnimationPlayer.ClearQueue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "clear_queue", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Returns the name of [code]animation[/code] or empty string if not found.
*/
func (o *AnimationPlayer) FindAnimation(animation *Animation) gdnative.String {
	log.Println("Calling AnimationPlayer.FindAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(animation)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "find_animation", goArguments, "gdnative.String")

	returnValue := goRet.Interface().(gdnative.String)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the [Animation] with key [code]name[/code] or [code]null[/code] if not found.
*/
func (o *AnimationPlayer) GetAnimation(name gdnative.String) *Animation {
	log.Println("Calling AnimationPlayer.GetAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_animation", goArguments, "*Animation")

	returnValue := goRet.Interface().(*Animation)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the list of stored animation names.
*/
func (o *AnimationPlayer) GetAnimationList() *PoolStringArray {
	log.Println("Calling AnimationPlayer.GetAnimationList()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_animation_list", goArguments, "*PoolStringArray")

	returnValue := goRet.Interface().(*PoolStringArray)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *AnimationPlayer) GetAnimationProcessMode() gdnative.Int {
	log.Println("Calling AnimationPlayer.GetAnimationProcessMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_animation_process_mode", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *AnimationPlayer) GetAssignedAnimation() gdnative.String {
	log.Println("Calling AnimationPlayer.GetAssignedAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_assigned_animation", goArguments, "gdnative.String")

	returnValue := goRet.Interface().(gdnative.String)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *AnimationPlayer) GetAutoplay() gdnative.String {
	log.Println("Calling AnimationPlayer.GetAutoplay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_autoplay", goArguments, "gdnative.String")

	returnValue := goRet.Interface().(gdnative.String)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Get the blend time (in seconds) between two animations, referenced by their names.
*/
func (o *AnimationPlayer) GetBlendTime(animFrom gdnative.String, animTo gdnative.String) gdnative.Float {
	log.Println("Calling AnimationPlayer.GetBlendTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(animFrom)
	goArguments[1] = reflect.ValueOf(animTo)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_blend_time", goArguments, "gdnative.Float")

	returnValue := goRet.Interface().(gdnative.Float)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *AnimationPlayer) GetCurrentAnimation() gdnative.String {
	log.Println("Calling AnimationPlayer.GetCurrentAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_current_animation", goArguments, "gdnative.String")

	returnValue := goRet.Interface().(gdnative.String)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *AnimationPlayer) GetCurrentAnimationLength() gdnative.Float {
	log.Println("Calling AnimationPlayer.GetCurrentAnimationLength()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_current_animation_length", goArguments, "gdnative.Float")

	returnValue := goRet.Interface().(gdnative.Float)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *AnimationPlayer) GetCurrentAnimationPosition() gdnative.Float {
	log.Println("Calling AnimationPlayer.GetCurrentAnimationPosition()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_current_animation_position", goArguments, "gdnative.Float")

	returnValue := goRet.Interface().(gdnative.Float)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *AnimationPlayer) GetDefaultBlendTime() gdnative.Float {
	log.Println("Calling AnimationPlayer.GetDefaultBlendTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_default_blend_time", goArguments, "gdnative.Float")

	returnValue := goRet.Interface().(gdnative.Float)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *AnimationPlayer) GetRoot() *NodePath {
	log.Println("Calling AnimationPlayer.GetRoot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_root", goArguments, "*NodePath")

	returnValue := goRet.Interface().(*NodePath)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *AnimationPlayer) GetSpeedScale() gdnative.Float {
	log.Println("Calling AnimationPlayer.GetSpeedScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_speed_scale", goArguments, "gdnative.Float")

	returnValue := goRet.Interface().(gdnative.Float)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns [code]true[/code] if the [code]AnimationPlayer[/code] stores an [Animation] with key [code]name[/code].
*/
func (o *AnimationPlayer) HasAnimation(name gdnative.String) gdnative.Bool {
	log.Println("Calling AnimationPlayer.HasAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "has_animation", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *AnimationPlayer) IsActive() gdnative.Bool {
	log.Println("Calling AnimationPlayer.IsActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "is_active", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns [code]true[/code] if playing an animation.
*/
func (o *AnimationPlayer) IsPlaying() gdnative.Bool {
	log.Println("Calling AnimationPlayer.IsPlaying()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "is_playing", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Play the animation with key [code]name[/code]. Custom speed and blend times can be set. If custom speed is negative (-1), 'from_end' being true can play the animation backwards.
*/
func (o *AnimationPlayer) Play(name gdnative.String, customBlend gdnative.Float, customSpeed gdnative.Float, fromEnd gdnative.Bool) {
	log.Println("Calling AnimationPlayer.Play()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 4, 4)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(customBlend)
	goArguments[2] = reflect.ValueOf(customSpeed)
	goArguments[3] = reflect.ValueOf(fromEnd)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "play", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Play the animation with key [code]name[/code] in reverse.
*/
func (o *AnimationPlayer) PlayBackwards(name gdnative.String, customBlend gdnative.Float) {
	log.Println("Calling AnimationPlayer.PlayBackwards()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(customBlend)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "play_backwards", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Queue an animation for playback once the current one is done.
*/
func (o *AnimationPlayer) Queue(name gdnative.String) {
	log.Println("Calling AnimationPlayer.Queue()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "queue", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Remove the animation with key [code]name[/code].
*/
func (o *AnimationPlayer) RemoveAnimation(name gdnative.String) {
	log.Println("Calling AnimationPlayer.RemoveAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "remove_animation", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Rename an existing animation with key [code]name[/code] to [code]newname[/code].
*/
func (o *AnimationPlayer) RenameAnimation(name gdnative.String, newname gdnative.String) {
	log.Println("Calling AnimationPlayer.RenameAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(name)
	goArguments[1] = reflect.ValueOf(newname)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "rename_animation", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Seek the animation to the [code]seconds[/code] point in time (in seconds). If [code]update[/code] is [code]true[/code], the animation updates too, otherwise it updates at process time.
*/
func (o *AnimationPlayer) Seek(seconds gdnative.Float, update gdnative.Bool) {
	log.Println("Calling AnimationPlayer.Seek()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(seconds)
	goArguments[1] = reflect.ValueOf(update)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "seek", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimationPlayer) SetActive(active gdnative.Bool) {
	log.Println("Calling AnimationPlayer.SetActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(active)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_active", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimationPlayer) SetAnimationProcessMode(mode gdnative.Int) {
	log.Println("Calling AnimationPlayer.SetAnimationProcessMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_animation_process_mode", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimationPlayer) SetAssignedAnimation(anim gdnative.String) {
	log.Println("Calling AnimationPlayer.SetAssignedAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(anim)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_assigned_animation", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimationPlayer) SetAutoplay(name gdnative.String) {
	log.Println("Calling AnimationPlayer.SetAutoplay()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(name)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_autoplay", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Specify a blend time (in seconds) between two animations, referenced by their names.
*/
func (o *AnimationPlayer) SetBlendTime(animFrom gdnative.String, animTo gdnative.String, sec gdnative.Float) {
	log.Println("Calling AnimationPlayer.SetBlendTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(animFrom)
	goArguments[1] = reflect.ValueOf(animTo)
	goArguments[2] = reflect.ValueOf(sec)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_blend_time", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimationPlayer) SetCurrentAnimation(anim gdnative.String) {
	log.Println("Calling AnimationPlayer.SetCurrentAnimation()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(anim)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_current_animation", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimationPlayer) SetDefaultBlendTime(sec gdnative.Float) {
	log.Println("Calling AnimationPlayer.SetDefaultBlendTime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(sec)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_default_blend_time", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimationPlayer) SetRoot(path *NodePath) {
	log.Println("Calling AnimationPlayer.SetRoot()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(path)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_root", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *AnimationPlayer) SetSpeedScale(speed gdnative.Float) {
	log.Println("Calling AnimationPlayer.SetSpeedScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(speed)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_speed_scale", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Stop the currently playing animation. If [code]reset[/code] is [code]true[/code], the anim position is reset to [code]0[/code].
*/
func (o *AnimationPlayer) Stop(reset gdnative.Bool) {
	log.Println("Calling AnimationPlayer.Stop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(reset)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "stop", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   AnimationPlayerImplementer is an interface for AnimationPlayer objects.
*/
type AnimationPlayerImplementer interface {
	Class
}
