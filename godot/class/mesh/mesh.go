package mesh

import (
	"log"
	"reflect"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

/*
Mesh is a type of [Resource] that contains vertex-array based geometry, divided in [i]surfaces[/i]. Each surface contains a completely separate array and a material used to draw it. Design wise, a mesh with multiple surfaces is preferred to a single surface, because objects created in 3D editing software commonly contain multiple materials.
*/
type Mesh struct {
	Resource
}

func (o *Mesh) BaseClass() string {
	return "Mesh"
}

/*
   Calculate a [ConvexPolygonShape] from the mesh.
*/
func (o *Mesh) CreateConvexShape() *Shape {
	log.Println("Calling Mesh.CreateConvexShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "create_convex_shape", goArguments, "*Shape")

	returnValue := goRet.Interface().(*Shape)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Calculate an outline mesh at a defined offset (margin) from the original mesh. Note: Typically returns the vertices in reverse order (e.g. clockwise to anti-clockwise).
*/
func (o *Mesh) CreateOutline(margin gdnative.Float) *Mesh {
	log.Println("Calling Mesh.CreateOutline()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(margin)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "create_outline", goArguments, "*Mesh")

	returnValue := goRet.Interface().(*Mesh)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Calculate a [ConcavePolygonShape] from the mesh.
*/
func (o *Mesh) CreateTrimeshShape() *Shape {
	log.Println("Calling Mesh.CreateTrimeshShape()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "create_trimesh_shape", goArguments, "*Shape")

	returnValue := goRet.Interface().(*Shape)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Generate a [TriangleMesh] from the mesh.
*/
func (o *Mesh) GenerateTriangleMesh() *TriangleMesh {
	log.Println("Calling Mesh.GenerateTriangleMesh()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "generate_triangle_mesh", goArguments, "*TriangleMesh")

	returnValue := goRet.Interface().(*TriangleMesh)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns all the vertices that make up the faces of the mesh. Each three vertices represent one triangle.
*/
func (o *Mesh) GetFaces() *PoolVector3Array {
	log.Println("Calling Mesh.GetFaces()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_faces", goArguments, "*PoolVector3Array")

	returnValue := goRet.Interface().(*PoolVector3Array)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Mesh) GetLightmapSizeHint() *Vector2 {
	log.Println("Calling Mesh.GetLightmapSizeHint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_lightmap_size_hint", goArguments, "*Vector2")

	returnValue := goRet.Interface().(*Vector2)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Mesh) SetLightmapSizeHint(size *Vector2) {
	log.Println("Calling Mesh.SetLightmapSizeHint()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(size)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_lightmap_size_hint", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   MeshImplementer is an interface for Mesh objects.
*/
type MeshImplementer interface {
	Class
}
