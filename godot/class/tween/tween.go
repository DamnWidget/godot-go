package tween

import (
	"log"
	"reflect"
)

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

/*
Node useful for animations with unknown start and end points, procedural animations, making one node follow another, and other simple behavior. Because it is easy to get it wrong, here is a quick usage example: [codeblock] var tween = get_node("Tween") tween.interpolate_property(get_node("Node2D_to_move"), "transform/origin", Vector2(0,0), Vector2(100,100), 1, Tween.TRANS_LINEAR, Tween.EASE_IN_OUT) tween.start() [/codeblock] Some of the methods of this class require a property name. You can get the property name by hovering over the property in the inspector of the editor. Many of the methods accept [code]trans_type[/code] and [code]ease_type[/code]. The first accepts an TRANS_* constant, and refers to the way the timing of the animation is handled (you might want to see [code]http://easings.net/[/code] for some examples). The second accepts an EASE_* constant, and controls the where [code]trans_type[/code] is applied to the interpolation (in the beginning, the end, or both). If you don't know which transition and easing to pick, you can try different TRANS_* constants with EASE_IN_OUT, and use the one that looks best.
*/
type Tween struct {
	Node
}

func (o *Tween) BaseClass() string {
	return "Tween"
}

/*
   Undocumented
*/
func (o *Tween) X_Remove(object *Object, key gdnative.String, firstOnly gdnative.Bool) {
	log.Println("Calling Tween.X_Remove()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 3, 3)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(key)
	goArguments[2] = reflect.ValueOf(firstOnly)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "_remove", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Follow [code]method[/code] of [code]object[/code] and apply the returned value on [code]target_method[/code] of [code]target[/code], beginning from [code]initial_val[/code] for [code]duration[/code] seconds, [code]delay[/code] later. Methods are animated by calling them with consequitive values. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) FollowMethod(object *Object, method gdnative.String, initialVal *Variant, target *Object, targetMethod gdnative.String, duration gdnative.Float, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Float) gdnative.Bool {
	log.Println("Calling Tween.FollowMethod()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 9, 9)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(method)
	goArguments[2] = reflect.ValueOf(initialVal)
	goArguments[3] = reflect.ValueOf(target)
	goArguments[4] = reflect.ValueOf(targetMethod)
	goArguments[5] = reflect.ValueOf(duration)
	goArguments[6] = reflect.ValueOf(transType)
	goArguments[7] = reflect.ValueOf(easeType)
	goArguments[8] = reflect.ValueOf(delay)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "follow_method", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Follow [code]property[/code] of [code]object[/code] and apply it on [code]target_property[/code] of [code]target[/code], beginning from [code]initial_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. Note that [code]target:target_property[/code] would equal [code]object:property[/code] at the end of the tween. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) FollowProperty(object *Object, property *NodePath, initialVal *Variant, target *Object, targetProperty *NodePath, duration gdnative.Float, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Float) gdnative.Bool {
	log.Println("Calling Tween.FollowProperty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 9, 9)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(property)
	goArguments[2] = reflect.ValueOf(initialVal)
	goArguments[3] = reflect.ValueOf(target)
	goArguments[4] = reflect.ValueOf(targetProperty)
	goArguments[5] = reflect.ValueOf(duration)
	goArguments[6] = reflect.ValueOf(transType)
	goArguments[7] = reflect.ValueOf(easeType)
	goArguments[8] = reflect.ValueOf(delay)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "follow_property", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the time needed for all tweens to end in seconds, measured from the start. Thus, if you have two tweens, one ending 10 seconds after the start and the other - 20 seconds, it would return 20 seconds, as by that time all tweens would have finished.
*/
func (o *Tween) GetRuntime() gdnative.Float {
	log.Println("Calling Tween.GetRuntime()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_runtime", goArguments, "gdnative.Float")

	returnValue := goRet.Interface().(gdnative.Float)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Tween) GetSpeedScale() gdnative.Float {
	log.Println("Calling Tween.GetSpeedScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_speed_scale", goArguments, "gdnative.Float")

	returnValue := goRet.Interface().(gdnative.Float)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Tween) GetTweenProcessMode() gdnative.Int {
	log.Println("Calling Tween.GetTweenProcessMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "get_tween_process_mode", goArguments, "gdnative.Int")

	returnValue := goRet.Interface().(gdnative.Int)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Call [code]callback[/code] of [code]object[/code] after [code]duration[/code]. [code]arg1[/code]-[code]arg5[/code] are arguments to be passed to the callback.
*/
func (o *Tween) InterpolateCallback(object *Object, duration gdnative.Float, callback gdnative.String, arg1 *Variant, arg2 *Variant, arg3 *Variant, arg4 *Variant, arg5 *Variant) gdnative.Bool {
	log.Println("Calling Tween.InterpolateCallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 8, 8)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(duration)
	goArguments[2] = reflect.ValueOf(callback)
	goArguments[3] = reflect.ValueOf(arg1)
	goArguments[4] = reflect.ValueOf(arg2)
	goArguments[5] = reflect.ValueOf(arg3)
	goArguments[6] = reflect.ValueOf(arg4)
	goArguments[7] = reflect.ValueOf(arg5)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "interpolate_callback", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Call [code]callback[/code] of [code]object[/code] after [code]duration[/code] on the main thread (similar to [method Object.call_deferred]). [code]arg1[/code]-[code]arg5[/code] are arguments to be passed to the callback.
*/
func (o *Tween) InterpolateDeferredCallback(object *Object, duration gdnative.Float, callback gdnative.String, arg1 *Variant, arg2 *Variant, arg3 *Variant, arg4 *Variant, arg5 *Variant) gdnative.Bool {
	log.Println("Calling Tween.InterpolateDeferredCallback()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 8, 8)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(duration)
	goArguments[2] = reflect.ValueOf(callback)
	goArguments[3] = reflect.ValueOf(arg1)
	goArguments[4] = reflect.ValueOf(arg2)
	goArguments[5] = reflect.ValueOf(arg3)
	goArguments[6] = reflect.ValueOf(arg4)
	goArguments[7] = reflect.ValueOf(arg5)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "interpolate_deferred_callback", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Animate [code]method[/code] of [code]object[/code] from [code]initial_val[/code] to [code]final_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. Methods are animated by calling them with consecutive values. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) InterpolateMethod(object *Object, method gdnative.String, initialVal *Variant, finalVal *Variant, duration gdnative.Float, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Float) gdnative.Bool {
	log.Println("Calling Tween.InterpolateMethod()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 8, 8)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(method)
	goArguments[2] = reflect.ValueOf(initialVal)
	goArguments[3] = reflect.ValueOf(finalVal)
	goArguments[4] = reflect.ValueOf(duration)
	goArguments[5] = reflect.ValueOf(transType)
	goArguments[6] = reflect.ValueOf(easeType)
	goArguments[7] = reflect.ValueOf(delay)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "interpolate_method", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Animate [code]property[/code] of [code]object[/code] from [code]initial_val[/code] to [code]final_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) InterpolateProperty(object *Object, property *NodePath, initialVal *Variant, finalVal *Variant, duration gdnative.Float, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Float) gdnative.Bool {
	log.Println("Calling Tween.InterpolateProperty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 8, 8)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(property)
	goArguments[2] = reflect.ValueOf(initialVal)
	goArguments[3] = reflect.ValueOf(finalVal)
	goArguments[4] = reflect.ValueOf(duration)
	goArguments[5] = reflect.ValueOf(transType)
	goArguments[6] = reflect.ValueOf(easeType)
	goArguments[7] = reflect.ValueOf(delay)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "interpolate_property", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns true if any tweens are currently running, and false otherwise. Note that this method doesn't consider tweens that have ended.
*/
func (o *Tween) IsActive() gdnative.Bool {
	log.Println("Calling Tween.IsActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "is_active", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Undocumented
*/
func (o *Tween) IsRepeat() gdnative.Bool {
	log.Println("Calling Tween.IsRepeat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "is_repeat", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Stop animating and completely remove a tween, given its object and property/method pair. Passing empty String as key will remove all tweens for given object.
*/
func (o *Tween) Remove(object *Object, key gdnative.String) gdnative.Bool {
	log.Println("Calling Tween.Remove()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(key)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "remove", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Stop animating and completely remove all tweens.
*/
func (o *Tween) RemoveAll() gdnative.Bool {
	log.Println("Calling Tween.RemoveAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "remove_all", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Resets a tween to the initial value (the one given, not the one before the tween), given its object and property/method pair. Passing empty String as key will reset all tweens for given object.
*/
func (o *Tween) Reset(object *Object, key gdnative.String) gdnative.Bool {
	log.Println("Calling Tween.Reset()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(key)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "reset", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Resets all tweens to their initial values (the ones given, not those before the tween).
*/
func (o *Tween) ResetAll() gdnative.Bool {
	log.Println("Calling Tween.ResetAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "reset_all", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Continue animating a stopped tween, given its object and property/method pair. Passing empty String as key will resume all tweens for given object.
*/
func (o *Tween) Resume(object *Object, key gdnative.String) gdnative.Bool {
	log.Println("Calling Tween.Resume()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(key)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "resume", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Continue animating all stopped tweens.
*/
func (o *Tween) ResumeAll() gdnative.Bool {
	log.Println("Calling Tween.ResumeAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "resume_all", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Seek the animation to the given [code]time[/code] in seconds.
*/
func (o *Tween) Seek(time gdnative.Float) gdnative.Bool {
	log.Println("Calling Tween.Seek()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(time)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "seek", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Activate/deactivate the tween. You can use this for pausing animations, though [method stop_all] and [method resume_all] might be more fit for this.
*/
func (o *Tween) SetActive(active gdnative.Bool) {
	log.Println("Calling Tween.SetActive()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(active)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_active", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Tween) SetRepeat(repeat gdnative.Bool) {
	log.Println("Calling Tween.SetRepeat()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(repeat)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_repeat", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Tween) SetSpeedScale(speed gdnative.Float) {
	log.Println("Calling Tween.SetSpeedScale()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(speed)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_speed_scale", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Undocumented
*/
func (o *Tween) SetTweenProcessMode(mode gdnative.Int) {
	log.Println("Calling Tween.SetTweenProcessMode()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 1, 1)
	goArguments[0] = reflect.ValueOf(mode)

	// Call the parent method.

	o.callParentMethod(o.BaseClass(), "set_tween_process_mode", goArguments, "")

	log.Println("  Function successfully completed.")

}

/*
   Start the tween node. You can define tweens both before and after this.
*/
func (o *Tween) Start() gdnative.Bool {
	log.Println("Calling Tween.Start()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "start", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Stop animating a tween, given its object and property/method pair. Passing empty String as key will stop all tweens for given object.
*/
func (o *Tween) Stop(object *Object, key gdnative.String) gdnative.Bool {
	log.Println("Calling Tween.Stop()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 2, 2)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(key)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "stop", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Stop animating all tweens.
*/
func (o *Tween) StopAll() gdnative.Bool {
	log.Println("Calling Tween.StopAll()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "stop_all", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Animate [code]method[/code] of [code]object[/code] from the value returned by [code]initial.initial_method[/code] to [code]final_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. Methods are animated by calling them with consecutive values. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) TargetingMethod(object *Object, method gdnative.String, initial *Object, initialMethod gdnative.String, finalVal *Variant, duration gdnative.Float, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Float) gdnative.Bool {
	log.Println("Calling Tween.TargetingMethod()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 9, 9)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(method)
	goArguments[2] = reflect.ValueOf(initial)
	goArguments[3] = reflect.ValueOf(initialMethod)
	goArguments[4] = reflect.ValueOf(finalVal)
	goArguments[5] = reflect.ValueOf(duration)
	goArguments[6] = reflect.ValueOf(transType)
	goArguments[7] = reflect.ValueOf(easeType)
	goArguments[8] = reflect.ValueOf(delay)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "targeting_method", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Animate [code]property[/code] of [code]object[/code] from the current value of the [code]initial_val[/code] property of [code]initial[/code] to [code]final_val[/code] for [code]duration[/code] seconds, [code]delay[/code] seconds later. [code]trans_type[/code] accepts TRANS_* constants, and is the way the animation is interpolated, while [code]ease_type[/code] accepts EASE_* constants, and controls the place of the interpolation (the beginning, the end, or both). You can read more about them in the class description.
*/
func (o *Tween) TargetingProperty(object *Object, property *NodePath, initial *Object, initialVal *NodePath, finalVal *Variant, duration gdnative.Float, transType gdnative.Int, easeType gdnative.Int, delay gdnative.Float) gdnative.Bool {
	log.Println("Calling Tween.TargetingProperty()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 9, 9)
	goArguments[0] = reflect.ValueOf(object)
	goArguments[1] = reflect.ValueOf(property)
	goArguments[2] = reflect.ValueOf(initial)
	goArguments[3] = reflect.ValueOf(initialVal)
	goArguments[4] = reflect.ValueOf(finalVal)
	goArguments[5] = reflect.ValueOf(duration)
	goArguments[6] = reflect.ValueOf(transType)
	goArguments[7] = reflect.ValueOf(easeType)
	goArguments[8] = reflect.ValueOf(delay)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "targeting_property", goArguments, "gdnative.Bool")

	returnValue := goRet.Interface().(gdnative.Bool)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   Returns the current time of the tween.
*/
func (o *Tween) Tell() gdnative.Float {
	log.Println("Calling Tween.Tell()")

	// Build out the method's arguments
	goArguments := make([]reflect.Value, 0, 0)

	// Call the parent method.

	goRet := o.callParentMethod(o.BaseClass(), "tell", goArguments, "gdnative.Float")

	returnValue := goRet.Interface().(gdnative.Float)

	log.Println("  Got return value: ", returnValue)
	return returnValue

}

/*
   TweenImplementer is an interface for Tween objects.
*/
type TweenImplementer interface {
	Class
}
