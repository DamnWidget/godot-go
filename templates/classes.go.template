package godot

{{ $view := . -}}
{{ $view.Header }}

/*
#include <stdio.h>
#include <stdlib.h>
#include <godot/gdnative.h>
#include <godot_nativescript.h>

void **build_array(int length);
void **build_array(int length) {
	void *ptr;
	void **arr = malloc(sizeof(void *) * length);
	for (int i = 0; i < length; i++) {
	    arr[i] = ptr;
	}

	return arr;
}

void add_element(void**, void*, int);
void add_element(void **array, void *element, int index) {
	printf("CGO: Array %p %p %p %p %p\n", &array, array, &array[index], *array, array[index]);
    array[index] = element;
	printf("CGO: Index %i %p\n", index, element);
	printf("CGO: Array %p %p %p %p %p\n", &array, array, &array[index], *array, array[index]);
}
*/
import "C"

import (
	"log"
	"reflect"
	"unsafe"
)

// Class is an interface for any objects that can have Godot
// inheritance.
type Class interface {
	baseClass() string
	setOwner(object *C.godot_object)
	getOwner() *C.godot_object
}

{{ range $i, $class := $view.GDClass -}}
    {{ if $view.IsValidClass $class.AttrName $class.AttrInherits -}}

        /*
        {{ $view.Trim $class.GDDescription.Text }}
        */
        type {{ $class.AttrName }} struct {
            {{ $class.AttrInherits }}
            {{ if eq $class.AttrName "Object" }}
                owner *C.godot_object
            {{ end }}
        }

        func (o *{{ $class.AttrName }}) baseClass() string {
            return "{{ $class.AttrName }}"
        }

        {{ if $class.GDMethods }}
            {{ range $j, $method := $class.GDMethods.GDMethod }}
                /*
                {{ $view.Trim $method.GDDescription.Text }}
                */
                func (o *{{ $class.AttrName }}) {{ $view.GoMethodName $method.AttrName }}({{ range $k, $arg := $method.GDArgument }}{{ $view.GoArgName $arg.AttrName }} {{ $view.GoValue $arg.AttrType }},{{ end }}) {{ if $method.GDReturn }}{{ $view.GoValue $method.GDReturn.AttrType }}{{ end }} {
                    log.Println("Calling {{ $class.AttrName }}.{{ $view.GoMethodName $method.AttrName }}()")

                    // Build out the method's arguments
                    goArguments := make([]reflect.Value, {{ len $method.GDArgument }}, {{ len $method.GDArgument }})
                    {{ range $k, $arg := $method.GDArgument -}}
                        goArguments[{{ $k }}] = reflect.ValueOf({{ $view.GoArgName $arg.AttrName }})
                    {{ end }}

                    // Call the parent method.
                    {{ if $method.GDReturn }}
                        {{ $returnType := $view.GoValue $method.GDReturn.AttrType }}{{ if ne $returnType "" }}
                            goRet := o.callParentMethod(o.baseClass(), "{{ $method.AttrName }}", goArguments, "{{ if $method.GDReturn }}{{ $view.GoValue $method.GDReturn.AttrType }}{{ end }}")
                        {{ else }}
                            o.callParentMethod(o.baseClass(), "{{ $method.AttrName }}", goArguments, "{{ if $method.GDReturn }}{{ $view.GoValue $method.GDReturn.AttrType }}{{ end }}")
                        {{ end }}
                    {{ end -}}
                    log.Println("Got return value!")
                    {{ if $method.GDReturn }}
                        {{ $returnType := $view.GoValue $method.GDReturn.AttrType }}{{ if ne $returnType "" }}
                            returnValue := goRet.Interface().({{ $view.GoValue $method.GDReturn.AttrType }})

                            return returnValue
                        {{ end }}
                    {{ end }}
                }
            {{ end }}
        {{ end }}

        {{ if eq $class.AttrName "Object" }}
            // SetOwner will internally set the Godot object inside the struct.
            // This is used to call parent methods.
            func (o *Object) setOwner(object *C.godot_object) {
                o.owner = object
            }
            
            func (o *Object) getOwner() *C.godot_object {
                return o.owner
            }

            // callParentMethod will call this object's method with the given method name.
            func (o *Object) callParentMethod(baseClass, methodName string, args []reflect.Value, returns string) reflect.Value {
            	log.Println("Calling parent method!")
            
            	// Convert the base class and method names to C strings.
            	log.Println("  Using base class: ", baseClass)
            	classCString := C.CString(baseClass)
            	log.Println("  Using method name: ", methodName)
            	methodCString := C.CString(methodName)
            
            	// Get the Godot method bind pointer so we can pass it to godot_method_bind_ptrcall.
            	log.Println("  Using godot object:", o.owner)
            	var methodBind *C.godot_method_bind
            	methodBind = C.godot_method_bind_get_method(classCString, methodCString)
            	log.Println("  Using method bind pointer: ", methodBind)
            
            	// Loop through the given arguments and see what type they are. When we know what
            	// type it is, we need to convert them to the correct godot objects.
            	// TODO: Probably pull this out into its own function?
            	variantArgs := []unsafe.Pointer{}
            	for _, arg := range args {
            		log.Println("  Argument type: ", arg.Type().String())
            
            		// Look up our conversion function in our map of conversion functions
            		// based on the Go type. This is essentially a more optimal case/switch
            		// statement on the type of Go object, so we can know how to convert it
            		// to a Godot object.
            		if convert, ok := goToGodotConversionMap[arg.Type().String()]; ok {
            			argValue := convert(arg.Interface())
            			variantArgs = append(variantArgs, argValue)
            		} else {
            			log.Fatal("Unknown type of argument value")
            		}
            	}
            	log.Println("  Built variant arguments: ", variantArgs)
            
            	// Construct a C array that will contain pointers to our arguments.
            	log.Println("  Allocating argument array in C.")
            	cArgsArray := C.build_array(C.int(len(variantArgs)))
            	log.Println("    C Array: ", cArgsArray)
            
            	// Loop through and add each argument to our C args array.
            	for i, arg := range variantArgs {
            		C.add_element(cArgsArray, arg, C.int(i))
            	}
            	log.Println("  Built argument array from variant arguments: ", cArgsArray)
            
            	// Construct our return object that will be populated by the method call.
            	// TODO: We need to have the return type passed to us so we know how to convert
            	// the return value to its correct type.
            	log.Println("  Building return value.")
            	var ret unsafe.Pointer
            	switch returns {
            	case "string":
            		ret = unsafe.Pointer(C.CString(""))
            	case "Node":
            		// Create a pointer to a pointer to a godot_object
            		var gdObject *C.godot_object
            		ret = unsafe.Pointer(gdObject)
            	default:
            		log.Fatal("Unknown return type specified.")
            	}
            
            	// Call the parent method. "ret" will be populated with the return value.
            	log.Println("  Calling bind_ptrcall...")
            	C.godot_method_bind_ptrcall(
            		methodBind,
            		unsafe.Pointer(o.owner),
            		cArgsArray, // void**
            		ret,        // void*
            	)
            	log.Println("  Finished calling method")
            
            	// Convert the return value based on the type.
            	var retValue reflect.Value
            	switch returns {
            	case "string":
            		gdString := (*C.godot_string)(ret)
            		retValue = reflect.ValueOf(C.GoString(C.godot_string_c_str(gdString)))
            	//case "Node":
            	//	// TODO: We might be able to optimize this better.
            	//	gdObject := (*C.godot_object)(ret)
            	//	nodeObject := &Node{
            	//		Object: Object{
            	//			owner: gdObject,
            	//		},
            	//	}
            
            	//	// Find out exactly what type of Node object this is. It's possible
            	//	// that it is actually a child class of Node that we need to downcast to.
            	//	typeValue := nodeObject.callParentMethod("Object", "get_type", []reflect.Value{}, "string")
            	//	objectType := typeValue.Interface().(string)
            
            	//	switch objectType {
            	//	case "Node":
            	//		retValue = reflect.ValueOf(nodeObject)
            	//	default:
            	//		log.Fatal("Unhandled type of object found when trying to downcast Node into its child type: ", objectType)
            	//	}
            
            	//	// TODO: We need to look up and see if this instance already exists in our instance registry.
            	}
            
            	// Return the converted variant.
            	return retValue
            }

        {{ end }}

        /*
        {{ $class.AttrName }}Implementer is an interface for {{ $class.AttrName }} objects.
        {{ $view.Trim $class.GDDescription.Text }}
        */
        type {{ $class.AttrName }}Implementer interface {
            {{ if ne $class.AttrName "Object" }}
                {{ $class.AttrInherits }}Implementer
            {{ else }}
                Class
            {{ end }}
            {{ if $class.GDMethods }}
                {{ range $j, $method := $class.GDMethods.GDMethod }}
                    {{ $view.GoMethodName $method.AttrName }}({{ range $k, $arg := $method.GDArgument }}{{ $view.GoArgName $arg.AttrName }} {{ $view.GoValue $arg.AttrType }},{{ end }}) {{ if $method.GDReturn }}{{ $view.GoValue $method.GDReturn.AttrType }}{{ end }} 
                {{ end }}
            {{ end }}
        }

    {{ end -}}
{{ end }}
