package main

/*
This is meant to parse the godot documentation to generate Go structs of all the godot
objects.
*/

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"github.com/pinzolo/casee"
	"github.com/shadowapex/godot-go/templates"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strings"
	"text/template"
	"unicode"
)

const classesUrl = "https://raw.githubusercontent.com/godotengine/godot/master/doc/base/classes.xml"

// View is a structure that embeds the classes.xml struct, but has additional methods
// attached to it that we can call inside our template.
type View struct {
	templates.GDDoc
	Header string
}

// Trim can be used inside the template to trim starting and ending whitespace.
func (v View) Trim(str string) string {
	return strings.TrimSpace(str)
}

// GoMethodName will convert the snake_case'd version of the Godot method name
// into a CamelCase version that is the Go convention.
func (v View) GoMethodName(methodString string) string {
	isPrivate := false

	// Convert the snake_case name to CamelCase
	if strings.HasPrefix(methodString, "_") {
		methodString = strings.Replace(methodString, "_", "X_", 1)
		isPrivate = true
	}
	methodString = casee.ToPascalCase(methodString)

	if isPrivate {
		return strings.Replace(methodString, "X", "X_", 1)
	}
	return methodString
}

// GoArgName will check for Go reserved keywords like "type" when used as argument
// names and convert them, so we don't get compile errors.
func (v View) GoArgName(argString string) string {
	switch argString {
	case "type":
		return "aType"
	case "default":
		return "aDefault"
	case "var":
		return "variable"
	case "func":
		return "function"
	case "return":
		return "returns"
	}

	return casee.ToCamelCase(argString)
}

// GoValue will convert the Godot value into a valid Go value.
func (v View) GoValue(returnString string) string {
	switch returnString {
	case "String":
		return "string"
	case "int":
		return "int64"
	case "uint":
		return "uint64"
	case "float":
		return "float64"
	case "void":
		return ""
	default:
		return returnString
	}
}

// IsValidClass will check the class to see if we should generate Go bindings for
// it.
func (v View) IsValidClass(classString, inheritsString string) bool {
	runeString := []rune(classString)
	if strings.HasPrefix(classString, "@") {
		return false
	}
	if unicode.IsLower(runeString[0]) {
		return false
	}
	// NOTE: Object is the only class without inheritance that we should generate.
	if classString == "Object" {
		return true
	}
	// NOTE: We should only autogenerate classes that inherit from "Object".
	if v.Trim(inheritsString) == "" {
		return false
	}

	return true
}

func main() {

	// Fetch the classes XML
	resp, err := http.Get(classesUrl)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		panic(err)
	}

	// Unmarshal the XML into a defined structure. This structure is generated by
	// cmd/generate.sh.
	var classes View
	xml.Unmarshal(body, &classes)
	classes.Header = `
//------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "templates/classes.go.template" so they can be included in the generated
//   code.
//------------------------------------------------------------------------------
`

	// Loop through all classes
	//for _, class := range classes.GDClass {
	//	fmt.Println("Name:", class.AttrName)
	//	fmt.Println("  Category:", class.AttrCategory)
	//	fmt.Println("  Inherits:", class.AttrInherits)
	//	fmt.Println("  Description:", class.GDDescription.Text)
	//	fmt.Println("  Constants:")
	//	if class.GDConstants != nil {
	//		for _, constant := range class.GDConstants.GDConstant {
	//			fmt.Println("    Constant:", constant)
	//		}
	//	}
	//	fmt.Println("  Members:")
	//	if class.GDMembers != nil {
	//		for _, member := range class.GDMembers.GDMember {
	//			fmt.Println("    Member:", member)
	//		}
	//	}
	//	fmt.Println("  Methods:")
	//	if class.GDMethods != nil {
	//		for _, method := range class.GDMethods.GDMethod {
	//			fmt.Println("    Method:")
	//			fmt.Println("      Name:", method.AttrName)
	//			fmt.Println("      Description:", method.GDDescription.Text)
	//			fmt.Println("      Qualifiers:", method.AttrQualifiers)
	//			fmt.Println("      Arguments:")
	//			for _, arg := range method.GDArgument {
	//				fmt.Println("        Name:", arg.AttrName)
	//				fmt.Println("        Default:", arg.AttrDefault)
	//				fmt.Println("        Index:", arg.AttrIndex)
	//				fmt.Println("        Type:", arg.AttrType)
	//			}
	//			fmt.Println("      Returns:")
	//			if method.GDReturn != nil {
	//				fmt.Println("        Name:", method.GDReturn.AttrType)
	//			}
	//		}
	//	}
	//	fmt.Println("  Signals:")
	//	if class.GDSignals != nil {
	//		for _, signal := range class.GDSignals.GDSignal {
	//			fmt.Println("    Signal:", signal)
	//		}
	//	}
	//	fmt.Println("  Theme Items:")
	//	if class.GDTheme_items != nil {
	//		for _, theme := range class.GDTheme_items.GDTheme_item {
	//			fmt.Println("    Theme:", theme)
	//		}
	//	}
	//}

	// List out template file
	basePath := os.Getenv("GOPATH") + "/src/github.com/shadowapex/godot-go/templates"
	templateFile := basePath + "/classes.go.template"

	// Create a template from our template file.
	t, err := template.ParseFiles(templateFile)
	if err != nil {
		log.Fatal("Error parsing template:", err)
	}
	templateBuffer := bytes.NewBufferString("")
	err = t.Execute(templateBuffer, classes)
	if err != nil {
		log.Fatal("Unable to apply template:", err)
	}

	// Output our template to STDOUT
	fmt.Println(templateBuffer.String())

}
