{{ $view := . -}}
package gdnative

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "types.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

/*
{{ range $i, $header := $view.Headers -}}
	#include <{{ $header }}>
{{ end -}}
*/
import "C"

{{/* Loop through and define all of the type definitions as Go structs */}}
{{ range $i, $typedef := $view.TypeDefinitions -}}
	{{/* Handle struct definitions */}}
	{{ if or (eq $typedef.Base "struct") (eq $typedef.Base "void") }}
		type {{ $typedef.GoName }} struct {
			base *C.{{ $typedef.Name }}
			{{/* Handle struct properties */}}
			{{ range $j, $propdef := $typedef.Properties -}}
				{{ if ($view.IsValidProperty $propdef) -}}
					{{ $propdef.GoName }} {{ $view.ToGoName $propdef.Base }}
				{{ end -}}
			{{ end -}}
		}

		func (t {{ $typedef.GoName }}) getBase() *C.{{ $typedef.Name }} {
			return t.base
		}

		{{/* Handle struct methods */}}
		{{ range $j, $method := ($view.MethodsList $typedef) }}
				// {{ $view.ToGoMethodName $typedef $method }} {{ $method.Name }} {{ $method.Arguments }} {{ $method.ReturnType }}
			{{ if ($view.MethodIsConstructor $method) -}}
				func {{ $view.ToGoMethodName $typedef $method }}({{ range $k, $arg := $method.Arguments }}{{ $view.ToGoArgName (index $arg 1) }} {{ $view.ToGoArgType (index $arg 0) }}, {{ end }}) *{{ $typedef.GoName }} {
					return &{{ $typedef.GoName }}{}
				}
			{{ else -}}
				func (t *{{ $typedef.GoName }}) {{ $view.ToGoMethodName $typedef $method }}({{ range $k, $arg := $method.Arguments }}{{ if $view.NotSelfArg (index $arg 1) }}{{ $view.ToGoArgName (index $arg 1) }} {{ $view.ToGoArgType (index $arg 0) }}, {{ end }}{{ end }})  {{ $view.ToGoReturnType $method.ReturnType }} {
					{{ range $k, $arg := $method.Arguments -}}
						{{ if $view.NotSelfArg (index $arg 1) -}}
							arg{{ $k }} := {{ $view.ToGoArgName (index $arg 1) }}.getBase()
						{{ else -}}
							arg{{ $k }} := t.getBase()
						{{ end -}}
					{{ end }}
					{{ if $view.HasReturn $method.ReturnType }}
						ret := C.go_{{ $method.Name }}(GDNative.api, {{ range $k, $arg := $method.Arguments }}arg{{ $k }}, {{ end }})

						return {{ $view.ToGoReturnType $method.ReturnType }}{base: ret}
					{{ else }}
						C.go_{{ $method.Name }}(GDNative.api, {{ range $k, $arg := $method.Arguments }}arg{{ $k }}, {{ end }})
					{{ end }}
				}
			{{ end }}
		{{ end }}

	{{ end }}

	{{/* Handle enum definitions */}}
	{{ if eq $typedef.Base "enum" }}
		type {{ $typedef.GoName }} int
		
		func (e {{ $typedef.GoName }}) getBase() C.{{ $typedef.Name }} {
			return C.{{ $typedef.Name }}(e)
		}
		
		const (
		{{ range $j, $propdef := $typedef.Properties -}}
			{{ if eq $j 0 -}}
				{{ $propdef.GoName }} {{ $typedef.GoName }} = iota
			{{ else -}}
				{{ $propdef.GoName }}
			{{ end -}}
		{{ end }}
		)
		
	{{ end }}

	{{/* Handle base type definitions */}}
	{{ if and ($typedef.SimpleType) (ne $typedef.Base "void") }}
		{{ if ($view.IsGodotBaseType $typedef) }}
			type {{ $typedef.GoName }} {{ $view.ToGoName $typedef.Base }}
		{{ else }}
			type {{ $typedef.GoName }} {{ $view.ToGoBaseType $typedef.Base }}

			func (t {{ $typedef.GoName }}) getBase() C.{{ $typedef.Base }} {
				return C.{{ $typedef.Base }}(t)
			}
		{{ end }}

	{{ end }}
{{ end }}
