{{ $view := . }}{{ $API := $view.API -}}
package {{ $view.Package }}

/*------------------------------------------------------------------------------
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "class.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/


{{ if $API.Singleton -}}
    func newSingleton{{ $view.GoClassName $API.Name }}() *{{ $view.SetClassName $API.Name $API.Singleton}} {
        obj := &{{ $view.SetClassName $API.Name $API.Singleton }}{}
        ptr := C.godot_global_get_singleton(C.CString("{{ $API.Name }}"))
        obj.owner = (*C.godot_object)(ptr)
        return obj
    }
    /*
    {{ $view.ClassDoc $API.Name }}
    */
    var {{ $view.GoClassName $API.Name }} = newSingleton{{ $view.GoClassName $API.Name }}()
{{ end }}
/*
{{ $view.ClassDoc $API.Name }}
*/
type {{ $view.SetClassName $API.Name $API.Singleton }} struct {
    {{ $view.SetBaseClassName $API.BaseClass }}
    {{ if eq $API.Name "Object" }}
        owner gdnative.Object
    {{ end }}
}

func (o *{{ $view.SetClassName $API.Name $API.Singleton }}) BaseClass() string {
    return "{{ $API.Name }}"
}

{{ if $API.Methods }}
    {{ range $j, $method := $API.Methods }}
        /*
        {{ $view.MethodDoc $API.Name $method.Name }}
        */
        func (o *{{ $view.SetClassName $API.Name $API.Singleton }}) {{ $view.GoMethodName $method.Name }}({{ range $k, $arg := $method.Arguments }}{{ $view.GoArgName $arg.Name }} {{ $view.GoValue $arg.Type }},{{ end }}) {{ if $method.ReturnType }}{{ $view.GoValue $method.ReturnType }}{{ end }} {
            log.Println("Calling {{ $API.Name }}.{{ $view.GoMethodName $method.Name }}()")

            // Build out the method's arguments
            goArguments := make([]reflect.Value, {{ len $method.Arguments }}, {{ len $method.Arguments }})
            {{ range $k, $arg := $method.Arguments -}}
                goArguments[{{ $k }}] = reflect.ValueOf({{ $view.GoArgName $arg.Name }})
            {{ end }}

            // Call the parent method.
            {{ if $method.ReturnType }}
                {{ $returnType := $view.GoValue $method.ReturnType }}{{ if ne $returnType "" }}
                    goRet := o.callParentMethod(o.BaseClass(), "{{ $method.Name }}", goArguments, "{{ if $method.ReturnType }}{{ $view.GoValue $method.ReturnType }}{{ end }}")
                {{ else }}
                    o.callParentMethod(o.BaseClass(), "{{ $method.Name }}", goArguments, "{{ if $method.ReturnType }}{{ $view.GoValue $method.ReturnType }}{{ end }}")
                {{ end }}
            {{ end -}}
            {{ if $method.ReturnType }}
                {{ $returnType := $view.GoValue $method.ReturnType }}{{ if ne $returnType "" }}
                    returnValue := goRet.Interface().({{ $view.GoValue $method.ReturnType }})

                    log.Println("  Got return value: ", returnValue)
                    return returnValue
            {{else}}
                log.Println("  Function successfully completed.")
                {{ end }}
            {{ end }}
        }
    {{ end }}
{{ end }}

{{ if eq $API.Name "Object" }}
    // SetOwner will internally set the Godot object inside the struct.
    // This is used to call parent methods.
    func (o *Object) SetOwner(object gdnative.Object) {
        o.owner = object
    }
    
    func (o *Object) GetOwner() gdnative.Object {
        return o.owner
    }

    // callParentMethod will call this object's method with the given method name.
    func (o *Object) callParentMethod(baseClass, methodName string, args []reflect.Value, returns string) reflect.Value {
    	log.Println("Calling parent method!")
    
    	// Convert the base class and method names to C strings.
    	log.Println("  Using base class: ", baseClass)
    	classCString := C.CString(baseClass)
    	log.Println("  Using method name: ", methodName)
    	methodCString := C.CString(methodName)
    
        // Get the Godot objects owner so we can pass it to godot_method_bind_ptrcall.
    	log.Println("  Using godot object owner:", o.getOwner())
        objectOwner := unsafe.Pointer(o.getOwner())

    	// Get the Godot method bind pointer so we can pass it to godot_method_bind_ptrcall.
    	var methodBind *C.godot_method_bind
    	methodBind = C.godot_method_bind_get_method(classCString, methodCString)
    	log.Println("  Using method bind pointer: ", methodBind)
    
    	// Loop through the given arguments and see what type they are. When we know what
    	// type it is, we need to convert them to the correct godot objects.
    	// TODO: Probably pull this out into its own function?
    	variantArgs := []unsafe.Pointer{}
    	for _, arg := range args {
    		log.Println("  Argument type: ", arg.Type().String())
    
    		// Look up our conversion function in our map of conversion functions
    		// based on the Go type. This is essentially a more optimal case/switch
    		// statement on the type of Go object, so we can know how to convert it
    		// to a Godot object.
    		if convert, ok := goToGodotConversionMap[arg.Type().String()]; ok {
    			argValue := convert(arg.Interface())
    			variantArgs = append(variantArgs, argValue)
    		} else {
                err := "Unknown type of argument value when calling parent method: " + arg.Type().String()
    			Log.Error(err)
                panic(err)
    		}
    	}
    	log.Println("  Built variant arguments: ", variantArgs)
    
    	// Construct a C array that will contain pointers to our arguments.
    	log.Println("  Allocating argument array in C.")
    	cArgsArray := C.build_array(C.int(len(variantArgs)))
    	log.Println("    C Array: ", cArgsArray)
    
    	// Loop through and add each argument to our C args array.
    	for i, arg := range variantArgs {
    		C.add_element(cArgsArray, arg, C.int(i))
    	}
    	log.Println("  Built argument array from variant arguments: ", cArgsArray)
    
    	// Construct our return object that will be populated by the method call.
        // Here we're just using a CString
    	log.Println("  Building return value.")
    	ret := unsafe.Pointer(C.CString(""))
    
    	// Call the parent method. "ret" will be populated with the return value.
    	log.Println("  Calling bind_ptrcall...")
    	C.godot_method_bind_ptrcall(
    		methodBind,
    		objectOwner,
            cArgsArray, // void**
    		ret,        // void*
    	)
    	log.Println("  Finished calling method")
    
    	// Convert the return value based on the type.
    	var retValue reflect.Value
        if _, ok := godotToGoConversionMap[returns]; ok {
            retValue = godotToGoConversionMap[returns](ret)
        } else {
	            panic("Return type not found when calling parent method: " + returns)
        }
   
    	// Return the converted variant.
    	return retValue
    }

{{ end }}
{{ if eq $API.Singleton false -}} 
    /*
    {{ $API.Name }}Implementer is an interface for {{ $API.Name }} objects.
    */
    type {{ $API.Name }}Implementer interface {
            Class
    }
{{ end -}}
